contract main {




// =====================  Runtime code  =====================


#
#  - safeTransfer(address arg1, uint256 arg2)
#
const DEFAULT_ADMIN_ROLE = 0

const MINTER_ROLE = 0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956


address owner;
array of struct stor1;
array of struct stor2;
mapping of address ownerOf;
mapping of uint256 balanceOf;
mapping of address approved;
mapping of uint8 stor6;
mapping of uint256 tokenOfOwnerByIndex;
mapping of uint256 stor8;
array of uint256 tokenByIndex;
mapping of uint256 stor10;
mapping of struct stor11;
mapping of struct roleAdmin;
array of struct roleMember;
array of struct stor14;
array of struct stor15;
mapping of address sub_498715ac;
uint8 stor17;

function getApproved(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    return approved[arg1]
}

function totalSupply() {
    return tokenByIndex.length
}

function getRoleAdmin(bytes32 arg1) {
    require calldata.size - 4 >= 32
    return uint256(roleAdmin[arg1].field_256)
}

function tokenOfOwnerByIndex(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    if arg2 >= balanceOf[address(arg1)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Enumerable: owner index out of bounds'
    return tokenOfOwnerByIndex[address(arg1)][arg2]
}

function sub_498715ac(?) {
    require calldata.size - 4 >= 32
    return sub_498715ac[arg1]
}

function tokenByIndex(uint256 arg1) {
    require calldata.size - 4 >= 32
    if arg1 >= tokenByIndex.length:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Enumerable: global index out of bounds'
    return tokenByIndex[arg1]
}

function ownerOf(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    return ownerOf[arg1]
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    return balanceOf[address(arg1)]
}

function owner() {
    return owner
}

function getRoleMember(bytes32 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if arg2 >= uint256(roleMember[arg1].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'EnumerableSet: index out of bounds'
    return address(roleMember[arg1][arg2].field_0)
}

function hasRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return bool(uint8(roleAdmin[arg1][address(arg2)].field_0))
}

function getRoleMemberCount(bytes32 arg1) {
    require calldata.size - 4 >= 32
    return uint256(roleMember[arg1].field_0)
}

function isApprovedForAll(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor6[address(arg1)][address(arg2)])
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function setApprovalForAll(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if msg.sender == arg1:
        revert with 0, 'ERC721: approve to caller'
    stor6[msg.sender][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function renounceRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg2 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: can only renounce roles for self'
    if uint8(roleAdmin[arg1][address(arg2)].field_0):
        uint8(roleAdmin[arg1][address(arg2)].field_0) = 0
        emit RoleRevoked(arg1, arg2, msg.sender);
}

function royaltyInfo(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if arg2 < 1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'value should be greater than or equal to 1'
    if not uint256(stor14[arg1].field_0):
        revert with 0, 50
    if not uint256(stor15[arg1].field_0):
        revert with 0, 50
    return address(stor14[arg1].field_0), uint256(stor15[arg1].field_0)
}

function updateCashbackForAuthor(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    idx = 0
    while idx < uint256(stor15[arg1].field_0):
        if idx >= uint256(stor14[arg1].field_0):
            revert with 0, 50
        if address(stor14[arg1][idx].field_0) == msg.sender:
            if idx >= uint256(stor15[arg1].field_0):
                revert with 0, 50
            uint256(stor15[arg1][idx].field_0) = arg2
            return 1
        if idx == -1:
            revert with 0, 17
        mem[0] = arg1
        mem[32] = 15
        idx = idx + 1
        continue 
    return 1
}

function allowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if arg1 == ownerOf[arg2]:
        return True
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
    if approved[arg2] == arg1:
        return True
    return bool(stor6[stor3[arg2]][address(arg1)])
}

function grantRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if not uint8(roleAdmin[uint256(roleAdmin[arg1].field_256)][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: sender must be an admin to grant'
    if not uint8(roleAdmin[arg1][address(arg2)].field_0):
        uint8(roleAdmin[arg1][address(arg2)].field_0) = 1
        emit RoleGranted(arg1, arg2, msg.sender);
    if not uint256(roleMember[arg1][1][address(arg2)].field_0):
        uint256(roleMember[arg1].field_0)++
        address(roleMember[arg1][uint256(roleMember[arg1].field_0)].field_0) = arg2
        Mask(96, 0, roleMember[arg1][uint256(roleMember[arg1].field_0)].field_160) = 0
        uint256(roleMember[arg1][1][address(arg2)].field_0) = uint256(roleMember[arg1].field_0)
}

function sub_972f3d70(?) {
    require calldata.size - 4 >= 64
    if uint256(stor15[arg1].field_0):
        mem[128] = uint256(stor15[arg1].field_0)
        idx = 128
        s = 0
        while (32 * uint256(stor15[arg1].field_0)) + 96 > idx:
            mem[idx + 32] = uint256(stor15[arg1][s].field_256)
            idx = idx + 32
            s = s + 1
            continue 
        return Array(len=uint256(stor15[arg1].field_0), data=mem[128 len 32 * uint256(stor15[arg1].field_0)])
    mem[(32 * uint256(stor15[arg1].field_0)) + 128] = 32
    mem[(32 * uint256(stor15[arg1].field_0)) + 160] = uint256(stor15[arg1].field_0)
    mem[(32 * uint256(stor15[arg1].field_0)) + 192 len 32 * uint256(stor15[arg1].field_0)] = mem[128 len 32 * uint256(stor15[arg1].field_0)]
    return memory
      from (32 * uint256(stor15[arg1].field_0)) + 128
       len (96 * uint256(stor15[arg1].field_0)) + 64
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if arg1 == ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approval to current owner'
    if ownerOf[arg2] != msg.sender:
        if not stor6[stor3[arg2]][address(msg.sender)]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        'ERC721: approve caller is not owner nor approved for all'
    approved[arg2] = arg1
    if not ownerOf[arg2]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg2], arg1, arg2);
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x5a05180f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x2a55205a00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x780e9d6300000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x80ac58cd00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    if 0x5b5e139f00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function tokenCashbackRecipients(uint256 arg1) {
    require calldata.size - 4 >= 32
    mem[64] = (32 * uint256(stor14[arg1].field_0)) + 128
    mem[96] = uint256(stor14[arg1].field_0)
    if not uint256(stor14[arg1].field_0):
        mem[(32 * uint256(stor14[arg1].field_0)) + 128] = 32
        mem[(32 * uint256(stor14[arg1].field_0)) + 160] = uint256(stor14[arg1].field_0)
        idx = 0
        s = (32 * uint256(stor14[arg1].field_0)) + 192
        t = 128
        while idx < uint256(stor14[arg1].field_0):
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * uint256(stor14[arg1].field_0)) + 128
           len (96 * uint256(stor14[arg1].field_0)) + 64
    mem[128] = address(stor14[arg1].field_0)
    idx = 128
    s = 0
    while (32 * uint256(stor14[arg1].field_0)) + 96 > idx:
        mem[idx + 32] = address(stor14[arg1][s].field_256)
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * uint256(stor14[arg1].field_0)) + 128] = 32
    mem[(32 * uint256(stor14[arg1].field_0)) + 160] = uint256(stor14[arg1].field_0)
    idx = 0
    s = mem[64] + 64
    t = 128
    while idx < uint256(stor14[arg1].field_0):
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * uint256(stor14[arg1].field_0)) + -mem[64] + 192
}

function revokeRole(bytes32 arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if not uint8(roleAdmin[uint256(roleAdmin[arg1].field_256)][address(msg.sender)].field_0):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: sender must be an admin to revoke'
    if uint8(roleAdmin[arg1][address(arg2)].field_0):
        uint8(roleAdmin[arg1][address(arg2)].field_0) = 0
        emit RoleRevoked(arg1, arg2, msg.sender);
    if uint256(roleMember[arg1][1][address(arg2)].field_0):
        if uint256(roleMember[arg1][1][address(arg2)].field_0) < 1:
            revert with 0, 17
        if uint256(roleMember[arg1].field_0) < 1:
            revert with 0, 17
        if uint256(roleMember[arg1].field_0) - 1 >= uint256(roleMember[arg1].field_0):
            revert with 0, 50
        if uint256(roleMember[arg1][1][address(arg2)].field_0) - 1 >= uint256(roleMember[arg1].field_0):
            revert with 0, 50
        uint256(roleMember[arg1][uint256(roleMember[arg1][1][address(arg2)].field_0)].field_0) = uint256(roleMember[arg1][uint256(roleMember[arg1].field_0)].field_0)
        if 1 > !(uint256(roleMember[arg1][1][address(arg2)].field_0) - 1):
            revert with 0, 17
        uint256(roleMember[arg1][1][uint256(roleMember[arg1][uint256(roleMember[arg1].field_0)].field_0)].field_0) = uint256(roleMember[arg1][1][address(arg2)].field_0)
        if not uint256(roleMember[arg1].field_0):
            revert with 0, 49
        uint256(roleMember[arg1][uint256(roleMember[arg1].field_0)].field_0) = 0
        uint256(roleMember[arg1].field_0)--
        uint256(roleMember[arg1][1][address(arg2)].field_0) = 0
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != msg.sender:
        if not ownerOf[arg3]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg3] != msg.sender:
            if not stor6[stor3[arg3]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer caller is not owner nor approved'
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg3] != arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer of token that is not own'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: transfer to the zero address'
    if not arg1:
        stor10[arg3] = tokenByIndex.length
        tokenByIndex.length++
        tokenByIndex[tokenByIndex.length] = arg3
    else:
        if arg1 != arg2:
            if not arg1:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
            stor8[arg3] = 0
            tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
    if arg2:
        if arg2 != arg1:
            if not arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
            stor8[arg3] = balanceOf[address(arg2)]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor10[arg3] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
        stor10[stor9[stor9.length]] = stor10[arg3]
        stor10[arg3] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    approved[arg3] = 0
    if not ownerOf[arg3]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg3], 0, arg3);
    if balanceOf[address(arg1)] < 1:
        revert with 0, 17
    balanceOf[address(arg1)]--
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    ownerOf[arg3] = arg2
    emit Transfer(arg1, arg2, arg3);
}

function name() {
    if bool(stor1.length):
        if bool(stor1.length) == uint255(stor1.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor1.length):
            if bool(stor1.length) == uint255(stor1.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor1.length):
                if 31 < uint255(stor1.length) * 0.5:
                    mem[128] = uint256(stor1.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor1.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor1[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor1.length), data=mem[128 len ceil32(uint255(stor1.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor1.length.field_8)
        else:
            if bool(stor1.length) == stor1.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor1.length.field_1 % 128:
                if 31 < stor1.length.field_1 % 128:
                    mem[128] = uint256(stor1.field_0)
                    idx = 128
                    s = 0
                    while stor1.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor1[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor1.length), data=mem[128 len ceil32(uint255(stor1.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor1.length.field_8)
        mem[ceil32(uint255(stor1.length) * 0.5) + 192 len ceil32(uint255(stor1.length) * 0.5)] = mem[128 len ceil32(uint255(stor1.length) * 0.5)]
        if ceil32(uint255(stor1.length) * 0.5) > uint255(stor1.length) * 0.5:
            mem[(uint255(stor1.length) * 0.5) + ceil32(uint255(stor1.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor1.length), data=mem[128 len ceil32(uint255(stor1.length) * 0.5)], mem[(2 * ceil32(uint255(stor1.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor1.length) * 0.5)]), 
    if bool(stor1.length) == stor1.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor1.length):
        if bool(stor1.length) == uint255(stor1.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor1.length):
            if 31 < uint255(stor1.length) * 0.5:
                mem[128] = uint256(stor1.field_0)
                idx = 128
                s = 0
                while (uint255(stor1.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor1[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor1.length % 128, data=mem[128 len ceil32(stor1.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor1.length.field_8)
    else:
        if bool(stor1.length) == stor1.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor1.length.field_1 % 128:
            if 31 < stor1.length.field_1 % 128:
                mem[128] = uint256(stor1.field_0)
                idx = 128
                s = 0
                while stor1.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor1[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor1.length % 128, data=mem[128 len ceil32(stor1.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor1.length.field_8)
    mem[ceil32(stor1.length.field_1 % 128) + 192 len ceil32(stor1.length.field_1 % 128)] = mem[128 len ceil32(stor1.length.field_1 % 128)]
    if ceil32(stor1.length.field_1 % 128) > stor1.length.field_1 % 128:
        mem[stor1.length.field_1 % 128 + ceil32(stor1.length.field_1 % 128) + 192] = 0
    return Array(len=stor1.length % 128, data=mem[128 len ceil32(stor1.length.field_1 % 128)], mem[(2 * ceil32(stor1.length.field_1 % 128)) + 192 len 2 * ceil32(stor1.length.field_1 % 128)]), 
}

function symbol() {
    if bool(stor2.length):
        if bool(stor2.length) == uint255(stor2.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor2.length):
            if bool(stor2.length) == uint255(stor2.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor2.length):
                if 31 < uint255(stor2.length) * 0.5:
                    mem[128] = uint256(stor2.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor2.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor2[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor2.length.field_8)
        else:
            if bool(stor2.length) == stor2.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor2.length.field_1 % 128:
                if 31 < stor2.length.field_1 % 128:
                    mem[128] = uint256(stor2.field_0)
                    idx = 128
                    s = 0
                    while stor2.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor2[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor2.length.field_8)
        mem[ceil32(uint255(stor2.length) * 0.5) + 192 len ceil32(uint255(stor2.length) * 0.5)] = mem[128 len ceil32(uint255(stor2.length) * 0.5)]
        if ceil32(uint255(stor2.length) * 0.5) > uint255(stor2.length) * 0.5:
            mem[(uint255(stor2.length) * 0.5) + ceil32(uint255(stor2.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor2.length), data=mem[128 len ceil32(uint255(stor2.length) * 0.5)], mem[(2 * ceil32(uint255(stor2.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor2.length) * 0.5)]), 
    if bool(stor2.length) == stor2.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor2.length):
        if bool(stor2.length) == uint255(stor2.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor2.length):
            if 31 < uint255(stor2.length) * 0.5:
                mem[128] = uint256(stor2.field_0)
                idx = 128
                s = 0
                while (uint255(stor2.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor2[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor2.length.field_8)
    else:
        if bool(stor2.length) == stor2.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor2.length.field_1 % 128:
            if 31 < stor2.length.field_1 % 128:
                mem[128] = uint256(stor2.field_0)
                idx = 128
                s = 0
                while stor2.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor2[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor2.length.field_8)
    mem[ceil32(stor2.length.field_1 % 128) + 192 len ceil32(stor2.length.field_1 % 128)] = mem[128 len ceil32(stor2.length.field_1 % 128)]
    if ceil32(stor2.length.field_1 % 128) > stor2.length.field_1 % 128:
        mem[stor2.length.field_1 % 128 + ceil32(stor2.length.field_1 % 128) + 192] = 0
    return Array(len=stor2.length % 128, data=mem[128 len ceil32(stor2.length.field_1 % 128)], mem[(2 * ceil32(stor2.length.field_1 % 128)) + 192 len 2 * ceil32(stor2.length.field_1 % 128)]), 
}

function mintWithTokenURI(address arg1, uint256 arg2, string arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg3.length)) + 97 < 96 or ceil32(ceil32(arg3.length)) + 97 > test266151307():
        revert with 0, 65
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    mem[arg3.length + 128] = 0
    if not stor17:
        if not uint8(roleAdmin[0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956][address(msg.sender)].field_0):
            revert with 0, 'ERC721PresetMinterPauserAutoId: must have minter role to mint'
    if not arg1:
        revert with 0, 'ERC721: mint to the zero address'
    if ownerOf[arg2]:
        revert with 0, 'ERC721: token already minted'
    stor10[arg2] = tokenByIndex.length
    tokenByIndex.length++
    tokenByIndex[tokenByIndex.length] = arg2
    if arg1:
        if arg1:
            if not arg1:
                revert with 0, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)]] = arg2
            stor8[arg2] = balanceOf[address(arg1)]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor10[arg2] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor10[arg2]] = tokenByIndex[tokenByIndex.length]
        stor10[stor9[stor9.length]] = stor10[arg2]
        stor10[arg2] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    if balanceOf[address(arg1)] > -2:
        revert with 0, 17
    balanceOf[address(arg1)]++
    ownerOf[arg2] = arg1
    emit Transfer(0, arg1, arg2);
    if not ownerOf[arg2]:
        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
    if bool(stor11[arg2].field_0):
        if bool(stor11[arg2].field_0) == uint255(uint256(stor11[arg2].field_0)) * 0.5 < 32:
            revert with 0, 34
        if not arg3.length:
            uint256(stor11[arg2].field_0) = 0
            idx = 0
            while (uint255(uint256(stor11[arg2].field_0)) * 0.5) + 31 / 32 > idx:
                uint256(stor11[arg2][idx].field_0) = 0
                idx = idx + 1
                continue 
        else:
            uint256(stor11[arg2].field_0) = (2 * arg3.length) + 1
            if arg3.length <= 0:
                idx = 0
                while (uint255(uint256(stor11[arg2].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor11[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(stor11[arg2].field_0) = mem[128]
                s = 1
                idx = 160
                while arg3.length + 128 > idx:
                    uint256(stor11[arg2][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = (Mask(251, 0, arg3.length - 1) >> 5) + 1
                while (uint255(uint256(stor11[arg2].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor11[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
    else:
        if bool(stor11[arg2].field_0) == stor11[arg2].field_1 % 128 < 32:
            revert with 0, 34
        if not arg3.length:
            uint256(stor11[arg2].field_0) = 0
            idx = 0
            while stor11[arg2].field_1 % 128 + 31 / 32 > idx:
                uint256(stor11[arg2][idx].field_0) = 0
                idx = idx + 1
                continue 
        else:
            uint256(stor11[arg2].field_0) = (2 * arg3.length) + 1
            if arg3.length <= 0:
                idx = 0
                while stor11[arg2].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor11[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(stor11[arg2].field_0) = mem[128]
                s = 1
                idx = 160
                while arg3.length + 128 > idx:
                    uint256(stor11[arg2][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = (Mask(251, 0, arg3.length - 1) >> 5) + 1
                while stor11[arg2].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor11[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
    return 1
}

function tokensOfOwner(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
    if balanceOf[address(arg1)] > test266151307():
        revert with 0, 65
    mem[96] = balanceOf[address(arg1)]
    mem[64] = (32 * balanceOf[address(arg1)]) + 128
    if not balanceOf[address(arg1)]:
        if not arg1:
            revert with 0, 'ERC721: balance query for the zero address'
        if var30002 >= var30001:
            mem[(32 * balanceOf[address(arg1)]) + 128] = 32
            mem[(32 * balanceOf[address(arg1)]) + 160] = balanceOf[address(arg1)]
            mem[(32 * balanceOf[address(arg1)]) + 192 len 32 * balanceOf[address(arg1)]] = mem[128 len 32 * balanceOf[address(arg1)]]
            return memory
              from (32 * balanceOf[address(arg1)]) + 128
               len (96 * balanceOf[address(arg1)]) + 64
        mem[0] = var32001
        mem[32] = sha3(address(arg1), 7)
        if var32001 >= balanceOf[address(arg1)]:
            revert with 0, 50
        mem[(32 * var32001) + 128] = tokenOfOwnerByIndex[address(arg1)][var32001]
        s = var32001
        t = tokenOfOwnerByIndex[address(arg1)][var32001]
        idx = var32001
        while idx != -1:
            if not arg1:
                revert with 0, 'ERC721: balance query for the zero address'
            if idx + 1 >= balanceOf[address(arg1)]:
                mem[(32 * balanceOf[address(arg1)]) + 128] = 32
                mem[(32 * balanceOf[address(arg1)]) + 160] = balanceOf[address(arg1)]
                idx = 0
                u = (32 * balanceOf[address(arg1)]) + 192
                v = 128
                while idx < balanceOf[address(arg1)]:
                    mem[u] = mem[v]
                    mem[(32 * s) + 128] = t
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                return memory
                  from (32 * balanceOf[address(arg1)]) + 128
                   len (96 * balanceOf[address(arg1)]) + 64
            mem[0] = idx + 1
            mem[32] = sha3(address(arg1), 7)
            if idx + 1 >= balanceOf[address(arg1)]:
                revert with 0, 50
            mem[(32 * idx + 2) + 128] = tokenOfOwnerByIndex[address(arg1)][idx + 1]
            s = idx + 1
            t = tokenOfOwnerByIndex[address(arg1)][idx + 1]
            idx = idx + 1
            continue 
    else:
        mem[128 len 32 * balanceOf[address(arg1)]] = call.data[calldata.size len 32 * balanceOf[address(arg1)]]
        if not arg1:
            revert with 0, 'ERC721: balance query for the zero address'
        if var31002 >= var31001:
            mem[(32 * balanceOf[address(arg1)]) + 128] = 32
            mem[(32 * balanceOf[address(arg1)]) + 160] = balanceOf[address(arg1)]
            mem[(32 * balanceOf[address(arg1)]) + 192 len 32 * balanceOf[address(arg1)]] = call.data[calldata.size len 32 * balanceOf[address(arg1)]]
            return memory
              from (32 * balanceOf[address(arg1)]) + 128
               len (96 * balanceOf[address(arg1)]) + 64
        mem[0] = var33001
        mem[32] = sha3(address(arg1), 7)
        if var33001 >= balanceOf[address(arg1)]:
            revert with 0, 50
        mem[(32 * var33001) + 128] = tokenOfOwnerByIndex[address(arg1)][var33001]
        s = var33001
        t = tokenOfOwnerByIndex[address(arg1)][var33001]
        idx = var33001
        while idx != -1:
            if not arg1:
                revert with 0, 'ERC721: balance query for the zero address'
            if idx + 1 >= balanceOf[address(arg1)]:
                mem[(32 * balanceOf[address(arg1)]) + 128] = 32
                mem[(32 * balanceOf[address(arg1)]) + 160] = balanceOf[address(arg1)]
                idx = 0
                u = (32 * balanceOf[address(arg1)]) + 192
                v = 128
                while idx < balanceOf[address(arg1)]:
                    mem[u] = mem[v]
                    mem[(32 * s) + 128] = t
                    idx = idx + 1
                    u = u + 32
                    v = v + 32
                    continue 
                return memory
                  from (32 * balanceOf[address(arg1)]) + 128
                   len (96 * balanceOf[address(arg1)]) + 64
            mem[0] = idx + 1
            mem[32] = sha3(address(arg1), 7)
            if idx + 1 >= balanceOf[address(arg1)]:
                revert with 0, 50
            mem[(32 * idx + 2) + 128] = tokenOfOwnerByIndex[address(arg1)][idx + 1]
            s = idx + 1
            t = tokenOfOwnerByIndex[address(arg1)][idx + 1]
            idx = idx + 1
            continue 
    revert with 0, 17
}

function burn(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: operator query for nonexistent token'
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg1] != msg.sender:
        if not ownerOf[arg1]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: approved query for nonexistent token'
        if approved[arg1] != msg.sender:
            if not stor6[stor3[arg1]][address(msg.sender)]:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721Burnable: caller is not owner nor approved'
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    if ownerOf[arg1]:
        if not ownerOf[arg1]:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: balance query for the zero address'
        if balanceOf[stor3[arg1]] < 1:
            revert with 0, 17
        if balanceOf[stor3[arg1]] - 1 != stor8[arg1]:
            tokenOfOwnerByIndex[stor3[arg1]][stor8[arg1]] = tokenOfOwnerByIndex[stor3[arg1]][stor4[stor3[arg1]] - 1]
            stor8[stor7[stor3[arg1]][stor4[stor3[arg1]] - 1]] = stor8[arg1]
        stor8[arg1] = 0
        tokenOfOwnerByIndex[stor3[arg1]][stor4[stor3[arg1]] - 1] = 0
    if tokenByIndex.length < 1:
        revert with 0, 17
    if tokenByIndex.length - 1 >= tokenByIndex.length:
        revert with 0, 50
    if stor10[arg1] >= tokenByIndex.length:
        revert with 0, 50
    tokenByIndex[stor10[arg1]] = tokenByIndex[tokenByIndex.length]
    stor10[stor9[stor9.length]] = stor10[arg1]
    stor10[arg1] = 0
    if not tokenByIndex.length:
        revert with 0, 49
    tokenByIndex[tokenByIndex.length] = 0
    tokenByIndex.length--
    approved[arg1] = 0
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721: owner query for nonexistent token'
    emit Approval(ownerOf[arg1], 0, arg1);
    if balanceOf[stor3[arg1]] < 1:
        revert with 0, 17
    balanceOf[stor3[arg1]]--
    ownerOf[arg1] = 0
    emit Transfer(ownerOf[arg1], 0, arg1);
    if bool(stor11[arg1].field_0):
        if bool(stor11[arg1].field_0) == uint255(uint256(stor11[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, uint256(stor11[arg1].field_0)):
            if bool(stor11[arg1].field_0):
                if bool(stor11[arg1].field_0) == uint255(uint256(stor11[arg1].field_0)) * 0.5 < 32:
                    revert with 0, 34
                uint256(stor11[arg1].field_0) = 0
                if 31 < uint255(uint256(stor11[arg1].field_0)) * 0.5:
                    idx = 0
                    while (uint255(uint256(stor11[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                        uint256(stor11[arg1][idx].field_0) = 0
                        idx = idx + 1
                        continue 
            else:
                if bool(stor11[arg1].field_0) == stor11[arg1].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor11[arg1].field_0) = 0
                if 31 < stor11[arg1].field_1 % 128:
                    idx = 0
                    while stor11[arg1].field_1 % 128 + 31 / 32 > idx:
                        uint256(stor11[arg1][idx].field_0) = 0
                        idx = idx + 1
                        continue 
    else:
        if bool(stor11[arg1].field_0) == stor11[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if stor11[arg1].field_1 % 128:
            if bool(stor11[arg1].field_0):
                if bool(stor11[arg1].field_0) == uint255(uint256(stor11[arg1].field_0)) * 0.5 < 32:
                    revert with 0, 34
                uint256(stor11[arg1].field_0) = 0
                if 31 < uint255(uint256(stor11[arg1].field_0)) * 0.5:
                    idx = 0
                    while (uint255(uint256(stor11[arg1].field_0)) * 0.5) + 31 / 32 > idx:
                        uint256(stor11[arg1][idx].field_0) = 0
                        idx = idx + 1
                        continue 
            else:
                if bool(stor11[arg1].field_0) == stor11[arg1].field_1 % 128 < 32:
                    revert with 0, 34
                uint256(stor11[arg1].field_0) = 0
                if 31 < stor11[arg1].field_1 % 128:
                    idx = 0
                    while stor11[arg1].field_1 % 128 + 31 / 32 > idx:
                        uint256(stor11[arg1][idx].field_0) = 0
                        idx = idx + 1
                        continue 
}

function tokenURI(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC721URIStorage: URI query for nonexistent token'
    if bool(stor11[arg1].field_0):
        if bool(stor11[arg1].field_0) == uint255(uint256(stor11[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        if bool(stor11[arg1].field_0):
            if bool(stor11[arg1].field_0) == uint255(uint256(stor11[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor11[arg1].field_0)):
                if 31 < uint255(uint256(stor11[arg1].field_0)) * 0.5:
                    mem[128] = uint256(stor11[arg1].field_0)
                    idx = 128
                    s = 0
                    while (uint255(uint256(stor11[arg1].field_0)) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor11[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, uint256(stor11[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5)]), 
                mem[128] = 256 * Mask(248, 0, stor11[arg1].field_8)
        else:
            if bool(stor11[arg1].field_0) == stor11[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor11[arg1].field_1 % 128:
                if 31 < stor11[arg1].field_1 % 128:
                    mem[128] = uint256(stor11[arg1].field_0)
                    idx = 128
                    s = 0
                    while stor11[arg1].field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor11[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, uint256(stor11[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5)]), 
                mem[128] = 256 * Mask(248, 0, stor11[arg1].field_8)
        mem[ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5) + 224 len ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5)] = mem[128 len ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5)]
        if ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5) > uint255(uint256(stor11[arg1].field_0)) * 0.5:
            mem[(uint255(uint256(stor11[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5) + 224] = 0
        return Array(len=2 * Mask(256, -1, uint256(stor11[arg1].field_0)), data=mem[128 len ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5)) + 224 len 2 * ceil32(uint255(uint256(stor11[arg1].field_0)) * 0.5)]), 
    if bool(stor11[arg1].field_0) == stor11[arg1].field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor11[arg1].field_0):
        if bool(stor11[arg1].field_0) == uint255(uint256(stor11[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, uint256(stor11[arg1].field_0)):
            if 31 < uint255(uint256(stor11[arg1].field_0)) * 0.5:
                mem[128] = uint256(stor11[arg1].field_0)
                idx = 128
                s = 0
                while (uint255(uint256(stor11[arg1].field_0)) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor11[arg1][s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor11[arg1].field_0 % 128, data=mem[128 len ceil32(stor11[arg1].field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor11[arg1].field_8)
    else:
        if bool(stor11[arg1].field_0) == stor11[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if stor11[arg1].field_1 % 128:
            if 31 < stor11[arg1].field_1 % 128:
                mem[128] = uint256(stor11[arg1].field_0)
                idx = 128
                s = 0
                while stor11[arg1].field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor11[arg1][s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor11[arg1].field_0 % 128, data=mem[128 len ceil32(stor11[arg1].field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor11[arg1].field_8)
    mem[ceil32(stor11[arg1].field_1 % 128) + 224 len ceil32(stor11[arg1].field_1 % 128)] = mem[128 len ceil32(stor11[arg1].field_1 % 128)]
    if ceil32(stor11[arg1].field_1 % 128) > stor11[arg1].field_1 % 128:
        mem[stor11[arg1].field_1 % 128 + ceil32(stor11[arg1].field_1 % 128) + 224] = 0
    return Array(len=stor11[arg1].field_0 % 128, data=mem[128 len ceil32(stor11[arg1].field_1 % 128)], mem[(2 * ceil32(stor11[arg1].field_1 % 128)) + 224 len 2 * ceil32(stor11[arg1].field_1 % 128)]), 
}

function mintWithCashback(address arg1, uint256 arg2, string arg3, address[] arg4, uint256[] arg5) {
    require calldata.size - 4 >= 160
    require arg1 == arg1
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg3.length)) + 97 < 96 or ceil32(ceil32(arg3.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg3.length
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    mem[arg3.length + 128] = 0
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg4.length) + 98 < 97 or ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(ceil32(arg3.length)) + 97] = arg4.length
    require arg4 + (32 * arg4.length) + 36 <= calldata.size
    idx = 0
    s = arg4 + 36
    t = ceil32(ceil32(arg3.length)) + 129
    while idx < arg4.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg5 <= test266151307()
    require arg5 + 35 < calldata.size
    if arg5.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg5.length) + 99 < 98 or ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + ceil32(32 * arg5.length) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + 98] = arg5.length
    require arg5 + (32 * arg5.length) + 36 <= calldata.size
    idx = 0
    s = arg5 + 36
    t = ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + 130
    while idx < arg5.length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if not stor17:
        if not uint8(roleAdmin[0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956][address(msg.sender)].field_0):
            revert with 0, 'ERC721PresetMinterPauserAutoId: must have minter role to mint'
    if not arg1:
        revert with 0, 'ERC721: mint to the zero address'
    if ownerOf[arg2]:
        revert with 0, 'ERC721: token already minted'
    stor10[arg2] = tokenByIndex.length
    tokenByIndex.length++
    tokenByIndex[tokenByIndex.length] = arg2
    if arg1:
        if arg1:
            if not arg1:
                revert with 0, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)]] = arg2
            stor8[arg2] = balanceOf[address(arg1)]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor10[arg2] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor10[arg2]] = tokenByIndex[tokenByIndex.length]
        stor10[stor9[stor9.length]] = stor10[arg2]
        stor10[arg2] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    if balanceOf[address(arg1)] > -2:
        revert with 0, 17
    balanceOf[address(arg1)]++
    ownerOf[arg2] = arg1
    emit Transfer(0, arg1, arg2);
    if not ownerOf[arg2]:
        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
    if bool(stor11[arg2].field_0):
        if bool(stor11[arg2].field_0) == uint255(uint256(stor11[arg2].field_0)) * 0.5 < 32:
            revert with 0, 34
        if not arg3.length:
            uint256(stor11[arg2].field_0) = 0
            idx = 0
            while (uint255(uint256(stor11[arg2].field_0)) * 0.5) + 31 / 32 > idx:
                uint256(stor11[arg2][idx].field_0) = 0
                idx = idx + 1
                continue 
            uint256(stor14[arg2].field_0) = arg4.length
            if not arg4.length:
                idx = 0
                while uint256(stor14[arg2].field_0) > idx:
                    uint256(stor14[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(arg3.length)) + 129
                while ceil32(ceil32(arg3.length)) + (32 * arg4.length) + 129 > idx:
                    address(stor14[arg2][s].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg4.length) + 31) >> 5
                while uint256(stor14[arg2].field_0) > idx:
                    uint256(stor14[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor15[arg2].field_0) = arg5.length
            if not arg5.length:
                idx = 0
                while uint256(stor15[arg2].field_0) > idx:
                    uint256(stor15[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + 130
                while ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + (32 * arg5.length) + 130 > idx:
                    uint256(stor15[arg2][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg5.length) + 31) >> 5
                while uint256(stor15[arg2].field_0) > idx:
                    uint256(stor15[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        else:
            uint256(stor11[arg2].field_0) = (2 * arg3.length) + 1
            if arg3.length <= 0:
                idx = 0
                while (uint255(uint256(stor11[arg2].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor11[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(stor11[arg2].field_0) = mem[128]
                s = 1
                idx = 160
                while arg3.length + 128 > idx:
                    uint256(stor11[arg2][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = (Mask(251, 0, arg3.length - 1) >> 5) + 1
                while (uint255(uint256(stor11[arg2].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor11[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor14[arg2].field_0) = arg4.length
            if not arg4.length:
                idx = 0
                while uint256(stor14[arg2].field_0) > idx:
                    uint256(stor14[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(arg3.length)) + 129
                while ceil32(ceil32(arg3.length)) + (32 * arg4.length) + 129 > idx:
                    address(stor14[arg2][s].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg4.length) + 31) >> 5
                while uint256(stor14[arg2].field_0) > idx:
                    uint256(stor14[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor15[arg2].field_0) = arg5.length
            if not arg5.length:
                idx = 0
                while uint256(stor15[arg2].field_0) > idx:
                    uint256(stor15[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + 130
                while ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + (32 * arg5.length) + 130 > idx:
                    uint256(stor15[arg2][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg5.length) + 31) >> 5
                while uint256(stor15[arg2].field_0) > idx:
                    uint256(stor15[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
    else:
        if bool(stor11[arg2].field_0) == stor11[arg2].field_1 % 128 < 32:
            revert with 0, 34
        if not arg3.length:
            uint256(stor11[arg2].field_0) = 0
            idx = 0
            while stor11[arg2].field_1 % 128 + 31 / 32 > idx:
                uint256(stor11[arg2][idx].field_0) = 0
                idx = idx + 1
                continue 
            uint256(stor14[arg2].field_0) = arg4.length
            if not arg4.length:
                idx = 0
                while uint256(stor14[arg2].field_0) > idx:
                    uint256(stor14[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(arg3.length)) + 129
                while ceil32(ceil32(arg3.length)) + (32 * arg4.length) + 129 > idx:
                    address(stor14[arg2][s].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg4.length) + 31) >> 5
                while uint256(stor14[arg2].field_0) > idx:
                    uint256(stor14[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor15[arg2].field_0) = arg5.length
            if not arg5.length:
                idx = 0
                while uint256(stor15[arg2].field_0) > idx:
                    uint256(stor15[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + 130
                while ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + (32 * arg5.length) + 130 > idx:
                    uint256(stor15[arg2][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg5.length) + 31) >> 5
                while uint256(stor15[arg2].field_0) > idx:
                    uint256(stor15[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        else:
            uint256(stor11[arg2].field_0) = (2 * arg3.length) + 1
            if arg3.length <= 0:
                idx = 0
                while stor11[arg2].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor11[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(stor11[arg2].field_0) = mem[128]
                s = 1
                idx = 160
                while arg3.length + 128 > idx:
                    uint256(stor11[arg2][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = (Mask(251, 0, arg3.length - 1) >> 5) + 1
                while stor11[arg2].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor11[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor14[arg2].field_0) = arg4.length
            if not arg4.length:
                idx = 0
                while uint256(stor14[arg2].field_0) > idx:
                    uint256(stor14[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(arg3.length)) + 129
                while ceil32(ceil32(arg3.length)) + (32 * arg4.length) + 129 > idx:
                    address(stor14[arg2][s].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg4.length) + 31) >> 5
                while uint256(stor14[arg2].field_0) > idx:
                    uint256(stor14[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor15[arg2].field_0) = arg5.length
            if not arg5.length:
                idx = 0
                while uint256(stor15[arg2].field_0) > idx:
                    uint256(stor15[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + 130
                while ceil32(ceil32(arg3.length)) + ceil32(32 * arg4.length) + (32 * arg5.length) + 130 > idx:
                    uint256(stor15[arg2][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * arg5.length) + 31) >> 5
                while uint256(stor15[arg2].field_0) > idx:
                    uint256(stor15[arg2][idx].field_0) = 0
                    idx = idx + 1
                    continue 
    return 1
}

function sub_fc3461fa(?) {
    require calldata.size - 4 >= 192
    require cd[4] == address(cd[4])
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(('cd', 68).length)) + 97 < 96 or ceil32(ceil32(('cd', 68).length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 68).length
    require cd[68] + ('cd', 68).length + 36 <= calldata.size
    mem[128 len ('cd', 68).length] = call.data[cd[68] + 36 len ('cd', 68).length]
    mem[('cd', 68).length + 128] = 0
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    if ('cd', 100).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 100).length) + 98 < 97 or ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(ceil32(('cd', 68).length)) + 97] = ('cd', 100).length
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 0
    s = cd[100] + 36
    t = ceil32(ceil32(('cd', 68).length)) + 129
    while idx < ('cd', 100).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[132] <= test266151307()
    require cd[132] + 35 < calldata.size
    if ('cd', 132).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 132).length) + 99 < 98 or ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + 98] = ('cd', 132).length
    require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
    idx = 0
    s = cd[132] + 36
    t = ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + 130
    while idx < ('cd', 132).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[164] == address(cd[164])
    if not address(cd[164]):
        revert with 0, 'Custom cashbacks cannot be set to 0 address'
    sub_498715ac[cd[36]] = address(cd[164])
    if not stor17:
        if not uint8(roleAdmin[0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956][address(msg.sender)].field_0):
            revert with 0, 'ERC721PresetMinterPauserAutoId: must have minter role to mint'
    if not address(cd[4]):
        revert with 0, 'ERC721: mint to the zero address'
    if ownerOf[cd[36]]:
        revert with 0, 'ERC721: token already minted'
    stor10[cd[36]] = tokenByIndex.length
    tokenByIndex.length++
    tokenByIndex[tokenByIndex.length] = cd[36]
    if address(cd[4]):
        if address(cd[4]):
            if not address(cd[4]):
                revert with 0, 'ERC721: balance query for the zero address'
            tokenOfOwnerByIndex[address(cd[4])][stor4[address(cd[4])]] = cd[36]
            stor8[cd[36]] = balanceOf[address(cd[4])]
    else:
        if tokenByIndex.length < 1:
            revert with 0, 17
        if tokenByIndex.length - 1 >= tokenByIndex.length:
            revert with 0, 50
        if stor10[cd[36]] >= tokenByIndex.length:
            revert with 0, 50
        tokenByIndex[stor10[cd[36]]] = tokenByIndex[tokenByIndex.length]
        stor10[stor9[stor9.length]] = stor10[cd[36]]
        stor10[cd[36]] = 0
        if not tokenByIndex.length:
            revert with 0, 49
        tokenByIndex[tokenByIndex.length] = 0
        tokenByIndex.length--
    if balanceOf[address(cd[4])] > -2:
        revert with 0, 17
    balanceOf[address(cd[4])]++
    ownerOf[cd[36]] = address(cd[4])
    emit Transfer(0, address(cd[4]), cd[36]);
    if not ownerOf[cd[36]]:
        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
    if bool(stor11[cd[36]].field_0):
        if bool(stor11[cd[36]].field_0) == uint255(uint256(stor11[cd[36]].field_0)) * 0.5 < 32:
            revert with 0, 34
        if not ('cd', 68).length:
            uint256(stor11[cd[36]].field_0) = 0
            idx = 0
            while (uint255(uint256(stor11[cd[36]].field_0)) * 0.5) + 31 / 32 > idx:
                uint256(stor11[cd[36]][idx].field_0) = 0
                idx = idx + 1
                continue 
            uint256(stor14[cd[36]].field_0) = ('cd', 100).length
            if not ('cd', 100).length:
                idx = 0
                while uint256(stor14[cd[36]].field_0) > idx:
                    uint256(stor14[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(('cd', 68).length)) + 129
                while ceil32(ceil32(('cd', 68).length)) + (32 * ('cd', 100).length) + 129 > idx:
                    address(stor14[cd[36]][s].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * ('cd', 100).length) + 31) >> 5
                while uint256(stor14[cd[36]].field_0) > idx:
                    uint256(stor14[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor15[cd[36]].field_0) = ('cd', 132).length
            if not ('cd', 132).length:
                idx = 0
                while uint256(stor15[cd[36]].field_0) > idx:
                    uint256(stor15[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + 130
                while ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + (32 * ('cd', 132).length) + 130 > idx:
                    uint256(stor15[cd[36]][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * ('cd', 132).length) + 31) >> 5
                while uint256(stor15[cd[36]].field_0) > idx:
                    uint256(stor15[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        else:
            uint256(stor11[cd[36]].field_0) = (2 * ('cd', 68).length) + 1
            if ('cd', 68).length <= 0:
                idx = 0
                while (uint255(uint256(stor11[cd[36]].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor11[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(stor11[cd[36]].field_0) = mem[128]
                s = 1
                idx = 160
                while ('cd', 68).length + 128 > idx:
                    uint256(stor11[cd[36]][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = (Mask(251, 0, ('cd', 68).length - 1) >> 5) + 1
                while (uint255(uint256(stor11[cd[36]].field_0)) * 0.5) + 31 / 32 > idx:
                    uint256(stor11[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor14[cd[36]].field_0) = ('cd', 100).length
            if not ('cd', 100).length:
                idx = 0
                while uint256(stor14[cd[36]].field_0) > idx:
                    uint256(stor14[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(('cd', 68).length)) + 129
                while ceil32(ceil32(('cd', 68).length)) + (32 * ('cd', 100).length) + 129 > idx:
                    address(stor14[cd[36]][s].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * ('cd', 100).length) + 31) >> 5
                while uint256(stor14[cd[36]].field_0) > idx:
                    uint256(stor14[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor15[cd[36]].field_0) = ('cd', 132).length
            if not ('cd', 132).length:
                idx = 0
                while uint256(stor15[cd[36]].field_0) > idx:
                    uint256(stor15[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + 130
                while ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + (32 * ('cd', 132).length) + 130 > idx:
                    uint256(stor15[cd[36]][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * ('cd', 132).length) + 31) >> 5
                while uint256(stor15[cd[36]].field_0) > idx:
                    uint256(stor15[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
    else:
        if bool(stor11[cd[36]].field_0) == stor11[cd[36]].field_1 % 128 < 32:
            revert with 0, 34
        if not ('cd', 68).length:
            uint256(stor11[cd[36]].field_0) = 0
            idx = 0
            while stor11[cd[36]].field_1 % 128 + 31 / 32 > idx:
                uint256(stor11[cd[36]][idx].field_0) = 0
                idx = idx + 1
                continue 
            uint256(stor14[cd[36]].field_0) = ('cd', 100).length
            if not ('cd', 100).length:
                idx = 0
                while uint256(stor14[cd[36]].field_0) > idx:
                    uint256(stor14[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(('cd', 68).length)) + 129
                while ceil32(ceil32(('cd', 68).length)) + (32 * ('cd', 100).length) + 129 > idx:
                    address(stor14[cd[36]][s].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * ('cd', 100).length) + 31) >> 5
                while uint256(stor14[cd[36]].field_0) > idx:
                    uint256(stor14[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor15[cd[36]].field_0) = ('cd', 132).length
            if not ('cd', 132).length:
                idx = 0
                while uint256(stor15[cd[36]].field_0) > idx:
                    uint256(stor15[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + 130
                while ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + (32 * ('cd', 132).length) + 130 > idx:
                    uint256(stor15[cd[36]][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * ('cd', 132).length) + 31) >> 5
                while uint256(stor15[cd[36]].field_0) > idx:
                    uint256(stor15[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
        else:
            uint256(stor11[cd[36]].field_0) = (2 * ('cd', 68).length) + 1
            if ('cd', 68).length <= 0:
                idx = 0
                while stor11[cd[36]].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor11[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                uint256(stor11[cd[36]].field_0) = mem[128]
                s = 1
                idx = 160
                while ('cd', 68).length + 128 > idx:
                    uint256(stor11[cd[36]][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = (Mask(251, 0, ('cd', 68).length - 1) >> 5) + 1
                while stor11[cd[36]].field_1 % 128 + 31 / 32 > idx:
                    uint256(stor11[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor14[cd[36]].field_0) = ('cd', 100).length
            if not ('cd', 100).length:
                idx = 0
                while uint256(stor14[cd[36]].field_0) > idx:
                    uint256(stor14[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(('cd', 68).length)) + 129
                while ceil32(ceil32(('cd', 68).length)) + (32 * ('cd', 100).length) + 129 > idx:
                    address(stor14[cd[36]][s].field_0) = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * ('cd', 100).length) + 31) >> 5
                while uint256(stor14[cd[36]].field_0) > idx:
                    uint256(stor14[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            uint256(stor15[cd[36]].field_0) = ('cd', 132).length
            if not ('cd', 132).length:
                idx = 0
                while uint256(stor15[cd[36]].field_0) > idx:
                    uint256(stor15[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
            else:
                s = 0
                idx = ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + 130
                while ceil32(ceil32(('cd', 68).length)) + ceil32(32 * ('cd', 100).length) + (32 * ('cd', 132).length) + 130 > idx:
                    uint256(stor15[cd[36]][s].field_0) = mem[idx]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = Mask(251, 0, (32 * ('cd', 132).length) + 31) >> 5
                while uint256(stor15[cd[36]].field_0) > idx:
                    uint256(stor15[cd[36]][idx].field_0) = 0
                    idx = idx + 1
                    continue 
    return 1
}

function mintMultiple(address[] arg1, uint256[] arg2, string[] arg3) {
    require calldata.size - 4 >= 96
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = 0
    s = arg1 + 36
    t = 128
    while idx < arg1.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    if arg2.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg2.length) + 98 < 97 or ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * arg1.length) + 97] = arg2.length
    require arg2 + (32 * arg2.length) + 36 <= calldata.size
    idx = 0
    s = arg2 + 36
    t = ceil32(32 * arg1.length) + 129
    while idx < arg2.length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    if arg3.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg3.length) + 99 < 98 or ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + ceil32(32 * arg3.length) + 99 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + ceil32(32 * arg3.length) + 99
    mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98] = arg3.length
    require arg3 + (32 * arg3.length) + 36 <= calldata.size
    idx = 0
    s = arg3 + 36
    t = ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130
    while idx < arg3.length:
        require cd[s] <= test266151307()
        require arg3 + cd[s] + 67 < calldata.size
        if cd[(arg3 + cd[s] + 36)] > test266151307():
            revert with 0, 65
        _544 = mem[64]
        if mem[64] + ceil32(ceil32(cd[(arg3 + cd[s] + 36)])) + 1 < mem[64] or mem[64] + ceil32(ceil32(cd[(arg3 + cd[s] + 36)])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(ceil32(cd[(arg3 + cd[s] + 36)])) + 1
        mem[_544] = cd[(arg3 + cd[s] + 36)]
        require arg3 + cd[s] + cd[(arg3 + cd[s] + 36)] + 68 <= calldata.size
        mem[_544 + 32 len cd[(arg3 + cd[s] + 36)]] = call.data[arg3 + cd[s] + 68 len cd[(arg3 + cd[s] + 36)]]
        mem[_544 + cd[(arg3 + cd[s] + 36)] + 32] = 0
        mem[t] = _544
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if stor17:
        idx = 0
        while idx < mem[96]:
            if idx >= mem[96]:
                revert with 0, 50
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, 'ERC721: mint to the zero address'
            if ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]:
                revert with 0, 'ERC721: token already minted'
            stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = tokenByIndex.length
            tokenByIndex.length++
            tokenByIndex[tokenByIndex.length] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
            if mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * arg1.length) + 129]);
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    mem[32] = 11
                    _792 = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                        if not _792:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _792) + 1
                            if _792 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _792 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _792 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                        if not _792:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _792) + 1
                            if _792 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _792 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _792 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(mem[(32 * idx) + 128])][stor4[address(mem[(32 * idx) + 128])]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    stor8[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = balanceOf[address(mem[(32 * idx) + 128])]
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * arg1.length) + 129]);
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    mem[32] = 11
                    _821 = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                        if not _821:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _821) + 1
                            if _821 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _821 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _821 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                        if not _821:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _821) + 1
                            if _821 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _821 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _821 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if tokenByIndex.length < 1:
                revert with 0, 17
            if tokenByIndex.length - 1 >= tokenByIndex.length:
                revert with 0, 50
            if stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] >= tokenByIndex.length:
                revert with 0, 50
            tokenByIndex[stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]] = tokenByIndex[tokenByIndex.length]
            stor10[stor9[stor9.length]] = stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]
            stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = 0
            if not tokenByIndex.length:
                revert with 0, 49
            tokenByIndex[tokenByIndex.length] = 0
            tokenByIndex.length--
            if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                revert with 0, 17
            balanceOf[address(mem[(32 * idx) + 128])]++
            ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = mem[(32 * idx) + 140 len 20]
            emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * arg1.length) + 129]);
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            if idx >= mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98]:
                revert with 0, 50
            if not ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]:
                revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
            mem[0] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
            mem[32] = 11
            _835 = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130]]
            if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0):
                if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                if not _835:
                    uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                else:
                    uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _835) + 1
                    if _835 <= 0:
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                        t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                        while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _835 + 32 > t:
                            uint256(stor[s]) = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _835 - 1) >> 5) + 1
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
            if not _835:
                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _835) + 1
            if _835 <= 0:
                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
            t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
            while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _835 + 32 > t:
                uint256(stor[s]) = mem[t]
                s = s + 1
                t = t + 32
                continue 
            s = sha3(sha3(mem[(32 * s) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _835 - 1) >> 5) + 1
            while sha3(sha3(mem[(32 * s) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * s) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
            if sha3(sha3(mem[(32 * s) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * s) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) == -1:
                revert with 0, 17
            s = sha3(sha3(mem[(32 * s) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * s) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) + 1
            continue 
    else:
        mem[0] = msg.sender
        mem[32] = sha3(0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956, 12)
        if not uint8(roleAdmin[0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956][address(msg.sender)].field_0):
            revert with 0, 'ERC721PresetMinterPauserAutoId: must have minter role to mint'
        idx = 0
        while idx < mem[96]:
            if idx >= mem[96]:
                revert with 0, 50
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, 'ERC721: mint to the zero address'
            if ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]:
                revert with 0, 'ERC721: token already minted'
            stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = tokenByIndex.length
            tokenByIndex.length++
            tokenByIndex[tokenByIndex.length] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
            if mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * arg1.length) + 129]);
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    mem[32] = 11
                    _799 = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                        if not _799:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _799) + 1
                            if _799 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _799 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _799 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                        if not _799:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _799) + 1
                            if _799 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _799 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _799 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(mem[(32 * idx) + 128])][stor4[address(mem[(32 * idx) + 128])]] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    stor8[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = balanceOf[address(mem[(32 * idx) + 128])]
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * arg1.length) + 129]);
                    if idx >= mem[ceil32(32 * arg1.length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
                    mem[32] = 11
                    _826 = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                        if not _826:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _826) + 1
                            if _826 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _826 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _826 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                        if not _826:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _826) + 1
                            if _826 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _826 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _826 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if tokenByIndex.length < 1:
                revert with 0, 17
            if tokenByIndex.length - 1 >= tokenByIndex.length:
                revert with 0, 50
            if stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] >= tokenByIndex.length:
                revert with 0, 50
            tokenByIndex[stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]] = tokenByIndex[tokenByIndex.length]
            stor10[stor9[stor9.length]] = stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]
            stor10[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = 0
            if not tokenByIndex.length:
                revert with 0, 49
            tokenByIndex[tokenByIndex.length] = 0
            tokenByIndex.length--
            if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                revert with 0, 17
            balanceOf[address(mem[(32 * idx) + 128])]++
            ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]] = mem[(32 * idx) + 140 len 20]
            emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * arg1.length) + 129]);
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            if idx >= mem[ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 98]:
                revert with 0, 50
            if not ownerOf[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]]:
                revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
            mem[0] = mem[(32 * idx) + ceil32(32 * arg1.length) + 129]
            mem[32] = 11
            _839 = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130]]
            if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0):
                if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5 < 32:
                    revert with 0, 34
                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
                if not _839:
                    uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                        uint256(stor[s]) = 0
                        s = s + 1
                        continue 
                else:
                    uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _839) + 1
                    if _839 <= 0:
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
                        t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
                        while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _839 + 32 > t:
                            uint256(stor[s]) = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _839 - 1) >> 5) + 1
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if bool(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 < 32:
                revert with 0, 34
            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)
            if not _839:
                uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = 0
                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = (2 * _839) + 1
            if _839 <= 0:
                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11))
                while sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                    uint256(stor[s]) = 0
                    s = s + 1
                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            uint256(stor11[mem[(32 * idx) + ceil32(32 * arg1.length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 32]
            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * arg1.length) + 129], 11)) + 1
            t = mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + 64
            while mem[(32 * idx) + ceil32(32 * arg1.length) + ceil32(32 * arg2.length) + 130] + _839 + 32 > t:
                uint256(stor[s]) = mem[t]
                s = s + 1
                t = t + 32
                continue 
            s = sha3(sha3(mem[(32 * s) + ceil32(32 * arg1.length) + 129], 11)) + (Mask(251, 0, _839 - 1) >> 5) + 1
            while sha3(sha3(mem[(32 * s) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * s) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) > s:
                uint256(stor[s]) = 0
                s = s + 1
                continue 
            if sha3(sha3(mem[(32 * s) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * s) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) == -1:
                revert with 0, 17
            s = sha3(sha3(mem[(32 * s) + ceil32(32 * arg1.length) + 129], 11)) + (stor11[mem[(32 * s) + ceil32(32 * arg1.length) + 129]].field_1 % 128 + 31 / 32) + 1
            continue 
    return 1
}

function sub_94f68d84(?) {
    require calldata.size - 4 >= 160
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        require cd[s] <= test266151307()
        require cd[68] + cd[s] + 67 < calldata.size
        if cd[(cd[68] + cd[s] + 36)] > test266151307():
            revert with 0, 65
        _4870 = mem[64]
        if mem[64] + ceil32(ceil32(cd[(cd[68] + cd[s] + 36)])) + 1 < mem[64] or mem[64] + ceil32(ceil32(cd[(cd[68] + cd[s] + 36)])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(ceil32(cd[(cd[68] + cd[s] + 36)])) + 1
        mem[_4870] = cd[(cd[68] + cd[s] + 36)]
        require cd[68] + cd[s] + cd[(cd[68] + cd[s] + 36)] + 68 <= calldata.size
        mem[_4870 + 32 len cd[(cd[68] + cd[s] + 36)]] = call.data[cd[68] + cd[s] + 68 len cd[(cd[68] + cd[s] + 36)]]
        mem[_4870 + cd[(cd[68] + cd[s] + 36)] + 32] = 0
        mem[t] = _4870
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    if ('cd', 100).length > test266151307():
        revert with 0, 65
    _4871 = mem[64]
    if mem[64] + ceil32(32 * ('cd', 100).length) + 1 < mem[64] or mem[64] + ceil32(32 * ('cd', 100).length) + 1 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + ceil32(32 * ('cd', 100).length) + 1
    mem[_4871] = ('cd', 100).length
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 0
    s = cd[100] + 36
    t = _4871 + 32
    while idx < ('cd', 100).length:
        require cd[s] <= test266151307()
        require cd[100] + cd[s] + 67 < calldata.size
        if cd[(cd[100] + cd[s] + 36)] > test266151307():
            revert with 0, 65
        _6491 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[100] + cd[s] + 36)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[100] + cd[s] + 36)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[100] + cd[s] + 36)]) + 1
        mem[_6491] = cd[(cd[100] + cd[s] + 36)]
        require cd[100] + cd[s] + (32 * cd[(cd[100] + cd[s] + 36)]) + 68 <= calldata.size
        u = 0
        v = cd[100] + cd[s] + 68
        w = _6491 + 32
        while u < cd[(cd[100] + cd[s] + 36)]:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _6491
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[132] <= test266151307()
    require cd[132] + 35 < calldata.size
    if ('cd', 132).length > test266151307():
        revert with 0, 65
    _6492 = mem[64]
    if mem[64] + ceil32(32 * ('cd', 132).length) + 1 < mem[64] or mem[64] + ceil32(32 * ('cd', 132).length) + 1 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + ceil32(32 * ('cd', 132).length) + 1
    mem[_6492] = ('cd', 132).length
    require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
    idx = 0
    s = cd[132] + 36
    t = _6492 + 32
    while idx < ('cd', 132).length:
        require cd[s] <= test266151307()
        require cd[132] + cd[s] + 67 < calldata.size
        if cd[(cd[132] + cd[s] + 36)] > test266151307():
            revert with 0, 65
        _8120 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[132] + cd[s] + 36)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[132] + cd[s] + 36)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[132] + cd[s] + 36)]) + 1
        mem[_8120] = cd[(cd[132] + cd[s] + 36)]
        require cd[132] + cd[s] + (32 * cd[(cd[132] + cd[s] + 36)]) + 68 <= calldata.size
        u = 0
        v = cd[132] + cd[s] + 68
        w = _8120 + 32
        while u < cd[(cd[132] + cd[s] + 36)]:
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _8120
        u = u + 1
        s = s + 32
        t = t + 32
        continue 
    if stor17:
        idx = 0
        while idx < mem[96]:
            if idx >= mem[96]:
                revert with 0, 50
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, 'ERC721: mint to the zero address'
            if ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                revert with 0, 'ERC721: token already minted'
            stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = tokenByIndex.length
            tokenByIndex.length++
            tokenByIndex[tokenByIndex.length] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[32] = 11
                    _9804 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _9804:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11403 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11504 = mem[_11403]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11403]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11504:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12892 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13006 = mem[_12892]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12892]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13006:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12892 + 32
                                    while _12892 + (32 * _13006) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13006) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11403 + 32
                                while _11403 + (32 * _11504) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11504) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14021 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14147 = mem[_14021]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14021]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14147:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14021 + 32
                                    while _14021 + (32 * _14147) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14147) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9804) + 1
                            if _9804 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _11399 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _11498 = mem[_11399]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11399]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _11498:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _12887 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _12998 = mem[_12887]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12887]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _12998:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _12887 + 32
                                        while _12887 + (32 * _12998) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _12998) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _11399 + 32
                                    while _11399 + (32 * _11498) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11498) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14015 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14138 = mem[_14015]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14015]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14138:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14015 + 32
                                        while _14015 + (32 * _14138) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14138) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9804 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9804 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _12999 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13167 = mem[_12999]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12999]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13167:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14017 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14141 = mem[_14017]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14017]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14141:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14017 + 32
                                        while _14017 + (32 * _14141) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14141) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _12999 + 32
                                    while _12999 + (32 * _13167) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13167) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14601 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14627 = mem[_14601]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14601]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14627:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14601 + 32
                                        while _14601 + (32 * _14627) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14627) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _9804:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11411 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11516 = mem[_11411]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11411]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11516:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12901 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13020 = mem[_12901]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12901]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13020:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12901 + 32
                                    while _12901 + (32 * _13020) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13020) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11411 + 32
                                while _11411 + (32 * _11516) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11516) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14031 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14162 = mem[_14031]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14031]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14162:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14031 + 32
                                    while _14031 + (32 * _14162) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14162) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9804) + 1
                            if _9804 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _11407 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _11510 = mem[_11407]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11407]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _11510:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _12896 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _13012 = mem[_12896]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12896]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _13012:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _12896 + 32
                                        while _12896 + (32 * _13012) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13012) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _11407 + 32
                                    while _11407 + (32 * _11510) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11510) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14025 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14153 = mem[_14025]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14025]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14153:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14025 + 32
                                        while _14025 + (32 * _14153) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14153) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9804 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9804 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _13013 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13178 = mem[_13013]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13013]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13178:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14027 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14156 = mem[_14027]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14027]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14156:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14027 + 32
                                        while _14027 + (32 * _14156) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14156) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13013 + 32
                                    while _13013 + (32 * _13178) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13178) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14603 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14630 = mem[_14603]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14603]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14630:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14603 + 32
                                        while _14603 + (32 * _14630) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14630) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(mem[(32 * idx) + 128])][stor4[address(mem[(32 * idx) + 128])]] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    stor8[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = balanceOf[address(mem[(32 * idx) + 128])]
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[32] = 11
                    _9833 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _9833:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11419 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11528 = mem[_11419]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11419]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11528:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12910 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13034 = mem[_12910]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12910]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13034:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12910 + 32
                                    while _12910 + (32 * _13034) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13034) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11419 + 32
                                while _11419 + (32 * _11528) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11528) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14041 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14177 = mem[_14041]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14041]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14177:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14041 + 32
                                    while _14041 + (32 * _14177) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14177) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9833) + 1
                            if _9833 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _11415 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _11522 = mem[_11415]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11415]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _11522:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _12905 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _13026 = mem[_12905]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12905]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _13026:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _12905 + 32
                                        while _12905 + (32 * _13026) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13026) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _11415 + 32
                                    while _11415 + (32 * _11522) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11522) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14035 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14168 = mem[_14035]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14035]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14168:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14035 + 32
                                        while _14035 + (32 * _14168) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14168) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9833 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9833 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _13027 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13189 = mem[_13027]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13027]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13189:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14037 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14171 = mem[_14037]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14037]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14171:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14037 + 32
                                        while _14037 + (32 * _14171) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14171) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13027 + 32
                                    while _13027 + (32 * _13189) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13189) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14605 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14633 = mem[_14605]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14605]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14633:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14605 + 32
                                        while _14605 + (32 * _14633) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14633) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _9833:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11427 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11540 = mem[_11427]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11427]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11540:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12919 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13048 = mem[_12919]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12919]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13048:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12919 + 32
                                    while _12919 + (32 * _13048) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13048) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11427 + 32
                                while _11427 + (32 * _11540) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11540) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14051 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14192 = mem[_14051]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14051]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14192:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14051 + 32
                                    while _14051 + (32 * _14192) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14192) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9833) + 1
                            if _9833 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _11423 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _11534 = mem[_11423]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11423]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _11534:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _12914 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _13040 = mem[_12914]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12914]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _13040:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _12914 + 32
                                        while _12914 + (32 * _13040) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13040) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11423 + 32
                                while _11423 + (32 * _11534) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11534) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14045 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14183 = mem[_14045]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14045]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14183:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14045 + 32
                                while _14045 + (32 * _14183) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14183) + 31) >> 5)
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                            t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                            while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9833 + 32 > t:
                                uint256(stor[s]) = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9833 - 1) >> 5) + 1
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _13041 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13200 = mem[_13041]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13041]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13200:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14047 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14186 = mem[_14047]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14047]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14186:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14047 + 32
                                while _14047 + (32 * _14186) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14186) + 31) >> 5)
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _13041 + 32
                            while _13041 + (32 * _13200) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13200) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14607 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14636 = mem[_14607]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14607]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14636:
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                            s = _14607 + 32
                            while _14607 + (32 * _14636) + 32 > s:
                                uint256(stor[t]) = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14636) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]] = tokenByIndex[tokenByIndex.length]
                stor10[stor9[stor9.length]] = stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]
                stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
                if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                    revert with 0, 17
                balanceOf[address(mem[(32 * idx) + 128])]++
                ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                    revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                mem[32] = 11
                _9847 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                    if not _9847:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4871]:
                            revert with 0, 50
                        _11435 = mem[(32 * idx) + _4871 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _11552 = mem[_11435]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11435]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _11552:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _12928 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _13062 = mem[_12928]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12928]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _13062:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _12928 + 32
                                while _12928 + (32 * _13062) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13062) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _11435 + 32
                            while _11435 + (32 * _11552) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11552) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14061 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14207 = mem[_14061]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14061]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14207:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14061 + 32
                                while _14061 + (32 * _14207) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14207) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9847) + 1
                        if _9847 <= 0:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11431 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11546 = mem[_11431]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11431]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11546:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12923 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13054 = mem[_12923]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12923]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13054:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12923 + 32
                                    while _12923 + (32 * _13054) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13054) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11431 + 32
                                while _11431 + (32 * _11546) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11546) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14055 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14198 = mem[_14055]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14055]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14198:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14055 + 32
                                    while _14055 + (32 * _14198) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14198) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                            t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                            while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9847 + 32 > t:
                                uint256(stor[s]) = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9847 - 1) >> 5) + 1
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _13055 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13211 = mem[_13055]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13055]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13211:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14057 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14201 = mem[_14057]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14057]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14201:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14057 + 32
                                    while _14057 + (32 * _14201) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14201) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13055 + 32
                                while _13055 + (32 * _13211) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13211) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14609 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14639 = mem[_14609]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14609]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14639:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14609 + 32
                                    while _14609 + (32 * _14639) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14639) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                else:
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                        revert with 0, 34
                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                    if not _9847:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4871]:
                            revert with 0, 50
                        _11443 = mem[(32 * idx) + _4871 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _11564 = mem[_11443]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11443]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _11564:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _12937 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _13076 = mem[_12937]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12937]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _13076:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _12937 + 32
                                while _12937 + (32 * _13076) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13076) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                        s = _11443 + 32
                        while _11443 + (32 * _11564) + 32 > s:
                            address(stor[t]) = mem[s + 12 len 20]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11564) + 31) >> 5)
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_6492]:
                            revert with 0, 50
                        _14071 = mem[(32 * idx) + _6492 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 15
                        _14222 = mem[_14071]
                        uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14071]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                        if not _14222:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                        s = _14071 + 32
                        while _14071 + (32 * _14222) + 32 > s:
                            uint256(stor[t]) = mem[s]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14222) + 31) >> 5)
                        while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                            revert with 0, 17
                        s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                        continue 
                    uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9847) + 1
                    if _9847 <= 0:
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4871]:
                            revert with 0, 50
                        _11439 = mem[(32 * idx) + _4871 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _11558 = mem[_11439]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11439]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _11558:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _12932 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _13068 = mem[_12932]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12932]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _13068:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _12932 + 32
                                while _12932 + (32 * _13068) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13068) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _11439 + 32
                            while _11439 + (32 * _11558) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11558) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14065 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14213 = mem[_14065]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14065]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14213:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14065 + 32
                                while _14065 + (32 * _14213) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14213) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                        t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                        while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9847 + 32 > t:
                            uint256(stor[s]) = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9847 - 1) >> 5) + 1
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4871]:
                            revert with 0, 50
                        _13069 = mem[(32 * idx) + _4871 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _13222 = mem[_13069]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13069]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _13222:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14067 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14216 = mem[_14067]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14067]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14216:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14067 + 32
                                while _14067 + (32 * _14216) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14216) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _13069 + 32
                            while _13069 + (32 * _13222) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13222) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14611 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14642 = mem[_14611]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14611]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14642:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14611 + 32
                                while _14611 + (32 * _14642) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14642) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    else:
        mem[0] = msg.sender
        mem[32] = sha3(0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956, 12)
        if not uint8(roleAdmin[0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956][address(msg.sender)].field_0):
            revert with 0, 'ERC721PresetMinterPauserAutoId: must have minter role to mint'
        idx = 0
        while idx < mem[96]:
            if idx >= mem[96]:
                revert with 0, 50
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, 'ERC721: mint to the zero address'
            if ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                revert with 0, 'ERC721: token already minted'
            stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = tokenByIndex.length
            tokenByIndex.length++
            tokenByIndex[tokenByIndex.length] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[32] = 11
                    _9811 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _9811:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11451 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11576 = mem[_11451]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11451]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11576:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12946 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13090 = mem[_12946]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12946]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13090:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12946 + 32
                                    while _12946 + (32 * _13090) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13090) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11451 + 32
                                while _11451 + (32 * _11576) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11576) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14081 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14237 = mem[_14081]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14081]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14237:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14081 + 32
                                    while _14081 + (32 * _14237) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14237) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9811) + 1
                            if _9811 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _11447 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _11570 = mem[_11447]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11447]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _11570:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _12941 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _13082 = mem[_12941]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12941]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _13082:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _12941 + 32
                                        while _12941 + (32 * _13082) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13082) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _11447 + 32
                                    while _11447 + (32 * _11570) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11570) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14075 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14228 = mem[_14075]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14075]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14228:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14075 + 32
                                        while _14075 + (32 * _14228) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14228) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9811 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9811 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _13083 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13233 = mem[_13083]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13083]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13233:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14077 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14231 = mem[_14077]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14077]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14231:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14077 + 32
                                        while _14077 + (32 * _14231) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14231) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13083 + 32
                                    while _13083 + (32 * _13233) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13233) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14613 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14645 = mem[_14613]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14613]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14645:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14613 + 32
                                        while _14613 + (32 * _14645) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14645) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _9811:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11459 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11588 = mem[_11459]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11459]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11588:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12955 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13104 = mem[_12955]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12955]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13104:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12955 + 32
                                    while _12955 + (32 * _13104) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13104) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11459 + 32
                                while _11459 + (32 * _11588) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11588) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14091 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14252 = mem[_14091]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14091]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14252:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14091 + 32
                                    while _14091 + (32 * _14252) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14252) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9811) + 1
                            if _9811 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _11455 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _11582 = mem[_11455]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11455]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _11582:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _12950 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _13096 = mem[_12950]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12950]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _13096:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _12950 + 32
                                        while _12950 + (32 * _13096) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13096) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _11455 + 32
                                    while _11455 + (32 * _11582) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11582) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14085 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14243 = mem[_14085]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14085]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14243:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14085 + 32
                                        while _14085 + (32 * _14243) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14243) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9811 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9811 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _13097 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13244 = mem[_13097]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13097]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13244:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14087 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14246 = mem[_14087]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14087]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14246:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14087 + 32
                                        while _14087 + (32 * _14246) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14246) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13097 + 32
                                    while _13097 + (32 * _13244) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13244) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14615 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14648 = mem[_14615]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14615]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14648:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14615 + 32
                                        while _14615 + (32 * _14648) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14648) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(mem[(32 * idx) + 128])][stor4[address(mem[(32 * idx) + 128])]] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    stor8[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = balanceOf[address(mem[(32 * idx) + 128])]
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[32] = 11
                    _9838 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _9838:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11467 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11600 = mem[_11467]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11467]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11600:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12964 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13118 = mem[_12964]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12964]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13118:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12964 + 32
                                    while _12964 + (32 * _13118) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13118) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11467 + 32
                                while _11467 + (32 * _11600) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11600) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14101 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14267 = mem[_14101]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14101]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14267:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14101 + 32
                                    while _14101 + (32 * _14267) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14267) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9838) + 1
                            if _9838 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _11463 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _11594 = mem[_11463]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11463]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _11594:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _12959 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _13110 = mem[_12959]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12959]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _13110:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _12959 + 32
                                        while _12959 + (32 * _13110) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13110) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _11463 + 32
                                    while _11463 + (32 * _11594) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11594) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14095 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14258 = mem[_14095]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14095]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14258:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14095 + 32
                                        while _14095 + (32 * _14258) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14258) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9838 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9838 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _13111 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13255 = mem[_13111]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13111]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13255:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14097 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14261 = mem[_14097]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14097]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14261:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14097 + 32
                                        while _14097 + (32 * _14261) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14261) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13111 + 32
                                    while _13111 + (32 * _13255) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13255) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _14617 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14651 = mem[_14617]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14617]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14651:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14617 + 32
                                        while _14617 + (32 * _14651) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14651) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _9838:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11475 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11612 = mem[_11475]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11475]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11612:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12973 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13132 = mem[_12973]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12973]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13132:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12973 + 32
                                    while _12973 + (32 * _13132) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13132) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11475 + 32
                                while _11475 + (32 * _11612) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11612) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14111 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14282 = mem[_14111]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14111]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14282:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14111 + 32
                                    while _14111 + (32 * _14282) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14282) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9838) + 1
                            if _9838 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4871]:
                                    revert with 0, 50
                                _11471 = mem[(32 * idx) + _4871 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _11606 = mem[_11471]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11471]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _11606:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6492]:
                                        revert with 0, 50
                                    _12968 = mem[(32 * idx) + _6492 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _13124 = mem[_12968]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12968]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _13124:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _12968 + 32
                                        while _12968 + (32 * _13124) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13124) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11471 + 32
                                while _11471 + (32 * _11606) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11606) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14105 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14273 = mem[_14105]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14105]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14273:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14105 + 32
                                while _14105 + (32 * _14273) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14273) + 31) >> 5)
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                            t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                            while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9838 + 32 > t:
                                uint256(stor[s]) = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9838 - 1) >> 5) + 1
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _13125 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13266 = mem[_13125]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13125]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13266:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14107 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14276 = mem[_14107]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14107]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14276:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14107 + 32
                                while _14107 + (32 * _14276) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14276) + 31) >> 5)
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _13125 + 32
                            while _13125 + (32 * _13266) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13266) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14619 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14654 = mem[_14619]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14619]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14654:
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                            s = _14619 + 32
                            while _14619 + (32 * _14654) + 32 > s:
                                uint256(stor[t]) = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14654) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]] = tokenByIndex[tokenByIndex.length]
                stor10[stor9[stor9.length]] = stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]
                stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
                if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                    revert with 0, 17
                balanceOf[address(mem[(32 * idx) + 128])]++
                ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                    revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                mem[32] = 11
                _9851 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                    if not _9851:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4871]:
                            revert with 0, 50
                        _11483 = mem[(32 * idx) + _4871 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _11624 = mem[_11483]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11483]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _11624:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _12982 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _13146 = mem[_12982]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12982]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _13146:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _12982 + 32
                                while _12982 + (32 * _13146) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13146) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _11483 + 32
                            while _11483 + (32 * _11624) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11624) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14121 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14297 = mem[_14121]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14121]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14297:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14121 + 32
                                while _14121 + (32 * _14297) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14297) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9851) + 1
                        if _9851 <= 0:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _11479 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _11618 = mem[_11479]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11479]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _11618:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _12977 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _13138 = mem[_12977]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12977]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _13138:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _12977 + 32
                                    while _12977 + (32 * _13138) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13138) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _11479 + 32
                                while _11479 + (32 * _11618) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11618) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14115 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14288 = mem[_14115]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14115]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14288:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14115 + 32
                                    while _14115 + (32 * _14288) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14288) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                            t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                            while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9851 + 32 > t:
                                uint256(stor[s]) = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9851 - 1) >> 5) + 1
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4871]:
                                revert with 0, 50
                            _13139 = mem[(32 * idx) + _4871 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13277 = mem[_13139]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13139]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13277:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14117 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14291 = mem[_14117]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14117]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14291:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14117 + 32
                                    while _14117 + (32 * _14291) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14291) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13139 + 32
                                while _13139 + (32 * _13277) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13277) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6492]:
                                    revert with 0, 50
                                _14621 = mem[(32 * idx) + _6492 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14657 = mem[_14621]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14621]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14657:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14621 + 32
                                    while _14621 + (32 * _14657) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14657) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                else:
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                        revert with 0, 34
                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                    if not _9851:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4871]:
                            revert with 0, 50
                        _11491 = mem[(32 * idx) + _4871 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _11636 = mem[_11491]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11491]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _11636:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _12991 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _13160 = mem[_12991]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12991]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _13160:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _12991 + 32
                                while _12991 + (32 * _13160) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13160) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                        s = _11491 + 32
                        while _11491 + (32 * _11636) + 32 > s:
                            address(stor[t]) = mem[s + 12 len 20]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11636) + 31) >> 5)
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_6492]:
                            revert with 0, 50
                        _14131 = mem[(32 * idx) + _6492 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 15
                        _14312 = mem[_14131]
                        uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14131]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                        if not _14312:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                        s = _14131 + 32
                        while _14131 + (32 * _14312) + 32 > s:
                            uint256(stor[t]) = mem[s]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14312) + 31) >> 5)
                        while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                            revert with 0, 17
                        s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                        continue 
                    uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _9851) + 1
                    if _9851 <= 0:
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4871]:
                            revert with 0, 50
                        _11487 = mem[(32 * idx) + _4871 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _11630 = mem[_11487]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_11487]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _11630:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _12986 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _13152 = mem[_12986]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_12986]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _13152:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _12986 + 32
                                while _12986 + (32 * _13152) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _13152) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _11487 + 32
                            while _11487 + (32 * _11630) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _11630) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14125 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14303 = mem[_14125]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14125]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14303:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14125 + 32
                                while _14125 + (32 * _14303) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14303) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                        t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                        while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _9851 + 32 > t:
                            uint256(stor[s]) = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _9851 - 1) >> 5) + 1
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4871]:
                            revert with 0, 50
                        _13153 = mem[(32 * idx) + _4871 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _13288 = mem[_13153]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13153]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _13288:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14127 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14306 = mem[_14127]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14127]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14306:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14127 + 32
                                while _14127 + (32 * _14306) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14306) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _13153 + 32
                            while _13153 + (32 * _13288) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13288) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6492]:
                                revert with 0, 50
                            _14623 = mem[(32 * idx) + _6492 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14660 = mem[_14623]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14623]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14660:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14623 + 32
                                while _14623 + (32 * _14660) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14660) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    return 1
}

function sub_f3ba443f(?) {
    require calldata.size - 4 >= 192
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        require cd[s] <= test266151307()
        require cd[68] + cd[s] + 67 < calldata.size
        if cd[(cd[68] + cd[s] + 36)] > test266151307():
            revert with 0, 65
        _4888 = mem[64]
        if mem[64] + ceil32(ceil32(cd[(cd[68] + cd[s] + 36)])) + 1 < mem[64] or mem[64] + ceil32(ceil32(cd[(cd[68] + cd[s] + 36)])) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(ceil32(cd[(cd[68] + cd[s] + 36)])) + 1
        mem[_4888] = cd[(cd[68] + cd[s] + 36)]
        require cd[68] + cd[s] + cd[(cd[68] + cd[s] + 36)] + 68 <= calldata.size
        mem[_4888 + 32 len cd[(cd[68] + cd[s] + 36)]] = call.data[cd[68] + cd[s] + 68 len cd[(cd[68] + cd[s] + 36)]]
        mem[_4888 + cd[(cd[68] + cd[s] + 36)] + 32] = 0
        mem[t] = _4888
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    if ('cd', 100).length > test266151307():
        revert with 0, 65
    _4889 = mem[64]
    if mem[64] + ceil32(32 * ('cd', 100).length) + 1 < mem[64] or mem[64] + ceil32(32 * ('cd', 100).length) + 1 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + ceil32(32 * ('cd', 100).length) + 1
    mem[_4889] = ('cd', 100).length
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 0
    s = cd[100] + 36
    t = _4889 + 32
    while idx < ('cd', 100).length:
        require cd[s] <= test266151307()
        require cd[100] + cd[s] + 67 < calldata.size
        if cd[(cd[100] + cd[s] + 36)] > test266151307():
            revert with 0, 65
        _6515 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[100] + cd[s] + 36)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[100] + cd[s] + 36)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[100] + cd[s] + 36)]) + 1
        mem[_6515] = cd[(cd[100] + cd[s] + 36)]
        require cd[100] + cd[s] + (32 * cd[(cd[100] + cd[s] + 36)]) + 68 <= calldata.size
        u = 0
        v = cd[100] + cd[s] + 68
        w = _6515 + 32
        while u < cd[(cd[100] + cd[s] + 36)]:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _6515
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[132] <= test266151307()
    require cd[132] + 35 < calldata.size
    if ('cd', 132).length > test266151307():
        revert with 0, 65
    _6516 = mem[64]
    if mem[64] + ceil32(32 * ('cd', 132).length) + 1 < mem[64] or mem[64] + ceil32(32 * ('cd', 132).length) + 1 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + ceil32(32 * ('cd', 132).length) + 1
    mem[_6516] = ('cd', 132).length
    require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
    idx = 0
    s = cd[132] + 36
    t = _6516 + 32
    while idx < ('cd', 132).length:
        require cd[s] <= test266151307()
        require cd[132] + cd[s] + 67 < calldata.size
        if cd[(cd[132] + cd[s] + 36)] > test266151307():
            revert with 0, 65
        _8141 = mem[64]
        if mem[64] + ceil32(32 * cd[(cd[132] + cd[s] + 36)]) + 1 < mem[64] or mem[64] + ceil32(32 * cd[(cd[132] + cd[s] + 36)]) + 1 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + ceil32(32 * cd[(cd[132] + cd[s] + 36)]) + 1
        mem[_8141] = cd[(cd[132] + cd[s] + 36)]
        require cd[132] + cd[s] + (32 * cd[(cd[132] + cd[s] + 36)]) + 68 <= calldata.size
        u = 0
        v = cd[132] + cd[s] + 68
        w = _8141 + 32
        while u < cd[(cd[132] + cd[s] + 36)]:
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _8141
        u = u + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[164] == address(cd[164])
    if not address(cd[164]):
        revert with 0, 'Custom cashbacks cannot be set to 0 address'
    idx = 0
    while idx < mem[ceil32(32 * ('cd', 4).length) + 97]:
        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
            revert with 0, 50
        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
        mem[32] = 16
        sub_498715ac[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = address(cd[164])
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    if stor17:
        idx = 0
        while idx < mem[96]:
            if idx >= mem[96]:
                revert with 0, 50
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, 'ERC721: mint to the zero address'
            if ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                revert with 0, 'ERC721: token already minted'
            stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = tokenByIndex.length
            tokenByIndex.length++
            tokenByIndex[tokenByIndex.length] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[32] = 11
                    _11460 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _11460:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13059 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13160 = mem[_13059]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13059]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13160:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14548 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14662 = mem[_14548]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14548]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14662:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14548 + 32
                                    while _14548 + (32 * _14662) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14662) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13059 + 32
                                while _13059 + (32 * _13160) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13160) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15677 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15803 = mem[_15677]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15677]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15803:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15677 + 32
                                    while _15677 + (32 * _15803) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15803) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11460) + 1
                            if _11460 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _13055 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13154 = mem[_13055]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13055]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13154:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _14543 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14654 = mem[_14543]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14543]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14654:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14543 + 32
                                        while _14543 + (32 * _14654) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14654) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13055 + 32
                                    while _13055 + (32 * _13154) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13154) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15671 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15794 = mem[_15671]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15671]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15794:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15671 + 32
                                        while _15671 + (32 * _15794) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15794) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11460 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11460 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _14655 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _14823 = mem[_14655]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14655]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _14823:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15673 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15797 = mem[_15673]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15673]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15797:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15673 + 32
                                        while _15673 + (32 * _15797) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15797) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _14655 + 32
                                    while _14655 + (32 * _14823) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14823) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _16257 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _16283 = mem[_16257]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16257]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _16283:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _16257 + 32
                                        while _16257 + (32 * _16283) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16283) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _11460:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13067 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13172 = mem[_13067]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13067]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13172:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14557 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14676 = mem[_14557]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14557]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14676:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14557 + 32
                                    while _14557 + (32 * _14676) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14676) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13067 + 32
                                while _13067 + (32 * _13172) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13172) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15687 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15818 = mem[_15687]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15687]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15818:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15687 + 32
                                    while _15687 + (32 * _15818) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15818) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11460) + 1
                            if _11460 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _13063 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13166 = mem[_13063]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13063]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13166:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _14552 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14668 = mem[_14552]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14552]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14668:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14552 + 32
                                        while _14552 + (32 * _14668) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14668) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13063 + 32
                                    while _13063 + (32 * _13166) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13166) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15681 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15809 = mem[_15681]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15681]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15809:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15681 + 32
                                        while _15681 + (32 * _15809) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15809) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11460 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11460 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _14669 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _14834 = mem[_14669]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14669]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _14834:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15683 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15812 = mem[_15683]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15683]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15812:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15683 + 32
                                        while _15683 + (32 * _15812) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15812) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _14669 + 32
                                    while _14669 + (32 * _14834) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14834) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _16259 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _16286 = mem[_16259]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16259]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _16286:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _16259 + 32
                                        while _16259 + (32 * _16286) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16286) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(mem[(32 * idx) + 128])][stor4[address(mem[(32 * idx) + 128])]] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    stor8[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = balanceOf[address(mem[(32 * idx) + 128])]
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[32] = 11
                    _11489 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _11489:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13075 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13184 = mem[_13075]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13075]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13184:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14566 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14690 = mem[_14566]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14566]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14690:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14566 + 32
                                    while _14566 + (32 * _14690) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14690) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13075 + 32
                                while _13075 + (32 * _13184) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13184) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15697 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15833 = mem[_15697]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15697]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15833:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15697 + 32
                                    while _15697 + (32 * _15833) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15833) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11489) + 1
                            if _11489 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _13071 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13178 = mem[_13071]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13071]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13178:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _14561 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14682 = mem[_14561]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14561]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14682:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14561 + 32
                                        while _14561 + (32 * _14682) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14682) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13071 + 32
                                    while _13071 + (32 * _13178) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13178) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15691 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15824 = mem[_15691]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15691]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15824:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15691 + 32
                                        while _15691 + (32 * _15824) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15824) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11489 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11489 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _14683 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _14845 = mem[_14683]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14683]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _14845:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15693 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15827 = mem[_15693]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15693]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15827:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15693 + 32
                                        while _15693 + (32 * _15827) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15827) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _14683 + 32
                                    while _14683 + (32 * _14845) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14845) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _16261 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _16289 = mem[_16261]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16261]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _16289:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _16261 + 32
                                        while _16261 + (32 * _16289) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16289) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _11489:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13083 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13196 = mem[_13083]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13083]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13196:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14575 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14704 = mem[_14575]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14575]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14704:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14575 + 32
                                    while _14575 + (32 * _14704) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14704) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13083 + 32
                                while _13083 + (32 * _13196) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13196) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15707 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15848 = mem[_15707]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15707]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15848:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15707 + 32
                                    while _15707 + (32 * _15848) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15848) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11489) + 1
                            if _11489 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _13079 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13190 = mem[_13079]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13079]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13190:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _14570 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14696 = mem[_14570]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14570]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14696:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14570 + 32
                                        while _14570 + (32 * _14696) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14696) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13079 + 32
                                while _13079 + (32 * _13190) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13190) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15701 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15839 = mem[_15701]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15701]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15839:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15701 + 32
                                while _15701 + (32 * _15839) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15839) + 31) >> 5)
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                            t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                            while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11489 + 32 > t:
                                uint256(stor[s]) = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11489 - 1) >> 5) + 1
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _14697 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _14856 = mem[_14697]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14697]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _14856:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15703 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15842 = mem[_15703]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15703]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15842:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15703 + 32
                                while _15703 + (32 * _15842) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15842) + 31) >> 5)
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _14697 + 32
                            while _14697 + (32 * _14856) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14856) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _16263 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _16292 = mem[_16263]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16263]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _16292:
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                            s = _16263 + 32
                            while _16263 + (32 * _16292) + 32 > s:
                                uint256(stor[t]) = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16292) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]] = tokenByIndex[tokenByIndex.length]
                stor10[stor9[stor9.length]] = stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]
                stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
                if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                    revert with 0, 17
                balanceOf[address(mem[(32 * idx) + 128])]++
                ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                    revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                mem[32] = 11
                _11503 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                    if not _11503:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4889]:
                            revert with 0, 50
                        _13091 = mem[(32 * idx) + _4889 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _13208 = mem[_13091]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13091]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _13208:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _14584 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14718 = mem[_14584]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14584]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14718:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14584 + 32
                                while _14584 + (32 * _14718) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14718) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _13091 + 32
                            while _13091 + (32 * _13208) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13208) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _15717 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _15863 = mem[_15717]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15717]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _15863:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15717 + 32
                                while _15717 + (32 * _15863) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15863) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11503) + 1
                        if _11503 <= 0:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13087 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13202 = mem[_13087]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13087]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13202:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14579 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14710 = mem[_14579]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14579]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14710:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14579 + 32
                                    while _14579 + (32 * _14710) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14710) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13087 + 32
                                while _13087 + (32 * _13202) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13202) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15711 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15854 = mem[_15711]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15711]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15854:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15711 + 32
                                    while _15711 + (32 * _15854) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15854) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                            t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                            while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11503 + 32 > t:
                                uint256(stor[s]) = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11503 - 1) >> 5) + 1
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _14711 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _14867 = mem[_14711]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14711]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _14867:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15713 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15857 = mem[_15713]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15713]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15857:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15713 + 32
                                    while _15713 + (32 * _15857) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15857) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _14711 + 32
                                while _14711 + (32 * _14867) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14867) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _16265 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _16295 = mem[_16265]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16265]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _16295:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _16265 + 32
                                    while _16265 + (32 * _16295) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16295) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                else:
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                        revert with 0, 34
                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                    if not _11503:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4889]:
                            revert with 0, 50
                        _13099 = mem[(32 * idx) + _4889 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _13220 = mem[_13099]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13099]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _13220:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _14593 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14732 = mem[_14593]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14593]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14732:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14593 + 32
                                while _14593 + (32 * _14732) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14732) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                        s = _13099 + 32
                        while _13099 + (32 * _13220) + 32 > s:
                            address(stor[t]) = mem[s + 12 len 20]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13220) + 31) >> 5)
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_6516]:
                            revert with 0, 50
                        _15727 = mem[(32 * idx) + _6516 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 15
                        _15878 = mem[_15727]
                        uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15727]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                        if not _15878:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                        s = _15727 + 32
                        while _15727 + (32 * _15878) + 32 > s:
                            uint256(stor[t]) = mem[s]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15878) + 31) >> 5)
                        while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                            revert with 0, 17
                        s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                        continue 
                    uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11503) + 1
                    if _11503 <= 0:
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4889]:
                            revert with 0, 50
                        _13095 = mem[(32 * idx) + _4889 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _13214 = mem[_13095]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13095]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _13214:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _14588 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14724 = mem[_14588]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14588]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14724:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14588 + 32
                                while _14588 + (32 * _14724) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14724) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _13095 + 32
                            while _13095 + (32 * _13214) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13214) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _15721 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _15869 = mem[_15721]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15721]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _15869:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15721 + 32
                                while _15721 + (32 * _15869) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15869) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                        t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                        while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11503 + 32 > t:
                            uint256(stor[s]) = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11503 - 1) >> 5) + 1
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4889]:
                            revert with 0, 50
                        _14725 = mem[(32 * idx) + _4889 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _14878 = mem[_14725]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14725]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _14878:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _15723 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _15872 = mem[_15723]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15723]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _15872:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15723 + 32
                                while _15723 + (32 * _15872) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15872) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _14725 + 32
                            while _14725 + (32 * _14878) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14878) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _16267 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _16298 = mem[_16267]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16267]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _16298:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _16267 + 32
                                while _16267 + (32 * _16298) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16298) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    else:
        mem[0] = msg.sender
        mem[32] = sha3(0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956, 12)
        if not uint8(roleAdmin[0xfe9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956][address(msg.sender)].field_0):
            revert with 0, 'ERC721PresetMinterPauserAutoId: must have minter role to mint'
        idx = 0
        while idx < mem[96]:
            if idx >= mem[96]:
                revert with 0, 50
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            if not mem[(32 * idx) + 140 len 20]:
                revert with 0, 'ERC721: mint to the zero address'
            if ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                revert with 0, 'ERC721: token already minted'
            stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = tokenByIndex.length
            tokenByIndex.length++
            tokenByIndex[tokenByIndex.length] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if mem[(32 * idx) + 140 len 20]:
                if not mem[(32 * idx) + 140 len 20]:
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[32] = 11
                    _11467 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _11467:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13107 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13232 = mem[_13107]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13107]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13232:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14602 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14746 = mem[_14602]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14602]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14746:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14602 + 32
                                    while _14602 + (32 * _14746) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14746) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13107 + 32
                                while _13107 + (32 * _13232) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13232) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15737 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15893 = mem[_15737]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15737]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15893:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15737 + 32
                                    while _15737 + (32 * _15893) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15893) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11467) + 1
                            if _11467 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _13103 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13226 = mem[_13103]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13103]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13226:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _14597 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14738 = mem[_14597]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14597]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14738:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14597 + 32
                                        while _14597 + (32 * _14738) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14738) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13103 + 32
                                    while _13103 + (32 * _13226) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13226) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15731 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15884 = mem[_15731]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15731]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15884:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15731 + 32
                                        while _15731 + (32 * _15884) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15884) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11467 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11467 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _14739 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _14889 = mem[_14739]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14739]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _14889:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15733 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15887 = mem[_15733]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15733]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15887:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15733 + 32
                                        while _15733 + (32 * _15887) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15887) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _14739 + 32
                                    while _14739 + (32 * _14889) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14889) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _16269 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _16301 = mem[_16269]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16269]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _16301:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _16269 + 32
                                        while _16269 + (32 * _16301) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16301) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _11467:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13115 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13244 = mem[_13115]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13115]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13244:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14611 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14760 = mem[_14611]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14611]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14760:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14611 + 32
                                    while _14611 + (32 * _14760) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14760) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13115 + 32
                                while _13115 + (32 * _13244) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13244) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15747 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15908 = mem[_15747]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15747]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15908:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15747 + 32
                                    while _15747 + (32 * _15908) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15908) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11467) + 1
                            if _11467 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _13111 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13238 = mem[_13111]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13111]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13238:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _14606 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14752 = mem[_14606]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14606]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14752:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14606 + 32
                                        while _14606 + (32 * _14752) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14752) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13111 + 32
                                    while _13111 + (32 * _13238) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13238) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15741 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15899 = mem[_15741]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15741]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15899:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15741 + 32
                                        while _15741 + (32 * _15899) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15899) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11467 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11467 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _14753 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _14900 = mem[_14753]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14753]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _14900:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15743 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15902 = mem[_15743]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15743]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15902:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15743 + 32
                                        while _15743 + (32 * _15902) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15902) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _14753 + 32
                                    while _14753 + (32 * _14900) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14900) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _16271 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _16304 = mem[_16271]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16271]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _16304:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _16271 + 32
                                        while _16271 + (32 * _16304) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16304) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                else:
                    if not mem[(32 * idx) + 140 len 20]:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(mem[(32 * idx) + 128])][stor4[address(mem[(32 * idx) + 128])]] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    stor8[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = balanceOf[address(mem[(32 * idx) + 128])]
                    if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                        revert with 0, 17
                    balanceOf[address(mem[(32 * idx) + 128])]++
                    ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                    emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                        revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[32] = 11
                    _11494 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _11494:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13123 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13256 = mem[_13123]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13123]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13256:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14620 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14774 = mem[_14620]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14620]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14774:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14620 + 32
                                    while _14620 + (32 * _14774) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14774) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13123 + 32
                                while _13123 + (32 * _13256) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13256) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15757 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15923 = mem[_15757]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15757]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15923:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15757 + 32
                                    while _15757 + (32 * _15923) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15923) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11494) + 1
                            if _11494 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _13119 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13250 = mem[_13119]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13119]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13250:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _14615 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14766 = mem[_14615]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14615]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14766:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14615 + 32
                                        while _14615 + (32 * _14766) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14766) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _13119 + 32
                                    while _13119 + (32 * _13250) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13250) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15751 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15914 = mem[_15751]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15751]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15914:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15751 + 32
                                        while _15751 + (32 * _15914) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15914) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                            else:
                                uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                                t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                                while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11494 + 32 > t:
                                    uint256(stor[s]) = mem[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11494 - 1) >> 5) + 1
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _14767 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _14911 = mem[_14767]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14767]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _14911:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _15753 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _15917 = mem[_15753]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15753]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _15917:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _15753 + 32
                                        while _15753 + (32 * _15917) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15917) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    s = _14767 + 32
                                    while _14767 + (32 * _14911) + 32 > s:
                                        address(stor[t]) = mem[s + 12 len 20]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14911) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _16273 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _16307 = mem[_16273]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16273]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _16307:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _16273 + 32
                                        while _16273 + (32 * _16307) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16307) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                    else:
                        if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                            revert with 0, 34
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                        if not _11494:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13131 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13268 = mem[_13131]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13131]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13268:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14629 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14788 = mem[_14629]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14629]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14788:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14629 + 32
                                    while _14629 + (32 * _14788) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14788) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13131 + 32
                                while _13131 + (32 * _13268) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13268) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15767 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15938 = mem[_15767]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15767]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15938:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15767 + 32
                                    while _15767 + (32 * _15938) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15938) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11494) + 1
                            if _11494 <= 0:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_4889]:
                                    revert with 0, 50
                                _13127 = mem[(32 * idx) + _4889 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 14
                                _13262 = mem[_13127]
                                uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13127]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                                if not _13262:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx >= mem[_6516]:
                                        revert with 0, 50
                                    _14624 = mem[(32 * idx) + _6516 + 32]
                                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                        revert with 0, 50
                                    mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                    mem[32] = 15
                                    _14780 = mem[_14624]
                                    uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14624]
                                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                    if not _14780:
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                        s = _14624 + 32
                                        while _14624 + (32 * _14780) + 32 > s:
                                            uint256(stor[t]) = mem[s]
                                            t = t + 1
                                            s = s + 32
                                            continue 
                                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14780) + 31) >> 5)
                                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13127 + 32
                                while _13127 + (32 * _13262) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13262) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15761 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15929 = mem[_15761]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15761]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15929:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15761 + 32
                                while _15761 + (32 * _15929) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15929) + 31) >> 5)
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                            t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                            while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11494 + 32 > t:
                                uint256(stor[s]) = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11494 - 1) >> 5) + 1
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _14781 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _14922 = mem[_14781]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14781]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _14922:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15763 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15932 = mem[_15763]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15763]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15932:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15763 + 32
                                while _15763 + (32 * _15932) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15932) + 31) >> 5)
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _14781 + 32
                            while _14781 + (32 * _14922) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14922) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _16275 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _16310 = mem[_16275]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16275]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _16310:
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                                    revert with 0, 17
                                s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                                continue 
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                            s = _16275 + 32
                            while _16275 + (32 * _16310) + 32 > s:
                                uint256(stor[t]) = mem[s]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16310) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]] = tokenByIndex[tokenByIndex.length]
                stor10[stor9[stor9.length]] = stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]
                stor10[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
                if balanceOf[address(mem[(32 * idx) + 128])] > -2:
                    revert with 0, 17
                balanceOf[address(mem[(32 * idx) + 128])]++
                ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]] = mem[(32 * idx) + 140 len 20]
                emit Transfer(0, mem[(32 * idx) + 140 len 20], mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]);
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                if not ownerOf[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]]:
                    revert with 0, 'ERC721URIStorage: URI set of nonexistent token'
                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                mem[32] = 11
                _11507 = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]]
                if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0):
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5 < 32:
                        revert with 0, 34
                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                    if not _11507:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4889]:
                            revert with 0, 50
                        _13139 = mem[(32 * idx) + _4889 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _13280 = mem[_13139]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13139]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _13280:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _14638 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14802 = mem[_14638]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14638]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14802:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14638 + 32
                                while _14638 + (32 * _14802) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14802) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _13139 + 32
                            while _13139 + (32 * _13280) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13280) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _15777 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _15953 = mem[_15777]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15777]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _15953:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15777 + 32
                                while _15777 + (32 * _15953) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15953) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11507) + 1
                        if _11507 <= 0:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _13135 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _13274 = mem[_13135]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13135]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _13274:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _14633 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _14794 = mem[_14633]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14633]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _14794:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _14633 + 32
                                    while _14633 + (32 * _14794) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14794) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _13135 + 32
                                while _13135 + (32 * _13274) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13274) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15771 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15944 = mem[_15771]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15771]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15944:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15771 + 32
                                    while _15771 + (32 * _15944) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15944) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                        else:
                            uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                            t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                            while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11507 + 32 > t:
                                uint256(stor[s]) = mem[t]
                                s = s + 1
                                t = t + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11507 - 1) >> 5) + 1
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + ((uint255(uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0)) * 0.5) + 31 / 32) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_4889]:
                                revert with 0, 50
                            _14795 = mem[(32 * idx) + _4889 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 14
                            _14933 = mem[_14795]
                            uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14795]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                            if not _14933:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _15773 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _15947 = mem[_15773]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15773]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _15947:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _15773 + 32
                                    while _15773 + (32 * _15947) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15947) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                                s = _14795 + 32
                                while _14795 + (32 * _14933) + 32 > s:
                                    address(stor[t]) = mem[s + 12 len 20]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14933) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                                if idx >= mem[_6516]:
                                    revert with 0, 50
                                _16277 = mem[(32 * idx) + _6516 + 32]
                                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                    revert with 0, 50
                                mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                                mem[32] = 15
                                _16313 = mem[_16277]
                                uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16277]
                                mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                                if not _16313:
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                else:
                                    t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                    s = _16277 + 32
                                    while _16277 + (32 * _16313) + 32 > s:
                                        uint256(stor[t]) = mem[s]
                                        t = t + 1
                                        s = s + 32
                                        continue 
                                    s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16313) + 31) >> 5)
                                    while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                else:
                    if bool(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 < 32:
                        revert with 0, 34
                    mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)
                    if not _11507:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = 0
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4889]:
                            revert with 0, 50
                        _13147 = mem[(32 * idx) + _4889 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _13292 = mem[_13147]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13147]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _13292:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _14647 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14816 = mem[_14647]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14647]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14816:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14647 + 32
                                while _14647 + (32 * _14816) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14816) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                        s = _13147 + 32
                        while _13147 + (32 * _13292) + 32 > s:
                            address(stor[t]) = mem[s + 12 len 20]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13292) + 31) >> 5)
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_6516]:
                            revert with 0, 50
                        _15787 = mem[(32 * idx) + _6516 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 15
                        _15968 = mem[_15787]
                        uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15787]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                        if not _15968:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                        s = _15787 + 32
                        while _15787 + (32 * _15968) + 32 > s:
                            uint256(stor[t]) = mem[s]
                            t = t + 1
                            s = s + 32
                            continue 
                        s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15968) + 31) >> 5)
                        while sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) == -1:
                            revert with 0, 17
                        s = sha3(sha3(mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]].field_0) + 1
                        continue 
                    uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = (2 * _11507) + 1
                    if _11507 <= 0:
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11))
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4889]:
                            revert with 0, 50
                        _13143 = mem[(32 * idx) + _4889 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _13286 = mem[_13143]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_13143]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _13286:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _14642 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _14808 = mem[_14642]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14642]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _14808:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _14642 + 32
                                while _14642 + (32 * _14808) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _14808) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _13143 + 32
                            while _13143 + (32 * _13286) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _13286) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _15781 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _15959 = mem[_15781]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15781]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _15959:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15781 + 32
                                while _15781 + (32 * _15959) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15959) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                    else:
                        uint256(stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 32]
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + 1
                        t = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + 64
                        while mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] + _11507 + 32 > t:
                            uint256(stor[s]) = mem[t]
                            s = s + 1
                            t = t + 32
                            continue 
                        s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (Mask(251, 0, _11507 - 1) >> 5) + 1
                        while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 11)) + (stor11[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_1 % 128 + 31 / 32) > s:
                            uint256(stor[s]) = 0
                            s = s + 1
                            continue 
                        if idx >= mem[_4889]:
                            revert with 0, 50
                        _14809 = mem[(32 * idx) + _4889 + 32]
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                        mem[32] = 14
                        _14944 = mem[_14809]
                        uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_14809]
                        mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)
                        if not _14944:
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _15783 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _15962 = mem[_15783]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_15783]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _15962:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _15783 + 32
                                while _15783 + (32 * _15962) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _15962) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                        else:
                            t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14))
                            s = _14809 + 32
                            while _14809 + (32 * _14944) + 32 > s:
                                address(stor[t]) = mem[s + 12 len 20]
                                t = t + 1
                                s = s + 32
                                continue 
                            s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + (Mask(251, 0, (32 * _14944) + 31) >> 5)
                            while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 14)) + uint256(stor14[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                uint256(stor[s]) = 0
                                s = s + 1
                                continue 
                            if idx >= mem[_6516]:
                                revert with 0, 50
                            _16279 = mem[(32 * idx) + _6516 + 32]
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[0] = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                            mem[32] = 15
                            _16316 = mem[_16279]
                            uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) = mem[_16279]
                            mem[0] = sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)
                            if not _16316:
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
                            else:
                                t = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15))
                                s = _16279 + 32
                                while _16279 + (32 * _16316) + 32 > s:
                                    uint256(stor[t]) = mem[s]
                                    t = t + 1
                                    s = s + 32
                                    continue 
                                s = sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + (Mask(251, 0, (32 * _16316) + 31) >> 5)
                                while sha3(sha3(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129], 15)) + uint256(stor15[mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]].field_0) > s:
                                    uint256(stor[s]) = 0
                                    s = s + 1
                                    continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    return 1
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    mem[96] = 0
    if not sub_498715ac[arg3]:
        if not uint256(stor14[arg3].field_0):
            if msg.value:
                call arg1 with:
                   value msg.value wei
                     gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            if not ownerOf[arg3]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[arg3] != arg1:
                revert with 0, 'ERC721: transfer of token that is not own'
            if not arg2:
                revert with 0, 'ERC721: transfer to the zero address'
            if not arg1:
                stor10[arg3] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = arg3
            else:
                if arg1 != arg2:
                    if not arg1:
                        revert with 0, 'ERC721: balance query for the zero address'
                    if balanceOf[address(arg1)] < 1:
                        revert with 0, 17
                    if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                        tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                        stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                    stor8[arg3] = 0
                    tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
            if arg2:
                if arg2 != arg1:
                    if not arg2:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                    stor8[arg3] = balanceOf[address(arg2)]
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor10[arg3] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                stor10[stor9[stor9.length]] = stor10[arg3]
                stor10[arg3] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
            approved[arg3] = 0
            if not ownerOf[arg3]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            emit Approval(ownerOf[arg3], 0, arg3);
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            balanceOf[address(arg1)]--
            if balanceOf[address(arg2)] > -2:
                revert with 0, 17
            balanceOf[address(arg2)]++
            ownerOf[arg3] = arg2
            emit Transfer(arg1, arg2, arg3);
            if ext_code.size(arg2):
                require ext_code.size(arg2)
                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
                if not ext_call.success:
                    if not return_data.size:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    if not return_data.size:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
        else:
            if not uint256(stor14[arg3].field_0):
                revert with 0, 'CashbackToken should be of cashback type'
            idx = 0
            s = 0
            while idx < uint256(stor15[arg3].field_0):
                if idx >= uint256(stor15[arg3].field_0):
                    revert with 0, 50
                if s > !uint256(stor15[arg3][idx].field_0):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                mem[0] = arg3
                mem[32] = 15
                idx = idx + 1
                s = s + uint256(stor15[arg3][idx].field_0)
                continue 
            if not sub_498715ac[arg3]:
                if s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) > msg.value:
                    call arg1 with:
                       value msg.value wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'Value should be greater than or equal to cashback value'
                idx = 0
                while idx < uint256(stor14[arg3].field_0):
                    if idx >= uint256(stor15[arg3].field_0):
                        revert with 0, 50
                    if uint256(stor15[arg3][idx].field_0) > 0:
                        if idx >= uint256(stor14[arg3].field_0):
                            revert with 0, 50
                        if idx >= uint256(stor15[arg3].field_0):
                            revert with 0, 50
                        call address(stor14[arg3][idx].field_0) with:
                           value uint256(stor15[arg3][idx].field_0) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    mem[0] = arg3
                    mem[32] = 14
                    idx = idx + 1
                    continue 
                if msg.value > s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0):
                    if msg.value < s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0):
                        revert with 0, 17
                    call arg1 with:
                       value msg.value - (s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0)) wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                if not ownerOf[arg3]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                if ownerOf[arg3] != arg1:
                    revert with 0, 'ERC721: transfer of token that is not own'
                if not arg2:
                    revert with 0, 'ERC721: transfer to the zero address'
                if not arg1:
                    stor10[arg3] = tokenByIndex.length
                    tokenByIndex.length++
                    tokenByIndex[tokenByIndex.length] = arg3
                else:
                    if arg1 != arg2:
                        if not arg1:
                            revert with 0, 'ERC721: balance query for the zero address'
                        if balanceOf[address(arg1)] < 1:
                            revert with 0, 17
                        if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                            tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                            stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                        stor8[arg3] = 0
                        tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                if arg2:
                    if arg2 != arg1:
                        if not arg2:
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                        stor8[arg3] = balanceOf[address(arg2)]
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor10[arg3] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                    stor10[stor9[stor9.length]] = stor10[arg3]
                    stor10[arg3] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                approved[arg3] = 0
                if not ownerOf[arg3]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                emit Approval(ownerOf[arg3], 0, arg3);
                if balanceOf[address(arg1)] < 1:
                    revert with 0, 17
                balanceOf[address(arg1)]--
                if balanceOf[address(arg2)] > -2:
                    revert with 0, 17
                balanceOf[address(arg2)]++
                ownerOf[arg3] = arg2
                emit Transfer(arg1, arg2, arg3);
                if ext_code.size(arg2):
                    require ext_code.size(arg2)
                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
                    if not ext_call.success:
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            else:
                mem[132] = arg2
                mem[164] = this.address
                require ext_code.size(0)
                staticcall 0x0.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(arg2), this.address
                mem[128] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 128
                require return_data.size >= 32
                if s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) > ext_call.return_data[0]:
                    revert with 0, 'Insufficient ERC20 allowance balance for paying for the asset.'
                mem[0] = arg3
                mem[32] = 14
                idx = 0
                while idx < uint256(stor14[arg3].field_0):
                    if idx >= uint256(stor15[arg3].field_0):
                        revert with 0, 50
                    if uint256(stor15[arg3][idx].field_0) > 0:
                        if idx >= uint256(stor14[arg3].field_0):
                            revert with 0, 50
                        mem[32] = 15
                        if idx >= uint256(stor15[arg3].field_0):
                            revert with 0, 50
                        mem[0] = sha3(arg3, 15)
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36] = address(stor14[arg3][idx].field_0)
                        mem[mem[64] + 68] = uint256(stor15[arg3][idx].field_0)
                        require ext_code.size(0)
                        call 0x0.0x23b872dd with:
                             gas gas_remaining wei
                            args address(arg2), address(stor14[arg3][idx].field_0), uint256(stor15[arg3][idx].field_0)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12829 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12829] == bool(mem[_12829])
                    if idx == -1:
                        revert with 0, 17
                    mem[0] = arg3
                    mem[32] = 14
                    idx = idx + 1
                    continue 
                if not msg.value:
                    if not ownerOf[arg3]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    if ownerOf[arg3] != arg1:
                        revert with 0, 'ERC721: transfer of token that is not own'
                    if not arg2:
                        revert with 0, 'ERC721: transfer to the zero address'
                    if not arg1:
                        stor10[arg3] = tokenByIndex.length
                        tokenByIndex.length++
                        tokenByIndex[tokenByIndex.length] = arg3
                        if arg2:
                            if arg2 == arg1:
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17627 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17627] == Mask(32, 224, mem[_17627])
                                        if Mask(32, 224, mem[_17627]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17628 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17628] == Mask(32, 224, mem[_17628])
                                        if Mask(32, 224, mem[_17628]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not arg2:
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                stor8[arg3] = balanceOf[address(arg2)]
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17629 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17629] == Mask(32, 224, mem[_17629])
                                        if Mask(32, 224, mem[_17629]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17630 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17630] == Mask(32, 224, mem[_17630])
                                        if Mask(32, 224, mem[_17630]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor10[arg3] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                            stor10[stor9[stor9.length]] = stor10[arg3]
                            stor10[arg3] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            approved[arg3] = 0
                            if not ownerOf[arg3]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[arg3], 0, arg3);
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            balanceOf[address(arg1)]--
                            if balanceOf[address(arg2)] > -2:
                                revert with 0, 17
                            balanceOf[address(arg2)]++
                            mem[0] = arg3
                            mem[32] = 3
                            ownerOf[arg3] = arg2
                            emit Transfer(arg1, arg2, arg3);
                            if ext_code.size(arg2):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = arg3
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = mem[96]
                                mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) <= mem[96]:
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17631 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17631] == Mask(32, 224, mem[_17631])
                                    if Mask(32, 224, mem[_17631]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    mem[mem[96] + mem[64] + 164] = 0
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17632 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17632] == Mask(32, 224, mem[_17632])
                                    if Mask(32, 224, mem[_17632]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if arg1 == arg2:
                            if arg2:
                                if arg2 == arg1:
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17609 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17609] == Mask(32, 224, mem[_17609])
                                            if Mask(32, 224, mem[_17609]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17610 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17610] == Mask(32, 224, mem[_17610])
                                            if Mask(32, 224, mem[_17610]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if not arg2:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                    stor8[arg3] = balanceOf[address(arg2)]
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17611 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17611] == Mask(32, 224, mem[_17611])
                                            if Mask(32, 224, mem[_17611]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17612 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17612] == Mask(32, 224, mem[_17612])
                                            if Mask(32, 224, mem[_17612]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor10[arg3] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                stor10[stor9[stor9.length]] = stor10[arg3]
                                stor10[arg3] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17613 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17613] == Mask(32, 224, mem[_17613])
                                        if Mask(32, 224, mem[_17613]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17614 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17614] == Mask(32, 224, mem[_17614])
                                        if Mask(32, 224, mem[_17614]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not arg1:
                                revert with 0, 'ERC721: balance query for the zero address'
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            if balanceOf[address(arg1)] - 1 == stor8[arg3]:
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17615 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17615] == Mask(32, 224, mem[_17615])
                                                if Mask(32, 224, mem[_17615]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17616 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17616] == Mask(32, 224, mem[_17616])
                                                if Mask(32, 224, mem[_17616]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17617 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17617] == Mask(32, 224, mem[_17617])
                                                if Mask(32, 224, mem[_17617]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17618 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17618] == Mask(32, 224, mem[_17618])
                                                if Mask(32, 224, mem[_17618]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17619 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17619] == Mask(32, 224, mem[_17619])
                                            if Mask(32, 224, mem[_17619]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17620 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17620] == Mask(32, 224, mem[_17620])
                                            if Mask(32, 224, mem[_17620]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17621 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17621] == Mask(32, 224, mem[_17621])
                                                if Mask(32, 224, mem[_17621]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17622 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17622] == Mask(32, 224, mem[_17622])
                                                if Mask(32, 224, mem[_17622]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17623 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17623] == Mask(32, 224, mem[_17623])
                                                if Mask(32, 224, mem[_17623]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17624 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17624] == Mask(32, 224, mem[_17624])
                                                if Mask(32, 224, mem[_17624]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17625 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17625] == Mask(32, 224, mem[_17625])
                                            if Mask(32, 224, mem[_17625]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17626 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17626] == Mask(32, 224, mem[_17626])
                                            if Mask(32, 224, mem[_17626]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    call msg.sender with:
                       value msg.value wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not ownerOf[arg3]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    if ownerOf[arg3] != arg1:
                        revert with 0, 'ERC721: transfer of token that is not own'
                    if not arg2:
                        revert with 0, 'ERC721: transfer to the zero address'
                    if not arg1:
                        stor10[arg3] = tokenByIndex.length
                        tokenByIndex.length++
                        tokenByIndex[tokenByIndex.length] = arg3
                        if arg2:
                            if arg2 == arg1:
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17651 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17651] == Mask(32, 224, mem[_17651])
                                        if Mask(32, 224, mem[_17651]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17652 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17652] == Mask(32, 224, mem[_17652])
                                        if Mask(32, 224, mem[_17652]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not arg2:
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                stor8[arg3] = balanceOf[address(arg2)]
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17653 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17653] == Mask(32, 224, mem[_17653])
                                        if Mask(32, 224, mem[_17653]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17654 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17654] == Mask(32, 224, mem[_17654])
                                        if Mask(32, 224, mem[_17654]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor10[arg3] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                            stor10[stor9[stor9.length]] = stor10[arg3]
                            stor10[arg3] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            approved[arg3] = 0
                            if not ownerOf[arg3]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[arg3], 0, arg3);
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            balanceOf[address(arg1)]--
                            if balanceOf[address(arg2)] > -2:
                                revert with 0, 17
                            balanceOf[address(arg2)]++
                            mem[0] = arg3
                            mem[32] = 3
                            ownerOf[arg3] = arg2
                            emit Transfer(arg1, arg2, arg3);
                            if ext_code.size(arg2):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = arg3
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = mem[96]
                                mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) <= mem[96]:
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17655 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17655] == Mask(32, 224, mem[_17655])
                                    if Mask(32, 224, mem[_17655]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    mem[mem[96] + mem[64] + 164] = 0
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17656 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17656] == Mask(32, 224, mem[_17656])
                                    if Mask(32, 224, mem[_17656]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if arg1 == arg2:
                            if arg2:
                                if arg2 == arg1:
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17633 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17633] == Mask(32, 224, mem[_17633])
                                            if Mask(32, 224, mem[_17633]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17634 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17634] == Mask(32, 224, mem[_17634])
                                            if Mask(32, 224, mem[_17634]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if not arg2:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                    stor8[arg3] = balanceOf[address(arg2)]
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17635 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17635] == Mask(32, 224, mem[_17635])
                                            if Mask(32, 224, mem[_17635]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17636 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17636] == Mask(32, 224, mem[_17636])
                                            if Mask(32, 224, mem[_17636]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor10[arg3] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                stor10[stor9[stor9.length]] = stor10[arg3]
                                stor10[arg3] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17637 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17637] == Mask(32, 224, mem[_17637])
                                        if Mask(32, 224, mem[_17637]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17638 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17638] == Mask(32, 224, mem[_17638])
                                        if Mask(32, 224, mem[_17638]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not arg1:
                                revert with 0, 'ERC721: balance query for the zero address'
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            if balanceOf[address(arg1)] - 1 == stor8[arg3]:
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17639 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17639] == Mask(32, 224, mem[_17639])
                                                if Mask(32, 224, mem[_17639]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17640 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17640] == Mask(32, 224, mem[_17640])
                                                if Mask(32, 224, mem[_17640]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17641 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17641] == Mask(32, 224, mem[_17641])
                                                if Mask(32, 224, mem[_17641]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17642 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17642] == Mask(32, 224, mem[_17642])
                                                if Mask(32, 224, mem[_17642]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17643 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17643] == Mask(32, 224, mem[_17643])
                                            if Mask(32, 224, mem[_17643]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17644 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17644] == Mask(32, 224, mem[_17644])
                                            if Mask(32, 224, mem[_17644]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17645 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17645] == Mask(32, 224, mem[_17645])
                                                if Mask(32, 224, mem[_17645]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17646 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17646] == Mask(32, 224, mem[_17646])
                                                if Mask(32, 224, mem[_17646]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17647 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17647] == Mask(32, 224, mem[_17647])
                                                if Mask(32, 224, mem[_17647]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17648 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17648] == Mask(32, 224, mem[_17648])
                                                if Mask(32, 224, mem[_17648]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17649 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17649] == Mask(32, 224, mem[_17649])
                                            if Mask(32, 224, mem[_17649]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17650 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17650] == Mask(32, 224, mem[_17650])
                                            if Mask(32, 224, mem[_17650]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
    else:
        if not uint256(stor14[arg3].field_0):
            if msg.value:
                call arg1 with:
                   value msg.value wei
                     gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            if not ownerOf[arg3]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[arg3] != arg1:
                revert with 0, 'ERC721: transfer of token that is not own'
            if not arg2:
                revert with 0, 'ERC721: transfer to the zero address'
            if not arg1:
                stor10[arg3] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = arg3
            else:
                if arg1 != arg2:
                    if not arg1:
                        revert with 0, 'ERC721: balance query for the zero address'
                    if balanceOf[address(arg1)] < 1:
                        revert with 0, 17
                    if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                        tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                        stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                    stor8[arg3] = 0
                    tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
            if arg2:
                if arg2 != arg1:
                    if not arg2:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                    stor8[arg3] = balanceOf[address(arg2)]
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor10[arg3] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                stor10[stor9[stor9.length]] = stor10[arg3]
                stor10[arg3] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
            approved[arg3] = 0
            if not ownerOf[arg3]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            emit Approval(ownerOf[arg3], 0, arg3);
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            balanceOf[address(arg1)]--
            if balanceOf[address(arg2)] > -2:
                revert with 0, 17
            balanceOf[address(arg2)]++
            ownerOf[arg3] = arg2
            emit Transfer(arg1, arg2, arg3);
            if ext_code.size(arg2):
                require ext_code.size(arg2)
                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
                if not ext_call.success:
                    if not return_data.size:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    if not return_data.size:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
        else:
            if not uint256(stor14[arg3].field_0):
                revert with 0, 'CashbackToken should be of cashback type'
            idx = 0
            s = 0
            while idx < uint256(stor15[arg3].field_0):
                if idx >= uint256(stor15[arg3].field_0):
                    revert with 0, 50
                if s > !uint256(stor15[arg3][idx].field_0):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                mem[0] = arg3
                mem[32] = 15
                idx = idx + 1
                s = s + uint256(stor15[arg3][idx].field_0)
                continue 
            if not sub_498715ac[arg3]:
                if s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) > msg.value:
                    call arg1 with:
                       value msg.value wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'Value should be greater than or equal to cashback value'
                idx = 0
                while idx < uint256(stor14[arg3].field_0):
                    if idx >= uint256(stor15[arg3].field_0):
                        revert with 0, 50
                    if uint256(stor15[arg3][idx].field_0) > 0:
                        if idx >= uint256(stor14[arg3].field_0):
                            revert with 0, 50
                        if idx >= uint256(stor15[arg3].field_0):
                            revert with 0, 50
                        call address(stor14[arg3][idx].field_0) with:
                           value uint256(stor15[arg3][idx].field_0) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    mem[0] = arg3
                    mem[32] = 14
                    idx = idx + 1
                    continue 
                if msg.value > s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0):
                    if msg.value < s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0):
                        revert with 0, 17
                    call arg1 with:
                       value msg.value - (s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0)) wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                if not ownerOf[arg3]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                if ownerOf[arg3] != arg1:
                    revert with 0, 'ERC721: transfer of token that is not own'
                if not arg2:
                    revert with 0, 'ERC721: transfer to the zero address'
                if not arg1:
                    stor10[arg3] = tokenByIndex.length
                    tokenByIndex.length++
                    tokenByIndex[tokenByIndex.length] = arg3
                else:
                    if arg1 != arg2:
                        if not arg1:
                            revert with 0, 'ERC721: balance query for the zero address'
                        if balanceOf[address(arg1)] < 1:
                            revert with 0, 17
                        if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                            tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                            stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                        stor8[arg3] = 0
                        tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                if arg2:
                    if arg2 != arg1:
                        if not arg2:
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                        stor8[arg3] = balanceOf[address(arg2)]
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor10[arg3] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                    stor10[stor9[stor9.length]] = stor10[arg3]
                    stor10[arg3] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                approved[arg3] = 0
                if not ownerOf[arg3]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                emit Approval(ownerOf[arg3], 0, arg3);
                if balanceOf[address(arg1)] < 1:
                    revert with 0, 17
                balanceOf[address(arg1)]--
                if balanceOf[address(arg2)] > -2:
                    revert with 0, 17
                balanceOf[address(arg2)]++
                ownerOf[arg3] = arg2
                emit Transfer(arg1, arg2, arg3);
                if ext_code.size(arg2):
                    require ext_code.size(arg2)
                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, uint32(msg.sender), address(arg1), arg3, 128, 0
                    if not ext_call.success:
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            else:
                mem[132] = arg2
                mem[164] = this.address
                require ext_code.size(sub_498715ac[arg3])
                staticcall sub_498715ac[arg3].0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(arg2), this.address
                mem[128] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 128
                require return_data.size >= 32
                if s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) > ext_call.return_data[0]:
                    revert with 0, 'Insufficient ERC20 allowance balance for paying for the asset.'
                mem[0] = arg3
                mem[32] = 14
                idx = 0
                while idx < uint256(stor14[arg3].field_0):
                    if idx >= uint256(stor15[arg3].field_0):
                        revert with 0, 50
                    if uint256(stor15[arg3][idx].field_0) > 0:
                        if idx >= uint256(stor14[arg3].field_0):
                            revert with 0, 50
                        mem[32] = 15
                        if idx >= uint256(stor15[arg3].field_0):
                            revert with 0, 50
                        mem[0] = sha3(arg3, 15)
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36] = address(stor14[arg3][idx].field_0)
                        mem[mem[64] + 68] = uint256(stor15[arg3][idx].field_0)
                        require ext_code.size(sub_498715ac[arg3])
                        call sub_498715ac[arg3].0x23b872dd with:
                             gas gas_remaining wei
                            args address(arg2), address(stor14[arg3][idx].field_0), uint256(stor15[arg3][idx].field_0)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12833 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12833] == bool(mem[_12833])
                    if idx == -1:
                        revert with 0, 17
                    mem[0] = arg3
                    mem[32] = 14
                    idx = idx + 1
                    continue 
                if not msg.value:
                    if not ownerOf[arg3]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    if ownerOf[arg3] != arg1:
                        revert with 0, 'ERC721: transfer of token that is not own'
                    if not arg2:
                        revert with 0, 'ERC721: transfer to the zero address'
                    if not arg1:
                        stor10[arg3] = tokenByIndex.length
                        tokenByIndex.length++
                        tokenByIndex[tokenByIndex.length] = arg3
                        if arg2:
                            if arg2 == arg1:
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17723 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17723] == Mask(32, 224, mem[_17723])
                                        if Mask(32, 224, mem[_17723]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17724 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17724] == Mask(32, 224, mem[_17724])
                                        if Mask(32, 224, mem[_17724]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not arg2:
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                stor8[arg3] = balanceOf[address(arg2)]
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17725 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17725] == Mask(32, 224, mem[_17725])
                                        if Mask(32, 224, mem[_17725]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17726 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17726] == Mask(32, 224, mem[_17726])
                                        if Mask(32, 224, mem[_17726]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor10[arg3] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                            stor10[stor9[stor9.length]] = stor10[arg3]
                            stor10[arg3] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            approved[arg3] = 0
                            if not ownerOf[arg3]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[arg3], 0, arg3);
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            balanceOf[address(arg1)]--
                            if balanceOf[address(arg2)] > -2:
                                revert with 0, 17
                            balanceOf[address(arg2)]++
                            mem[0] = arg3
                            mem[32] = 3
                            ownerOf[arg3] = arg2
                            emit Transfer(arg1, arg2, arg3);
                            if ext_code.size(arg2):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = arg3
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = mem[96]
                                mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) <= mem[96]:
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17727 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17727] == Mask(32, 224, mem[_17727])
                                    if Mask(32, 224, mem[_17727]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    mem[mem[96] + mem[64] + 164] = 0
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17728 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17728] == Mask(32, 224, mem[_17728])
                                    if Mask(32, 224, mem[_17728]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if arg1 == arg2:
                            if arg2:
                                if arg2 == arg1:
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17705 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17705] == Mask(32, 224, mem[_17705])
                                            if Mask(32, 224, mem[_17705]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17706 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17706] == Mask(32, 224, mem[_17706])
                                            if Mask(32, 224, mem[_17706]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if not arg2:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                    stor8[arg3] = balanceOf[address(arg2)]
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17707 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17707] == Mask(32, 224, mem[_17707])
                                            if Mask(32, 224, mem[_17707]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17708 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17708] == Mask(32, 224, mem[_17708])
                                            if Mask(32, 224, mem[_17708]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor10[arg3] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                stor10[stor9[stor9.length]] = stor10[arg3]
                                stor10[arg3] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17709 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17709] == Mask(32, 224, mem[_17709])
                                        if Mask(32, 224, mem[_17709]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17710 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17710] == Mask(32, 224, mem[_17710])
                                        if Mask(32, 224, mem[_17710]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not arg1:
                                revert with 0, 'ERC721: balance query for the zero address'
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            if balanceOf[address(arg1)] - 1 == stor8[arg3]:
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17711 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17711] == Mask(32, 224, mem[_17711])
                                                if Mask(32, 224, mem[_17711]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17712 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17712] == Mask(32, 224, mem[_17712])
                                                if Mask(32, 224, mem[_17712]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17713 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17713] == Mask(32, 224, mem[_17713])
                                                if Mask(32, 224, mem[_17713]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17714 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17714] == Mask(32, 224, mem[_17714])
                                                if Mask(32, 224, mem[_17714]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17715 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17715] == Mask(32, 224, mem[_17715])
                                            if Mask(32, 224, mem[_17715]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17716 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17716] == Mask(32, 224, mem[_17716])
                                            if Mask(32, 224, mem[_17716]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17717 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17717] == Mask(32, 224, mem[_17717])
                                                if Mask(32, 224, mem[_17717]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17718 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17718] == Mask(32, 224, mem[_17718])
                                                if Mask(32, 224, mem[_17718]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17719 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17719] == Mask(32, 224, mem[_17719])
                                                if Mask(32, 224, mem[_17719]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17720 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17720] == Mask(32, 224, mem[_17720])
                                                if Mask(32, 224, mem[_17720]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17721 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17721] == Mask(32, 224, mem[_17721])
                                            if Mask(32, 224, mem[_17721]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17722 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17722] == Mask(32, 224, mem[_17722])
                                            if Mask(32, 224, mem[_17722]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    call msg.sender with:
                       value msg.value wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not ownerOf[arg3]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    if ownerOf[arg3] != arg1:
                        revert with 0, 'ERC721: transfer of token that is not own'
                    if not arg2:
                        revert with 0, 'ERC721: transfer to the zero address'
                    if not arg1:
                        stor10[arg3] = tokenByIndex.length
                        tokenByIndex.length++
                        tokenByIndex[tokenByIndex.length] = arg3
                        if arg2:
                            if arg2 == arg1:
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17747 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17747] == Mask(32, 224, mem[_17747])
                                        if Mask(32, 224, mem[_17747]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17748 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17748] == Mask(32, 224, mem[_17748])
                                        if Mask(32, 224, mem[_17748]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not arg2:
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                stor8[arg3] = balanceOf[address(arg2)]
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17749 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17749] == Mask(32, 224, mem[_17749])
                                        if Mask(32, 224, mem[_17749]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17750 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17750] == Mask(32, 224, mem[_17750])
                                        if Mask(32, 224, mem[_17750]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor10[arg3] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                            stor10[stor9[stor9.length]] = stor10[arg3]
                            stor10[arg3] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            approved[arg3] = 0
                            if not ownerOf[arg3]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[arg3], 0, arg3);
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            balanceOf[address(arg1)]--
                            if balanceOf[address(arg2)] > -2:
                                revert with 0, 17
                            balanceOf[address(arg2)]++
                            mem[0] = arg3
                            mem[32] = 3
                            ownerOf[arg3] = arg2
                            emit Transfer(arg1, arg2, arg3);
                            if ext_code.size(arg2):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = arg3
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = mem[96]
                                mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) <= mem[96]:
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17751 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17751] == Mask(32, 224, mem[_17751])
                                    if Mask(32, 224, mem[_17751]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    mem[mem[96] + mem[64] + 164] = 0
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17752 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17752] == Mask(32, 224, mem[_17752])
                                    if Mask(32, 224, mem[_17752]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if arg1 == arg2:
                            if arg2:
                                if arg2 == arg1:
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17729 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17729] == Mask(32, 224, mem[_17729])
                                            if Mask(32, 224, mem[_17729]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17730 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17730] == Mask(32, 224, mem[_17730])
                                            if Mask(32, 224, mem[_17730]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if not arg2:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                    stor8[arg3] = balanceOf[address(arg2)]
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17731 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17731] == Mask(32, 224, mem[_17731])
                                            if Mask(32, 224, mem[_17731]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17732 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17732] == Mask(32, 224, mem[_17732])
                                            if Mask(32, 224, mem[_17732]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor10[arg3] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                stor10[stor9[stor9.length]] = stor10[arg3]
                                stor10[arg3] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17733 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17733] == Mask(32, 224, mem[_17733])
                                        if Mask(32, 224, mem[_17733]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17734 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17734] == Mask(32, 224, mem[_17734])
                                        if Mask(32, 224, mem[_17734]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not arg1:
                                revert with 0, 'ERC721: balance query for the zero address'
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            if balanceOf[address(arg1)] - 1 == stor8[arg3]:
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17735 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17735] == Mask(32, 224, mem[_17735])
                                                if Mask(32, 224, mem[_17735]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17736 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17736] == Mask(32, 224, mem[_17736])
                                                if Mask(32, 224, mem[_17736]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17737 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17737] == Mask(32, 224, mem[_17737])
                                                if Mask(32, 224, mem[_17737]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17738 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17738] == Mask(32, 224, mem[_17738])
                                                if Mask(32, 224, mem[_17738]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17739 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17739] == Mask(32, 224, mem[_17739])
                                            if Mask(32, 224, mem[_17739]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17740 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17740] == Mask(32, 224, mem[_17740])
                                            if Mask(32, 224, mem[_17740]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17741 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17741] == Mask(32, 224, mem[_17741])
                                                if Mask(32, 224, mem[_17741]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17742 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17742] == Mask(32, 224, mem[_17742])
                                                if Mask(32, 224, mem[_17742]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17743 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17743] == Mask(32, 224, mem[_17743])
                                                if Mask(32, 224, mem[_17743]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17744 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17744] == Mask(32, 224, mem[_17744])
                                                if Mask(32, 224, mem[_17744]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17745 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17745] == Mask(32, 224, mem[_17745])
                                            if Mask(32, 224, mem[_17745]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17746 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17746] == Mask(32, 224, mem[_17746])
                                            if Mask(32, 224, mem[_17746]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4) payable {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require calldata.size > arg4 + 35
    if arg4.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg4.length)) + 97 < 96 or ceil32(ceil32(arg4.length)) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg4.length
    require arg4 + arg4.length + 36 <= calldata.size
    mem[128 len arg4.length] = arg4[all]
    if not sub_498715ac[arg3]:
        if not uint256(stor14[arg3].field_0):
            if msg.value:
                call arg1 with:
                   value msg.value wei
                     gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            if not ownerOf[arg3]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[arg3] != arg1:
                revert with 0, 'ERC721: transfer of token that is not own'
            if not arg2:
                revert with 0, 'ERC721: transfer to the zero address'
            if not arg1:
                stor10[arg3] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = arg3
            else:
                if arg1 != arg2:
                    if not arg1:
                        revert with 0, 'ERC721: balance query for the zero address'
                    if balanceOf[address(arg1)] < 1:
                        revert with 0, 17
                    if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                        tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                        stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                    stor8[arg3] = 0
                    tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
            if arg2:
                if arg2 != arg1:
                    if not arg2:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                    stor8[arg3] = balanceOf[address(arg2)]
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor10[arg3] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                stor10[stor9[stor9.length]] = stor10[arg3]
                stor10[arg3] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
            approved[arg3] = 0
            if not ownerOf[arg3]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            emit Approval(ownerOf[arg3], 0, arg3);
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            balanceOf[address(arg1)]--
            if balanceOf[address(arg2)] > -2:
                revert with 0, 17
            balanceOf[address(arg2)]++
            ownerOf[arg3] = arg2
            emit Transfer(arg1, arg2, arg3);
            if ext_code.size(arg2):
                require ext_code.size(arg2)
                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
                if not ext_call.success:
                    if not return_data.size:
                        if not arg4.length:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with arg4[all]
                    if not return_data.size:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
        else:
            if not uint256(stor14[arg3].field_0):
                revert with 0, 'CashbackToken should be of cashback type'
            idx = 0
            s = 0
            while idx < uint256(stor15[arg3].field_0):
                if idx >= uint256(stor15[arg3].field_0):
                    revert with 0, 50
                if s > !uint256(stor15[arg3][idx].field_0):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                mem[0] = arg3
                mem[32] = 15
                idx = idx + 1
                s = s + uint256(stor15[arg3][idx].field_0)
                continue 
            if not sub_498715ac[arg3]:
                if s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) > msg.value:
                    call arg1 with:
                       value msg.value wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'Value should be greater than or equal to cashback value'
                idx = 0
                while idx < uint256(stor14[arg3].field_0):
                    if idx >= uint256(stor15[arg3].field_0):
                        revert with 0, 50
                    if uint256(stor15[arg3][idx].field_0) > 0:
                        if idx >= uint256(stor14[arg3].field_0):
                            revert with 0, 50
                        if idx >= uint256(stor15[arg3].field_0):
                            revert with 0, 50
                        call address(stor14[arg3][idx].field_0) with:
                           value uint256(stor15[arg3][idx].field_0) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    mem[0] = arg3
                    mem[32] = 14
                    idx = idx + 1
                    continue 
                if msg.value > s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0):
                    if msg.value < s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0):
                        revert with 0, 17
                    call arg1 with:
                       value msg.value - (s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0)) wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                if not ownerOf[arg3]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                if ownerOf[arg3] != arg1:
                    revert with 0, 'ERC721: transfer of token that is not own'
                if not arg2:
                    revert with 0, 'ERC721: transfer to the zero address'
                if not arg1:
                    stor10[arg3] = tokenByIndex.length
                    tokenByIndex.length++
                    tokenByIndex[tokenByIndex.length] = arg3
                else:
                    if arg1 != arg2:
                        if not arg1:
                            revert with 0, 'ERC721: balance query for the zero address'
                        if balanceOf[address(arg1)] < 1:
                            revert with 0, 17
                        if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                            tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                            stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                        stor8[arg3] = 0
                        tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                if arg2:
                    if arg2 != arg1:
                        if not arg2:
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                        stor8[arg3] = balanceOf[address(arg2)]
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor10[arg3] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                    stor10[stor9[stor9.length]] = stor10[arg3]
                    stor10[arg3] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                approved[arg3] = 0
                if not ownerOf[arg3]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                emit Approval(ownerOf[arg3], 0, arg3);
                if balanceOf[address(arg1)] < 1:
                    revert with 0, 17
                balanceOf[address(arg1)]--
                if balanceOf[address(arg2)] > -2:
                    revert with 0, 17
                balanceOf[address(arg2)]++
                ownerOf[arg3] = arg2
                emit Transfer(arg1, arg2, arg3);
                if ext_code.size(arg2):
                    require ext_code.size(arg2)
                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
                    if not ext_call.success:
                        if not return_data.size:
                            if not arg4.length:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with arg4[all]
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            else:
                mem[ceil32(ceil32(arg4.length)) + 101] = arg2
                mem[ceil32(ceil32(arg4.length)) + 133] = this.address
                require ext_code.size(0)
                staticcall 0x0.0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(arg2), this.address
                mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97
                require return_data.size >= 32
                if s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) > ext_call.return_data[0]:
                    revert with 0, 'Insufficient ERC20 allowance balance for paying for the asset.'
                mem[0] = arg3
                mem[32] = 14
                idx = 0
                while idx < uint256(stor14[arg3].field_0):
                    if idx >= uint256(stor15[arg3].field_0):
                        revert with 0, 50
                    if uint256(stor15[arg3][idx].field_0) > 0:
                        if idx >= uint256(stor14[arg3].field_0):
                            revert with 0, 50
                        mem[32] = 15
                        if idx >= uint256(stor15[arg3].field_0):
                            revert with 0, 50
                        mem[0] = sha3(arg3, 15)
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36] = address(stor14[arg3][idx].field_0)
                        mem[mem[64] + 68] = uint256(stor15[arg3][idx].field_0)
                        require ext_code.size(0)
                        call 0x0.0x23b872dd with:
                             gas gas_remaining wei
                            args address(arg2), address(stor14[arg3][idx].field_0), uint256(stor15[arg3][idx].field_0)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12829 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12829] == bool(mem[_12829])
                    if idx == -1:
                        revert with 0, 17
                    mem[0] = arg3
                    mem[32] = 14
                    idx = idx + 1
                    continue 
                if not msg.value:
                    if not ownerOf[arg3]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    if ownerOf[arg3] != arg1:
                        revert with 0, 'ERC721: transfer of token that is not own'
                    if not arg2:
                        revert with 0, 'ERC721: transfer to the zero address'
                    if not arg1:
                        stor10[arg3] = tokenByIndex.length
                        tokenByIndex.length++
                        tokenByIndex[tokenByIndex.length] = arg3
                        if arg2:
                            if arg2 == arg1:
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17627 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17627] == Mask(32, 224, mem[_17627])
                                        if Mask(32, 224, mem[_17627]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17628 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17628] == Mask(32, 224, mem[_17628])
                                        if Mask(32, 224, mem[_17628]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not arg2:
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                stor8[arg3] = balanceOf[address(arg2)]
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17629 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17629] == Mask(32, 224, mem[_17629])
                                        if Mask(32, 224, mem[_17629]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17630 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17630] == Mask(32, 224, mem[_17630])
                                        if Mask(32, 224, mem[_17630]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor10[arg3] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                            stor10[stor9[stor9.length]] = stor10[arg3]
                            stor10[arg3] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            approved[arg3] = 0
                            if not ownerOf[arg3]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[arg3], 0, arg3);
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            balanceOf[address(arg1)]--
                            if balanceOf[address(arg2)] > -2:
                                revert with 0, 17
                            balanceOf[address(arg2)]++
                            mem[0] = arg3
                            mem[32] = 3
                            ownerOf[arg3] = arg2
                            emit Transfer(arg1, arg2, arg3);
                            if ext_code.size(arg2):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = arg3
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = mem[96]
                                mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) <= mem[96]:
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17631 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17631] == Mask(32, 224, mem[_17631])
                                    if Mask(32, 224, mem[_17631]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    mem[mem[96] + mem[64] + 164] = 0
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17632 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17632] == Mask(32, 224, mem[_17632])
                                    if Mask(32, 224, mem[_17632]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if arg1 == arg2:
                            if arg2:
                                if arg2 == arg1:
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17609 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17609] == Mask(32, 224, mem[_17609])
                                            if Mask(32, 224, mem[_17609]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17610 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17610] == Mask(32, 224, mem[_17610])
                                            if Mask(32, 224, mem[_17610]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if not arg2:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                    stor8[arg3] = balanceOf[address(arg2)]
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17611 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17611] == Mask(32, 224, mem[_17611])
                                            if Mask(32, 224, mem[_17611]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17612 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17612] == Mask(32, 224, mem[_17612])
                                            if Mask(32, 224, mem[_17612]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor10[arg3] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                stor10[stor9[stor9.length]] = stor10[arg3]
                                stor10[arg3] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17613 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17613] == Mask(32, 224, mem[_17613])
                                        if Mask(32, 224, mem[_17613]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17614 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17614] == Mask(32, 224, mem[_17614])
                                        if Mask(32, 224, mem[_17614]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not arg1:
                                revert with 0, 'ERC721: balance query for the zero address'
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            if balanceOf[address(arg1)] - 1 == stor8[arg3]:
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17615 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17615] == Mask(32, 224, mem[_17615])
                                                if Mask(32, 224, mem[_17615]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17616 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17616] == Mask(32, 224, mem[_17616])
                                                if Mask(32, 224, mem[_17616]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17617 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17617] == Mask(32, 224, mem[_17617])
                                                if Mask(32, 224, mem[_17617]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17618 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17618] == Mask(32, 224, mem[_17618])
                                                if Mask(32, 224, mem[_17618]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17619 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17619] == Mask(32, 224, mem[_17619])
                                            if Mask(32, 224, mem[_17619]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17620 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17620] == Mask(32, 224, mem[_17620])
                                            if Mask(32, 224, mem[_17620]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17621 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17621] == Mask(32, 224, mem[_17621])
                                                if Mask(32, 224, mem[_17621]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17622 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17622] == Mask(32, 224, mem[_17622])
                                                if Mask(32, 224, mem[_17622]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17623 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17623] == Mask(32, 224, mem[_17623])
                                                if Mask(32, 224, mem[_17623]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17624 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17624] == Mask(32, 224, mem[_17624])
                                                if Mask(32, 224, mem[_17624]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17625 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17625] == Mask(32, 224, mem[_17625])
                                            if Mask(32, 224, mem[_17625]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17626 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17626] == Mask(32, 224, mem[_17626])
                                            if Mask(32, 224, mem[_17626]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    call msg.sender with:
                       value msg.value wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not ownerOf[arg3]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    if ownerOf[arg3] != arg1:
                        revert with 0, 'ERC721: transfer of token that is not own'
                    if not arg2:
                        revert with 0, 'ERC721: transfer to the zero address'
                    if not arg1:
                        stor10[arg3] = tokenByIndex.length
                        tokenByIndex.length++
                        tokenByIndex[tokenByIndex.length] = arg3
                        if arg2:
                            if arg2 == arg1:
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17651 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17651] == Mask(32, 224, mem[_17651])
                                        if Mask(32, 224, mem[_17651]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17652 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17652] == Mask(32, 224, mem[_17652])
                                        if Mask(32, 224, mem[_17652]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not arg2:
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                stor8[arg3] = balanceOf[address(arg2)]
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17653 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17653] == Mask(32, 224, mem[_17653])
                                        if Mask(32, 224, mem[_17653]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17654 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17654] == Mask(32, 224, mem[_17654])
                                        if Mask(32, 224, mem[_17654]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor10[arg3] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                            stor10[stor9[stor9.length]] = stor10[arg3]
                            stor10[arg3] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            approved[arg3] = 0
                            if not ownerOf[arg3]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[arg3], 0, arg3);
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            balanceOf[address(arg1)]--
                            if balanceOf[address(arg2)] > -2:
                                revert with 0, 17
                            balanceOf[address(arg2)]++
                            mem[0] = arg3
                            mem[32] = 3
                            ownerOf[arg3] = arg2
                            emit Transfer(arg1, arg2, arg3);
                            if ext_code.size(arg2):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = arg3
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = mem[96]
                                mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) <= mem[96]:
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17655 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17655] == Mask(32, 224, mem[_17655])
                                    if Mask(32, 224, mem[_17655]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    mem[mem[96] + mem[64] + 164] = 0
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17656 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17656] == Mask(32, 224, mem[_17656])
                                    if Mask(32, 224, mem[_17656]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if arg1 == arg2:
                            if arg2:
                                if arg2 == arg1:
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17633 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17633] == Mask(32, 224, mem[_17633])
                                            if Mask(32, 224, mem[_17633]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17634 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17634] == Mask(32, 224, mem[_17634])
                                            if Mask(32, 224, mem[_17634]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if not arg2:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                    stor8[arg3] = balanceOf[address(arg2)]
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17635 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17635] == Mask(32, 224, mem[_17635])
                                            if Mask(32, 224, mem[_17635]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17636 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17636] == Mask(32, 224, mem[_17636])
                                            if Mask(32, 224, mem[_17636]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor10[arg3] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                stor10[stor9[stor9.length]] = stor10[arg3]
                                stor10[arg3] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17637 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17637] == Mask(32, 224, mem[_17637])
                                        if Mask(32, 224, mem[_17637]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17638 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17638] == Mask(32, 224, mem[_17638])
                                        if Mask(32, 224, mem[_17638]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not arg1:
                                revert with 0, 'ERC721: balance query for the zero address'
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            if balanceOf[address(arg1)] - 1 == stor8[arg3]:
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17639 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17639] == Mask(32, 224, mem[_17639])
                                                if Mask(32, 224, mem[_17639]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17640 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17640] == Mask(32, 224, mem[_17640])
                                                if Mask(32, 224, mem[_17640]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17641 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17641] == Mask(32, 224, mem[_17641])
                                                if Mask(32, 224, mem[_17641]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17642 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17642] == Mask(32, 224, mem[_17642])
                                                if Mask(32, 224, mem[_17642]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17643 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17643] == Mask(32, 224, mem[_17643])
                                            if Mask(32, 224, mem[_17643]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17644 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17644] == Mask(32, 224, mem[_17644])
                                            if Mask(32, 224, mem[_17644]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17645 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17645] == Mask(32, 224, mem[_17645])
                                                if Mask(32, 224, mem[_17645]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17646 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17646] == Mask(32, 224, mem[_17646])
                                                if Mask(32, 224, mem[_17646]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17647 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17647] == Mask(32, 224, mem[_17647])
                                                if Mask(32, 224, mem[_17647]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17648 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17648] == Mask(32, 224, mem[_17648])
                                                if Mask(32, 224, mem[_17648]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17649 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17649] == Mask(32, 224, mem[_17649])
                                            if Mask(32, 224, mem[_17649]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17650 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17650] == Mask(32, 224, mem[_17650])
                                            if Mask(32, 224, mem[_17650]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
    else:
        if not uint256(stor14[arg3].field_0):
            if msg.value:
                call arg1 with:
                   value msg.value wei
                     gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            if not ownerOf[arg3]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            if ownerOf[arg3] != arg1:
                revert with 0, 'ERC721: transfer of token that is not own'
            if not arg2:
                revert with 0, 'ERC721: transfer to the zero address'
            if not arg1:
                stor10[arg3] = tokenByIndex.length
                tokenByIndex.length++
                tokenByIndex[tokenByIndex.length] = arg3
            else:
                if arg1 != arg2:
                    if not arg1:
                        revert with 0, 'ERC721: balance query for the zero address'
                    if balanceOf[address(arg1)] < 1:
                        revert with 0, 17
                    if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                        tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                        stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                    stor8[arg3] = 0
                    tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
            if arg2:
                if arg2 != arg1:
                    if not arg2:
                        revert with 0, 'ERC721: balance query for the zero address'
                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                    stor8[arg3] = balanceOf[address(arg2)]
            else:
                if tokenByIndex.length < 1:
                    revert with 0, 17
                if tokenByIndex.length - 1 >= tokenByIndex.length:
                    revert with 0, 50
                if stor10[arg3] >= tokenByIndex.length:
                    revert with 0, 50
                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                stor10[stor9[stor9.length]] = stor10[arg3]
                stor10[arg3] = 0
                if not tokenByIndex.length:
                    revert with 0, 49
                tokenByIndex[tokenByIndex.length] = 0
                tokenByIndex.length--
            approved[arg3] = 0
            if not ownerOf[arg3]:
                revert with 0, 'ERC721: owner query for nonexistent token'
            emit Approval(ownerOf[arg3], 0, arg3);
            if balanceOf[address(arg1)] < 1:
                revert with 0, 17
            balanceOf[address(arg1)]--
            if balanceOf[address(arg2)] > -2:
                revert with 0, 17
            balanceOf[address(arg2)]++
            ownerOf[arg3] = arg2
            emit Transfer(arg1, arg2, arg3);
            if ext_code.size(arg2):
                require ext_code.size(arg2)
                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
                if not ext_call.success:
                    if not return_data.size:
                        if not arg4.length:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with arg4[all]
                    if not return_data.size:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
        else:
            if not uint256(stor14[arg3].field_0):
                revert with 0, 'CashbackToken should be of cashback type'
            idx = 0
            s = 0
            while idx < uint256(stor15[arg3].field_0):
                if idx >= uint256(stor15[arg3].field_0):
                    revert with 0, 50
                if s > !uint256(stor15[arg3][idx].field_0):
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                mem[0] = arg3
                mem[32] = 15
                idx = idx + 1
                s = s + uint256(stor15[arg3][idx].field_0)
                continue 
            if not sub_498715ac[arg3]:
                if s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) > msg.value:
                    call arg1 with:
                       value msg.value wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'Value should be greater than or equal to cashback value'
                idx = 0
                while idx < uint256(stor14[arg3].field_0):
                    if idx >= uint256(stor15[arg3].field_0):
                        revert with 0, 50
                    if uint256(stor15[arg3][idx].field_0) > 0:
                        if idx >= uint256(stor14[arg3].field_0):
                            revert with 0, 50
                        if idx >= uint256(stor15[arg3].field_0):
                            revert with 0, 50
                        call address(stor14[arg3][idx].field_0) with:
                           value uint256(stor15[arg3][idx].field_0) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    mem[0] = arg3
                    mem[32] = 14
                    idx = idx + 1
                    continue 
                if msg.value > s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0):
                    if msg.value < s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0):
                        revert with 0, 17
                    call arg1 with:
                       value msg.value - (s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0)) wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                if not ownerOf[arg3]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                if ownerOf[arg3] != arg1:
                    revert with 0, 'ERC721: transfer of token that is not own'
                if not arg2:
                    revert with 0, 'ERC721: transfer to the zero address'
                if not arg1:
                    stor10[arg3] = tokenByIndex.length
                    tokenByIndex.length++
                    tokenByIndex[tokenByIndex.length] = arg3
                else:
                    if arg1 != arg2:
                        if not arg1:
                            revert with 0, 'ERC721: balance query for the zero address'
                        if balanceOf[address(arg1)] < 1:
                            revert with 0, 17
                        if balanceOf[address(arg1)] - 1 != stor8[arg3]:
                            tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                            stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                        stor8[arg3] = 0
                        tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                if arg2:
                    if arg2 != arg1:
                        if not arg2:
                            revert with 0, 'ERC721: balance query for the zero address'
                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                        stor8[arg3] = balanceOf[address(arg2)]
                else:
                    if tokenByIndex.length < 1:
                        revert with 0, 17
                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                        revert with 0, 50
                    if stor10[arg3] >= tokenByIndex.length:
                        revert with 0, 50
                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                    stor10[stor9[stor9.length]] = stor10[arg3]
                    stor10[arg3] = 0
                    if not tokenByIndex.length:
                        revert with 0, 49
                    tokenByIndex[tokenByIndex.length] = 0
                    tokenByIndex.length--
                approved[arg3] = 0
                if not ownerOf[arg3]:
                    revert with 0, 'ERC721: owner query for nonexistent token'
                emit Approval(ownerOf[arg3], 0, arg3);
                if balanceOf[address(arg1)] < 1:
                    revert with 0, 17
                balanceOf[address(arg1)]--
                if balanceOf[address(arg2)] > -2:
                    revert with 0, 17
                balanceOf[address(arg2)]++
                ownerOf[arg3] = arg2
                emit Transfer(arg1, arg2, arg3);
                if ext_code.size(arg2):
                    require ext_code.size(arg2)
                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
                    if not ext_call.success:
                        if not return_data.size:
                            if not arg4.length:
                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            revert with arg4[all]
                        if not return_data.size:
                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
                    if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
            else:
                mem[ceil32(ceil32(arg4.length)) + 101] = arg2
                mem[ceil32(ceil32(arg4.length)) + 133] = this.address
                require ext_code.size(sub_498715ac[arg3])
                staticcall sub_498715ac[arg3].0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(arg2), this.address
                mem[ceil32(ceil32(arg4.length)) + 97] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(ceil32(arg4.length)) + ceil32(return_data.size) + 97
                require return_data.size >= 32
                if s * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) * uint256(stor15[arg3].field_0) > ext_call.return_data[0]:
                    revert with 0, 'Insufficient ERC20 allowance balance for paying for the asset.'
                mem[0] = arg3
                mem[32] = 14
                idx = 0
                while idx < uint256(stor14[arg3].field_0):
                    if idx >= uint256(stor15[arg3].field_0):
                        revert with 0, 50
                    if uint256(stor15[arg3][idx].field_0) > 0:
                        if idx >= uint256(stor14[arg3].field_0):
                            revert with 0, 50
                        mem[32] = 15
                        if idx >= uint256(stor15[arg3].field_0):
                            revert with 0, 50
                        mem[0] = sha3(arg3, 15)
                        mem[mem[64] + 4] = arg2
                        mem[mem[64] + 36] = address(stor14[arg3][idx].field_0)
                        mem[mem[64] + 68] = uint256(stor15[arg3][idx].field_0)
                        require ext_code.size(sub_498715ac[arg3])
                        call sub_498715ac[arg3].0x23b872dd with:
                             gas gas_remaining wei
                            args address(arg2), address(stor14[arg3][idx].field_0), uint256(stor15[arg3][idx].field_0)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12833 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_12833] == bool(mem[_12833])
                    if idx == -1:
                        revert with 0, 17
                    mem[0] = arg3
                    mem[32] = 14
                    idx = idx + 1
                    continue 
                if not msg.value:
                    if not ownerOf[arg3]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    if ownerOf[arg3] != arg1:
                        revert with 0, 'ERC721: transfer of token that is not own'
                    if not arg2:
                        revert with 0, 'ERC721: transfer to the zero address'
                    if not arg1:
                        stor10[arg3] = tokenByIndex.length
                        tokenByIndex.length++
                        tokenByIndex[tokenByIndex.length] = arg3
                        if arg2:
                            if arg2 == arg1:
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17723 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17723] == Mask(32, 224, mem[_17723])
                                        if Mask(32, 224, mem[_17723]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17724 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17724] == Mask(32, 224, mem[_17724])
                                        if Mask(32, 224, mem[_17724]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not arg2:
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                stor8[arg3] = balanceOf[address(arg2)]
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17725 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17725] == Mask(32, 224, mem[_17725])
                                        if Mask(32, 224, mem[_17725]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17726 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17726] == Mask(32, 224, mem[_17726])
                                        if Mask(32, 224, mem[_17726]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor10[arg3] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                            stor10[stor9[stor9.length]] = stor10[arg3]
                            stor10[arg3] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            approved[arg3] = 0
                            if not ownerOf[arg3]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[arg3], 0, arg3);
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            balanceOf[address(arg1)]--
                            if balanceOf[address(arg2)] > -2:
                                revert with 0, 17
                            balanceOf[address(arg2)]++
                            mem[0] = arg3
                            mem[32] = 3
                            ownerOf[arg3] = arg2
                            emit Transfer(arg1, arg2, arg3);
                            if ext_code.size(arg2):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = arg3
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = mem[96]
                                mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) <= mem[96]:
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17727 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17727] == Mask(32, 224, mem[_17727])
                                    if Mask(32, 224, mem[_17727]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    mem[mem[96] + mem[64] + 164] = 0
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17728 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17728] == Mask(32, 224, mem[_17728])
                                    if Mask(32, 224, mem[_17728]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if arg1 == arg2:
                            if arg2:
                                if arg2 == arg1:
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17705 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17705] == Mask(32, 224, mem[_17705])
                                            if Mask(32, 224, mem[_17705]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17706 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17706] == Mask(32, 224, mem[_17706])
                                            if Mask(32, 224, mem[_17706]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if not arg2:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                    stor8[arg3] = balanceOf[address(arg2)]
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17707 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17707] == Mask(32, 224, mem[_17707])
                                            if Mask(32, 224, mem[_17707]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17708 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17708] == Mask(32, 224, mem[_17708])
                                            if Mask(32, 224, mem[_17708]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor10[arg3] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                stor10[stor9[stor9.length]] = stor10[arg3]
                                stor10[arg3] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17709 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17709] == Mask(32, 224, mem[_17709])
                                        if Mask(32, 224, mem[_17709]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17710 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17710] == Mask(32, 224, mem[_17710])
                                        if Mask(32, 224, mem[_17710]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not arg1:
                                revert with 0, 'ERC721: balance query for the zero address'
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            if balanceOf[address(arg1)] - 1 == stor8[arg3]:
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17711 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17711] == Mask(32, 224, mem[_17711])
                                                if Mask(32, 224, mem[_17711]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17712 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17712] == Mask(32, 224, mem[_17712])
                                                if Mask(32, 224, mem[_17712]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17713 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17713] == Mask(32, 224, mem[_17713])
                                                if Mask(32, 224, mem[_17713]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17714 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17714] == Mask(32, 224, mem[_17714])
                                                if Mask(32, 224, mem[_17714]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17715 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17715] == Mask(32, 224, mem[_17715])
                                            if Mask(32, 224, mem[_17715]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17716 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17716] == Mask(32, 224, mem[_17716])
                                            if Mask(32, 224, mem[_17716]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17717 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17717] == Mask(32, 224, mem[_17717])
                                                if Mask(32, 224, mem[_17717]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17718 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17718] == Mask(32, 224, mem[_17718])
                                                if Mask(32, 224, mem[_17718]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17719 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17719] == Mask(32, 224, mem[_17719])
                                                if Mask(32, 224, mem[_17719]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17720 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17720] == Mask(32, 224, mem[_17720])
                                                if Mask(32, 224, mem[_17720]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17721 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17721] == Mask(32, 224, mem[_17721])
                                            if Mask(32, 224, mem[_17721]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17722 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17722] == Mask(32, 224, mem[_17722])
                                            if Mask(32, 224, mem[_17722]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                else:
                    call msg.sender with:
                       value msg.value wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not ownerOf[arg3]:
                        revert with 0, 'ERC721: owner query for nonexistent token'
                    if ownerOf[arg3] != arg1:
                        revert with 0, 'ERC721: transfer of token that is not own'
                    if not arg2:
                        revert with 0, 'ERC721: transfer to the zero address'
                    if not arg1:
                        stor10[arg3] = tokenByIndex.length
                        tokenByIndex.length++
                        tokenByIndex[tokenByIndex.length] = arg3
                        if arg2:
                            if arg2 == arg1:
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17747 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17747] == Mask(32, 224, mem[_17747])
                                        if Mask(32, 224, mem[_17747]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17748 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17748] == Mask(32, 224, mem[_17748])
                                        if Mask(32, 224, mem[_17748]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if not arg2:
                                    revert with 0, 'ERC721: balance query for the zero address'
                                tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                stor8[arg3] = balanceOf[address(arg2)]
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17749 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17749] == Mask(32, 224, mem[_17749])
                                        if Mask(32, 224, mem[_17749]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17750 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17750] == Mask(32, 224, mem[_17750])
                                        if Mask(32, 224, mem[_17750]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if tokenByIndex.length < 1:
                                revert with 0, 17
                            if tokenByIndex.length - 1 >= tokenByIndex.length:
                                revert with 0, 50
                            if stor10[arg3] >= tokenByIndex.length:
                                revert with 0, 50
                            tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                            stor10[stor9[stor9.length]] = stor10[arg3]
                            stor10[arg3] = 0
                            if not tokenByIndex.length:
                                revert with 0, 49
                            tokenByIndex[tokenByIndex.length] = 0
                            tokenByIndex.length--
                            approved[arg3] = 0
                            if not ownerOf[arg3]:
                                revert with 0, 'ERC721: owner query for nonexistent token'
                            emit Approval(ownerOf[arg3], 0, arg3);
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            balanceOf[address(arg1)]--
                            if balanceOf[address(arg2)] > -2:
                                revert with 0, 17
                            balanceOf[address(arg2)]++
                            mem[0] = arg3
                            mem[32] = 3
                            ownerOf[arg3] = arg2
                            emit Transfer(arg1, arg2, arg3);
                            if ext_code.size(arg2):
                                mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = arg1
                                mem[mem[64] + 68] = arg3
                                mem[mem[64] + 100] = 128
                                mem[mem[64] + 132] = mem[96]
                                mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                if ceil32(mem[96]) <= mem[96]:
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17751 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17751] == Mask(32, 224, mem[_17751])
                                    if Mask(32, 224, mem[_17751]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    mem[mem[96] + mem[64] + 164] = 0
                                    require ext_code.size(arg2)
                                    call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        if not return_data.size:
                                            if not mem[96]:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with memory
                                              from 128
                                               len mem[96]
                                        if not return_data.size:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17752 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_17752] == Mask(32, 224, mem[_17752])
                                    if Mask(32, 224, mem[_17752]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                    else:
                        if arg1 == arg2:
                            if arg2:
                                if arg2 == arg1:
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17729 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17729] == Mask(32, 224, mem[_17729])
                                            if Mask(32, 224, mem[_17729]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17730 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17730] == Mask(32, 224, mem[_17730])
                                            if Mask(32, 224, mem[_17730]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if not arg2:
                                        revert with 0, 'ERC721: balance query for the zero address'
                                    tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                    stor8[arg3] = balanceOf[address(arg2)]
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17731 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17731] == Mask(32, 224, mem[_17731])
                                            if Mask(32, 224, mem[_17731]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17732 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17732] == Mask(32, 224, mem[_17732])
                                            if Mask(32, 224, mem[_17732]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                if tokenByIndex.length < 1:
                                    revert with 0, 17
                                if tokenByIndex.length - 1 >= tokenByIndex.length:
                                    revert with 0, 50
                                if stor10[arg3] >= tokenByIndex.length:
                                    revert with 0, 50
                                tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                stor10[stor9[stor9.length]] = stor10[arg3]
                                stor10[arg3] = 0
                                if not tokenByIndex.length:
                                    revert with 0, 49
                                tokenByIndex[tokenByIndex.length] = 0
                                tokenByIndex.length--
                                approved[arg3] = 0
                                if not ownerOf[arg3]:
                                    revert with 0, 'ERC721: owner query for nonexistent token'
                                emit Approval(ownerOf[arg3], 0, arg3);
                                if balanceOf[address(arg1)] < 1:
                                    revert with 0, 17
                                balanceOf[address(arg1)]--
                                if balanceOf[address(arg2)] > -2:
                                    revert with 0, 17
                                balanceOf[address(arg2)]++
                                mem[0] = arg3
                                mem[32] = 3
                                ownerOf[arg3] = arg2
                                emit Transfer(arg1, arg2, arg3);
                                if ext_code.size(arg2):
                                    mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = arg1
                                    mem[mem[64] + 68] = arg3
                                    mem[mem[64] + 100] = 128
                                    mem[mem[64] + 132] = mem[96]
                                    mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                    if ceil32(mem[96]) <= mem[96]:
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17733 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17733] == Mask(32, 224, mem[_17733])
                                        if Mask(32, 224, mem[_17733]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        mem[mem[96] + mem[64] + 164] = 0
                                        require ext_code.size(arg2)
                                        call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            if not return_data.size:
                                                if not mem[96]:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with memory
                                                  from 128
                                                   len mem[96]
                                            if not return_data.size:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _17734 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_17734] == Mask(32, 224, mem[_17734])
                                        if Mask(32, 224, mem[_17734]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                        else:
                            if not arg1:
                                revert with 0, 'ERC721: balance query for the zero address'
                            if balanceOf[address(arg1)] < 1:
                                revert with 0, 17
                            if balanceOf[address(arg1)] - 1 == stor8[arg3]:
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17735 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17735] == Mask(32, 224, mem[_17735])
                                                if Mask(32, 224, mem[_17735]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17736 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17736] == Mask(32, 224, mem[_17736])
                                                if Mask(32, 224, mem[_17736]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17737 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17737] == Mask(32, 224, mem[_17737])
                                                if Mask(32, 224, mem[_17737]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17738 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17738] == Mask(32, 224, mem[_17738])
                                                if Mask(32, 224, mem[_17738]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17739 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17739] == Mask(32, 224, mem[_17739])
                                            if Mask(32, 224, mem[_17739]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17740 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17740] == Mask(32, 224, mem[_17740])
                                            if Mask(32, 224, mem[_17740]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                            else:
                                tokenOfOwnerByIndex[address(arg1)][stor8[arg3]] = tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1]
                                stor8[stor7[address(arg1)][stor4[address(arg1)] - 1]] = stor8[arg3]
                                stor8[arg3] = 0
                                tokenOfOwnerByIndex[address(arg1)][stor4[address(arg1)] - 1] = 0
                                if arg2:
                                    if arg2 == arg1:
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17741 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17741] == Mask(32, 224, mem[_17741])
                                                if Mask(32, 224, mem[_17741]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17742 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17742] == Mask(32, 224, mem[_17742])
                                                if Mask(32, 224, mem[_17742]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                    else:
                                        if not arg2:
                                            revert with 0, 'ERC721: balance query for the zero address'
                                        tokenOfOwnerByIndex[address(arg2)][stor4[address(arg2)]] = arg3
                                        stor8[arg3] = balanceOf[address(arg2)]
                                        approved[arg3] = 0
                                        if not ownerOf[arg3]:
                                            revert with 0, 'ERC721: owner query for nonexistent token'
                                        emit Approval(ownerOf[arg3], 0, arg3);
                                        if balanceOf[address(arg1)] < 1:
                                            revert with 0, 17
                                        balanceOf[address(arg1)]--
                                        if balanceOf[address(arg2)] > -2:
                                            revert with 0, 17
                                        balanceOf[address(arg2)]++
                                        mem[0] = arg3
                                        mem[32] = 3
                                        ownerOf[arg3] = arg2
                                        emit Transfer(arg1, arg2, arg3);
                                        if ext_code.size(arg2):
                                            mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = arg1
                                            mem[mem[64] + 68] = arg3
                                            mem[mem[64] + 100] = 128
                                            mem[mem[64] + 132] = mem[96]
                                            mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                            if ceil32(mem[96]) <= mem[96]:
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17743 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17743] == Mask(32, 224, mem[_17743])
                                                if Mask(32, 224, mem[_17743]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                            else:
                                                mem[mem[96] + mem[64] + 164] = 0
                                                require ext_code.size(arg2)
                                                call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                     gas gas_remaining wei
                                                    args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    if not return_data.size:
                                                        if not mem[96]:
                                                            revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                        revert with memory
                                                          from 128
                                                           len mem[96]
                                                    if not return_data.size:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _17744 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_17744] == Mask(32, 224, mem[_17744])
                                                if Mask(32, 224, mem[_17744]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                else:
                                    if tokenByIndex.length < 1:
                                        revert with 0, 17
                                    if tokenByIndex.length - 1 >= tokenByIndex.length:
                                        revert with 0, 50
                                    if stor10[arg3] >= tokenByIndex.length:
                                        revert with 0, 50
                                    tokenByIndex[stor10[arg3]] = tokenByIndex[tokenByIndex.length]
                                    stor10[stor9[stor9.length]] = stor10[arg3]
                                    stor10[arg3] = 0
                                    if not tokenByIndex.length:
                                        revert with 0, 49
                                    tokenByIndex[tokenByIndex.length] = 0
                                    tokenByIndex.length--
                                    approved[arg3] = 0
                                    if not ownerOf[arg3]:
                                        revert with 0, 'ERC721: owner query for nonexistent token'
                                    emit Approval(ownerOf[arg3], 0, arg3);
                                    if balanceOf[address(arg1)] < 1:
                                        revert with 0, 17
                                    balanceOf[address(arg1)]--
                                    if balanceOf[address(arg2)] > -2:
                                        revert with 0, 17
                                    balanceOf[address(arg2)]++
                                    mem[0] = arg3
                                    mem[32] = 3
                                    ownerOf[arg3] = arg2
                                    emit Transfer(arg1, arg2, arg3);
                                    if ext_code.size(arg2):
                                        mem[mem[64]] = 0x150b7a0200000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = arg1
                                        mem[mem[64] + 68] = arg3
                                        mem[mem[64] + 100] = 128
                                        mem[mem[64] + 132] = mem[96]
                                        mem[mem[64] + 164 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
                                        if ceil32(mem[96]) <= mem[96]:
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, Array(len=mem[96], data=mem[mem[64] + 164 len ceil32(mem[96])])
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17745 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17745] == Mask(32, 224, mem[_17745])
                                            if Mask(32, 224, mem[_17745]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                        else:
                                            mem[mem[96] + mem[64] + 164] = 0
                                            require ext_code.size(arg2)
                                            call arg2.onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) with:
                                                 gas gas_remaining wei
                                                args msg.sender, address(arg1), arg3, 128, mem[mem[64] + 132 len ceil32(mem[96]) + 32]
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                if not return_data.size:
                                                    if not mem[96]:
                                                        revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                    revert with memory
                                                      from 128
                                                       len mem[96]
                                                if not return_data.size:
                                                    revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _17746 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_17746] == Mask(32, 224, mem[_17746])
                                            if Mask(32, 224, mem[_17746]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                                                revert with 0, 'ERC721: transfer to non ERC721Receiver implementer'
}



}

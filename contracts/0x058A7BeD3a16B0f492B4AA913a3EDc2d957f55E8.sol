contract main {




// =====================  Runtime code  =====================


#
#  - sub_5a3dc926(?)
#  - sub_6fb4db8a(?)
#
address stor0;
address stor1;
address stor2;
mapping of uint8 stor3;

function removeContract(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor0 != msg.sender:
        if stor1 != msg.sender:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
    selfdestruct(arg1)
}

function _fallback() payable {
    revert
}

function sub_2f867852(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    require ext_code.size(address(arg1))
    call address(arg1).sync() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_a007ef12(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require ext_code.size(address(arg1))
    call address(arg1).skim(address arg1) with:
         gas gas_remaining wei
        args address(arg2)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function updateOperator(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if stor0 != msg.sender:
        if stor1 != msg.sender:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
    if not arg1:
        revert with 0, 'Operator needs valid address'
    stor3[address(arg1)] = uint8(arg2)
}

function sub_2ceff651(?) {
    require calldata.size - 4 >= 64
    require arg2 == address(arg2)
    if stor0 != msg.sender:
        if stor1 != msg.sender:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
    if not arg1:
        stor0 = address(arg2)
    else:
        if 1 == arg1:
            stor1 = address(arg2)
        else:
            if 2 == arg1:
                stor2 = address(arg2)
}

function getRolesAddress() {
    if stor0 != msg.sender:
        if stor1 != msg.sender:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
    mem[128] = stor0
    mem[160] = stor1
    mem[192] = stor2
    mem[224] = 32
    idx = 0
    s = 128
    t = 288
    while idx < 3:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return Array(len=3, data=mem[288 len 96])
}

function getTokenBalance(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor0 != msg.sender:
        if stor2 != msg.sender:
            if bool(stor3[msg.sender]) != 1:
                revert with 0, 'Not authorized'
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function withdrawToken(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor0 != msg.sender:
        if stor1 != msg.sender:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function sub_da6253d6(?) {
    require calldata.size - 4 >= 128
    if arg1 <= 0:
        revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
    if arg2 <= 0:
        revert with 0, 'INSUFFICIENT_LIQUIDITY'
    if arg3 <= 0:
        revert with 0, 'INSUFFICIENT_LIQUIDITY'
    if arg1 and 998 > -1 / arg1:
        revert with 0, 17
    if 998 * arg1 / 998 != arg1:
        revert with 0, 'MUL error'
    if not arg3:
        if arg2 and 1000 > -1 / arg2:
            revert with 0, 17
        if 1000 * arg2 / 1000 != arg2:
            revert with 0, 'MUL error'
        if 1000 * arg2 > !(998 * arg1):
            revert with 0, 17
        if (1000 * arg2) + (998 * arg1) < 1000 * arg2:
            revert with 0, 'Add error'
        if not (1000 * arg2) + (998 * arg1):
            revert with 0, 18
        if 0 / (1000 * arg2) + (998 * arg1) < arg4:
            revert with 0, 17
        if (0 / (1000 * arg2) + (998 * arg1)) - arg4 > 0 / (1000 * arg2) + (998 * arg1):
            revert with 0, 'SUB error'
        return ((0 / (1000 * arg2) + (998 * arg1)) - arg4)
    if 998 * arg1 and arg3 > -1 / 998 * arg1:
        revert with 0, 17
    if not arg3:
        revert with 0, 18
    if 998 * arg1 * arg3 / arg3 != 998 * arg1:
        revert with 0, 'MUL error'
    if arg2 and 1000 > -1 / arg2:
        revert with 0, 17
    if 1000 * arg2 / 1000 != arg2:
        revert with 0, 'MUL error'
    if 1000 * arg2 > !(998 * arg1):
        revert with 0, 17
    if (1000 * arg2) + (998 * arg1) < 1000 * arg2:
        revert with 0, 'Add error'
    if not (1000 * arg2) + (998 * arg1):
        revert with 0, 18
    if 998 * arg1 * arg3 / (1000 * arg2) + (998 * arg1) < arg4:
        revert with 0, 17
    if (998 * arg1 * arg3 / (1000 * arg2) + (998 * arg1)) - arg4 > 998 * arg1 * arg3 / (1000 * arg2) + (998 * arg1):
        revert with 0, 'SUB error'
    return ((998 * arg1 * arg3 / (1000 * arg2) + (998 * arg1)) - arg4)
}

function getAmountIn(uint256 arg1, uint256 arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    if arg1 <= 0:
        revert with 0, 'INSUFFICIENT_OUTPUT_AMOUNT'
    if arg2 <= 0:
        revert with 0, 'INSUFFICIENT_LIQUIDITY'
    if arg3 <= 0:
        revert with 0, 'INSUFFICIENT_LIQUIDITY'
    if not arg1:
        if arg3 < arg1:
            revert with 0, 17
        if arg3 - arg1 > arg3:
            revert with 0, 'SUB error'
        if arg3 - arg1 and 998 > -1 / arg3 - arg1:
            revert with 0, 17
        if (998 * arg3) - (998 * arg1) / 998 != arg3 - arg1:
            revert with 0, 'MUL error'
        if not (998 * arg3) - (998 * arg1):
            revert with 0, 18
        if 0 / (998 * arg3) - (998 * arg1) > -2:
            revert with 0, 17
        if (0 / (998 * arg3) - (998 * arg1)) + 1 < 0 / (998 * arg3) - (998 * arg1):
            revert with 0, 'Add error'
        return ((0 / (998 * arg3) - (998 * arg1)) + 1)
    if arg2 and arg1 > -1 / arg2:
        revert with 0, 17
    if not arg1:
        revert with 0, 18
    if arg2 * arg1 / arg1 != arg2:
        revert with 0, 'MUL error'
    if arg2 * arg1 and 1000 > -1 / arg2 * arg1:
        revert with 0, 17
    if 1000 * arg2 * arg1 / 1000 != arg2 * arg1:
        revert with 0, 'MUL error'
    if arg3 < arg1:
        revert with 0, 17
    if arg3 - arg1 > arg3:
        revert with 0, 'SUB error'
    if arg3 - arg1 and 998 > -1 / arg3 - arg1:
        revert with 0, 17
    if (998 * arg3) - (998 * arg1) / 998 != arg3 - arg1:
        revert with 0, 'MUL error'
    if not (998 * arg3) - (998 * arg1):
        revert with 0, 18
    if 1000 * arg2 * arg1 / (998 * arg3) - (998 * arg1) > -2:
        revert with 0, 17
    if (1000 * arg2 * arg1 / (998 * arg3) - (998 * arg1)) + 1 < 1000 * arg2 * arg1 / (998 * arg3) - (998 * arg1):
        revert with 0, 'Add error'
    return ((1000 * arg2 * arg1 / (998 * arg3) - (998 * arg1)) + 1)
}

function sub_2016bc4d(?) payable {
    require calldata.size - 4 >= 128
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    if stor0 != msg.sender:
        if stor1 != msg.sender:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
    require ext_code.size(address(arg3))
    staticcall address(arg3).token0() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(arg3))
    staticcall address(arg3).token1() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if arg1 > 0x480ebe7b9d58566c87ce9b80a5fb05082bd371c8651c7b299b30:
        revert with 0, 17
    if arg2 > 0x480ebe7b9d58566c87ce9b80a5fb05082bd371c8651c7b299b30:
        revert with 0, 17
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < 10^15 * arg1:
        revert with 0, 'amount0In is big'
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < 10^15 * arg2:
        revert with 0, 'amount1In is big'
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).0xa9059cbb with:
         gas gas_remaining wei
        args address(arg3), 10^15 * arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).0xa9059cbb with:
         gas gas_remaining wei
        args address(arg3), 10^15 * arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(address(arg3))
    call address(arg3).mint(address arg1) with:
         gas gas_remaining wei
        args address(arg4)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(arg3))
    call address(arg3).skim(address arg1) with:
         gas gas_remaining wei
        args address(arg4)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    return ext_call.return_data[0]
}

function getPairReserve(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor0 != msg.sender:
        if stor2 != msg.sender:
            if bool(stor3[msg.sender]) != 1:
                revert with 0, 'Not authorized'
    mem[192] = 2
    require ext_code.size(arg1)
    staticcall arg1.getReserves() with:
            gas gas_remaining wei
    mem[288 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    mem[256] = ext_call.return_data[50 len 14]
    mem[224] = ext_call.return_data[18 len 14]
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[128] = ext_call.return_data[12 len 20]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[160] = ext_call.return_data[12 len 20]
    if Mask(112, 0, ext_call.return_data[0]) <= mem[274 len 14]:
        if mem[274 len 14] > 0x4189374bc6a7ef9db22d0e5604:
            revert with 0, 17
        if not Mask(112, 0, ext_call.return_data[0]):
            revert with 0, 18
        mem[(4 * ceil32(return_data.size)) + 288] = 96
        idx = 0
        s = 128
        t = (4 * ceil32(return_data.size)) + 416
        while idx < 2:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        idx = 0
        s = 224
        t = (4 * ceil32(return_data.size)) + 512
        while idx < 2:
            mem[t] = mem[s + 18 len 14]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return 96, 
               192,
               Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, ext_call.return_data[50 len 14])) / Mask(112, 0, ext_call.return_data[0])),
               2,
               mem[(4 * ceil32(return_data.size)) + 416 len 64],
               2,
               mem[(4 * ceil32(return_data.size)) + 512 len 64]
    if Mask(112, 0, ext_call.return_data[0]) > 0x4189374bc6a7ef9db22d0e5604:
        revert with 0, 17
    if not mem[274 len 14]:
        revert with 0, 18
    mem[(4 * ceil32(return_data.size)) + 288] = 96
    idx = 0
    s = 128
    t = (4 * ceil32(return_data.size)) + 416
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    s = 224
    t = (4 * ceil32(return_data.size)) + 512
    while idx < 2:
        mem[t] = mem[s + 18 len 14]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return 96, 
           192,
           Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, ext_call.return_data[0])) / Mask(112, 0, ext_call.return_data[50 len 14])),
           2,
           mem[(4 * ceil32(return_data.size)) + 416 len 64],
           2,
           mem[(4 * ceil32(return_data.size)) + 512 len 64]
}

function sub_e8ea7770(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if msg.sender == stor0:
        if ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 4).length
        mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 129
        if not ('cd', 4).length:
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _159 = mem[(32 * idx) + 128]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_159))
                staticcall address(_159).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _183 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] = mem[_183]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            _182 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 64 len 32 * _182] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * _182]
            return 32, mem[mem[64] + 32 len (32 * _182) + 32]
        mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _163 = mem[(32 * idx) + 128]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_163))
            staticcall address(_163).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _185 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] = mem[_185]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _184 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 64 len 32 * _184] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * _184]
        return 32, mem[mem[64] + 32 len (32 * _184) + 32]
    if msg.sender == stor2:
        if ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 4).length
        mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 129
        if not ('cd', 4).length:
            idx = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _167 = mem[(32 * idx) + 128]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_167))
                staticcall address(_167).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _187 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] = mem[_187]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[mem[64]] = 32
            _186 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 64 len 32 * _186] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * _186]
            return 32, mem[mem[64] + 32 len (32 * _186) + 32]
        mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _171 = mem[(32 * idx) + 128]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_171))
            staticcall address(_171).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _189 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] = mem[_189]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _188 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 64 len 32 * _188] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * _188]
        return 32, mem[mem[64] + 32 len (32 * _188) + 32]
    mem[0] = msg.sender
    mem[32] = 3
    if bool(stor3[msg.sender]) != 1:
        revert with 0, 'Not authorized'
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 4).length
    mem[64] = ceil32(32 * ('cd', 4).length) + (32 * ('cd', 4).length) + 129
    if not ('cd', 4).length:
        idx = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _175 = mem[(32 * idx) + 128]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_175))
            staticcall address(_175).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _191 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] = mem[_191]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _190 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 64 len 32 * _190] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * _190]
        return 32, mem[mem[64] + 32 len (32 * _190) + 32]
    mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    idx = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        _179 = mem[(32 * idx) + 128]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_179))
        staticcall address(_179).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _193 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
            revert with 0, 50
        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129] = mem[_193]
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    _192 = mem[ceil32(32 * ('cd', 4).length) + 97]
    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + 97]
    mem[mem[64] + 64 len 32 * _192] = mem[ceil32(32 * ('cd', 4).length) + 129 len 32 * _192]
    return 32, mem[mem[64] + 32 len (32 * _192) + 32]
}

function sub_44173160(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if msg.sender == stor0:
        idx = 0
        while idx < ('cd', 4).length:
            _229 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = 0
            t = 0
            while s < _229:
                if idx >= mem[96]:
                    revert with 0, 50
                _235 = mem[(32 * idx) + 128]
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _241 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = address(_241)
                require ext_code.size(address(_235))
                staticcall address(_235).0xdd62ed3e with:
                        gas gas_remaining wei
                       args address(this.address), address(_241)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _250 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _253 = mem[_250]
                if not mem[_250]:
                    if s == -1:
                        revert with 0, 17
                    _229 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    s = s + 1
                    t = mem[_250]
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                _259 = mem[(32 * idx) + 128]
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                mem[mem[64] + 36] = 0
                require ext_code.size(address(_259))
                call address(_259).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4], 0
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _274 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_274] == bool(mem[_274])
                if s == -1:
                    revert with 0, 17
                _229 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = s + 1
                t = _253
                continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
    else:
        if msg.sender == stor2:
            idx = 0
            while idx < ('cd', 4).length:
                _230 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = 0
                t = 0
                while s < _230:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _237 = mem[(32 * idx) + 128]
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    _243 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(_243)
                    require ext_code.size(address(_237))
                    staticcall address(_237).0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(_243)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _251 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _254 = mem[_251]
                    if not mem[_251]:
                        if s == -1:
                            revert with 0, 17
                        _230 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        s = s + 1
                        t = mem[_251]
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _261 = mem[(32 * idx) + 128]
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(_261))
                    call address(_261).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _275 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_275] == bool(mem[_275])
                    if s == -1:
                        revert with 0, 17
                    _230 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    s = s + 1
                    t = _254
                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
        else:
            mem[0] = msg.sender
            mem[32] = 3
            if bool(stor3[msg.sender]) != 1:
                revert with 0, 'Not authorized'
            idx = 0
            while idx < ('cd', 4).length:
                _231 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = 0
                t = 0
                while s < _231:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _239 = mem[(32 * idx) + 128]
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    _245 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = address(_245)
                    require ext_code.size(address(_239))
                    staticcall address(_239).0xdd62ed3e with:
                            gas gas_remaining wei
                           args address(this.address), address(_245)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _252 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _255 = mem[_252]
                    if not mem[_252]:
                        if s == -1:
                            revert with 0, 17
                        _231 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        s = s + 1
                        t = mem[_252]
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    _263 = mem[(32 * idx) + 128]
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(_263))
                    call address(_263).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4], 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _276 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_276] == bool(mem[_276])
                    if s == -1:
                        revert with 0, 17
                    _231 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    s = s + 1
                    t = _255
                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
}

function withdrawTokens(address[] arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(32 * arg1.length) + 97 < 96 or ceil32(32 * arg1.length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = arg1.length
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    idx = 0
    s = arg1 + 36
    t = 128
    while idx < arg1.length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if msg.sender == stor0:
        if arg1.length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * arg1.length) + 97] = arg1.length
        mem[64] = ceil32(32 * arg1.length) + (32 * arg1.length) + 129
        if not arg1.length:
            idx = 0
            s = 0
            s = 0
            while idx < arg1.length:
                if idx >= mem[96]:
                    revert with 0, 50
                _205 = mem[(32 * idx) + 128]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_205))
                staticcall address(_205).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _229 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _241 = mem[_229]
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _241
                require ext_code.size(address(_205))
                call address(_205).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _241
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _270 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_270] == bool(mem[_270])
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _241
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _241
                s = _205
                continue 
            mem[mem[64]] = 32
            _228 = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 64 len 32 * _228] = mem[ceil32(32 * arg1.length) + 129 len 32 * _228]
            return 32, mem[mem[64] + 32 len (32 * _228) + 32]
        mem[ceil32(32 * arg1.length) + 129 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
        idx = 0
        s = 0
        s = 0
        while idx < arg1.length:
            if idx >= mem[96]:
                revert with 0, 50
            _209 = mem[(32 * idx) + 128]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_209))
            staticcall address(_209).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _231 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _243 = mem[_231]
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = _243
            require ext_code.size(address(_209))
            call address(_209).0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, _243
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _271 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_271] == bool(mem[_271])
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _243
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _243
            s = _209
            continue 
        mem[mem[64]] = 32
        _230 = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 64 len 32 * _230] = mem[ceil32(32 * arg1.length) + 129 len 32 * _230]
        return 32, mem[mem[64] + 32 len (32 * _230) + 32]
    if msg.sender == stor1:
        if arg1.length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * arg1.length) + 97] = arg1.length
        mem[64] = ceil32(32 * arg1.length) + (32 * arg1.length) + 129
        if not arg1.length:
            idx = 0
            s = 0
            s = 0
            while idx < arg1.length:
                if idx >= mem[96]:
                    revert with 0, 50
                _213 = mem[(32 * idx) + 128]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_213))
                staticcall address(_213).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _233 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _245 = mem[_233]
                mem[mem[64] + 4] = msg.sender
                mem[mem[64] + 36] = _245
                require ext_code.size(address(_213))
                call address(_213).0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, _245
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _272 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_272] == bool(mem[_272])
                if idx >= mem[ceil32(32 * arg1.length) + 97]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _245
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _245
                s = _213
                continue 
            mem[mem[64]] = 32
            _232 = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + 97]
            mem[mem[64] + 64 len 32 * _232] = mem[ceil32(32 * arg1.length) + 129 len 32 * _232]
            return 32, mem[mem[64] + 32 len (32 * _232) + 32]
        mem[ceil32(32 * arg1.length) + 129 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
        idx = 0
        s = 0
        s = 0
        while idx < arg1.length:
            if idx >= mem[96]:
                revert with 0, 50
            _217 = mem[(32 * idx) + 128]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_217))
            staticcall address(_217).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _235 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _247 = mem[_235]
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = _247
            require ext_code.size(address(_217))
            call address(_217).0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, _247
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _273 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_273] == bool(mem[_273])
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _247
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _247
            s = _217
            continue 
        mem[mem[64]] = 32
        _234 = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 64 len 32 * _234] = mem[ceil32(32 * arg1.length) + 129 len 32 * _234]
        return 32, mem[mem[64] + 32 len (32 * _234) + 32]
    if stor2 != msg.sender:
        revert with 0, 'Not authorized'
    if arg1.length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * arg1.length) + 97] = arg1.length
    mem[64] = ceil32(32 * arg1.length) + (32 * arg1.length) + 129
    if not arg1.length:
        idx = 0
        s = 0
        s = 0
        while idx < arg1.length:
            if idx >= mem[96]:
                revert with 0, 50
            _221 = mem[(32 * idx) + 128]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_221))
            staticcall address(_221).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _237 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _249 = mem[_237]
            mem[mem[64] + 4] = msg.sender
            mem[mem[64] + 36] = _249
            require ext_code.size(address(_221))
            call address(_221).0xa9059cbb with:
                 gas gas_remaining wei
                args msg.sender, _249
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _274 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_274] == bool(mem[_274])
            if idx >= mem[ceil32(32 * arg1.length) + 97]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _249
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _249
            s = _221
            continue 
        mem[mem[64]] = 32
        _236 = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + 97]
        mem[mem[64] + 64 len 32 * _236] = mem[ceil32(32 * arg1.length) + 129 len 32 * _236]
        return 32, mem[mem[64] + 32 len (32 * _236) + 32]
    mem[ceil32(32 * arg1.length) + 129 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
    idx = 0
    s = 0
    s = 0
    while idx < arg1.length:
        if idx >= mem[96]:
            revert with 0, 50
        _225 = mem[(32 * idx) + 128]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_225))
        staticcall address(_225).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _239 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _251 = mem[_239]
        mem[mem[64] + 4] = msg.sender
        mem[mem[64] + 36] = _251
        require ext_code.size(address(_225))
        call address(_225).0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, _251
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _275 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_275] == bool(mem[_275])
        if idx >= mem[ceil32(32 * arg1.length) + 97]:
            revert with 0, 50
        mem[(32 * idx) + ceil32(32 * arg1.length) + 129] = _251
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = _251
        s = _225
        continue 
    mem[mem[64]] = 32
    _238 = mem[ceil32(32 * arg1.length) + 97]
    mem[mem[64] + 32] = mem[ceil32(32 * arg1.length) + 97]
    mem[mem[64] + 64 len 32 * _238] = mem[ceil32(32 * arg1.length) + 129 len 32 * _238]
    return 32, mem[mem[64] + 32 len (32 * _238) + 32]
}

function sub_e740972f(?) {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if msg.sender == stor0:
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = 20
        mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131 len 640] = call.data[calldata.size len 640]
        idx = 0
        while idx < ('cd', 4).length:
            _301 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = 0
            while s < _301:
                _346 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                t = 0
                u = 0
                v = 0
                while t < _346:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _352 = mem[(32 * idx) + 128]
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    _364 = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                    mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                    mem[mem[64] + 36] = address(_364)
                    require ext_code.size(address(_352))
                    staticcall address(_352).getPair(address arg1, address arg2) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_364)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _373 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _376 = mem[_373]
                    require mem[_373] == mem[_373 + 12 len 20]
                    if not mem[_373 + 12 len 20]:
                        if t == -1:
                            revert with 0, 17
                        _301 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        _346 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                        t = t + 1
                        u = u
                        v = mem[_373]
                        continue 
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131] = mem[_373 + 12 len 20]
                    if 1 > !u:
                        revert with 0, 17
                    if u + 1 < 20:
                        if t == -1:
                            revert with 0, 17
                        _301 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        _346 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                        t = t + 1
                        u = u + 1
                        v = _376
                        continue 
                    if s == -1:
                        revert with 0, 17
                    _301 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    _346 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                    s = s + 1
                    continue 
                if s == -1:
                    revert with 0, 17
                _301 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = s + 1
                continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _250 = mem[64]
        mem[mem[64]] = 32
        _256 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
        t = mem[64] + 64
        while idx < _256:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from mem[64]
           len _250 + (32 * _256) + -mem[64] + 64
    if msg.sender == stor2:
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = 20
        mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131 len 640] = call.data[calldata.size len 640]
        idx = 0
        while idx < ('cd', 4).length:
            _302 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = 0
            while s < _302:
                _347 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                t = 0
                u = 0
                v = 0
                while t < _347:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _354 = mem[(32 * idx) + 128]
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    _366 = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                    mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                    mem[mem[64] + 36] = address(_366)
                    require ext_code.size(address(_354))
                    staticcall address(_354).getPair(address arg1, address arg2) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_366)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _374 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _377 = mem[_374]
                    require mem[_374] == mem[_374 + 12 len 20]
                    if not mem[_374 + 12 len 20]:
                        if t == -1:
                            revert with 0, 17
                        _302 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        _347 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                        t = t + 1
                        u = u
                        v = mem[_374]
                        continue 
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131] = mem[_374 + 12 len 20]
                    if 1 > !u:
                        revert with 0, 17
                    if u + 1 < 20:
                        if t == -1:
                            revert with 0, 17
                        _302 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        _347 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                        t = t + 1
                        u = u + 1
                        v = _377
                        continue 
                    if s == -1:
                        revert with 0, 17
                    _302 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    _347 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                    s = s + 1
                    continue 
                if s == -1:
                    revert with 0, 17
                _302 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = s + 1
                continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _252 = mem[64]
        mem[mem[64]] = 32
        _258 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
        mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
        t = mem[64] + 64
        while idx < _258:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from mem[64]
           len _252 + (32 * _258) + -mem[64] + 64
    mem[0] = msg.sender
    mem[32] = 3
    if bool(stor3[msg.sender]) != 1:
        revert with 0, 'Not authorized'
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = 20
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131 len 640] = call.data[calldata.size len 640]
    idx = 0
    while idx < ('cd', 4).length:
        _303 = mem[ceil32(32 * ('cd', 4).length) + 97]
        s = 0
        while s < _303:
            _348 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
            t = 0
            u = 0
            v = 0
            while t < _348:
                if idx >= mem[96]:
                    revert with 0, 50
                _356 = mem[(32 * idx) + 128]
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                _368 = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                mem[mem[64] + 36] = address(_368)
                require ext_code.size(address(_356))
                staticcall address(_356).getPair(address arg1, address arg2) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(_368)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _375 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _378 = mem[_375]
                require mem[_375] == mem[_375 + 12 len 20]
                if not mem[_375 + 12 len 20]:
                    if t == -1:
                        revert with 0, 17
                    _303 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    _348 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                    t = t + 1
                    u = u
                    v = mem[_375]
                    continue 
                if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                    revert with 0, 50
                mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131] = mem[_375 + 12 len 20]
                if 1 > !u:
                    revert with 0, 17
                if u + 1 < 20:
                    if t == -1:
                        revert with 0, 17
                    _303 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    _348 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                    t = t + 1
                    u = u + 1
                    v = _378
                    continue 
                if s == -1:
                    revert with 0, 17
                _303 = mem[ceil32(32 * ('cd', 4).length) + 97]
                _348 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                s = s + 1
                continue 
            if s == -1:
                revert with 0, 17
            _303 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = s + 1
            continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    _254 = mem[64]
    mem[mem[64]] = 32
    _260 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
    mem[mem[64] + 32] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
    t = mem[64] + 64
    while idx < _260:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len _254 + (32 * _260) + -mem[64] + 64
}

function sub_0ad1d9a6(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if msg.sender == stor0:
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770] = 20
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442] = 20
        mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 2114
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474 len 640] = call.data[calldata.size len 640]
        idx = 0
        while idx < ('cd', 4).length:
            _340 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = 0
            t = 0
            u = 0
            while s < _340:
                if idx >= mem[96]:
                    revert with 0, 50
                _349 = mem[(32 * idx) + 128]
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _356 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
                mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                require ext_code.size(address(_349))
                staticcall address(_349).0x70a08231 with:
                        gas gas_remaining wei
                       args address(_356)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _370 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _376 = mem[_370]
                if not mem[_370]:
                    if s == -1:
                        revert with 0, 17
                    _340 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    s = s + 1
                    t = t
                    u = mem[_370]
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] = mem[(32 * idx) + 140 len 20]
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]:
                    revert with 0, 50
                mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]:
                    revert with 0, 50
                mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474] = _376
                if 1 > !t:
                    revert with 0, 17
                if t + 1 <= 20:
                    if s == -1:
                        revert with 0, 17
                    _340 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    s = s + 1
                    t = t + 1
                    u = _376
                    continue 
                if idx == -1:
                    revert with 0, 17
                _340 = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = idx + 1
                continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _268 = mem[64]
        mem[mem[64]] = 96
        _277 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
        mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
        t = mem[64] + 128
        while idx < _277:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _277) + 128
        _355 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]
        mem[_268 + (32 * _277) + 128] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802
        t = _268 + (32 * _277) + 160
        while idx < _355:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_268 + 64] = (32 * _277) + (32 * _355) + 160
        _409 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]
        mem[_268 + (32 * _277) + (32 * _355) + 160] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]
        mem[_268 + (32 * _277) + (32 * _355) + 192 len 32 * _409] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474 len 32 * _409]
        return memory
          from mem[64]
           len _268 + (32 * _277) + (32 * _355) + (32 * _409) + -mem[64] + 192
    if msg.sender == stor2:
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770] = 20
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442] = 20
        mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 2114
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474 len 640] = call.data[calldata.size len 640]
        idx = 0
        while idx < ('cd', 4).length:
            _341 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = 0
            t = 0
            u = 0
            while s < _341:
                if idx >= mem[96]:
                    revert with 0, 50
                _351 = mem[(32 * idx) + 128]
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _359 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
                mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                require ext_code.size(address(_351))
                staticcall address(_351).0x70a08231 with:
                        gas gas_remaining wei
                       args address(_359)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _371 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _377 = mem[_371]
                if not mem[_371]:
                    if s == -1:
                        revert with 0, 17
                    _341 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    s = s + 1
                    t = t
                    u = mem[_371]
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] = mem[(32 * idx) + 140 len 20]
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]:
                    revert with 0, 50
                mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]:
                    revert with 0, 50
                mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474] = _377
                if 1 > !t:
                    revert with 0, 17
                if t + 1 <= 20:
                    if s == -1:
                        revert with 0, 17
                    _341 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    s = s + 1
                    t = t + 1
                    u = _377
                    continue 
                if idx == -1:
                    revert with 0, 17
                _341 = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = idx + 1
                continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _270 = mem[64]
        mem[mem[64]] = 96
        _280 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
        mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
        t = mem[64] + 128
        while idx < _280:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _280) + 128
        _358 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]
        mem[_270 + (32 * _280) + 128] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802
        t = _270 + (32 * _280) + 160
        while idx < _358:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_270 + 64] = (32 * _280) + (32 * _358) + 160
        _410 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]
        mem[_270 + (32 * _280) + (32 * _358) + 160] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]
        mem[_270 + (32 * _280) + (32 * _358) + 192 len 32 * _410] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474 len 32 * _410]
        return memory
          from mem[64]
           len _270 + (32 * _280) + (32 * _358) + (32 * _410) + -mem[64] + 192
    mem[0] = msg.sender
    mem[32] = 3
    if bool(stor3[msg.sender]) != 1:
        revert with 0, 'Not authorized'
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130 len 640] = call.data[calldata.size len 640]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770] = 20
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802 len 640] = call.data[calldata.size len 640]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442] = 20
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 2114
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474 len 640] = call.data[calldata.size len 640]
    idx = 0
    while idx < ('cd', 4).length:
        _342 = mem[ceil32(32 * ('cd', 4).length) + 97]
        s = 0
        t = 0
        u = 0
        while s < _342:
            if idx >= mem[96]:
                revert with 0, 50
            _353 = mem[(32 * idx) + 128]
            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _362 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
            mem[mem[64] + 4] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
            require ext_code.size(address(_353))
            staticcall address(_353).0x70a08231 with:
                    gas gas_remaining wei
                   args address(_362)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _372 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _378 = mem[_372]
            if not mem[_372]:
                if s == -1:
                    revert with 0, 17
                _342 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = s + 1
                t = t
                u = mem[_372]
                continue 
            if idx >= mem[96]:
                revert with 0, 50
            if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                revert with 0, 50
            mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130] = mem[(32 * idx) + 140 len 20]
            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]:
                revert with 0, 50
            mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
            if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]:
                revert with 0, 50
            mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474] = _378
            if 1 > !t:
                revert with 0, 17
            if t + 1 <= 20:
                if s == -1:
                    revert with 0, 17
                _342 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = s + 1
                t = t + 1
                u = _378
                continue 
            if idx == -1:
                revert with 0, 17
            _342 = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = idx + 1
            continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    _272 = mem[64]
    mem[mem[64]] = 96
    _283 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
    mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    t = mem[64] + 128
    while idx < _283:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 32] = (32 * _283) + 128
    _361 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]
    mem[_272 + (32 * _283) + 128] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 770]
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 802
    t = _272 + (32 * _283) + 160
    while idx < _361:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[_272 + 64] = (32 * _283) + (32 * _361) + 160
    _411 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]
    mem[_272 + (32 * _283) + (32 * _361) + 160] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1442]
    mem[_272 + (32 * _283) + (32 * _361) + 192 len 32 * _411] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 1474 len 32 * _411]
    return memory
      from mem[64]
       len _272 + (32 * _283) + (32 * _361) + (32 * _411) + -mem[64] + 192
}

function sub_fc38d5b0(?) {
    require calldata.size - 4 >= 96
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if msg.sender == stor0:
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771] = 20
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443] = 20
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115] = 20
        mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2787
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147 len 640] = call.data[calldata.size len 640]
        idx = 0
        while idx < ('cd', 4).length:
            _562 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = 0
            while s < _562:
                _652 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                t = 0
                u = 0
                v = 0
                while t < _652:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _661 = mem[(32 * idx) + 128]
                    if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    _676 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[mem[64] + 4] = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]
                    mem[mem[64] + 36] = address(_676)
                    require ext_code.size(address(_661))
                    staticcall address(_661).0xdd62ed3e with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_676)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _689 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _695 = mem[_689]
                    if not mem[_689]:
                        if t == -1:
                            revert with 0, 17
                        _562 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        _652 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                        t = t + 1
                        u = u
                        v = mem[_689]
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131] = mem[(32 * idx) + 140 len 20]
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                    if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475] = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147] = _695
                    if 1 > !u:
                        revert with 0, 17
                    if u + 1 <= 20:
                        if t == -1:
                            revert with 0, 17
                        _562 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        _652 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                        t = t + 1
                        u = u + 1
                        v = _695
                        continue 
                    if s == -1:
                        revert with 0, 17
                    _562 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    _652 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                    s = s + 1
                    continue 
                if s == -1:
                    revert with 0, 17
                _562 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = s + 1
                continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _466 = mem[64]
        mem[mem[64]] = 128
        _472 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
        t = mem[64] + 160
        while idx < _472:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _472) + 160
        _571 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]
        mem[mem[64] + (32 * _472) + 160] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803
        t = mem[64] + (32 * _472) + 192
        while idx < _571:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_466 + 64] = (32 * _472) + (32 * _571) + 192
        _667 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]
        mem[_466 + (32 * _472) + (32 * _571) + 192] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475
        t = _466 + (32 * _472) + (32 * _571) + 224
        while idx < _667:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_466 + 96] = (32 * _472) + (32 * _571) + (32 * _667) + 224
        _736 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]
        mem[_466 + (32 * _472) + (32 * _571) + (32 * _667) + 224] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]
        mem[_466 + (32 * _472) + (32 * _571) + (32 * _667) + 256 len 32 * _736] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147 len 32 * _736]
        return memory
          from mem[64]
           len _466 + (32 * _472) + (32 * _571) + (32 * _667) + (32 * _736) + -mem[64] + 256
    if msg.sender == stor2:
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771] = 20
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443] = 20
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475 len 640] = call.data[calldata.size len 640]
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115] = 20
        mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2787
        mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147 len 640] = call.data[calldata.size len 640]
        idx = 0
        while idx < ('cd', 4).length:
            _563 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = 0
            while s < _563:
                _653 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                t = 0
                u = 0
                v = 0
                while t < _653:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _663 = mem[(32 * idx) + 128]
                    if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    _678 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
                    mem[mem[64] + 4] = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]
                    mem[mem[64] + 36] = address(_678)
                    require ext_code.size(address(_663))
                    staticcall address(_663).0xdd62ed3e with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], address(_678)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _691 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _697 = mem[_691]
                    if not mem[_691]:
                        if t == -1:
                            revert with 0, 17
                        _563 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        _653 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                        t = t + 1
                        u = u
                        v = mem[_691]
                        continue 
                    if idx >= mem[96]:
                        revert with 0, 50
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131] = mem[(32 * idx) + 140 len 20]
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                    if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                        revert with 0, 50
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475] = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]
                    if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]:
                        revert with 0, 50
                    mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147] = _697
                    if 1 > !u:
                        revert with 0, 17
                    if u + 1 <= 20:
                        if t == -1:
                            revert with 0, 17
                        _563 = mem[ceil32(32 * ('cd', 4).length) + 97]
                        _653 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                        t = t + 1
                        u = u + 1
                        v = _697
                        continue 
                    if s == -1:
                        revert with 0, 17
                    _563 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    _653 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                    s = s + 1
                    continue 
                if s == -1:
                    revert with 0, 17
                _563 = mem[ceil32(32 * ('cd', 4).length) + 97]
                s = s + 1
                continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        _468 = mem[64]
        mem[mem[64]] = 128
        _474 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
        mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
        t = mem[64] + 160
        while idx < _474:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _474) + 160
        _573 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]
        mem[mem[64] + (32 * _474) + 160] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803
        t = mem[64] + (32 * _474) + 192
        while idx < _573:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_468 + 64] = (32 * _474) + (32 * _573) + 192
        _670 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]
        mem[_468 + (32 * _474) + (32 * _573) + 192] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475
        t = _468 + (32 * _474) + (32 * _573) + 224
        while idx < _670:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_468 + 96] = (32 * _474) + (32 * _573) + (32 * _670) + 224
        _737 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]
        mem[_468 + (32 * _474) + (32 * _573) + (32 * _670) + 224] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]
        mem[_468 + (32 * _474) + (32 * _573) + (32 * _670) + 256 len 32 * _737] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147 len 32 * _737]
        return memory
          from mem[64]
           len _468 + (32 * _474) + (32 * _573) + (32 * _670) + (32 * _737) + -mem[64] + 256
    mem[0] = msg.sender
    mem[32] = 3
    if bool(stor3[msg.sender]) != 1:
        revert with 0, 'Not authorized'
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131 len 640] = call.data[calldata.size len 640]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771] = 20
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803 len 640] = call.data[calldata.size len 640]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443] = 20
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475 len 640] = call.data[calldata.size len 640]
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115] = 20
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2787
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147 len 640] = call.data[calldata.size len 640]
    idx = 0
    while idx < ('cd', 4).length:
        _564 = mem[ceil32(32 * ('cd', 4).length) + 97]
        s = 0
        while s < _564:
            _654 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
            t = 0
            u = 0
            v = 0
            while t < _654:
                if idx >= mem[96]:
                    revert with 0, 50
                _665 = mem[(32 * idx) + 128]
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _680 = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129]
                mem[mem[64] + 4] = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]
                mem[mem[64] + 36] = address(_680)
                require ext_code.size(address(_665))
                staticcall address(_665).0xdd62ed3e with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], address(_680)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _693 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _699 = mem[_693]
                if not mem[_693]:
                    if t == -1:
                        revert with 0, 17
                    _564 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    _654 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                    t = t + 1
                    u = u
                    v = mem[_693]
                    continue 
                if idx >= mem[96]:
                    revert with 0, 50
                if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                    revert with 0, 50
                mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131] = mem[(32 * idx) + 140 len 20]
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]:
                    revert with 0, 50
                mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803] = mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 141 len 20]
                if t >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]:
                    revert with 0, 50
                mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475] = mem[(32 * t) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]
                if u >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]:
                    revert with 0, 50
                mem[(32 * u) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147] = _699
                if 1 > !u:
                    revert with 0, 17
                if u + 1 <= 20:
                    if t == -1:
                        revert with 0, 17
                    _564 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    _654 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                    t = t + 1
                    u = u + 1
                    v = _699
                    continue 
                if s == -1:
                    revert with 0, 17
                _564 = mem[ceil32(32 * ('cd', 4).length) + 97]
                _654 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]
                s = s + 1
                continue 
            if s == -1:
                revert with 0, 17
            _564 = mem[ceil32(32 * ('cd', 4).length) + 97]
            s = s + 1
            continue 
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    _470 = mem[64]
    mem[mem[64]] = 128
    _476 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
    mem[mem[64] + 128] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
    t = mem[64] + 160
    while idx < _476:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[_470 + 32] = (32 * _476) + 160
    _575 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]
    mem[_470 + (32 * _476) + 160] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 771]
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 803
    t = _470 + (32 * _476) + 192
    while idx < _575:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[_470 + 64] = (32 * _476) + (32 * _575) + 192
    _673 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]
    mem[_470 + (32 * _476) + (32 * _575) + 192] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1443]
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 1475
    t = _470 + (32 * _476) + (32 * _575) + 224
    while idx < _673:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[_470 + 96] = (32 * _476) + (32 * _575) + (32 * _673) + 224
    _738 = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]
    mem[_470 + (32 * _476) + (32 * _575) + (32 * _673) + 224] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2115]
    mem[_470 + (32 * _476) + (32 * _575) + (32 * _673) + 256 len 32 * _738] = mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 2147 len 32 * _738]
    return memory
      from mem[64]
       len _470 + (32 * _476) + (32 * _575) + (32 * _673) + (32 * _738) + -mem[64] + 256
}

function sub_b0cb255e(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if msg.sender == stor0:
        require ext_code.size(address(arg2))
        staticcall address(arg2).getReserves() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 96
        require ext_call.return_data[0] == ext_call.return_data[18 len 14]
        require ext_call.return_data[32] == ext_call.return_data[50 len 14]
        require ext_call.return_data[64] == ext_call.return_data[92 len 4]
        require ext_code.size(address(arg2))
        staticcall address(arg2).token0() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(address(arg2))
        staticcall address(arg2).token1() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) != address(arg1):
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'Check pair address'
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < arg3:
            revert with 0, 'Refill _tokenIn amountIn'
        if arg3 <= 0:
            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
        if address(ext_call.return_data[0]) != address(arg1):
            if Mask(112, 0, ext_call.return_data[32]) <= 0:
                revert with 0, 'INSUFFICIENT_LIQUIDITY'
            if Mask(112, 0, ext_call.return_data[0]) <= 0:
                revert with 0, 'INSUFFICIENT_LIQUIDITY'
            if arg3 and 998 > -1 / arg3:
                revert with 0, 17
            if 998 * arg3 / 998 != arg3:
                revert with 0, 'MUL error'
            if not Mask(112, 0, ext_call.return_data[0]):
                if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 17
                if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 'MUL error'
                if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                    revert with 0, 17
                if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 'Add error'
                if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                    revert with 0, 18
                if 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                    revert with 0, 17
                if (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                    revert with 0, 'SUB error'
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).0xa9059cbb with:
                     gas gas_remaining wei
                    args address(arg2), arg3
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(address(arg2))
                call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                return ((0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
            if 998 * arg3 and Mask(112, 0, ext_call.return_data[0]) > -1 / 998 * arg3:
                revert with 0, 17
            if not Mask(112, 0, ext_call.return_data[0]):
                revert with 0, 18
            if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 998 * arg3:
                revert with 0, 'MUL error'
            if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                revert with 0, 17
            if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                revert with 0, 'MUL error'
            if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                revert with 0, 17
            if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                revert with 0, 'Add error'
            if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                revert with 0, 18
            if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                revert with 0, 17
            if (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                revert with 0, 'SUB error'
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).0xa9059cbb with:
                 gas gas_remaining wei
                args address(arg2), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(address(arg2))
            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return ((998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
        if Mask(112, 0, ext_call.return_data[0]) <= 0:
            revert with 0, 'INSUFFICIENT_LIQUIDITY'
        if Mask(112, 0, ext_call.return_data[32]) <= 0:
            revert with 0, 'INSUFFICIENT_LIQUIDITY'
        if arg3 and 998 > -1 / arg3:
            revert with 0, 17
        if 998 * arg3 / 998 != arg3:
            revert with 0, 'MUL error'
        if not Mask(112, 0, ext_call.return_data[32]):
            if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
                revert with 0, 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
                revert with 0, 'MUL error'
            if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
                revert with 0, 17
            if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 0, 'Add error'
            if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                revert with 0, 18
            if 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
                revert with 0, 17
            if (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                revert with 0, 'SUB error'
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).0xa9059cbb with:
                 gas gas_remaining wei
                args address(arg2), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(address(arg2))
            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0, None
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            return ((0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4)
        if 998 * arg3 and Mask(112, 0, ext_call.return_data[32]) > -1 / 998 * arg3:
            revert with 0, 17
        if not Mask(112, 0, ext_call.return_data[32]):
            revert with 0, 18
        if 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 998 * arg3:
            revert with 0, 'MUL error'
        if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
            revert with 0, 17
        if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
            revert with 0, 'MUL error'
        if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
            revert with 0, 17
        if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
            revert with 0, 'Add error'
        if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
            revert with 0, 18
        if 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
            revert with 0, 17
        if (998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
            revert with 0, 'SUB error'
        require ext_code.size(address(ext_call.return_data[0]))
        call address(ext_call.return_data[0]).0xa9059cbb with:
             gas gas_remaining wei
            args address(arg2), arg3
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        require ext_code.size(address(arg2))
        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
             gas gas_remaining wei
            args 0, (998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0
    else:
        if msg.sender == stor1:
            require ext_code.size(address(arg2))
            staticcall address(arg2).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg2))
            staticcall address(arg2).token0() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(address(arg2))
            staticcall address(arg2).token1() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(ext_call.return_data[0]) == address(arg1):
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < arg3:
                    revert with 0, 'Refill _tokenIn amountIn'
                if arg3 <= 0:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                if address(ext_call.return_data[0]) != address(arg1):
                    if Mask(112, 0, ext_call.return_data[32]) <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if Mask(112, 0, ext_call.return_data[0]) <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if arg3 and 998 > -1 / arg3:
                        revert with 0, 17
                    if 998 * arg3 / 998 != arg3:
                        revert with 0, 'MUL error'
                    if not Mask(112, 0, ext_call.return_data[0]):
                        if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'MUL error'
                        if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                            revert with 0, 17
                        if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'Add error'
                        if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                            revert with 0, 18
                        if 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                            revert with 0, 17
                        if (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                            revert with 0, 'SUB error'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), arg3
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0, None
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        return ((0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
                    if 998 * arg3 and Mask(112, 0, ext_call.return_data[0]) > -1 / 998 * arg3:
                        revert with 0, 17
                    if not Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 18
                    if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 998 * arg3:
                        revert with 0, 'MUL error'
                    if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 'MUL error'
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                        revert with 0, 17
                    if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 'Add error'
                    if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                        revert with 0, 18
                    if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                        revert with 0, 17
                    if (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                        revert with 0, 'SUB error'
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), arg3
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return ((998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                if arg3 and 998 > -1 / arg3:
                    revert with 0, 17
                if 998 * arg3 / 998 != arg3:
                    revert with 0, 'MUL error'
                if not Mask(112, 0, ext_call.return_data[32]):
                    if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 'MUL error'
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
                        revert with 0, 17
                    if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 'Add error'
                    if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                        revert with 0, 18
                    if 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
                        revert with 0, 17
                    if (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                        revert with 0, 'SUB error'
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), arg3
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return ((0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4)
                if 998 * arg3 and Mask(112, 0, ext_call.return_data[32]) > -1 / 998 * arg3:
                    revert with 0, 17
                if not Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 18
                if 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 998 * arg3:
                    revert with 0, 'MUL error'
                if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
                    revert with 0, 17
                if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
                    revert with 0, 'MUL error'
                if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
                    revert with 0, 17
                if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                    revert with 0, 'Add error'
                if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                    revert with 0, 18
                if 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
                    revert with 0, 17
                if (998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                    revert with 0, 'SUB error'
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).0xa9059cbb with:
                     gas gas_remaining wei
                    args address(arg2), arg3
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(address(arg2))
                call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0
            else:
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'Check pair address'
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < arg3:
                    revert with 0, 'Refill _tokenIn amountIn'
                if arg3 <= 0:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                if address(ext_call.return_data[0]) != address(arg1):
                    if Mask(112, 0, ext_call.return_data[32]) <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if Mask(112, 0, ext_call.return_data[0]) <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if arg3 and 998 > -1 / arg3:
                        revert with 0, 17
                    if 998 * arg3 / 998 != arg3:
                        revert with 0, 'MUL error'
                    if not Mask(112, 0, ext_call.return_data[0]):
                        if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'MUL error'
                        if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                            revert with 0, 17
                        if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'Add error'
                        if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                            revert with 0, 18
                        if 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                            revert with 0, 17
                        if (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                            revert with 0, 'SUB error'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), arg3
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        return ((0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
                    if 998 * arg3 and Mask(112, 0, ext_call.return_data[0]) > -1 / 998 * arg3:
                        revert with 0, 17
                    if not Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 18
                    if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 998 * arg3:
                        revert with 0, 'MUL error'
                    if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 'MUL error'
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                        revert with 0, 17
                    if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 'Add error'
                    if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                        revert with 0, 18
                    if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                        revert with 0, 17
                    if (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                        revert with 0, 'SUB error'
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), arg3
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0, None
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return ((998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                if arg3 and 998 > -1 / arg3:
                    revert with 0, 17
                if 998 * arg3 / 998 != arg3:
                    revert with 0, 'MUL error'
                if not Mask(112, 0, ext_call.return_data[32]):
                    if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 'MUL error'
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
                        revert with 0, 17
                    if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 'Add error'
                    if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                        revert with 0, 18
                    if 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
                        revert with 0, 17
                    if (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                        revert with 0, 'SUB error'
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), arg3
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0, None
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return ((0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4)
                if 998 * arg3 and Mask(112, 0, ext_call.return_data[32]) > -1 / 998 * arg3:
                    revert with 0, 17
                if not Mask(112, 0, ext_call.return_data[32]):
                    revert with 0, 18
                if 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 998 * arg3:
                    revert with 0, 'MUL error'
                if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
                    revert with 0, 17
                if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
                    revert with 0, 'MUL error'
                if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
                    revert with 0, 17
                if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                    revert with 0, 'Add error'
                if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                    revert with 0, 18
                if 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
                    revert with 0, 17
                if (998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                    revert with 0, 'SUB error'
                require ext_code.size(address(ext_call.return_data[0]))
                call address(ext_call.return_data[0]).0xa9059cbb with:
                     gas gas_remaining wei
                    args address(arg2), arg3
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                require ext_code.size(address(arg2))
                call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                     gas gas_remaining wei
                    args 0, (998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0, None
        else:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
            require ext_code.size(address(arg2))
            staticcall address(arg2).getReserves() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 96
            require ext_call.return_data[0] == ext_call.return_data[18 len 14]
            require ext_call.return_data[32] == ext_call.return_data[50 len 14]
            require ext_call.return_data[64] == ext_call.return_data[92 len 4]
            require ext_code.size(address(arg2))
            staticcall address(arg2).token0() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(address(arg2))
            staticcall address(arg2).token1() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(ext_call.return_data[0]) == address(arg1):
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < arg3:
                    revert with 0, 'Refill _tokenIn amountIn'
                if arg3 <= 0:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                if address(ext_call.return_data[0]) != address(arg1):
                    if Mask(112, 0, ext_call.return_data[32]) <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if Mask(112, 0, ext_call.return_data[0]) <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if arg3 and 998 > -1 / arg3:
                        revert with 0, 17
                    if 998 * arg3 / 998 != arg3:
                        revert with 0, 'MUL error'
                    if not Mask(112, 0, ext_call.return_data[0]):
                        if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'MUL error'
                        if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                            revert with 0, 17
                        if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'Add error'
                        if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                            revert with 0, 18
                        if 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                            revert with 0, 17
                        if (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                            revert with 0, 'SUB error'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), arg3
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0, None
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        return ((0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
                    if 998 * arg3 and Mask(112, 0, ext_call.return_data[0]) > -1 / 998 * arg3:
                        revert with 0, 17
                    if not Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 18
                    if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 998 * arg3:
                        revert with 0, 'MUL error'
                    if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 'MUL error'
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                        revert with 0, 17
                    if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 'Add error'
                    if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                        revert with 0, 18
                    if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                        revert with 0, 17
                    if (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                        revert with 0, 'SUB error'
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), arg3
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0, None
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return ((998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                if arg3 and 998 > -1 / arg3:
                    revert with 0, 17
                if 998 * arg3 / 998 != arg3:
                    revert with 0, 'MUL error'
                if not Mask(112, 0, ext_call.return_data[32]):
                    if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 'MUL error'
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
                        revert with 0, 17
                    if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 'Add error'
                    if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                        revert with 0, 18
                    if 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
                        revert with 0, 17
                    if (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                        revert with 0, 'SUB error'
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), arg3
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return ((0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4)
            else:
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'Check pair address'
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < arg3:
                    revert with 0, 'Refill _tokenIn amountIn'
                if arg3 <= 0:
                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                if address(ext_call.return_data[0]) != address(arg1):
                    if Mask(112, 0, ext_call.return_data[32]) <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if Mask(112, 0, ext_call.return_data[0]) <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if arg3 and 998 > -1 / arg3:
                        revert with 0, 17
                    if 998 * arg3 / 998 != arg3:
                        revert with 0, 'MUL error'
                    if not Mask(112, 0, ext_call.return_data[0]):
                        if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 17
                        if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'MUL error'
                        if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                            revert with 0, 17
                        if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                            revert with 0, 'Add error'
                        if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                            revert with 0, 18
                        if 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                            revert with 0, 17
                        if (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                            revert with 0, 'SUB error'
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), arg3
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        return ((0 / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
                    if 998 * arg3 and Mask(112, 0, ext_call.return_data[0]) > -1 / 998 * arg3:
                        revert with 0, 17
                    if not Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 18
                    if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / Mask(112, 0, ext_call.return_data[0]) != 998 * arg3:
                        revert with 0, 'MUL error'
                    if Mask(112, 0, ext_call.return_data[32]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 17
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) / 1000 != Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 'MUL error'
                    if 1000 * Mask(112, 0, ext_call.return_data[32]) > !(998 * arg3):
                        revert with 0, 17
                    if (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[32]):
                        revert with 0, 'Add error'
                    if not (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                        revert with 0, 18
                    if 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3) < arg4:
                        revert with 0, 17
                    if (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3):
                        revert with 0, 'SUB error'
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), arg3
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args (998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4, 0, address(this.address), 128, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return ((998 * arg3 * Mask(112, 0, ext_call.return_data[0]) / (1000 * Mask(112, 0, ext_call.return_data[32])) + (998 * arg3)) - arg4)
                if Mask(112, 0, ext_call.return_data[0]) <= 0:
                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                if Mask(112, 0, ext_call.return_data[32]) <= 0:
                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                if arg3 and 998 > -1 / arg3:
                    revert with 0, 17
                if 998 * arg3 / 998 != arg3:
                    revert with 0, 'MUL error'
                if not Mask(112, 0, ext_call.return_data[32]):
                    if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 17
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 'MUL error'
                    if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
                        revert with 0, 17
                    if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                        revert with 0, 'Add error'
                    if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                        revert with 0, 18
                    if 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
                        revert with 0, 17
                    if (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                        revert with 0, 'SUB error'
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), arg3
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, (0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0, None
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    return ((0 / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4)
            ('bool', ('mask_shl', 112, 0, 0, ('ext_call.return_data', 32, 32)))
            if 998 * arg3 and Mask(112, 0, ext_call.return_data[32]) > -1 / 998 * arg3:
                revert with 0, 17
            if not Mask(112, 0, ext_call.return_data[32]):
                revert with 0, 18
            if 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / Mask(112, 0, ext_call.return_data[32]) != 998 * arg3:
                revert with 0, 'MUL error'
            if Mask(112, 0, ext_call.return_data[0]) and 1000 > -1 / Mask(112, 0, ext_call.return_data[0]):
                revert with 0, 17
            if 1000 * Mask(112, 0, ext_call.return_data[0]) / 1000 != Mask(112, 0, ext_call.return_data[0]):
                revert with 0, 'MUL error'
            if 1000 * Mask(112, 0, ext_call.return_data[0]) > !(998 * arg3):
                revert with 0, 17
            if (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < 1000 * Mask(112, 0, ext_call.return_data[0]):
                revert with 0, 'Add error'
            if not (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                revert with 0, 18
            if 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3) < arg4:
                revert with 0, 17
            if (998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4 > 998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3):
                revert with 0, 'SUB error'
            require ext_code.size(address(ext_call.return_data[0]))
            call address(ext_call.return_data[0]).0xa9059cbb with:
                 gas gas_remaining wei
                args address(arg2), arg3
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            require ext_code.size(address(arg2))
            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                 gas gas_remaining wei
                args 0, (998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4, address(this.address), 128, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    return ((998 * arg3 * Mask(112, 0, ext_call.return_data[32]) / (1000 * Mask(112, 0, ext_call.return_data[0])) + (998 * arg3)) - arg4)
}

function sub_fd9220d9(?) {
    require calldata.size - 4 >= 224
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg7 == address(arg7)
    if msg.sender == stor0:
        if not address(arg3):
            revert with 0, 'Set router'
        mem[100] = this.address
        require ext_code.size(address(arg2))
        staticcall address(arg2).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[ceil32(return_data.size) + 100] = this.address
        require ext_code.size(address(arg1))
        staticcall address(arg1).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < arg5:
            revert with 0, 'Refill amountIn'
        mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
        mem[(2 * ceil32(return_data.size)) + 132] = arg5
        require ext_code.size(address(arg1))
        call address(arg1).approve(address arg1, uint256 arg2) with:
             gas gas_remaining wei
            args address(arg3), arg5
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if not address(arg4):
            mem[(4 * ceil32(return_data.size)) + 96] = 2
            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
            mem[(4 * ceil32(return_data.size)) + 196] = arg5
            mem[(4 * ceil32(return_data.size)) + 228] = arg6
            mem[(4 * ceil32(return_data.size)) + 260] = 160
            mem[(4 * ceil32(return_data.size)) + 356] = 2
            idx = 0
            s = (4 * ceil32(return_data.size)) + 128
            t = (4 * ceil32(return_data.size)) + 388
            while idx < 2:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
            require ext_code.size(address(arg3))
            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                 gas gas_remaining wei
                args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = (6 * ceil32(return_data.size)) + 192
            require return_data.size >= 32
            _357 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
            _369 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                revert with 0, 65
            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                revert with 0, 65
            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
            mem[(6 * ceil32(return_data.size)) + 192] = _369
            require _357 + (32 * _369) + 32 <= return_data.size
            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _369] = mem[(4 * ceil32(return_data.size)) + _357 + 224 len 32 * _369]
            mem[mem[64] + 4] = address(arg3)
            mem[mem[64] + 36] = 0
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), 0
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _561 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_561] == bool(mem[_561])
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(arg2))
            staticcall address(arg2).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _609 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_609] < ext_call.return_data[0]:
                revert with 0, 17
            mem[mem[64]] = mem[_609] - ext_call.return_data[0]
        else:
            if address(arg1) == address(arg4):
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg5
                mem[(4 * ceil32(return_data.size)) + 228] = arg6
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                require ext_code.size(address(arg3))
                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _354 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
                _366 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _366
                require _354 + (32 * _366) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _366] = mem[(4 * ceil32(return_data.size)) + _354 + 224 len 32 * _366]
                mem[mem[64] + 4] = address(arg3)
                mem[mem[64] + 36] = 0
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg3), 0
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _558 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_558] == bool(mem[_558])
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _606 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_606] < ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = mem[_606] - ext_call.return_data[0]
            else:
                if address(arg2) == address(arg4):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = arg5
                    mem[(4 * ceil32(return_data.size)) + 228] = arg6
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _356 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
                    _368 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _368
                    require _356 + (32 * _368) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _368] = mem[(4 * ceil32(return_data.size)) + _356 + 224 len 32 * _368]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _560 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_560] == bool(mem[_560])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _608 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_608] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_608] - ext_call.return_data[0]
                else:
                    mem[(4 * ceil32(return_data.size)) + 96] = 3
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                    mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 228] = arg5
                    mem[(4 * ceil32(return_data.size)) + 260] = arg6
                    mem[(4 * ceil32(return_data.size)) + 292] = 160
                    mem[(4 * ceil32(return_data.size)) + 388] = 3
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 420
                    while idx < 3:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 224
                    require return_data.size >= 32
                    _355 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 255
                    _367 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 225 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 225
                    mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]
                    require _355 + (32 * _367) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 256 len 32 * _367] = mem[(4 * ceil32(return_data.size)) + _355 + 256 len 32 * _367]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _559 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_559] == bool(mem[_559])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _607 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_607] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_607] - ext_call.return_data[0]
    else:
        if msg.sender == stor1:
            if not address(arg3):
                revert with 0, 'Set router'
            mem[100] = this.address
            require ext_code.size(address(arg2))
            staticcall address(arg2).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] < arg5:
                revert with 0, 'Refill amountIn'
            mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(2 * ceil32(return_data.size)) + 132] = arg5
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), arg5
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not address(arg4):
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg5
                mem[(4 * ceil32(return_data.size)) + 228] = arg6
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                require ext_code.size(address(arg3))
                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _361 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
                _373 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _373
                require _361 + (32 * _373) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _373] = mem[(4 * ceil32(return_data.size)) + _361 + 224 len 32 * _373]
                mem[mem[64] + 4] = address(arg3)
                mem[mem[64] + 36] = 0
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg3), 0
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _565 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_565] == bool(mem[_565])
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _613 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_613] < ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = mem[_613] - ext_call.return_data[0]
            else:
                if address(arg1) == address(arg4):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = arg5
                    mem[(4 * ceil32(return_data.size)) + 228] = arg6
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _358 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
                    _370 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _370
                    require _358 + (32 * _370) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _370] = mem[(4 * ceil32(return_data.size)) + _358 + 224 len 32 * _370]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _562 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_562] == bool(mem[_562])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _610 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_610] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_610] - ext_call.return_data[0]
                else:
                    if address(arg2) == address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _360 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
                        _372 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _372
                        require _360 + (32 * _372) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _372] = mem[(4 * ceil32(return_data.size)) + _360 + 224 len 32 * _372]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _564 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_564] == bool(mem[_564])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _612 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_612] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_612] - ext_call.return_data[0]
                    else:
                        mem[(4 * ceil32(return_data.size)) + 96] = 3
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                        mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 228] = arg5
                        mem[(4 * ceil32(return_data.size)) + 260] = arg6
                        mem[(4 * ceil32(return_data.size)) + 292] = 160
                        mem[(4 * ceil32(return_data.size)) + 388] = 3
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 420
                        while idx < 3:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _359 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 255
                        _371 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 225 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 225
                        mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]
                        require _359 + (32 * _371) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 256 len 32 * _371] = mem[(4 * ceil32(return_data.size)) + _359 + 256 len 32 * _371]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _563 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_563] == bool(mem[_563])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _611 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_611] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_611] - ext_call.return_data[0]
        else:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
            if not address(arg3):
                revert with 0, 'Set router'
            mem[100] = this.address
            require ext_code.size(address(arg2))
            staticcall address(arg2).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] < arg5:
                revert with 0, 'Refill amountIn'
            mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(2 * ceil32(return_data.size)) + 132] = arg5
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), arg5
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not address(arg4):
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = arg5
                mem[(4 * ceil32(return_data.size)) + 228] = arg6
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                require ext_code.size(address(arg3))
                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _365 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
                _377 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _377
                require _365 + (32 * _377) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _377] = mem[(4 * ceil32(return_data.size)) + _365 + 224 len 32 * _377]
                mem[mem[64] + 4] = address(arg3)
                mem[mem[64] + 36] = 0
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg3), 0
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _569 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_569] == bool(mem[_569])
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _617 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_617] < ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = mem[_617] - ext_call.return_data[0]
            else:
                if address(arg1) == address(arg4):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = arg5
                    mem[(4 * ceil32(return_data.size)) + 228] = arg6
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _362 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
                    _374 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _374
                    require _362 + (32 * _374) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _374] = mem[(4 * ceil32(return_data.size)) + _362 + 224 len 32 * _374]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _566 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_566] == bool(mem[_566])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _614 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_614] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_614] - ext_call.return_data[0]
                else:
                    if address(arg2) == address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _364 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 223
                        _376 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _376
                        require _364 + (32 * _376) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _376] = mem[(4 * ceil32(return_data.size)) + _364 + 224 len 32 * _376]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _568 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_568] == bool(mem[_568])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _616 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_616] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_616] - ext_call.return_data[0]
                    else:
                        mem[(4 * ceil32(return_data.size)) + 96] = 3
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                        mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 228] = arg5
                        mem[(4 * ceil32(return_data.size)) + 260] = arg6
                        mem[(4 * ceil32(return_data.size)) + 292] = 160
                        mem[(4 * ceil32(return_data.size)) + 388] = 3
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 420
                        while idx < 3:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _363 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 255
                        _375 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 225 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]) + 225
                        mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, arg5) >> 32 + 224]
                        require _363 + (32 * _375) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 256 len 32 * _375] = mem[(4 * ceil32(return_data.size)) + _363 + 256 len 32 * _375]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _567 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_567] == bool(mem[_567])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _615 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_615] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_615] - ext_call.return_data[0]
    return memory
      from mem[64]
       len 32
}

function sub_32fd5fd6(?) {
    require calldata.size - 4 >= 256
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    if ('cd', 100).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 100).length) + 100 < 99 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = ('cd', 100).length
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 0
    s = cd[100] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
    while idx < ('cd', 100).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[132] <= test266151307()
    require cd[132] + 35 < calldata.size
    if ('cd', 132).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 132).length) + 101 < 100 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 101 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 101
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100] = ('cd', 132).length
    require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
    idx = 0
    s = cd[132] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 132
    while idx < ('cd', 132).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[228] == address(cd[228])
    if msg.sender == stor0:
        if ('cd', 4).length != ('cd', 36).length:
            revert with 0, 'Check length1'
        if ('cd', 4).length != ('cd', 68).length:
            revert with 0, 'Check length2'
        if ('cd', 4).length != ('cd', 132).length:
            revert with 0, 'Check length3'
        idx = 0
        s = 0
        s = 0
        t = 0
        t = 0
        t = 0
        while idx < ('cd', 68).length:
            if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                revert with 0, 50
            _1840 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                revert with 0, 50
            _1847 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131]
            if idx >= mem[96]:
                revert with 0, 50
            _1855 = mem[(32 * idx) + 128]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _1862 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100]:
                revert with 0, 50
            _1870 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 132]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_1855))
            staticcall address(_1855).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1883 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_1883] >= _1870:
                if not address(_1847):
                    _1897 = mem[64]
                    mem[mem[64]] = 2
                    mem[64] = mem[64] + 96
                    if 0 >= mem[_1897]:
                        revert with 0, 50
                    mem[_1897 + 32] = address(_1855)
                    if 1 >= mem[_1897]:
                        revert with 0, 50
                    mem[_1897 + 64] = address(_1862)
                    mem[_1897 + 100] = address(_1840)
                    mem[_1897 + 132] = _1870
                    require ext_code.size(address(_1855))
                    call address(_1855).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(_1840), _1870
                    mem[_1897 + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1897 + ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    mem[_1897 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[_1897 + ceil32(return_data.size) + 100] = _1870
                    mem[_1897 + ceil32(return_data.size) + 132] = cd[164]
                    mem[_1897 + ceil32(return_data.size) + 164] = 160
                    mem[_1897 + ceil32(return_data.size) + 260] = mem[_1897]
                    s = 0
                    t = _1897 + 32
                    u = _1897 + ceil32(return_data.size) + 292
                    while s < mem[_1897]:
                        mem[u] = mem[t + 12 len 20]
                        s = s + 1
                        t = t + 32
                        u = u + 32
                        continue 
                    mem[_1897 + ceil32(return_data.size) + 196] = address(cd[228])
                    mem[_1897 + ceil32(return_data.size) + 228] = block.timestamp
                    require ext_code.size(address(_1840))
                    call address(_1840).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args _1870, cd[164], 160, address(cd[228]), block.timestamp, mem[_1897 + ceil32(return_data.size) + 260 len (32 * mem[_1897]) + 32]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1897 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = _1897 + (2 * ceil32(return_data.size)) + 96
                    require return_data.size >= 32
                    _2131 = mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32
                    require mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 <= test266151307()
                    require _1897 + ceil32(return_data.size) + return_data.size + 96 > _1897 + ceil32(return_data.size) + mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 127
                    _2143 = mem[_1897 + ceil32(return_data.size) + mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]
                    if mem[_1897 + ceil32(return_data.size) + mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[_1897 + ceil32(return_data.size) + mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 1 < 0 or _1897 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1897 + ceil32(return_data.size) + mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = _1897 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1897 + ceil32(return_data.size) + mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 97
                    mem[_1897 + (2 * ceil32(return_data.size)) + 96] = mem[_1897 + ceil32(return_data.size) + mem[_1897 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]
                    require _2131 + (32 * _2143) + 32 <= return_data.size
                    t = _1897 + ceil32(return_data.size) + _2131 + 128
                    u = _1897 + (2 * ceil32(return_data.size)) + 128
                    s = 0
                    while s < _2143:
                        mem[u] = mem[t]
                        t = t + 32
                        u = u + 32
                        s = s + 1
                        continue 
                else:
                    if address(_1855) == address(_1847):
                        _1900 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1900]:
                            revert with 0, 50
                        mem[_1900 + 32] = address(_1855)
                        if 1 >= mem[_1900]:
                            revert with 0, 50
                        mem[_1900 + 64] = address(_1862)
                        mem[_1900 + 100] = address(_1840)
                        mem[_1900 + 132] = _1870
                        require ext_code.size(address(_1855))
                        call address(_1855).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(_1840), _1870
                        mem[_1900 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _1900 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[_1900 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1900 + ceil32(return_data.size) + 100] = _1870
                        mem[_1900 + ceil32(return_data.size) + 132] = cd[164]
                        mem[_1900 + ceil32(return_data.size) + 164] = 160
                        mem[_1900 + ceil32(return_data.size) + 260] = mem[_1900]
                        s = 0
                        t = _1900 + 32
                        u = _1900 + ceil32(return_data.size) + 292
                        while s < mem[_1900]:
                            mem[u] = mem[t + 12 len 20]
                            s = s + 1
                            t = t + 32
                            u = u + 32
                            continue 
                        mem[_1900 + ceil32(return_data.size) + 196] = address(cd[228])
                        mem[_1900 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(address(_1840))
                        call address(_1840).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args _1870, cd[164], 160, address(cd[228]), block.timestamp, mem[_1900 + ceil32(return_data.size) + 260 len (32 * mem[_1900]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1900 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1900 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2128 = mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32
                        require mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 <= test266151307()
                        require _1900 + ceil32(return_data.size) + return_data.size + 96 > _1900 + ceil32(return_data.size) + mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 127
                        _2140 = mem[_1900 + ceil32(return_data.size) + mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]
                        if mem[_1900 + ceil32(return_data.size) + mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_1900 + ceil32(return_data.size) + mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 1 < 0 or _1900 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1900 + ceil32(return_data.size) + mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 97 > test266151307():
                            revert with 0, 65
                        mem[64] = _1900 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1900 + ceil32(return_data.size) + mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 97
                        mem[_1900 + (2 * ceil32(return_data.size)) + 96] = mem[_1900 + ceil32(return_data.size) + mem[_1900 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]
                        require _2128 + (32 * _2140) + 32 <= return_data.size
                        t = _1900 + ceil32(return_data.size) + _2128 + 128
                        u = _1900 + (2 * ceil32(return_data.size)) + 128
                        s = 0
                        while s < _2140:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s + 1
                            continue 
                    else:
                        if address(_1862) == address(_1847):
                            _1913 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_1913]:
                                revert with 0, 50
                            mem[_1913 + 32] = address(_1855)
                            if 1 >= mem[_1913]:
                                revert with 0, 50
                            mem[_1913 + 64] = address(_1862)
                            mem[_1913 + 100] = address(_1840)
                            mem[_1913 + 132] = _1870
                            require ext_code.size(address(_1855))
                            call address(_1855).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_1840), _1870
                            mem[_1913 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _1913 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[_1913 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_1913 + ceil32(return_data.size) + 100] = _1870
                            mem[_1913 + ceil32(return_data.size) + 132] = cd[164]
                            mem[_1913 + ceil32(return_data.size) + 164] = 160
                            mem[_1913 + ceil32(return_data.size) + 260] = mem[_1913]
                            s = 0
                            t = _1913 + 32
                            u = _1913 + ceil32(return_data.size) + 292
                            while s < mem[_1913]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_1913 + ceil32(return_data.size) + 196] = address(cd[228])
                            mem[_1913 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(address(_1840))
                            call address(_1840).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args _1870, cd[164], 160, address(cd[228]), block.timestamp, mem[_1913 + ceil32(return_data.size) + 260 len (32 * mem[_1913]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1913 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1913 + (2 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            _2130 = mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32
                            require mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 <= test266151307()
                            require _1913 + ceil32(return_data.size) + return_data.size + 96 > _1913 + ceil32(return_data.size) + mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 127
                            _2142 = mem[_1913 + ceil32(return_data.size) + mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]
                            if mem[_1913 + ceil32(return_data.size) + mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_1913 + ceil32(return_data.size) + mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 1 < 0 or _1913 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1913 + ceil32(return_data.size) + mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 97 > test266151307():
                                revert with 0, 65
                            mem[64] = _1913 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1913 + ceil32(return_data.size) + mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]) + 97
                            mem[_1913 + (2 * ceil32(return_data.size)) + 96] = mem[_1913 + ceil32(return_data.size) + mem[_1913 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1870) >> 32 + 96]
                            require _2130 + (32 * _2142) + 32 <= return_data.size
                            t = _1913 + ceil32(return_data.size) + _2130 + 128
                            u = _1913 + (2 * ceil32(return_data.size)) + 128
                            s = 0
                            while s < _2142:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
                        else:
                            _1901 = mem[64]
                            mem[mem[64]] = 3
                            mem[64] = mem[64] + 128
                            if 0 >= mem[_1901]:
                                revert with 0, 50
                            mem[_1901 + 32] = address(_1855)
                            if 1 >= mem[_1901]:
                                revert with 0, 50
                            mem[_1901 + 64] = address(_1847)
                            if 2 >= mem[_1901]:
                                revert with 0, 50
                            mem[_1901 + 96] = address(_1862)
                            mem[_1901 + 132] = address(_1840)
                            mem[_1901 + 164] = _1870
                            require ext_code.size(address(_1855))
                            call address(_1855).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_1840), _1870
                            mem[_1901 + 128] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _1901 + ceil32(return_data.size) + 128
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[_1901 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_1901 + ceil32(return_data.size) + 132] = _1870
                            mem[_1901 + ceil32(return_data.size) + 164] = cd[164]
                            mem[_1901 + ceil32(return_data.size) + 196] = 160
                            mem[_1901 + ceil32(return_data.size) + 292] = mem[_1901]
                            s = 0
                            t = _1901 + 32
                            u = _1901 + ceil32(return_data.size) + 324
                            while s < mem[_1901]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_1901 + ceil32(return_data.size) + 228] = address(cd[228])
                            mem[_1901 + ceil32(return_data.size) + 260] = block.timestamp
                            require ext_code.size(address(_1840))
                            call address(_1840).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args _1870, cd[164], 160, address(cd[228]), block.timestamp, mem[_1901 + ceil32(return_data.size) + 292 len (32 * mem[_1901]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1901 + ceil32(return_data.size) + 128 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1901 + (2 * ceil32(return_data.size)) + 128
                            require return_data.size >= 32
                            _2129 = mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32
                            require mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32 <= test266151307()
                            require _1901 + ceil32(return_data.size) + return_data.size + 128 > _1901 + ceil32(return_data.size) + mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32 + 159
                            _2141 = mem[_1901 + ceil32(return_data.size) + mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32 + 128]
                            if mem[_1901 + ceil32(return_data.size) + mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32 + 128] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_1901 + ceil32(return_data.size) + mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32 + 128]) + 1 < 0 or _1901 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1901 + ceil32(return_data.size) + mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32 + 128]) + 129 > test266151307():
                                revert with 0, 65
                            mem[64] = _1901 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1901 + ceil32(return_data.size) + mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32 + 128]) + 129
                            mem[_1901 + (2 * ceil32(return_data.size)) + 128] = mem[_1901 + ceil32(return_data.size) + mem[_1901 + ceil32(return_data.size) + 128 len 4], Mask(224, 32, _1870) >> 32 + 128]
                            require _2129 + (32 * _2141) + 32 <= return_data.size
                            t = _1901 + ceil32(return_data.size) + _2129 + 160
                            u = _1901 + (2 * ceil32(return_data.size)) + 160
                            s = 0
                            while s < _2141:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _1870
            s = _1862
            t = _1855
            t = _1847
            t = _1840
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(s))
        staticcall address(s).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1846 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_1846] <= cd[196]:
            revert with 0, 'Check result'
        mem[mem[64]] = mem[_1846]
    else:
        if msg.sender == stor1:
            if ('cd', 4).length != ('cd', 36).length:
                revert with 0, 'Check length1'
            if ('cd', 4).length != ('cd', 68).length:
                revert with 0, 'Check length2'
            if ('cd', 4).length != ('cd', 132).length:
                revert with 0, 'Check length3'
            idx = 0
            s = 0
            s = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 68).length:
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                _1842 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                    revert with 0, 50
                _1850 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131]
                if idx >= mem[96]:
                    revert with 0, 50
                _1857 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _1865 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100]:
                    revert with 0, 50
                _1873 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 132]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_1857))
                staticcall address(_1857).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1885 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1885] >= _1873:
                    if not address(_1850):
                        _1898 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1898]:
                            revert with 0, 50
                        mem[_1898 + 32] = address(_1857)
                        if 1 >= mem[_1898]:
                            revert with 0, 50
                        mem[_1898 + 64] = address(_1865)
                        mem[_1898 + 100] = address(_1842)
                        mem[_1898 + 132] = _1873
                        require ext_code.size(address(_1857))
                        call address(_1857).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(_1842), _1873
                        mem[_1898 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _1898 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[_1898 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1898 + ceil32(return_data.size) + 100] = _1873
                        mem[_1898 + ceil32(return_data.size) + 132] = cd[164]
                        mem[_1898 + ceil32(return_data.size) + 164] = 160
                        mem[_1898 + ceil32(return_data.size) + 260] = mem[_1898]
                        s = 0
                        t = _1898 + 32
                        u = _1898 + ceil32(return_data.size) + 292
                        while s < mem[_1898]:
                            mem[u] = mem[t + 12 len 20]
                            s = s + 1
                            t = t + 32
                            u = u + 32
                            continue 
                        mem[_1898 + ceil32(return_data.size) + 196] = address(cd[228])
                        mem[_1898 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(address(_1842))
                        call address(_1842).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _1898 + ceil32(return_data.size) + (32 * mem[_1898]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2123 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2135 = mem[_2123]
                        require mem[_2123] <= test266151307()
                        require _2123 + return_data.size > _2123 + mem[_2123] + 31
                        _2147 = mem[_2123 + mem[_2123]]
                        if mem[_2123 + mem[_2123]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_2123 + mem[_2123]]) + 1 < 0 or _2123 + ceil32(return_data.size) + ceil32(32 * mem[_2123 + mem[_2123]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _2123 + ceil32(return_data.size) + ceil32(32 * mem[_2123 + mem[_2123]]) + 1
                        mem[_2123 + ceil32(return_data.size)] = _2147
                        require _2135 + (32 * _2147) + 32 <= return_data.size
                        t = _2123 + _2135 + 32
                        u = _2123 + ceil32(return_data.size) + 32
                        s = 0
                        while s < _2147:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s + 1
                            continue 
                    else:
                        if address(_1857) == address(_1850):
                            _1904 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_1904]:
                                revert with 0, 50
                            mem[_1904 + 32] = address(_1857)
                            if 1 >= mem[_1904]:
                                revert with 0, 50
                            mem[_1904 + 64] = address(_1865)
                            mem[_1904 + 100] = address(_1842)
                            mem[_1904 + 132] = _1873
                            require ext_code.size(address(_1857))
                            call address(_1857).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_1842), _1873
                            mem[_1904 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _1904 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[_1904 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_1904 + ceil32(return_data.size) + 100] = _1873
                            mem[_1904 + ceil32(return_data.size) + 132] = cd[164]
                            mem[_1904 + ceil32(return_data.size) + 164] = 160
                            mem[_1904 + ceil32(return_data.size) + 260] = mem[_1904]
                            s = 0
                            t = _1904 + 32
                            u = _1904 + ceil32(return_data.size) + 292
                            while s < mem[_1904]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_1904 + ceil32(return_data.size) + 196] = address(cd[228])
                            mem[_1904 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(address(_1842))
                            call address(_1842).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args _1873, cd[164], 160, address(cd[228]), block.timestamp, mem[_1904 + ceil32(return_data.size) + 260 len (32 * mem[_1904]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1904 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1904 + (2 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            _2132 = mem[_1904 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32
                            require mem[_1904 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 <= test266151307()
                            require _1904 + ceil32(return_data.size) + return_data.size + 96 > _1904 + ceil32(return_data.size) + mem[_1904 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 127
                            _2144 = mem[_1904 + ceil32(return_data.size) + mem[_1904 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]
                            if mem[_1904 + ceil32(return_data.size) + mem[_1904 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_1904 + ceil32(return_data.size) + mem[_1904 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]) + 1 < 0 or _1904 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1904 + ceil32(return_data.size) + mem[_1904 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]) + 97 > test266151307():
                                revert with 0, 65
                            mem[64] = _1904 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1904 + ceil32(return_data.size) + mem[_1904 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]) + 97
                            mem[_1904 + (2 * ceil32(return_data.size)) + 96] = _2144
                            require _2132 + (32 * _2144) + 32 <= return_data.size
                            t = _1904 + ceil32(return_data.size) + _2132 + 128
                            u = _1904 + (2 * ceil32(return_data.size)) + 128
                            s = 0
                            while s < _2144:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
                        else:
                            if address(_1865) == address(_1850):
                                _1916 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_1916]:
                                    revert with 0, 50
                                mem[_1916 + 32] = address(_1857)
                                if 1 >= mem[_1916]:
                                    revert with 0, 50
                                mem[_1916 + 64] = address(_1865)
                                mem[_1916 + 100] = address(_1842)
                                mem[_1916 + 132] = _1873
                                require ext_code.size(address(_1857))
                                call address(_1857).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_1842), _1873
                                mem[_1916 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _1916 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[_1916 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_1916 + ceil32(return_data.size) + 100] = _1873
                                mem[_1916 + ceil32(return_data.size) + 132] = cd[164]
                                mem[_1916 + ceil32(return_data.size) + 164] = 160
                                mem[_1916 + ceil32(return_data.size) + 260] = mem[_1916]
                                s = 0
                                t = _1916 + 32
                                u = _1916 + ceil32(return_data.size) + 292
                                while s < mem[_1916]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_1916 + ceil32(return_data.size) + 196] = address(cd[228])
                                mem[_1916 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(address(_1842))
                                call address(_1842).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args _1873, cd[164], 160, address(cd[228]), block.timestamp, mem[_1916 + ceil32(return_data.size) + 260 len (32 * mem[_1916]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_1916 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = _1916 + (2 * ceil32(return_data.size)) + 96
                                require return_data.size >= 32
                                _2134 = mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32
                                require mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 <= test266151307()
                                require _1916 + ceil32(return_data.size) + return_data.size + 96 > _1916 + ceil32(return_data.size) + mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 127
                                _2146 = mem[_1916 + ceil32(return_data.size) + mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]
                                if mem[_1916 + ceil32(return_data.size) + mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_1916 + ceil32(return_data.size) + mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]) + 1 < 0 or _1916 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1916 + ceil32(return_data.size) + mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]) + 97 > test266151307():
                                    revert with 0, 65
                                mem[64] = _1916 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1916 + ceil32(return_data.size) + mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]) + 97
                                mem[_1916 + (2 * ceil32(return_data.size)) + 96] = mem[_1916 + ceil32(return_data.size) + mem[_1916 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1873) >> 32 + 96]
                                require _2134 + (32 * _2146) + 32 <= return_data.size
                                t = _1916 + ceil32(return_data.size) + _2134 + 128
                                u = _1916 + (2 * ceil32(return_data.size)) + 128
                                s = 0
                                while s < _2146:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                            else:
                                _1905 = mem[64]
                                mem[mem[64]] = 3
                                mem[64] = mem[64] + 128
                                if 0 >= mem[_1905]:
                                    revert with 0, 50
                                mem[_1905 + 32] = address(_1857)
                                if 1 >= mem[_1905]:
                                    revert with 0, 50
                                mem[_1905 + 64] = address(_1850)
                                if 2 >= mem[_1905]:
                                    revert with 0, 50
                                mem[_1905 + 96] = address(_1865)
                                mem[_1905 + 132] = address(_1842)
                                mem[_1905 + 164] = _1873
                                require ext_code.size(address(_1857))
                                call address(_1857).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_1842), _1873
                                mem[_1905 + 128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _1905 + ceil32(return_data.size) + 128
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[_1905 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_1905 + ceil32(return_data.size) + 132] = _1873
                                mem[_1905 + ceil32(return_data.size) + 164] = cd[164]
                                mem[_1905 + ceil32(return_data.size) + 196] = 160
                                mem[_1905 + ceil32(return_data.size) + 292] = mem[_1905]
                                s = 0
                                t = _1905 + 32
                                u = _1905 + ceil32(return_data.size) + 324
                                while s < mem[_1905]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_1905 + ceil32(return_data.size) + 228] = address(cd[228])
                                mem[_1905 + ceil32(return_data.size) + 260] = block.timestamp
                                require ext_code.size(address(_1842))
                                call address(_1842).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _1905 + ceil32(return_data.size) + (32 * mem[_1905]) + -mem[64] + 320]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2121 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2133 = mem[_2121]
                                require mem[_2121] <= test266151307()
                                require _2121 + return_data.size > _2121 + mem[_2121] + 31
                                _2145 = mem[_2121 + mem[_2121]]
                                if mem[_2121 + mem[_2121]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_2121 + mem[_2121]]) + 1 < 0 or _2121 + ceil32(return_data.size) + ceil32(32 * mem[_2121 + mem[_2121]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _2121 + ceil32(return_data.size) + ceil32(32 * mem[_2121 + mem[_2121]]) + 1
                                mem[_2121 + ceil32(return_data.size)] = _2145
                                require _2133 + (32 * _2145) + 32 <= return_data.size
                                t = _2121 + _2133 + 32
                                u = _2121 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _2145:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1873
                s = _1865
                t = _1857
                t = _1850
                t = _1842
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(s))
            staticcall address(s).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1849 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_1849] <= cd[196]:
                revert with 0, 'Check result'
            mem[mem[64]] = mem[_1849]
        else:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
            if ('cd', 4).length != ('cd', 36).length:
                revert with 0, 'Check length1'
            if ('cd', 4).length != ('cd', 68).length:
                revert with 0, 'Check length2'
            if ('cd', 4).length != ('cd', 132).length:
                revert with 0, 'Check length3'
            idx = 0
            s = 0
            s = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 68).length:
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                _1844 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                    revert with 0, 50
                _1853 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131]
                if idx >= mem[96]:
                    revert with 0, 50
                _1859 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _1868 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100]:
                    revert with 0, 50
                _1876 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 132]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_1859))
                staticcall address(_1859).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1887 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1887] >= _1876:
                    if not address(_1853):
                        _1899 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_1899]:
                            revert with 0, 50
                        mem[_1899 + 32] = address(_1859)
                        if 1 >= mem[_1899]:
                            revert with 0, 50
                        mem[_1899 + 64] = address(_1868)
                        mem[_1899 + 100] = address(_1844)
                        mem[_1899 + 132] = _1876
                        require ext_code.size(address(_1859))
                        call address(_1859).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(_1844), _1876
                        mem[_1899 + 96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _1899 + ceil32(return_data.size) + 96
                        require return_data.size >= 32
                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                        mem[_1899 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_1899 + ceil32(return_data.size) + 100] = _1876
                        mem[_1899 + ceil32(return_data.size) + 132] = cd[164]
                        mem[_1899 + ceil32(return_data.size) + 164] = 160
                        mem[_1899 + ceil32(return_data.size) + 260] = mem[_1899]
                        s = 0
                        t = _1899 + 32
                        u = _1899 + ceil32(return_data.size) + 292
                        while s < mem[_1899]:
                            mem[u] = mem[t + 12 len 20]
                            s = s + 1
                            t = t + 32
                            u = u + 32
                            continue 
                        mem[_1899 + ceil32(return_data.size) + 196] = address(cd[228])
                        mem[_1899 + ceil32(return_data.size) + 228] = block.timestamp
                        require ext_code.size(address(_1844))
                        call address(_1844).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args _1876, cd[164], 160, address(cd[228]), block.timestamp, mem[_1899 + ceil32(return_data.size) + 260 len (32 * mem[_1899]) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1899 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = _1899 + (2 * ceil32(return_data.size)) + 96
                        require return_data.size >= 32
                        _2139 = mem[_1899 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32
                        require mem[_1899 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 <= test266151307()
                        require _1899 + ceil32(return_data.size) + return_data.size + 96 > _1899 + ceil32(return_data.size) + mem[_1899 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 127
                        _2151 = mem[_1899 + ceil32(return_data.size) + mem[_1899 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]
                        if mem[_1899 + ceil32(return_data.size) + mem[_1899 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_1899 + ceil32(return_data.size) + mem[_1899 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 1 < 0 or _1899 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1899 + ceil32(return_data.size) + mem[_1899 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 97 > test266151307():
                            revert with 0, 65
                        mem[64] = _1899 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1899 + ceil32(return_data.size) + mem[_1899 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 97
                        mem[_1899 + (2 * ceil32(return_data.size)) + 96] = _2151
                        require _2139 + (32 * _2151) + 32 <= return_data.size
                        t = _1899 + ceil32(return_data.size) + _2139 + 128
                        u = _1899 + (2 * ceil32(return_data.size)) + 128
                        s = 0
                        while s < _2151:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s + 1
                            continue 
                    else:
                        if address(_1859) == address(_1853):
                            _1908 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_1908]:
                                revert with 0, 50
                            mem[_1908 + 32] = address(_1859)
                            if 1 >= mem[_1908]:
                                revert with 0, 50
                            mem[_1908 + 64] = address(_1868)
                            mem[_1908 + 100] = address(_1844)
                            mem[_1908 + 132] = _1876
                            require ext_code.size(address(_1859))
                            call address(_1859).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_1844), _1876
                            mem[_1908 + 96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _1908 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                            mem[_1908 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_1908 + ceil32(return_data.size) + 100] = _1876
                            mem[_1908 + ceil32(return_data.size) + 132] = cd[164]
                            mem[_1908 + ceil32(return_data.size) + 164] = 160
                            mem[_1908 + ceil32(return_data.size) + 260] = mem[_1908]
                            s = 0
                            t = _1908 + 32
                            u = _1908 + ceil32(return_data.size) + 292
                            while s < mem[_1908]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_1908 + ceil32(return_data.size) + 196] = address(cd[228])
                            mem[_1908 + ceil32(return_data.size) + 228] = block.timestamp
                            require ext_code.size(address(_1844))
                            call address(_1844).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args _1876, cd[164], 160, address(cd[228]), block.timestamp, mem[_1908 + ceil32(return_data.size) + 260 len (32 * mem[_1908]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1908 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1908 + (2 * ceil32(return_data.size)) + 96
                            require return_data.size >= 32
                            _2136 = mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32
                            require mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 <= test266151307()
                            require _1908 + ceil32(return_data.size) + return_data.size + 96 > _1908 + ceil32(return_data.size) + mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 127
                            _2148 = mem[_1908 + ceil32(return_data.size) + mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]
                            if mem[_1908 + ceil32(return_data.size) + mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_1908 + ceil32(return_data.size) + mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 1 < 0 or _1908 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1908 + ceil32(return_data.size) + mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 97 > test266151307():
                                revert with 0, 65
                            mem[64] = _1908 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1908 + ceil32(return_data.size) + mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 97
                            mem[_1908 + (2 * ceil32(return_data.size)) + 96] = mem[_1908 + ceil32(return_data.size) + mem[_1908 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]
                            require _2136 + (32 * _2148) + 32 <= return_data.size
                            t = _1908 + ceil32(return_data.size) + _2136 + 128
                            u = _1908 + (2 * ceil32(return_data.size)) + 128
                            s = 0
                            while s < _2148:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
                        else:
                            if address(_1868) == address(_1853):
                                _1919 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_1919]:
                                    revert with 0, 50
                                mem[_1919 + 32] = address(_1859)
                                if 1 >= mem[_1919]:
                                    revert with 0, 50
                                mem[_1919 + 64] = address(_1868)
                                mem[_1919 + 100] = address(_1844)
                                mem[_1919 + 132] = _1876
                                require ext_code.size(address(_1859))
                                call address(_1859).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_1844), _1876
                                mem[_1919 + 96] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _1919 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[_1919 + ceil32(return_data.size) + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_1919 + ceil32(return_data.size) + 100] = _1876
                                mem[_1919 + ceil32(return_data.size) + 132] = cd[164]
                                mem[_1919 + ceil32(return_data.size) + 164] = 160
                                mem[_1919 + ceil32(return_data.size) + 260] = mem[_1919]
                                s = 0
                                t = _1919 + 32
                                u = _1919 + ceil32(return_data.size) + 292
                                while s < mem[_1919]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_1919 + ceil32(return_data.size) + 196] = address(cd[228])
                                mem[_1919 + ceil32(return_data.size) + 228] = block.timestamp
                                require ext_code.size(address(_1844))
                                call address(_1844).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args _1876, cd[164], 160, address(cd[228]), block.timestamp, mem[_1919 + ceil32(return_data.size) + 260 len (32 * mem[_1919]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_1919 + ceil32(return_data.size) + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = _1919 + (2 * ceil32(return_data.size)) + 96
                                require return_data.size >= 32
                                _2138 = mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32
                                require mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 <= test266151307()
                                require _1919 + ceil32(return_data.size) + return_data.size + 96 > _1919 + ceil32(return_data.size) + mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 127
                                _2150 = mem[_1919 + ceil32(return_data.size) + mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]
                                if mem[_1919 + ceil32(return_data.size) + mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_1919 + ceil32(return_data.size) + mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 1 < 0 or _1919 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1919 + ceil32(return_data.size) + mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 97 > test266151307():
                                    revert with 0, 65
                                mem[64] = _1919 + (2 * ceil32(return_data.size)) + ceil32(32 * mem[_1919 + ceil32(return_data.size) + mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]) + 97
                                mem[_1919 + (2 * ceil32(return_data.size)) + 96] = mem[_1919 + ceil32(return_data.size) + mem[_1919 + ceil32(return_data.size) + 96 len 4], Mask(224, 32, _1876) >> 32 + 96]
                                require _2138 + (32 * _2150) + 32 <= return_data.size
                                t = _1919 + ceil32(return_data.size) + _2138 + 128
                                u = _1919 + (2 * ceil32(return_data.size)) + 128
                                s = 0
                                while s < _2150:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                            else:
                                _1909 = mem[64]
                                mem[mem[64]] = 3
                                mem[64] = mem[64] + 128
                                if 0 >= mem[_1909]:
                                    revert with 0, 50
                                mem[_1909 + 32] = address(_1859)
                                if 1 >= mem[_1909]:
                                    revert with 0, 50
                                mem[_1909 + 64] = address(_1853)
                                if 2 >= mem[_1909]:
                                    revert with 0, 50
                                mem[_1909 + 96] = address(_1868)
                                mem[_1909 + 132] = address(_1844)
                                mem[_1909 + 164] = _1876
                                require ext_code.size(address(_1859))
                                call address(_1859).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_1844), _1876
                                mem[_1909 + 128] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _1909 + ceil32(return_data.size) + 128
                                require return_data.size >= 32
                                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                mem[_1909 + ceil32(return_data.size) + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_1909 + ceil32(return_data.size) + 132] = _1876
                                mem[_1909 + ceil32(return_data.size) + 164] = cd[164]
                                mem[_1909 + ceil32(return_data.size) + 196] = 160
                                mem[_1909 + ceil32(return_data.size) + 292] = mem[_1909]
                                s = 0
                                t = _1909 + 32
                                u = _1909 + ceil32(return_data.size) + 324
                                while s < mem[_1909]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_1909 + ceil32(return_data.size) + 228] = address(cd[228])
                                mem[_1909 + ceil32(return_data.size) + 260] = block.timestamp
                                require ext_code.size(address(_1844))
                                call address(_1844).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _1909 + ceil32(return_data.size) + (32 * mem[_1909]) + -mem[64] + 320]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2125 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _2137 = mem[_2125]
                                require mem[_2125] <= test266151307()
                                require _2125 + return_data.size > _2125 + mem[_2125] + 31
                                _2149 = mem[_2125 + mem[_2125]]
                                if mem[_2125 + mem[_2125]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_2125 + mem[_2125]]) + 1 < 0 or _2125 + ceil32(return_data.size) + ceil32(32 * mem[_2125 + mem[_2125]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _2125 + ceil32(return_data.size) + ceil32(32 * mem[_2125 + mem[_2125]]) + 1
                                mem[_2125 + ceil32(return_data.size)] = _2149
                                require _2137 + (32 * _2149) + 32 <= return_data.size
                                t = _2125 + _2137 + 32
                                u = _2125 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _2149:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _1876
                s = _1868
                t = _1859
                t = _1853
                t = _1844
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(s))
            staticcall address(s).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1852 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_1852] <= cd[196]:
                revert with 0, 'Check result'
            mem[mem[64]] = mem[_1852]
    return memory
      from mem[64]
       len 32
}

function sub_aecc64b5(?) {
    require calldata.size - 4 >= 192
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if msg.sender == stor0:
        if arg3 > 0x480ebe7b9d58566c87ce9b80a5fb05082bd371c8651c7b299b30:
            revert with 0, 17
        require ext_code.size(address(arg2))
        staticcall address(arg2).token0() with:
                gas gas_remaining wei
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require ext_code.size(address(arg2))
        staticcall address(arg2).token1() with:
                gas gas_remaining wei
        mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        if address(ext_call.return_data[0]) == address(arg1):
            mem[(2 * ceil32(return_data.size)) + 100] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 96
            require return_data.size >= 32
            if address(ext_call.return_data[0]) != address(arg1):
                idx = 0
                s = 0
                s = 10^15 * arg3
                t = 0
                t = 0
                while idx < arg4:
                    if s and arg5 > -1 / s:
                        revert with 0, 17
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _897 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_897] < s * arg5 / 100:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1006 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1006] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1006] - ext_call.return_data[0]
                        return memory
                          from mem[64]
                           len 32
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _969 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1005 = mem[_969]
                    require mem[_969] == mem[_969 + 18 len 14]
                    _1041 = mem[_969 + 32]
                    require mem[_969 + 32] == mem[_969 + 50 len 14]
                    require mem[_969 + 64] == mem[_969 + 92 len 4]
                    if s * arg5 / 100 <= 0:
                        revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_969 + 18 len 14] <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if mem[_969 + 50 len 14] <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                        revert with 0, 17
                    if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                        revert with 0, 'MUL error'
                    if not mem[_969 + 50 len 14]:
                        if mem[_969 + 18 len 14] and 1000 > -1 / mem[_969 + 18 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_969 + 18 len 14] / 1000 != mem[_969 + 18 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_969 + 18 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_969 + 18 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 0 / (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (0 / (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1353 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1353] == bool(mem[_1353])
                        _1425 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1425 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1425 + 36] = 0
                        mem[_1425 + 68] = (0 / (1000 * Mask(112, 0, _1005)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1425 + 100] = this.address
                        mem[_1425 + 132] = 128
                        mem[_1425 + 164] = mem[_1425]
                        t = 0
                        while t < mem[_1425]:
                            mem[t + _1425 + 196] = mem[_1425 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1425]) > mem[_1425]:
                            mem[_1425 + mem[_1425] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (0 / (1000 * Mask(112, 0, _1005)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1425], mem[_1425 + 196 len ceil32(mem[_1425])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (0 / (1000 * Mask(112, 0, _1005)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1041
                        t = _1005
                        continue 
                    if 998 * s * arg5 / 100 and mem[_969 + 50 len 14] > -1 / 998 * s * arg5 / 100:
                        revert with 0, 17
                    if not mem[_969 + 50 len 14]:
                        revert with 0, 18
                    if 998 * s * arg5 / 100 * mem[_969 + 50 len 14] / mem[_969 + 50 len 14] != 998 * s * arg5 / 100:
                        revert with 0, 'MUL error'
                    if mem[_969 + 18 len 14] and 1000 > -1 / mem[_969 + 18 len 14]:
                        revert with 0, 17
                    if 1000 * mem[_969 + 18 len 14] / 1000 != mem[_969 + 18 len 14]:
                        revert with 0, 'MUL error'
                    if 1000 * mem[_969 + 18 len 14] > !(998 * s * arg5 / 100):
                        revert with 0, 17
                    if (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_969 + 18 len 14]:
                        revert with 0, 'Add error'
                    if not (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100):
                        revert with 0, 18
                    if 998 * s * arg5 / 100 * mem[_969 + 50 len 14] / (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                        revert with 0, 17
                    if (998 * s * arg5 / 100 * mem[_969 + 50 len 14] / (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_969 + 50 len 14] / (1000 * mem[_969 + 18 len 14]) + (998 * s * arg5 / 100):
                        revert with 0, 'SUB error'
                    mem[mem[64] + 4] = address(arg2)
                    mem[mem[64] + 36] = s * arg5 / 100
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), s * arg5 / 100
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1438 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1438] == bool(mem[_1438])
                    _1497 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1497 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1497 + 36] = 0
                    mem[_1497 + 68] = (998 * s * arg5 / 100 * Mask(112, 0, _1041) / (1000 * Mask(112, 0, _1005)) + (998 * s * arg5 / 100)) - arg6
                    mem[_1497 + 100] = this.address
                    mem[_1497 + 132] = 128
                    mem[_1497 + 164] = mem[_1497]
                    t = 0
                    while t < mem[_1497]:
                        mem[t + _1497 + 196] = mem[_1497 + t + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_1497]) > mem[_1497]:
                        mem[_1497 + mem[_1497] + 196] = 0
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, (998 * s * arg5 / 100 * Mask(112, 0, _1041) / (1000 * Mask(112, 0, _1005)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1497], mem[_1497 + 196 len ceil32(mem[_1497])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = (998 * s * arg5 / 100 * Mask(112, 0, _1041) / (1000 * Mask(112, 0, _1005)) + (998 * s * arg5 / 100)) - arg6
                    s = s * arg5 / 100
                    t = _1041
                    t = _1005
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _849 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_849] < ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = mem[_849] - ext_call.return_data[0]
            else:
                idx = 0
                s = 0
                s = 10^15 * arg3
                t = 0
                t = 0
                while idx < arg4:
                    if s and arg5 > -1 / s:
                        revert with 0, 17
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _898 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_898] < s * arg5 / 100:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1008 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1008] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1008] - ext_call.return_data[0]
                        return memory
                          from mem[64]
                           len 32
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1007 = mem[_971]
                    require mem[_971] == mem[_971 + 18 len 14]
                    _1042 = mem[_971 + 32]
                    require mem[_971 + 32] == mem[_971 + 50 len 14]
                    require mem[_971 + 64] == mem[_971 + 92 len 4]
                    if s * arg5 / 100 <= 0:
                        revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_971 + 50 len 14] <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if mem[_971 + 18 len 14] <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                        revert with 0, 17
                    if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                        revert with 0, 'MUL error'
                    if not mem[_971 + 18 len 14]:
                        if mem[_971 + 50 len 14] and 1000 > -1 / mem[_971 + 50 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_971 + 50 len 14] / 1000 != mem[_971 + 50 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_971 + 50 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_971 + 50 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 0 / (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (0 / (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1354 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1354] == bool(mem[_1354])
                        _1426 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1426 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1426 + 36] = (0 / (1000 * Mask(112, 0, _1042)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1426 + 68] = 0
                        mem[_1426 + 100] = this.address
                        mem[_1426 + 132] = 128
                        mem[_1426 + 164] = mem[_1426]
                        t = 0
                        while t < mem[_1426]:
                            mem[t + _1426 + 196] = mem[_1426 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1426]) > mem[_1426]:
                            mem[_1426 + mem[_1426] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (0 / (1000 * Mask(112, 0, _1042)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1426], mem[_1426 + 196 len ceil32(mem[_1426])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (0 / (1000 * Mask(112, 0, _1042)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1042
                        t = _1007
                        continue 
                    if 998 * s * arg5 / 100 and mem[_971 + 18 len 14] > -1 / 998 * s * arg5 / 100:
                        revert with 0, 17
                    if not mem[_971 + 18 len 14]:
                        revert with 0, 18
                    if 998 * s * arg5 / 100 * mem[_971 + 18 len 14] / mem[_971 + 18 len 14] != 998 * s * arg5 / 100:
                        revert with 0, 'MUL error'
                    if mem[_971 + 50 len 14] and 1000 > -1 / mem[_971 + 50 len 14]:
                        revert with 0, 17
                    if 1000 * mem[_971 + 50 len 14] / 1000 != mem[_971 + 50 len 14]:
                        revert with 0, 'MUL error'
                    if 1000 * mem[_971 + 50 len 14] > !(998 * s * arg5 / 100):
                        revert with 0, 17
                    if (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_971 + 50 len 14]:
                        revert with 0, 'Add error'
                    if not (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100):
                        revert with 0, 18
                    if 998 * s * arg5 / 100 * mem[_971 + 18 len 14] / (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                        revert with 0, 17
                    if (998 * s * arg5 / 100 * mem[_971 + 18 len 14] / (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_971 + 18 len 14] / (1000 * mem[_971 + 50 len 14]) + (998 * s * arg5 / 100):
                        revert with 0, 'SUB error'
                    mem[mem[64] + 4] = address(arg2)
                    mem[mem[64] + 36] = s * arg5 / 100
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), s * arg5 / 100
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1440 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1440] == bool(mem[_1440])
                    _1498 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1498 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1498 + 36] = (998 * s * arg5 / 100 * Mask(112, 0, _1007) / (1000 * Mask(112, 0, _1042)) + (998 * s * arg5 / 100)) - arg6
                    mem[_1498 + 68] = 0
                    mem[_1498 + 100] = this.address
                    mem[_1498 + 132] = 128
                    mem[_1498 + 164] = mem[_1498]
                    t = 0
                    while t < mem[_1498]:
                        mem[t + _1498 + 196] = mem[_1498 + t + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_1498]) > mem[_1498]:
                        mem[_1498 + mem[_1498] + 196] = 0
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args (998 * s * arg5 / 100 * Mask(112, 0, _1007) / (1000 * Mask(112, 0, _1042)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1498], mem[_1498 + 196 len ceil32(mem[_1498])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = (998 * s * arg5 / 100 * Mask(112, 0, _1007) / (1000 * Mask(112, 0, _1042)) + (998 * s * arg5 / 100)) - arg6
                    s = s * arg5 / 100
                    t = _1042
                    t = _1007
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _850 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_850] < ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = mem[_850] - ext_call.return_data[0]
        else:
            if ext_call.return_data[12 len 20] != address(arg1):
                revert with 0, 'Check pair address'
            mem[(2 * ceil32(return_data.size)) + 100] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[64] = (4 * ceil32(return_data.size)) + 96
            require return_data.size >= 32
            if address(ext_call.return_data[0]) != address(arg1):
                idx = 0
                s = 0
                s = 10^15 * arg3
                t = 0
                t = 0
                while idx < arg4:
                    if s and arg5 > -1 / s:
                        revert with 0, 17
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _899 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_899] < s * arg5 / 100:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1010 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1010] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1010] - ext_call.return_data[0]
                        return memory
                          from mem[64]
                           len 32
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _973 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1009 = mem[_973]
                    require mem[_973] == mem[_973 + 18 len 14]
                    _1043 = mem[_973 + 32]
                    require mem[_973 + 32] == mem[_973 + 50 len 14]
                    require mem[_973 + 64] == mem[_973 + 92 len 4]
                    if s * arg5 / 100 <= 0:
                        revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_973 + 18 len 14] <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if mem[_973 + 50 len 14] <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                        revert with 0, 17
                    if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                        revert with 0, 'MUL error'
                    if not mem[_973 + 50 len 14]:
                        if mem[_973 + 18 len 14] and 1000 > -1 / mem[_973 + 18 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_973 + 18 len 14] / 1000 != mem[_973 + 18 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_973 + 18 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_973 + 18 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 0 / (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (0 / (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1355 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1355] == bool(mem[_1355])
                        _1427 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1427 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1427 + 36] = 0
                        mem[_1427 + 68] = (0 / (1000 * Mask(112, 0, _1009)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1427 + 100] = this.address
                        mem[_1427 + 132] = 128
                        mem[_1427 + 164] = mem[_1427]
                        t = 0
                        while t < mem[_1427]:
                            mem[t + _1427 + 196] = mem[_1427 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1427]) > mem[_1427]:
                            mem[_1427 + mem[_1427] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (0 / (1000 * Mask(112, 0, _1009)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1427], mem[_1427 + 196 len ceil32(mem[_1427])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (0 / (1000 * Mask(112, 0, _1009)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1043
                        t = _1009
                        continue 
                    if 998 * s * arg5 / 100 and mem[_973 + 50 len 14] > -1 / 998 * s * arg5 / 100:
                        revert with 0, 17
                    if not mem[_973 + 50 len 14]:
                        revert with 0, 18
                    if 998 * s * arg5 / 100 * mem[_973 + 50 len 14] / mem[_973 + 50 len 14] != 998 * s * arg5 / 100:
                        revert with 0, 'MUL error'
                    if mem[_973 + 18 len 14] and 1000 > -1 / mem[_973 + 18 len 14]:
                        revert with 0, 17
                    if 1000 * mem[_973 + 18 len 14] / 1000 != mem[_973 + 18 len 14]:
                        revert with 0, 'MUL error'
                    if 1000 * mem[_973 + 18 len 14] > !(998 * s * arg5 / 100):
                        revert with 0, 17
                    if (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_973 + 18 len 14]:
                        revert with 0, 'Add error'
                    if not (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100):
                        revert with 0, 18
                    if 998 * s * arg5 / 100 * mem[_973 + 50 len 14] / (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                        revert with 0, 17
                    if (998 * s * arg5 / 100 * mem[_973 + 50 len 14] / (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_973 + 50 len 14] / (1000 * mem[_973 + 18 len 14]) + (998 * s * arg5 / 100):
                        revert with 0, 'SUB error'
                    mem[mem[64] + 4] = address(arg2)
                    mem[mem[64] + 36] = s * arg5 / 100
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), s * arg5 / 100
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1442 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1442] == bool(mem[_1442])
                    _1499 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1499 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1499 + 36] = 0
                    mem[_1499 + 68] = (998 * s * arg5 / 100 * Mask(112, 0, _1043) / (1000 * Mask(112, 0, _1009)) + (998 * s * arg5 / 100)) - arg6
                    mem[_1499 + 100] = this.address
                    mem[_1499 + 132] = 128
                    mem[_1499 + 164] = mem[_1499]
                    t = 0
                    while t < mem[_1499]:
                        mem[t + _1499 + 196] = mem[_1499 + t + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_1499]) > mem[_1499]:
                        mem[_1499 + mem[_1499] + 196] = 0
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args 0, (998 * s * arg5 / 100 * Mask(112, 0, _1043) / (1000 * Mask(112, 0, _1009)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1499], mem[_1499 + 196 len ceil32(mem[_1499])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = (998 * s * arg5 / 100 * Mask(112, 0, _1043) / (1000 * Mask(112, 0, _1009)) + (998 * s * arg5 / 100)) - arg6
                    s = s * arg5 / 100
                    t = _1043
                    t = _1009
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _851 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_851] < ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = mem[_851] - ext_call.return_data[0]
            else:
                idx = 0
                s = 0
                s = 10^15 * arg3
                t = 0
                t = 0
                while idx < arg4:
                    if s and arg5 > -1 / s:
                        revert with 0, 17
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(ext_call.return_data[0]))
                    staticcall address(ext_call.return_data[0]).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _900 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_900] < s * arg5 / 100:
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg1))
                        staticcall address(arg1).0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1012 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1012] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1012] - ext_call.return_data[0]
                        return memory
                          from mem[64]
                           len 32
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _975 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1011 = mem[_975]
                    require mem[_975] == mem[_975 + 18 len 14]
                    _1044 = mem[_975 + 32]
                    require mem[_975 + 32] == mem[_975 + 50 len 14]
                    require mem[_975 + 64] == mem[_975 + 92 len 4]
                    if s * arg5 / 100 <= 0:
                        revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                    if mem[_975 + 50 len 14] <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if mem[_975 + 18 len 14] <= 0:
                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                    if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                        revert with 0, 17
                    if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                        revert with 0, 'MUL error'
                    if not mem[_975 + 18 len 14]:
                        if mem[_975 + 50 len 14] and 1000 > -1 / mem[_975 + 50 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_975 + 50 len 14] / 1000 != mem[_975 + 50 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_975 + 50 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_975 + 50 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 0 / (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (0 / (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1356 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1356] == bool(mem[_1356])
                        _1428 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1428 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1428 + 36] = (0 / (1000 * Mask(112, 0, _1044)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1428 + 68] = 0
                        mem[_1428 + 100] = this.address
                        mem[_1428 + 132] = 128
                        mem[_1428 + 164] = mem[_1428]
                        t = 0
                        while t < mem[_1428]:
                            mem[t + _1428 + 196] = mem[_1428 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1428]) > mem[_1428]:
                            mem[_1428 + mem[_1428] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (0 / (1000 * Mask(112, 0, _1044)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1428], mem[_1428 + 196 len ceil32(mem[_1428])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (0 / (1000 * Mask(112, 0, _1044)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1044
                        t = _1011
                        continue 
                    if 998 * s * arg5 / 100 and mem[_975 + 18 len 14] > -1 / 998 * s * arg5 / 100:
                        revert with 0, 17
                    if not mem[_975 + 18 len 14]:
                        revert with 0, 18
                    if 998 * s * arg5 / 100 * mem[_975 + 18 len 14] / mem[_975 + 18 len 14] != 998 * s * arg5 / 100:
                        revert with 0, 'MUL error'
                    if mem[_975 + 50 len 14] and 1000 > -1 / mem[_975 + 50 len 14]:
                        revert with 0, 17
                    if 1000 * mem[_975 + 50 len 14] / 1000 != mem[_975 + 50 len 14]:
                        revert with 0, 'MUL error'
                    if 1000 * mem[_975 + 50 len 14] > !(998 * s * arg5 / 100):
                        revert with 0, 17
                    if (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_975 + 50 len 14]:
                        revert with 0, 'Add error'
                    if not (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100):
                        revert with 0, 18
                    if 998 * s * arg5 / 100 * mem[_975 + 18 len 14] / (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                        revert with 0, 17
                    if (998 * s * arg5 / 100 * mem[_975 + 18 len 14] / (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_975 + 18 len 14] / (1000 * mem[_975 + 50 len 14]) + (998 * s * arg5 / 100):
                        revert with 0, 'SUB error'
                    mem[mem[64] + 4] = address(arg2)
                    mem[mem[64] + 36] = s * arg5 / 100
                    require ext_code.size(address(ext_call.return_data[0]))
                    call address(ext_call.return_data[0]).0xa9059cbb with:
                         gas gas_remaining wei
                        args address(arg2), s * arg5 / 100
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1444 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1444] == bool(mem[_1444])
                    _1500 = mem[64]
                    mem[64] = mem[64] + 32
                    mem[_1500 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1500 + 36] = (998 * s * arg5 / 100 * Mask(112, 0, _1011) / (1000 * Mask(112, 0, _1044)) + (998 * s * arg5 / 100)) - arg6
                    mem[_1500 + 68] = 0
                    mem[_1500 + 100] = this.address
                    mem[_1500 + 132] = 128
                    mem[_1500 + 164] = mem[_1500]
                    t = 0
                    while t < mem[_1500]:
                        mem[t + _1500 + 196] = mem[_1500 + t + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_1500]) > mem[_1500]:
                        mem[_1500 + mem[_1500] + 196] = 0
                    require ext_code.size(address(arg2))
                    call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                         gas gas_remaining wei
                        args (998 * s * arg5 / 100 * Mask(112, 0, _1011) / (1000 * Mask(112, 0, _1044)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1500], mem[_1500 + 196 len ceil32(mem[_1500])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = (998 * s * arg5 / 100 * Mask(112, 0, _1011) / (1000 * Mask(112, 0, _1044)) + (998 * s * arg5 / 100)) - arg6
                    s = s * arg5 / 100
                    t = _1044
                    t = _1011
                    continue 
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _852 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_852] < ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = mem[_852] - ext_call.return_data[0]
    else:
        if msg.sender == stor1:
            if arg3 > 0x480ebe7b9d58566c87ce9b80a5fb05082bd371c8651c7b299b30:
                revert with 0, 17
            require ext_code.size(address(arg2))
            staticcall address(arg2).token0() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(address(arg2))
            staticcall address(arg2).token1() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(ext_call.return_data[0]) == address(arg1):
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 96
                require return_data.size >= 32
                if address(ext_call.return_data[0]) != address(arg1):
                    idx = 0
                    s = 0
                    s = 10^15 * arg3
                    t = 0
                    t = 0
                    while idx < arg4:
                        if s and arg5 > -1 / s:
                            revert with 0, 17
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _901 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_901] < s * arg5 / 100:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1014 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1014] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1014] - ext_call.return_data[0]
                            return memory
                              from mem[64]
                               len 32
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _977 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1013 = mem[_977]
                        require mem[_977] == mem[_977 + 18 len 14]
                        _1045 = mem[_977 + 32]
                        require mem[_977 + 32] == mem[_977 + 50 len 14]
                        require mem[_977 + 64] == mem[_977 + 92 len 4]
                        if s * arg5 / 100 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_977 + 18 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if mem[_977 + 50 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                            revert with 0, 17
                        if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if not mem[_977 + 50 len 14]:
                            if mem[_977 + 18 len 14] and 1000 > -1 / mem[_977 + 18 len 14]:
                                revert with 0, 17
                            if 1000 * mem[_977 + 18 len 14] / 1000 != mem[_977 + 18 len 14]:
                                revert with 0, 'MUL error'
                            if 1000 * mem[_977 + 18 len 14] > !(998 * s * arg5 / 100):
                                revert with 0, 17
                            if (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_977 + 18 len 14]:
                                revert with 0, 'Add error'
                            if not (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 18
                            if 0 / (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                                revert with 0, 17
                            if (0 / (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(arg2)
                            mem[mem[64] + 36] = s * arg5 / 100
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(arg2), s * arg5 / 100
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1357 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1357] == bool(mem[_1357])
                            _1429 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_1429 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1429 + 36] = 0
                            mem[_1429 + 68] = (0 / (1000 * Mask(112, 0, _1013)) + (998 * s * arg5 / 100)) - arg6
                            mem[_1429 + 100] = this.address
                            mem[_1429 + 132] = 128
                            mem[_1429 + 164] = mem[_1429]
                            t = 0
                            while t < mem[_1429]:
                                mem[t + _1429 + 196] = mem[_1429 + t + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_1429]) > mem[_1429]:
                                mem[_1429 + mem[_1429] + 196] = 0
                            require ext_code.size(address(arg2))
                            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (0 / (1000 * Mask(112, 0, _1013)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1429], mem[_1429 + 196 len ceil32(mem[_1429])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = (0 / (1000 * Mask(112, 0, _1013)) + (998 * s * arg5 / 100)) - arg6
                            s = s * arg5 / 100
                            t = _1045
                            t = _1013
                            continue 
                        if 998 * s * arg5 / 100 and mem[_977 + 50 len 14] > -1 / 998 * s * arg5 / 100:
                            revert with 0, 17
                        if not mem[_977 + 50 len 14]:
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_977 + 50 len 14] / mem[_977 + 50 len 14] != 998 * s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if mem[_977 + 18 len 14] and 1000 > -1 / mem[_977 + 18 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_977 + 18 len 14] / 1000 != mem[_977 + 18 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_977 + 18 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_977 + 18 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_977 + 50 len 14] / (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (998 * s * arg5 / 100 * mem[_977 + 50 len 14] / (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_977 + 50 len 14] / (1000 * mem[_977 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1446 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1446] == bool(mem[_1446])
                        _1501 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1501 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1501 + 36] = 0
                        mem[_1501 + 68] = (998 * s * arg5 / 100 * Mask(112, 0, _1045) / (1000 * Mask(112, 0, _1013)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1501 + 100] = this.address
                        mem[_1501 + 132] = 128
                        mem[_1501 + 164] = mem[_1501]
                        t = 0
                        while t < mem[_1501]:
                            mem[t + _1501 + 196] = mem[_1501 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1501]) > mem[_1501]:
                            mem[_1501 + mem[_1501] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (998 * s * arg5 / 100 * Mask(112, 0, _1045) / (1000 * Mask(112, 0, _1013)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1501], mem[_1501 + 196 len ceil32(mem[_1501])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (998 * s * arg5 / 100 * Mask(112, 0, _1045) / (1000 * Mask(112, 0, _1013)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1045
                        t = _1013
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _853 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_853] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_853] - ext_call.return_data[0]
                else:
                    idx = 0
                    s = 0
                    s = 10^15 * arg3
                    t = 0
                    t = 0
                    while idx < arg4:
                        if s and arg5 > -1 / s:
                            revert with 0, 17
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _902 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_902] < s * arg5 / 100:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1016 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1016] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1016] - ext_call.return_data[0]
                            return memory
                              from mem[64]
                               len 32
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _979 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1015 = mem[_979]
                        require mem[_979] == mem[_979 + 18 len 14]
                        _1046 = mem[_979 + 32]
                        require mem[_979 + 32] == mem[_979 + 50 len 14]
                        require mem[_979 + 64] == mem[_979 + 92 len 4]
                        if s * arg5 / 100 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_979 + 50 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if mem[_979 + 18 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                            revert with 0, 17
                        if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if not mem[_979 + 18 len 14]:
                            if mem[_979 + 50 len 14] and 1000 > -1 / mem[_979 + 50 len 14]:
                                revert with 0, 17
                            if 1000 * mem[_979 + 50 len 14] / 1000 != mem[_979 + 50 len 14]:
                                revert with 0, 'MUL error'
                            if 1000 * mem[_979 + 50 len 14] > !(998 * s * arg5 / 100):
                                revert with 0, 17
                            if (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_979 + 50 len 14]:
                                revert with 0, 'Add error'
                            if not (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 18
                            if 0 / (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                                revert with 0, 17
                            if (0 / (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(arg2)
                            mem[mem[64] + 36] = s * arg5 / 100
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(arg2), s * arg5 / 100
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1358 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1358] == bool(mem[_1358])
                            _1430 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_1430 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1430 + 36] = (0 / (1000 * Mask(112, 0, _1046)) + (998 * s * arg5 / 100)) - arg6
                            mem[_1430 + 68] = 0
                            mem[_1430 + 100] = this.address
                            mem[_1430 + 132] = 128
                            mem[_1430 + 164] = mem[_1430]
                            t = 0
                            while t < mem[_1430]:
                                mem[t + _1430 + 196] = mem[_1430 + t + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_1430]) > mem[_1430]:
                                mem[_1430 + mem[_1430] + 196] = 0
                            require ext_code.size(address(arg2))
                            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (0 / (1000 * Mask(112, 0, _1046)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1430], mem[_1430 + 196 len ceil32(mem[_1430])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = (0 / (1000 * Mask(112, 0, _1046)) + (998 * s * arg5 / 100)) - arg6
                            s = s * arg5 / 100
                            t = _1046
                            t = _1015
                            continue 
                        if 998 * s * arg5 / 100 and mem[_979 + 18 len 14] > -1 / 998 * s * arg5 / 100:
                            revert with 0, 17
                        if not mem[_979 + 18 len 14]:
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_979 + 18 len 14] / mem[_979 + 18 len 14] != 998 * s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if mem[_979 + 50 len 14] and 1000 > -1 / mem[_979 + 50 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_979 + 50 len 14] / 1000 != mem[_979 + 50 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_979 + 50 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_979 + 50 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_979 + 18 len 14] / (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (998 * s * arg5 / 100 * mem[_979 + 18 len 14] / (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_979 + 18 len 14] / (1000 * mem[_979 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1448 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1448] == bool(mem[_1448])
                        _1502 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1502 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1502 + 36] = (998 * s * arg5 / 100 * Mask(112, 0, _1015) / (1000 * Mask(112, 0, _1046)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1502 + 68] = 0
                        mem[_1502 + 100] = this.address
                        mem[_1502 + 132] = 128
                        mem[_1502 + 164] = mem[_1502]
                        t = 0
                        while t < mem[_1502]:
                            mem[t + _1502 + 196] = mem[_1502 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1502]) > mem[_1502]:
                            mem[_1502 + mem[_1502] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (998 * s * arg5 / 100 * Mask(112, 0, _1015) / (1000 * Mask(112, 0, _1046)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1502], mem[_1502 + 196 len ceil32(mem[_1502])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (998 * s * arg5 / 100 * Mask(112, 0, _1015) / (1000 * Mask(112, 0, _1046)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1046
                        t = _1015
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _854 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_854] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_854] - ext_call.return_data[0]
            else:
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'Check pair address'
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 96
                require return_data.size >= 32
                if address(ext_call.return_data[0]) != address(arg1):
                    idx = 0
                    s = 0
                    s = 10^15 * arg3
                    t = 0
                    t = 0
                    while idx < arg4:
                        if s and arg5 > -1 / s:
                            revert with 0, 17
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _903 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_903] < s * arg5 / 100:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1018 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1018] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1018] - ext_call.return_data[0]
                            return memory
                              from mem[64]
                               len 32
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _981 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1017 = mem[_981]
                        require mem[_981] == mem[_981 + 18 len 14]
                        _1047 = mem[_981 + 32]
                        require mem[_981 + 32] == mem[_981 + 50 len 14]
                        require mem[_981 + 64] == mem[_981 + 92 len 4]
                        if s * arg5 / 100 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_981 + 18 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if mem[_981 + 50 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                            revert with 0, 17
                        if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if not mem[_981 + 50 len 14]:
                            if mem[_981 + 18 len 14] and 1000 > -1 / mem[_981 + 18 len 14]:
                                revert with 0, 17
                            if 1000 * mem[_981 + 18 len 14] / 1000 != mem[_981 + 18 len 14]:
                                revert with 0, 'MUL error'
                            if 1000 * mem[_981 + 18 len 14] > !(998 * s * arg5 / 100):
                                revert with 0, 17
                            if (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_981 + 18 len 14]:
                                revert with 0, 'Add error'
                            if not (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 18
                            if 0 / (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                                revert with 0, 17
                            if (0 / (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(arg2)
                            mem[mem[64] + 36] = s * arg5 / 100
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(arg2), s * arg5 / 100
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1359 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1359] == bool(mem[_1359])
                            _1431 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_1431 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1431 + 36] = 0
                            mem[_1431 + 68] = (0 / (1000 * Mask(112, 0, _1017)) + (998 * s * arg5 / 100)) - arg6
                            mem[_1431 + 100] = this.address
                            mem[_1431 + 132] = 128
                            mem[_1431 + 164] = mem[_1431]
                            t = 0
                            while t < mem[_1431]:
                                mem[t + _1431 + 196] = mem[_1431 + t + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_1431]) > mem[_1431]:
                                mem[_1431 + mem[_1431] + 196] = 0
                            require ext_code.size(address(arg2))
                            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (0 / (1000 * Mask(112, 0, _1017)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1431], mem[_1431 + 196 len ceil32(mem[_1431])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = (0 / (1000 * Mask(112, 0, _1017)) + (998 * s * arg5 / 100)) - arg6
                            s = s * arg5 / 100
                            t = _1047
                            t = _1017
                            continue 
                        if 998 * s * arg5 / 100 and mem[_981 + 50 len 14] > -1 / 998 * s * arg5 / 100:
                            revert with 0, 17
                        if not mem[_981 + 50 len 14]:
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_981 + 50 len 14] / mem[_981 + 50 len 14] != 998 * s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if mem[_981 + 18 len 14] and 1000 > -1 / mem[_981 + 18 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_981 + 18 len 14] / 1000 != mem[_981 + 18 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_981 + 18 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_981 + 18 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_981 + 50 len 14] / (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (998 * s * arg5 / 100 * mem[_981 + 50 len 14] / (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_981 + 50 len 14] / (1000 * mem[_981 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1450 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1450] == bool(mem[_1450])
                        _1503 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1503 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1503 + 36] = 0
                        mem[_1503 + 68] = (998 * s * arg5 / 100 * Mask(112, 0, _1047) / (1000 * Mask(112, 0, _1017)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1503 + 100] = this.address
                        mem[_1503 + 132] = 128
                        mem[_1503 + 164] = mem[_1503]
                        t = 0
                        while t < mem[_1503]:
                            mem[t + _1503 + 196] = mem[_1503 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1503]) > mem[_1503]:
                            mem[_1503 + mem[_1503] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (998 * s * arg5 / 100 * Mask(112, 0, _1047) / (1000 * Mask(112, 0, _1017)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1503], mem[_1503 + 196 len ceil32(mem[_1503])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (998 * s * arg5 / 100 * Mask(112, 0, _1047) / (1000 * Mask(112, 0, _1017)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1047
                        t = _1017
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _855 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_855] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_855] - ext_call.return_data[0]
                else:
                    idx = 0
                    s = 0
                    s = 10^15 * arg3
                    t = 0
                    t = 0
                    while idx < arg4:
                        if s and arg5 > -1 / s:
                            revert with 0, 17
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _904 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_904] < s * arg5 / 100:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1020 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1020] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1020] - ext_call.return_data[0]
                            return memory
                              from mem[64]
                               len 32
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _983 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1019 = mem[_983]
                        require mem[_983] == mem[_983 + 18 len 14]
                        _1048 = mem[_983 + 32]
                        require mem[_983 + 32] == mem[_983 + 50 len 14]
                        require mem[_983 + 64] == mem[_983 + 92 len 4]
                        if s * arg5 / 100 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_983 + 50 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if mem[_983 + 18 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                            revert with 0, 17
                        if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if not mem[_983 + 18 len 14]:
                            if mem[_983 + 50 len 14] and 1000 > -1 / mem[_983 + 50 len 14]:
                                revert with 0, 17
                            if 1000 * mem[_983 + 50 len 14] / 1000 != mem[_983 + 50 len 14]:
                                revert with 0, 'MUL error'
                            if 1000 * mem[_983 + 50 len 14] > !(998 * s * arg5 / 100):
                                revert with 0, 17
                            if (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_983 + 50 len 14]:
                                revert with 0, 'Add error'
                            if not (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 18
                            if 0 / (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                                revert with 0, 17
                            if (0 / (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(arg2)
                            mem[mem[64] + 36] = s * arg5 / 100
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(arg2), s * arg5 / 100
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1360 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1360] == bool(mem[_1360])
                            _1432 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_1432 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1432 + 36] = (0 / (1000 * Mask(112, 0, _1048)) + (998 * s * arg5 / 100)) - arg6
                            mem[_1432 + 68] = 0
                            mem[_1432 + 100] = this.address
                            mem[_1432 + 132] = 128
                            mem[_1432 + 164] = mem[_1432]
                            t = 0
                            while t < mem[_1432]:
                                mem[t + _1432 + 196] = mem[_1432 + t + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_1432]) > mem[_1432]:
                                mem[_1432 + mem[_1432] + 196] = 0
                            require ext_code.size(address(arg2))
                            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (0 / (1000 * Mask(112, 0, _1048)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1432], mem[_1432 + 196 len ceil32(mem[_1432])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = (0 / (1000 * Mask(112, 0, _1048)) + (998 * s * arg5 / 100)) - arg6
                            s = s * arg5 / 100
                            t = _1048
                            t = _1019
                            continue 
                        if 998 * s * arg5 / 100 and mem[_983 + 18 len 14] > -1 / 998 * s * arg5 / 100:
                            revert with 0, 17
                        if not mem[_983 + 18 len 14]:
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_983 + 18 len 14] / mem[_983 + 18 len 14] != 998 * s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if mem[_983 + 50 len 14] and 1000 > -1 / mem[_983 + 50 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_983 + 50 len 14] / 1000 != mem[_983 + 50 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_983 + 50 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_983 + 50 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_983 + 18 len 14] / (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (998 * s * arg5 / 100 * mem[_983 + 18 len 14] / (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_983 + 18 len 14] / (1000 * mem[_983 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1452 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1452] == bool(mem[_1452])
                        _1504 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1504 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1504 + 36] = (998 * s * arg5 / 100 * Mask(112, 0, _1019) / (1000 * Mask(112, 0, _1048)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1504 + 68] = 0
                        mem[_1504 + 100] = this.address
                        mem[_1504 + 132] = 128
                        mem[_1504 + 164] = mem[_1504]
                        t = 0
                        while t < mem[_1504]:
                            mem[t + _1504 + 196] = mem[_1504 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1504]) > mem[_1504]:
                            mem[_1504 + mem[_1504] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (998 * s * arg5 / 100 * Mask(112, 0, _1019) / (1000 * Mask(112, 0, _1048)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1504], mem[_1504 + 196 len ceil32(mem[_1504])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (998 * s * arg5 / 100 * Mask(112, 0, _1019) / (1000 * Mask(112, 0, _1048)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1048
                        t = _1019
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _856 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_856] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_856] - ext_call.return_data[0]
        else:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
            if arg3 > 0x480ebe7b9d58566c87ce9b80a5fb05082bd371c8651c7b299b30:
                revert with 0, 17
            require ext_code.size(address(arg2))
            staticcall address(arg2).token0() with:
                    gas gas_remaining wei
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            require ext_code.size(address(arg2))
            staticcall address(arg2).token1() with:
                    gas gas_remaining wei
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
            if address(ext_call.return_data[0]) == address(arg1):
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 96
                require return_data.size >= 32
                if address(ext_call.return_data[0]) != address(arg1):
                    idx = 0
                    s = 0
                    s = 10^15 * arg3
                    t = 0
                    t = 0
                    while idx < arg4:
                        if s and arg5 > -1 / s:
                            revert with 0, 17
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _905 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_905] < s * arg5 / 100:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1022 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1022] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1022] - ext_call.return_data[0]
                            return memory
                              from mem[64]
                               len 32
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _985 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1021 = mem[_985]
                        require mem[_985] == mem[_985 + 18 len 14]
                        _1049 = mem[_985 + 32]
                        require mem[_985 + 32] == mem[_985 + 50 len 14]
                        require mem[_985 + 64] == mem[_985 + 92 len 4]
                        if s * arg5 / 100 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_985 + 18 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if mem[_985 + 50 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                            revert with 0, 17
                        if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if not mem[_985 + 50 len 14]:
                            if mem[_985 + 18 len 14] and 1000 > -1 / mem[_985 + 18 len 14]:
                                revert with 0, 17
                            if 1000 * mem[_985 + 18 len 14] / 1000 != mem[_985 + 18 len 14]:
                                revert with 0, 'MUL error'
                            if 1000 * mem[_985 + 18 len 14] > !(998 * s * arg5 / 100):
                                revert with 0, 17
                            if (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_985 + 18 len 14]:
                                revert with 0, 'Add error'
                            if not (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 18
                            if 0 / (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                                revert with 0, 17
                            if (0 / (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(arg2)
                            mem[mem[64] + 36] = s * arg5 / 100
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(arg2), s * arg5 / 100
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1361 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1361] == bool(mem[_1361])
                            _1433 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_1433 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1433 + 36] = 0
                            mem[_1433 + 68] = (0 / (1000 * Mask(112, 0, _1021)) + (998 * s * arg5 / 100)) - arg6
                            mem[_1433 + 100] = this.address
                            mem[_1433 + 132] = 128
                            mem[_1433 + 164] = mem[_1433]
                            t = 0
                            while t < mem[_1433]:
                                mem[t + _1433 + 196] = mem[_1433 + t + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_1433]) > mem[_1433]:
                                mem[_1433 + mem[_1433] + 196] = 0
                            require ext_code.size(address(arg2))
                            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (0 / (1000 * Mask(112, 0, _1021)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1433], mem[_1433 + 196 len ceil32(mem[_1433])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = (0 / (1000 * Mask(112, 0, _1021)) + (998 * s * arg5 / 100)) - arg6
                            s = s * arg5 / 100
                            t = _1049
                            t = _1021
                            continue 
                        if 998 * s * arg5 / 100 and mem[_985 + 50 len 14] > -1 / 998 * s * arg5 / 100:
                            revert with 0, 17
                        if not mem[_985 + 50 len 14]:
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_985 + 50 len 14] / mem[_985 + 50 len 14] != 998 * s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if mem[_985 + 18 len 14] and 1000 > -1 / mem[_985 + 18 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_985 + 18 len 14] / 1000 != mem[_985 + 18 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_985 + 18 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_985 + 18 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_985 + 50 len 14] / (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (998 * s * arg5 / 100 * mem[_985 + 50 len 14] / (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_985 + 50 len 14] / (1000 * mem[_985 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1454 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1454] == bool(mem[_1454])
                        _1505 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1505 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1505 + 36] = 0
                        mem[_1505 + 68] = (998 * s * arg5 / 100 * Mask(112, 0, _1049) / (1000 * Mask(112, 0, _1021)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1505 + 100] = this.address
                        mem[_1505 + 132] = 128
                        mem[_1505 + 164] = mem[_1505]
                        t = 0
                        while t < mem[_1505]:
                            mem[t + _1505 + 196] = mem[_1505 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1505]) > mem[_1505]:
                            mem[_1505 + mem[_1505] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (998 * s * arg5 / 100 * Mask(112, 0, _1049) / (1000 * Mask(112, 0, _1021)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1505], mem[_1505 + 196 len ceil32(mem[_1505])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (998 * s * arg5 / 100 * Mask(112, 0, _1049) / (1000 * Mask(112, 0, _1021)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1049
                        t = _1021
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _857 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_857] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_857] - ext_call.return_data[0]
                else:
                    idx = 0
                    s = 0
                    s = 10^15 * arg3
                    t = 0
                    t = 0
                    while idx < arg4:
                        if s and arg5 > -1 / s:
                            revert with 0, 17
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _906 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_906] < s * arg5 / 100:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1024 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1024] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1024] - ext_call.return_data[0]
                            return memory
                              from mem[64]
                               len 32
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _987 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1023 = mem[_987]
                        require mem[_987] == mem[_987 + 18 len 14]
                        _1050 = mem[_987 + 32]
                        require mem[_987 + 32] == mem[_987 + 50 len 14]
                        require mem[_987 + 64] == mem[_987 + 92 len 4]
                        if s * arg5 / 100 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_987 + 50 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if mem[_987 + 18 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                            revert with 0, 17
                        if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if not mem[_987 + 18 len 14]:
                            if mem[_987 + 50 len 14] and 1000 > -1 / mem[_987 + 50 len 14]:
                                revert with 0, 17
                            if 1000 * mem[_987 + 50 len 14] / 1000 != mem[_987 + 50 len 14]:
                                revert with 0, 'MUL error'
                            if 1000 * mem[_987 + 50 len 14] > !(998 * s * arg5 / 100):
                                revert with 0, 17
                            if (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_987 + 50 len 14]:
                                revert with 0, 'Add error'
                            if not (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 18
                            if 0 / (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                                revert with 0, 17
                            if (0 / (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(arg2)
                            mem[mem[64] + 36] = s * arg5 / 100
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(arg2), s * arg5 / 100
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1362 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1362] == bool(mem[_1362])
                            _1434 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_1434 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1434 + 36] = (0 / (1000 * Mask(112, 0, _1050)) + (998 * s * arg5 / 100)) - arg6
                            mem[_1434 + 68] = 0
                            mem[_1434 + 100] = this.address
                            mem[_1434 + 132] = 128
                            mem[_1434 + 164] = mem[_1434]
                            t = 0
                            while t < mem[_1434]:
                                mem[t + _1434 + 196] = mem[_1434 + t + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_1434]) > mem[_1434]:
                                mem[_1434 + mem[_1434] + 196] = 0
                            require ext_code.size(address(arg2))
                            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (0 / (1000 * Mask(112, 0, _1050)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1434], mem[_1434 + 196 len ceil32(mem[_1434])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = (0 / (1000 * Mask(112, 0, _1050)) + (998 * s * arg5 / 100)) - arg6
                            s = s * arg5 / 100
                            t = _1050
                            t = _1023
                            continue 
                        if 998 * s * arg5 / 100 and mem[_987 + 18 len 14] > -1 / 998 * s * arg5 / 100:
                            revert with 0, 17
                        if not mem[_987 + 18 len 14]:
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_987 + 18 len 14] / mem[_987 + 18 len 14] != 998 * s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if mem[_987 + 50 len 14] and 1000 > -1 / mem[_987 + 50 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_987 + 50 len 14] / 1000 != mem[_987 + 50 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_987 + 50 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_987 + 50 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_987 + 18 len 14] / (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (998 * s * arg5 / 100 * mem[_987 + 18 len 14] / (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_987 + 18 len 14] / (1000 * mem[_987 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1456 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1456] == bool(mem[_1456])
                        _1506 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1506 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1506 + 36] = (998 * s * arg5 / 100 * Mask(112, 0, _1023) / (1000 * Mask(112, 0, _1050)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1506 + 68] = 0
                        mem[_1506 + 100] = this.address
                        mem[_1506 + 132] = 128
                        mem[_1506 + 164] = mem[_1506]
                        t = 0
                        while t < mem[_1506]:
                            mem[t + _1506 + 196] = mem[_1506 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1506]) > mem[_1506]:
                            mem[_1506 + mem[_1506] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (998 * s * arg5 / 100 * Mask(112, 0, _1023) / (1000 * Mask(112, 0, _1050)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1506], mem[_1506 + 196 len ceil32(mem[_1506])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (998 * s * arg5 / 100 * Mask(112, 0, _1023) / (1000 * Mask(112, 0, _1050)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1050
                        t = _1023
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _858 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_858] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_858] - ext_call.return_data[0]
            else:
                if ext_call.return_data[12 len 20] != address(arg1):
                    revert with 0, 'Check pair address'
                mem[(2 * ceil32(return_data.size)) + 100] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = (4 * ceil32(return_data.size)) + 96
                require return_data.size >= 32
                if address(ext_call.return_data[0]) != address(arg1):
                    idx = 0
                    s = 0
                    s = 10^15 * arg3
                    t = 0
                    t = 0
                    while idx < arg4:
                        if s and arg5 > -1 / s:
                            revert with 0, 17
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _907 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_907] < s * arg5 / 100:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1026 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1026] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1026] - ext_call.return_data[0]
                            return memory
                              from mem[64]
                               len 32
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _989 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1025 = mem[_989]
                        require mem[_989] == mem[_989 + 18 len 14]
                        _1051 = mem[_989 + 32]
                        require mem[_989 + 32] == mem[_989 + 50 len 14]
                        require mem[_989 + 64] == mem[_989 + 92 len 4]
                        if s * arg5 / 100 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_989 + 18 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if mem[_989 + 50 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                            revert with 0, 17
                        if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if not mem[_989 + 50 len 14]:
                            if mem[_989 + 18 len 14] and 1000 > -1 / mem[_989 + 18 len 14]:
                                revert with 0, 17
                            if 1000 * mem[_989 + 18 len 14] / 1000 != mem[_989 + 18 len 14]:
                                revert with 0, 'MUL error'
                            if 1000 * mem[_989 + 18 len 14] > !(998 * s * arg5 / 100):
                                revert with 0, 17
                            if (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_989 + 18 len 14]:
                                revert with 0, 'Add error'
                            if not (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 18
                            if 0 / (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                                revert with 0, 17
                            if (0 / (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(arg2)
                            mem[mem[64] + 36] = s * arg5 / 100
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(arg2), s * arg5 / 100
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1363 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1363] == bool(mem[_1363])
                            _1435 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_1435 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1435 + 36] = 0
                            mem[_1435 + 68] = (0 / (1000 * Mask(112, 0, _1025)) + (998 * s * arg5 / 100)) - arg6
                            mem[_1435 + 100] = this.address
                            mem[_1435 + 132] = 128
                            mem[_1435 + 164] = mem[_1435]
                            t = 0
                            while t < mem[_1435]:
                                mem[t + _1435 + 196] = mem[_1435 + t + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_1435]) > mem[_1435]:
                                mem[_1435 + mem[_1435] + 196] = 0
                            require ext_code.size(address(arg2))
                            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (0 / (1000 * Mask(112, 0, _1025)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1435], mem[_1435 + 196 len ceil32(mem[_1435])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = (0 / (1000 * Mask(112, 0, _1025)) + (998 * s * arg5 / 100)) - arg6
                            s = s * arg5 / 100
                            t = _1051
                            t = _1025
                            continue 
                        if 998 * s * arg5 / 100 and mem[_989 + 50 len 14] > -1 / 998 * s * arg5 / 100:
                            revert with 0, 17
                        if not mem[_989 + 50 len 14]:
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_989 + 50 len 14] / mem[_989 + 50 len 14] != 998 * s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if mem[_989 + 18 len 14] and 1000 > -1 / mem[_989 + 18 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_989 + 18 len 14] / 1000 != mem[_989 + 18 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_989 + 18 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_989 + 18 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_989 + 50 len 14] / (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (998 * s * arg5 / 100 * mem[_989 + 50 len 14] / (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_989 + 50 len 14] / (1000 * mem[_989 + 18 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1458 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1458] == bool(mem[_1458])
                        _1507 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1507 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1507 + 36] = 0
                        mem[_1507 + 68] = (998 * s * arg5 / 100 * Mask(112, 0, _1051) / (1000 * Mask(112, 0, _1025)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1507 + 100] = this.address
                        mem[_1507 + 132] = 128
                        mem[_1507 + 164] = mem[_1507]
                        t = 0
                        while t < mem[_1507]:
                            mem[t + _1507 + 196] = mem[_1507 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1507]) > mem[_1507]:
                            mem[_1507 + mem[_1507] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args 0, (998 * s * arg5 / 100 * Mask(112, 0, _1051) / (1000 * Mask(112, 0, _1025)) + (998 * s * arg5 / 100)) - arg6, address(this.address), 128, mem[_1507], mem[_1507 + 196 len ceil32(mem[_1507])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (998 * s * arg5 / 100 * Mask(112, 0, _1051) / (1000 * Mask(112, 0, _1025)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1051
                        t = _1025
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _859 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_859] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_859] - ext_call.return_data[0]
                else:
                    idx = 0
                    s = 0
                    s = 10^15 * arg3
                    t = 0
                    t = 0
                    while idx < arg4:
                        if s and arg5 > -1 / s:
                            revert with 0, 17
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(ext_call.return_data[0]))
                        staticcall address(ext_call.return_data[0]).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _908 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_908] < s * arg5 / 100:
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg1))
                            staticcall address(arg1).0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1028 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1028] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1028] - ext_call.return_data[0]
                            return memory
                              from mem[64]
                               len 32
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _991 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1027 = mem[_991]
                        require mem[_991] == mem[_991 + 18 len 14]
                        _1052 = mem[_991 + 32]
                        require mem[_991 + 32] == mem[_991 + 50 len 14]
                        require mem[_991 + 64] == mem[_991 + 92 len 4]
                        if s * arg5 / 100 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if mem[_991 + 50 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if mem[_991 + 18 len 14] <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if s * arg5 / 100 and 998 > -1 / s * arg5 / 100:
                            revert with 0, 17
                        if 998 * s * arg5 / 100 / 998 != s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if not mem[_991 + 18 len 14]:
                            if mem[_991 + 50 len 14] and 1000 > -1 / mem[_991 + 50 len 14]:
                                revert with 0, 17
                            if 1000 * mem[_991 + 50 len 14] / 1000 != mem[_991 + 50 len 14]:
                                revert with 0, 'MUL error'
                            if 1000 * mem[_991 + 50 len 14] > !(998 * s * arg5 / 100):
                                revert with 0, 17
                            if (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_991 + 50 len 14]:
                                revert with 0, 'Add error'
                            if not (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 18
                            if 0 / (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                                revert with 0, 17
                            if (0 / (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 0 / (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(arg2)
                            mem[mem[64] + 36] = s * arg5 / 100
                            require ext_code.size(address(ext_call.return_data[0]))
                            call address(ext_call.return_data[0]).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(arg2), s * arg5 / 100
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1364 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1364] == bool(mem[_1364])
                            _1436 = mem[64]
                            mem[64] = mem[64] + 32
                            mem[_1436 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1436 + 36] = (0 / (1000 * Mask(112, 0, _1052)) + (998 * s * arg5 / 100)) - arg6
                            mem[_1436 + 68] = 0
                            mem[_1436 + 100] = this.address
                            mem[_1436 + 132] = 128
                            mem[_1436 + 164] = mem[_1436]
                            t = 0
                            while t < mem[_1436]:
                                mem[t + _1436 + 196] = mem[_1436 + t + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_1436]) > mem[_1436]:
                                mem[_1436 + mem[_1436] + 196] = 0
                            require ext_code.size(address(arg2))
                            call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (0 / (1000 * Mask(112, 0, _1052)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1436], mem[_1436 + 196 len ceil32(mem[_1436])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = (0 / (1000 * Mask(112, 0, _1052)) + (998 * s * arg5 / 100)) - arg6
                            s = s * arg5 / 100
                            t = _1052
                            t = _1027
                            continue 
                        if 998 * s * arg5 / 100 and mem[_991 + 18 len 14] > -1 / 998 * s * arg5 / 100:
                            revert with 0, 17
                        if not mem[_991 + 18 len 14]:
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_991 + 18 len 14] / mem[_991 + 18 len 14] != 998 * s * arg5 / 100:
                            revert with 0, 'MUL error'
                        if mem[_991 + 50 len 14] and 1000 > -1 / mem[_991 + 50 len 14]:
                            revert with 0, 17
                        if 1000 * mem[_991 + 50 len 14] / 1000 != mem[_991 + 50 len 14]:
                            revert with 0, 'MUL error'
                        if 1000 * mem[_991 + 50 len 14] > !(998 * s * arg5 / 100):
                            revert with 0, 17
                        if (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100) < 1000 * mem[_991 + 50 len 14]:
                            revert with 0, 'Add error'
                        if not (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 18
                        if 998 * s * arg5 / 100 * mem[_991 + 18 len 14] / (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100) < arg6:
                            revert with 0, 17
                        if (998 * s * arg5 / 100 * mem[_991 + 18 len 14] / (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100)) - arg6 > 998 * s * arg5 / 100 * mem[_991 + 18 len 14] / (1000 * mem[_991 + 50 len 14]) + (998 * s * arg5 / 100):
                            revert with 0, 'SUB error'
                        mem[mem[64] + 4] = address(arg2)
                        mem[mem[64] + 36] = s * arg5 / 100
                        require ext_code.size(address(ext_call.return_data[0]))
                        call address(ext_call.return_data[0]).0xa9059cbb with:
                             gas gas_remaining wei
                            args address(arg2), s * arg5 / 100
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1460 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1460] == bool(mem[_1460])
                        _1508 = mem[64]
                        mem[64] = mem[64] + 32
                        mem[_1508 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1508 + 36] = (998 * s * arg5 / 100 * Mask(112, 0, _1027) / (1000 * Mask(112, 0, _1052)) + (998 * s * arg5 / 100)) - arg6
                        mem[_1508 + 68] = 0
                        mem[_1508 + 100] = this.address
                        mem[_1508 + 132] = 128
                        mem[_1508 + 164] = mem[_1508]
                        t = 0
                        while t < mem[_1508]:
                            mem[t + _1508 + 196] = mem[_1508 + t + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_1508]) > mem[_1508]:
                            mem[_1508 + mem[_1508] + 196] = 0
                        require ext_code.size(address(arg2))
                        call address(arg2).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                             gas gas_remaining wei
                            args (998 * s * arg5 / 100 * Mask(112, 0, _1027) / (1000 * Mask(112, 0, _1052)) + (998 * s * arg5 / 100)) - arg6, 0, address(this.address), 128, mem[_1508], mem[_1508 + 196 len ceil32(mem[_1508])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = (998 * s * arg5 / 100 * Mask(112, 0, _1027) / (1000 * Mask(112, 0, _1052)) + (998 * s * arg5 / 100)) - arg6
                        s = s * arg5 / 100
                        t = _1052
                        t = _1027
                        continue 
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _860 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_860] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_860] - ext_call.return_data[0]
    return memory
      from mem[64]
       len 32
}

function sub_74a7ae1b(?) {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if msg.sender == stor0:
        if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            revert with 0, 17
        if 2 * ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + 97] = 2 * ('cd', 4).length
        if not uint255(('cd', 4).length):
            if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                revert with 0, 17
            if 2 * ('cd', 4).length > test266151307():
                revert with 0, 65
            mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129] = 2 * ('cd', 4).length
            if uint255(('cd', 4).length):
                mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
                if ('cd', 4).length > test266151307():
                    revert with 0, 65
                mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
                mem[64] = ceil32(32 * ('cd', 4).length) + (163 * ('cd', 4).length) + 193
                if not ('cd', 4).length:
                    idx = 0
                    s = 0
                    t = 0
                    t = 0
                    t = 0
                    t = 0
                    t = 0
                    t = 0
                    while idx < ('cd', 4).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1718 = mem[(32 * idx) + 128]
                        require ext_code.size(mem[(32 * idx) + 140 len 20])
                        staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1810 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1861 = mem[_1810]
                        require mem[_1810] == mem[_1810 + 18 len 14]
                        _1930 = mem[_1810 + 32]
                        require mem[_1810 + 32] == mem[_1810 + 50 len 14]
                        require mem[_1810 + 64] == mem[_1810 + 92 len 4]
                        require ext_code.size(address(_1718))
                        staticcall address(_1718).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2098 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2146 = mem[_2098]
                        require mem[_2098] == mem[_2098 + 12 len 20]
                        require ext_code.size(address(_1718))
                        staticcall address(_1718).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2218 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2242 = mem[_2218]
                        require mem[_2218] == mem[_2218 + 12 len 20]
                        if Mask(112, 0, _1861) <= Mask(112, 0, _1930):
                            if Mask(112, 0, _1930) > 0x4189374bc6a7ef9db22d0e5604:
                                revert with 0, 17
                            if not Mask(112, 0, _1861):
                                revert with 0, 18
                            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2146)
                            if 1 > !s:
                                revert with 0, 17
                            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2242)
                            if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                                revert with 0, 50
                            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1861)
                            if 1 > !s:
                                revert with 0, 17
                            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                                revert with 0, 50
                            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1930)
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                                revert with 0, 50
                            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1930)) / Mask(112, 0, _1861))
                            if 2 > !s:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 2
                            t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1930)) / Mask(112, 0, _1861))
                            t = _2242
                            t = _2146
                            t = _1930
                            t = _1861
                            t = _1718
                            continue 
                        if Mask(112, 0, _1861) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1930):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2146)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2242)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1861)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1930)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1861)) / Mask(112, 0, _1930))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1861)) / Mask(112, 0, _1930))
                        t = _2242
                        t = _2146
                        t = _1930
                        t = _1861
                        t = _1718
                        continue 
                    _1786 = mem[64]
                    mem[mem[64]] = 96
                    _1834 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 129
                    t = mem[64] + 128
                    while idx < _1834:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1786 + 32] = (32 * _1834) + 128
                    _2530 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                    mem[_1786 + (32 * _1834) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                    t = _1786 + (32 * _1834) + 160
                    while idx < _2530:
                        mem[t] = mem[s + 18 len 14]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1786 + 64] = (32 * _1834) + (32 * _2530) + 160
                    _2674 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                    mem[_1786 + (32 * _1834) + (32 * _2530) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                    mem[_1786 + (32 * _1834) + (32 * _2530) + 192 len 32 * _2674] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2674]
                    return memory
                      from mem[64]
                       len _1786 + (32 * _1834) + (32 * _2530) + (32 * _2674) + -mem[64] + 192
                mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
                idx = 0
                s = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1721 = mem[(32 * idx) + 128]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1811 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1863 = mem[_1811]
                    require mem[_1811] == mem[_1811 + 18 len 14]
                    _1931 = mem[_1811 + 32]
                    require mem[_1811 + 32] == mem[_1811 + 50 len 14]
                    require mem[_1811 + 64] == mem[_1811 + 92 len 4]
                    require ext_code.size(address(_1721))
                    staticcall address(_1721).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2099 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2147 = mem[_2099]
                    require mem[_2099] == mem[_2099 + 12 len 20]
                    require ext_code.size(address(_1721))
                    staticcall address(_1721).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2219 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2243 = mem[_2219]
                    require mem[_2219] == mem[_2219 + 12 len 20]
                    if Mask(112, 0, _1863) <= Mask(112, 0, _1931):
                        if Mask(112, 0, _1931) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1863):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2147)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2243)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1863)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1931)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1931)) / Mask(112, 0, _1863))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1931)) / Mask(112, 0, _1863))
                        t = _2243
                        t = _2147
                        t = _1931
                        t = _1863
                        t = _1721
                        continue 
                    if Mask(112, 0, _1863) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1931):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2147)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2243)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1863)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1931)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1863)) / Mask(112, 0, _1931))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1863)) / Mask(112, 0, _1931))
                    t = _2243
                    t = _2147
                    t = _1931
                    t = _1863
                    t = _1721
                    continue 
                _1787 = mem[64]
                mem[mem[64]] = 96
                _1835 = mem[ceil32(32 * ('cd', 4).length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 129
                t = mem[64] + 128
                while idx < _1835:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1787 + 32] = (32 * _1835) + 128
                _2531 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                mem[_1787 + (32 * _1835) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                t = _1787 + (32 * _1835) + 160
                while idx < _2531:
                    mem[t] = mem[s + 18 len 14]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1787 + 64] = (32 * _1835) + (32 * _2531) + 160
                _2675 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1787 + (32 * _1835) + (32 * _2531) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1787 + (32 * _1835) + (32 * _2531) + 192 len 32 * _2675] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2675]
                return memory
                  from mem[64]
                   len _1787 + (32 * _1835) + (32 * _2531) + (32 * _2675) + -mem[64] + 192
            if ('cd', 4).length > test266151307():
                revert with 0, 65
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
            mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
            if ('cd', 4).length:
                mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
                idx = 0
                s = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1715 = mem[(32 * idx) + 128]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1809 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1859 = mem[_1809]
                    require mem[_1809] == mem[_1809 + 18 len 14]
                    _1929 = mem[_1809 + 32]
                    require mem[_1809 + 32] == mem[_1809 + 50 len 14]
                    require mem[_1809 + 64] == mem[_1809 + 92 len 4]
                    require ext_code.size(address(_1715))
                    staticcall address(_1715).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2097 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2145 = mem[_2097]
                    require mem[_2097] == mem[_2097 + 12 len 20]
                    require ext_code.size(address(_1715))
                    staticcall address(_1715).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2217 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2241 = mem[_2217]
                    require mem[_2217] == mem[_2217 + 12 len 20]
                    if Mask(112, 0, _1859) <= Mask(112, 0, _1929):
                        if Mask(112, 0, _1929) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1859):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2145)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2241)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1859)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1929)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1929)) / Mask(112, 0, _1859))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1929)) / Mask(112, 0, _1859))
                        t = _2241
                        t = _2145
                        t = _1929
                        t = _1859
                        t = _1715
                        continue 
                    if Mask(112, 0, _1859) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1929):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2145)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2241)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1859)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1929)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1859)) / Mask(112, 0, _1929))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1859)) / Mask(112, 0, _1929))
                    t = _2241
                    t = _2145
                    t = _1929
                    t = _1859
                    t = _1715
                    continue 
                _1785 = mem[64]
                mem[mem[64]] = 96
                _1833 = mem[ceil32(32 * ('cd', 4).length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 129
                t = mem[64] + 128
                while idx < _1833:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 32] = (32 * _1833) + 128
                _2529 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                mem[_1785 + (32 * _1833) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                t = _1785 + (32 * _1833) + 160
                while idx < _2529:
                    mem[t] = mem[s + 18 len 14]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1785 + 64] = (32 * _1833) + (32 * _2529) + 160
                _2673 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1785 + (32 * _1833) + (32 * _2529) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1785 + (32 * _1833) + (32 * _2529) + 192 len 32 * _2673] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2673]
                return memory
                  from mem[64]
                   len _1785 + (32 * _1833) + (32 * _2529) + (32 * _2673) + -mem[64] + 192
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1712 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1808 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1857 = mem[_1808]
                require mem[_1808] == mem[_1808 + 18 len 14]
                _1928 = mem[_1808 + 32]
                require mem[_1808 + 32] == mem[_1808 + 50 len 14]
                require mem[_1808 + 64] == mem[_1808 + 92 len 4]
                require ext_code.size(address(_1712))
                staticcall address(_1712).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2096 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2144 = mem[_2096]
                require mem[_2096] == mem[_2096 + 12 len 20]
                require ext_code.size(address(_1712))
                staticcall address(_1712).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2216 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2240 = mem[_2216]
                require mem[_2216] == mem[_2216 + 12 len 20]
                if Mask(112, 0, _1857) <= Mask(112, 0, _1928):
                    if Mask(112, 0, _1928) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1857):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2144)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2240)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1857)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1928)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1928)) / Mask(112, 0, _1857))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1928)) / Mask(112, 0, _1857))
                    t = _2240
                    t = _2144
                    t = _1928
                    t = _1857
                    t = _1712
                    continue 
                if Mask(112, 0, _1857) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1928):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2144)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2240)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1857)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1928)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1857)) / Mask(112, 0, _1928))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1857)) / Mask(112, 0, _1928))
                t = _2240
                t = _2144
                t = _1928
                t = _1857
                t = _1712
                continue 
            _1784 = mem[64]
            mem[mem[64]] = 96
            _1832 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1832:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1784 + 32] = (32 * _1832) + 128
            _2528 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1784 + (32 * _1832) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1784 + (32 * _1832) + 160
            while idx < _2528:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1784 + 64] = (32 * _1832) + (32 * _2528) + 160
            _2672 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1784 + (32 * _1832) + (32 * _2528) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1784 + (32 * _1832) + (32 * _2528) + 192 len 32 * _2672] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2672]
            var55001 = _2672
            var55002 = ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + (32 * _2672) + 193
            var55007 = _1784 + (32 * _1832) + (32 * _2528) + (32 * _2672) + 192
            return memory
              from mem[64]
               len _1784 + (32 * _1832) + (32 * _2528) + (32 * _2672) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + 129 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
        if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            revert with 0, 17
        if 2 * ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129] = 2 * ('cd', 4).length
        if not uint255(('cd', 4).length):
            if ('cd', 4).length > test266151307():
                revert with 0, 65
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
            mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
            if not ('cd', 4).length:
                idx = 0
                s = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1724 = mem[(32 * idx) + 128]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1812 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1865 = mem[_1812]
                    require mem[_1812] == mem[_1812 + 18 len 14]
                    _1932 = mem[_1812 + 32]
                    require mem[_1812 + 32] == mem[_1812 + 50 len 14]
                    require mem[_1812 + 64] == mem[_1812 + 92 len 4]
                    require ext_code.size(address(_1724))
                    staticcall address(_1724).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2100 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2148 = mem[_2100]
                    require mem[_2100] == mem[_2100 + 12 len 20]
                    require ext_code.size(address(_1724))
                    staticcall address(_1724).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2220 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2244 = mem[_2220]
                    require mem[_2220] == mem[_2220 + 12 len 20]
                    if Mask(112, 0, _1865) <= Mask(112, 0, _1932):
                        if Mask(112, 0, _1932) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1865):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2148)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2244)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1865)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1932)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1932)) / Mask(112, 0, _1865))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1932)) / Mask(112, 0, _1865))
                        t = _2244
                        t = _2148
                        t = _1932
                        t = _1865
                        t = _1724
                        continue 
                    if Mask(112, 0, _1865) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1932):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2148)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2244)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1865)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1932)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1865)) / Mask(112, 0, _1932))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1865)) / Mask(112, 0, _1932))
                    t = _2244
                    t = _2148
                    t = _1932
                    t = _1865
                    t = _1724
                    continue 
                _1788 = mem[64]
                mem[mem[64]] = 96
                _1836 = mem[ceil32(32 * ('cd', 4).length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 129
                t = mem[64] + 128
                while idx < _1836:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 32] = (32 * _1836) + 128
                _2532 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                mem[_1788 + (32 * _1836) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                t = _1788 + (32 * _1836) + 160
                while idx < _2532:
                    mem[t] = mem[s + 18 len 14]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1788 + 64] = (32 * _1836) + (32 * _2532) + 160
                _2676 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1788 + (32 * _1836) + (32 * _2532) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1788 + (32 * _1836) + (32 * _2532) + 192 len 32 * _2676] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2676]
                return memory
                  from mem[64]
                   len _1788 + (32 * _1836) + (32 * _2532) + (32 * _2676) + -mem[64] + 192
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1727 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1813 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1867 = mem[_1813]
                require mem[_1813] == mem[_1813 + 18 len 14]
                _1933 = mem[_1813 + 32]
                require mem[_1813 + 32] == mem[_1813 + 50 len 14]
                require mem[_1813 + 64] == mem[_1813 + 92 len 4]
                require ext_code.size(address(_1727))
                staticcall address(_1727).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2101 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2149 = mem[_2101]
                require mem[_2101] == mem[_2101 + 12 len 20]
                require ext_code.size(address(_1727))
                staticcall address(_1727).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2221 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2245 = mem[_2221]
                require mem[_2221] == mem[_2221 + 12 len 20]
                if Mask(112, 0, _1867) <= Mask(112, 0, _1933):
                    if Mask(112, 0, _1933) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1867):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2149)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2245)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1867)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1933)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1933)) / Mask(112, 0, _1867))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1933)) / Mask(112, 0, _1867))
                    t = _2245
                    t = _2149
                    t = _1933
                    t = _1867
                    t = _1727
                    continue 
                if Mask(112, 0, _1867) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1933):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2149)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2245)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1867)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1933)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1867)) / Mask(112, 0, _1933))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1867)) / Mask(112, 0, _1933))
                t = _2245
                t = _2149
                t = _1933
                t = _1867
                t = _1727
                continue 
            _1789 = mem[64]
            mem[mem[64]] = 96
            _1837 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1837:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _1837) + 128
            _2533 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1789 + (32 * _1837) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1789 + (32 * _1837) + 160
            while idx < _2533:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1789 + 64] = (32 * _1837) + (32 * _2533) + 160
            _2677 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1789 + (32 * _1837) + (32 * _2533) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1789 + (32 * _1837) + (32 * _2533) + 192 len 32 * _2677] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2677]
            return memory
              from mem[64]
               len _1789 + (32 * _1837) + (32 * _2533) + (32 * _2677) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
        if ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
        mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
        if not ('cd', 4).length:
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1730 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1814 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1869 = mem[_1814]
                require mem[_1814] == mem[_1814 + 18 len 14]
                _1934 = mem[_1814 + 32]
                require mem[_1814 + 32] == mem[_1814 + 50 len 14]
                require mem[_1814 + 64] == mem[_1814 + 92 len 4]
                require ext_code.size(address(_1730))
                staticcall address(_1730).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2102 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2150 = mem[_2102]
                require mem[_2102] == mem[_2102 + 12 len 20]
                require ext_code.size(address(_1730))
                staticcall address(_1730).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2222 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2246 = mem[_2222]
                require mem[_2222] == mem[_2222 + 12 len 20]
                if Mask(112, 0, _1869) <= Mask(112, 0, _1934):
                    if Mask(112, 0, _1934) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1869):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2150)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2246)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1869)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1934)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1934)) / Mask(112, 0, _1869))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1934)) / Mask(112, 0, _1869))
                    t = _2246
                    t = _2150
                    t = _1934
                    t = _1869
                    t = _1730
                    continue 
                if Mask(112, 0, _1869) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1934):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2150)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2246)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1869)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1934)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1869)) / Mask(112, 0, _1934))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1869)) / Mask(112, 0, _1934))
                t = _2246
                t = _2150
                t = _1934
                t = _1869
                t = _1730
                continue 
            _1790 = mem[64]
            mem[mem[64]] = 96
            _1838 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1838:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _1838) + 128
            _2534 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1790 + (32 * _1838) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1790 + (32 * _1838) + 160
            while idx < _2534:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1790 + 64] = (32 * _1838) + (32 * _2534) + 160
            _2678 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1790 + (32 * _1838) + (32 * _2534) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1790 + (32 * _1838) + (32 * _2534) + 192 len 32 * _2678] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2678]
            return memory
              from mem[64]
               len _1790 + (32 * _1838) + (32 * _2534) + (32 * _2678) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        idx = 0
        s = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _1733 = mem[(32 * idx) + 128]
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1815 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1871 = mem[_1815]
            require mem[_1815] == mem[_1815 + 18 len 14]
            _1935 = mem[_1815 + 32]
            require mem[_1815 + 32] == mem[_1815 + 50 len 14]
            require mem[_1815 + 64] == mem[_1815 + 92 len 4]
            require ext_code.size(address(_1733))
            staticcall address(_1733).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2103 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2151 = mem[_2103]
            require mem[_2103] == mem[_2103 + 12 len 20]
            require ext_code.size(address(_1733))
            staticcall address(_1733).token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2223 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2247 = mem[_2223]
            require mem[_2223] == mem[_2223 + 12 len 20]
            if Mask(112, 0, _1871) <= Mask(112, 0, _1935):
                if Mask(112, 0, _1935) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1871):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2151)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2247)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1871)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1935)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1935)) / Mask(112, 0, _1871))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1935)) / Mask(112, 0, _1871))
                t = _2247
                t = _2151
                t = _1935
                t = _1871
                t = _1733
                continue 
            if Mask(112, 0, _1871) > 0x4189374bc6a7ef9db22d0e5604:
                revert with 0, 17
            if not Mask(112, 0, _1935):
                revert with 0, 18
            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2151)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2247)
            if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1871)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1935)
            if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1871)) / Mask(112, 0, _1935))
            if 2 > !s:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 2
            t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1871)) / Mask(112, 0, _1935))
            t = _2247
            t = _2151
            t = _1935
            t = _1871
            t = _1733
            continue 
        _1791 = mem[64]
        mem[mem[64]] = 96
        _1839 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 128
        while idx < _1839:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _1839) + 128
        _2535 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        mem[_1791 + (32 * _1839) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
        t = _1791 + (32 * _1839) + 160
        while idx < _2535:
            mem[t] = mem[s + 18 len 14]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_1791 + 64] = (32 * _1839) + (32 * _2535) + 160
        _2679 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1791 + (32 * _1839) + (32 * _2535) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1791 + (32 * _1839) + (32 * _2535) + 192 len 32 * _2679] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2679]
        return memory
          from mem[64]
           len _1791 + (32 * _1839) + (32 * _2535) + (32 * _2679) + -mem[64] + 192
    if msg.sender == stor2:
        if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            revert with 0, 17
        if 2 * ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + 97] = 2 * ('cd', 4).length
        if not uint255(('cd', 4).length):
            if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
                revert with 0, 17
            if 2 * ('cd', 4).length > test266151307():
                revert with 0, 65
            mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129] = 2 * ('cd', 4).length
            if not uint255(('cd', 4).length):
                if ('cd', 4).length > test266151307():
                    revert with 0, 65
                mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
                mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
                if not ('cd', 4).length:
                    idx = 0
                    s = 0
                    t = 0
                    t = 0
                    t = 0
                    t = 0
                    t = 0
                    t = 0
                    while idx < ('cd', 4).length:
                        if idx >= mem[96]:
                            revert with 0, 50
                        _1736 = mem[(32 * idx) + 128]
                        require ext_code.size(mem[(32 * idx) + 140 len 20])
                        staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1816 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1873 = mem[_1816]
                        require mem[_1816] == mem[_1816 + 18 len 14]
                        _1936 = mem[_1816 + 32]
                        require mem[_1816 + 32] == mem[_1816 + 50 len 14]
                        require mem[_1816 + 64] == mem[_1816 + 92 len 4]
                        require ext_code.size(address(_1736))
                        staticcall address(_1736).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2104 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2152 = mem[_2104]
                        require mem[_2104] == mem[_2104 + 12 len 20]
                        require ext_code.size(address(_1736))
                        staticcall address(_1736).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2224 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2248 = mem[_2224]
                        require mem[_2224] == mem[_2224 + 12 len 20]
                        if Mask(112, 0, _1873) <= Mask(112, 0, _1936):
                            if Mask(112, 0, _1936) > 0x4189374bc6a7ef9db22d0e5604:
                                revert with 0, 17
                            if not Mask(112, 0, _1873):
                                revert with 0, 18
                            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2152)
                            if 1 > !s:
                                revert with 0, 17
                            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                                revert with 0, 50
                            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2248)
                            if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                                revert with 0, 50
                            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1873)
                            if 1 > !s:
                                revert with 0, 17
                            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                                revert with 0, 50
                            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1936)
                            if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                                revert with 0, 50
                            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1936)) / Mask(112, 0, _1873))
                            if 2 > !s:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + 2
                            t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1936)) / Mask(112, 0, _1873))
                            t = _2248
                            t = _2152
                            t = _1936
                            t = _1873
                            t = _1736
                            continue 
                        if Mask(112, 0, _1873) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1936):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2152)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2248)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1873)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1936)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1873)) / Mask(112, 0, _1936))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1873)) / Mask(112, 0, _1936))
                        t = _2248
                        t = _2152
                        t = _1936
                        t = _1873
                        t = _1736
                        continue 
                    _1792 = mem[64]
                    mem[mem[64]] = 96
                    _1840 = mem[ceil32(32 * ('cd', 4).length) + 97]
                    mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + 129
                    t = mem[64] + 128
                    while idx < _1840:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1792 + 32] = (32 * _1840) + 128
                    _2536 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                    mem[_1792 + (32 * _1840) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                    idx = 0
                    s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                    t = _1792 + (32 * _1840) + 160
                    while idx < _2536:
                        mem[t] = mem[s + 18 len 14]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[_1792 + 64] = (32 * _1840) + (32 * _2536) + 160
                    _2680 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                    mem[_1792 + (32 * _1840) + (32 * _2536) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                    mem[_1792 + (32 * _1840) + (32 * _2536) + 192 len 32 * _2680] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2680]
                    return memory
                      from mem[64]
                       len _1792 + (32 * _1840) + (32 * _2536) + (32 * _2680) + -mem[64] + 192
                mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
                idx = 0
                s = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1739 = mem[(32 * idx) + 128]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1817 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1875 = mem[_1817]
                    require mem[_1817] == mem[_1817 + 18 len 14]
                    _1937 = mem[_1817 + 32]
                    require mem[_1817 + 32] == mem[_1817 + 50 len 14]
                    require mem[_1817 + 64] == mem[_1817 + 92 len 4]
                    require ext_code.size(address(_1739))
                    staticcall address(_1739).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2105 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2153 = mem[_2105]
                    require mem[_2105] == mem[_2105 + 12 len 20]
                    require ext_code.size(address(_1739))
                    staticcall address(_1739).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2225 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2249 = mem[_2225]
                    require mem[_2225] == mem[_2225 + 12 len 20]
                    if Mask(112, 0, _1875) <= Mask(112, 0, _1937):
                        if Mask(112, 0, _1937) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1875):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2153)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2249)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1875)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1937)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1937)) / Mask(112, 0, _1875))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1937)) / Mask(112, 0, _1875))
                        t = _2249
                        t = _2153
                        t = _1937
                        t = _1875
                        t = _1739
                        continue 
                    if Mask(112, 0, _1875) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1937):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2153)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2249)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1875)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1937)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1875)) / Mask(112, 0, _1937))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1875)) / Mask(112, 0, _1937))
                    t = _2249
                    t = _2153
                    t = _1937
                    t = _1875
                    t = _1739
                    continue 
                _1793 = mem[64]
                mem[mem[64]] = 96
                _1841 = mem[ceil32(32 * ('cd', 4).length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 129
                t = mem[64] + 128
                while idx < _1841:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 32] = (32 * _1841) + 128
                _2537 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                mem[_1793 + (32 * _1841) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                t = _1793 + (32 * _1841) + 160
                while idx < _2537:
                    mem[t] = mem[s + 18 len 14]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1793 + 64] = (32 * _1841) + (32 * _2537) + 160
                _2681 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1793 + (32 * _1841) + (32 * _2537) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1793 + (32 * _1841) + (32 * _2537) + 192 len 32 * _2681] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2681]
                return memory
                  from mem[64]
                   len _1793 + (32 * _1841) + (32 * _2537) + (32 * _2681) + -mem[64] + 192
            mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
            if ('cd', 4).length > test266151307():
                revert with 0, 65
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
            mem[64] = ceil32(32 * ('cd', 4).length) + (163 * ('cd', 4).length) + 193
            if not ('cd', 4).length:
                idx = 0
                s = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1742 = mem[(32 * idx) + 128]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1818 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1877 = mem[_1818]
                    require mem[_1818] == mem[_1818 + 18 len 14]
                    _1938 = mem[_1818 + 32]
                    require mem[_1818 + 32] == mem[_1818 + 50 len 14]
                    require mem[_1818 + 64] == mem[_1818 + 92 len 4]
                    require ext_code.size(address(_1742))
                    staticcall address(_1742).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2106 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2154 = mem[_2106]
                    require mem[_2106] == mem[_2106 + 12 len 20]
                    require ext_code.size(address(_1742))
                    staticcall address(_1742).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2226 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2250 = mem[_2226]
                    require mem[_2226] == mem[_2226 + 12 len 20]
                    if Mask(112, 0, _1877) <= Mask(112, 0, _1938):
                        if Mask(112, 0, _1938) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1877):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2154)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2250)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1877)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1938)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1938)) / Mask(112, 0, _1877))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1938)) / Mask(112, 0, _1877))
                        t = _2250
                        t = _2154
                        t = _1938
                        t = _1877
                        t = _1742
                        continue 
                    if Mask(112, 0, _1877) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1938):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2154)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2250)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1877)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1938)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1877)) / Mask(112, 0, _1938))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1877)) / Mask(112, 0, _1938))
                    t = _2250
                    t = _2154
                    t = _1938
                    t = _1877
                    t = _1742
                    continue 
                _1794 = mem[64]
                mem[mem[64]] = 96
                _1842 = mem[ceil32(32 * ('cd', 4).length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 129
                t = mem[64] + 128
                while idx < _1842:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 32] = (32 * _1842) + 128
                _2538 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                mem[_1794 + (32 * _1842) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                t = _1794 + (32 * _1842) + 160
                while idx < _2538:
                    mem[t] = mem[s + 18 len 14]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1794 + 64] = (32 * _1842) + (32 * _2538) + 160
                _2682 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1794 + (32 * _1842) + (32 * _2538) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1794 + (32 * _1842) + (32 * _2538) + 192 len 32 * _2682] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2682]
                return memory
                  from mem[64]
                   len _1794 + (32 * _1842) + (32 * _2538) + (32 * _2682) + -mem[64] + 192
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1745 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1819 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1879 = mem[_1819]
                require mem[_1819] == mem[_1819 + 18 len 14]
                _1939 = mem[_1819 + 32]
                require mem[_1819 + 32] == mem[_1819 + 50 len 14]
                require mem[_1819 + 64] == mem[_1819 + 92 len 4]
                require ext_code.size(address(_1745))
                staticcall address(_1745).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2107 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2155 = mem[_2107]
                require mem[_2107] == mem[_2107 + 12 len 20]
                require ext_code.size(address(_1745))
                staticcall address(_1745).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2227 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2251 = mem[_2227]
                require mem[_2227] == mem[_2227 + 12 len 20]
                if Mask(112, 0, _1879) <= Mask(112, 0, _1939):
                    if Mask(112, 0, _1939) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1879):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2155)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2251)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1879)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1939)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1939)) / Mask(112, 0, _1879))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1939)) / Mask(112, 0, _1879))
                    t = _2251
                    t = _2155
                    t = _1939
                    t = _1879
                    t = _1745
                    continue 
                if Mask(112, 0, _1879) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1939):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2155)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2251)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1879)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1939)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1879)) / Mask(112, 0, _1939))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1879)) / Mask(112, 0, _1939))
                t = _2251
                t = _2155
                t = _1939
                t = _1879
                t = _1745
                continue 
            _1795 = mem[64]
            mem[mem[64]] = 96
            _1843 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1843:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _1843) + 128
            _2539 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1795 + (32 * _1843) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1795 + (32 * _1843) + 160
            while idx < _2539:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1795 + 64] = (32 * _1843) + (32 * _2539) + 160
            _2683 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1795 + (32 * _1843) + (32 * _2539) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1795 + (32 * _1843) + (32 * _2539) + 192 len 32 * _2683] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2683]
            return memory
              from mem[64]
               len _1795 + (32 * _1843) + (32 * _2539) + (32 * _2683) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + 129 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
        if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            revert with 0, 17
        if 2 * ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129] = 2 * ('cd', 4).length
        if not uint255(('cd', 4).length):
            if ('cd', 4).length > test266151307():
                revert with 0, 65
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
            mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
            if not ('cd', 4).length:
                idx = 0
                s = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1748 = mem[(32 * idx) + 128]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1820 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1881 = mem[_1820]
                    require mem[_1820] == mem[_1820 + 18 len 14]
                    _1940 = mem[_1820 + 32]
                    require mem[_1820 + 32] == mem[_1820 + 50 len 14]
                    require mem[_1820 + 64] == mem[_1820 + 92 len 4]
                    require ext_code.size(address(_1748))
                    staticcall address(_1748).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2108 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2156 = mem[_2108]
                    require mem[_2108] == mem[_2108 + 12 len 20]
                    require ext_code.size(address(_1748))
                    staticcall address(_1748).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2228 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2252 = mem[_2228]
                    require mem[_2228] == mem[_2228 + 12 len 20]
                    if Mask(112, 0, _1881) <= Mask(112, 0, _1940):
                        if Mask(112, 0, _1940) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1881):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2156)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2252)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1881)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1940)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1940)) / Mask(112, 0, _1881))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1940)) / Mask(112, 0, _1881))
                        t = _2252
                        t = _2156
                        t = _1940
                        t = _1881
                        t = _1748
                        continue 
                    if Mask(112, 0, _1881) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1940):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2156)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2252)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1881)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1940)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1881)) / Mask(112, 0, _1940))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1881)) / Mask(112, 0, _1940))
                    t = _2252
                    t = _2156
                    t = _1940
                    t = _1881
                    t = _1748
                    continue 
                _1796 = mem[64]
                mem[mem[64]] = 96
                _1844 = mem[ceil32(32 * ('cd', 4).length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 129
                t = mem[64] + 128
                while idx < _1844:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[mem[64] + 32] = (32 * _1844) + 128
                _2540 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                mem[_1796 + (32 * _1844) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                t = _1796 + (32 * _1844) + 160
                while idx < _2540:
                    mem[t] = mem[s + 18 len 14]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1796 + 64] = (32 * _1844) + (32 * _2540) + 160
                _2684 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1796 + (32 * _1844) + (32 * _2540) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1796 + (32 * _1844) + (32 * _2540) + 192 len 32 * _2684] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2684]
                return memory
                  from mem[64]
                   len _1796 + (32 * _1844) + (32 * _2540) + (32 * _2684) + -mem[64] + 192
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1751 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1821 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1883 = mem[_1821]
                require mem[_1821] == mem[_1821 + 18 len 14]
                _1941 = mem[_1821 + 32]
                require mem[_1821 + 32] == mem[_1821 + 50 len 14]
                require mem[_1821 + 64] == mem[_1821 + 92 len 4]
                require ext_code.size(address(_1751))
                staticcall address(_1751).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2109 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2157 = mem[_2109]
                require mem[_2109] == mem[_2109 + 12 len 20]
                require ext_code.size(address(_1751))
                staticcall address(_1751).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2229 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2253 = mem[_2229]
                require mem[_2229] == mem[_2229 + 12 len 20]
                if Mask(112, 0, _1883) <= Mask(112, 0, _1941):
                    if Mask(112, 0, _1941) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1883):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2157)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2253)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1883)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1941)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1941)) / Mask(112, 0, _1883))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1941)) / Mask(112, 0, _1883))
                    t = _2253
                    t = _2157
                    t = _1941
                    t = _1883
                    t = _1751
                    continue 
                if Mask(112, 0, _1883) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1941):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2157)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2253)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1883)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1941)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1883)) / Mask(112, 0, _1941))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1883)) / Mask(112, 0, _1941))
                t = _2253
                t = _2157
                t = _1941
                t = _1883
                t = _1751
                continue 
            _1797 = mem[64]
            mem[mem[64]] = 96
            _1845 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1845:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _1845) + 128
            _2541 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1797 + (32 * _1845) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1797 + (32 * _1845) + 160
            while idx < _2541:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1797 + 64] = (32 * _1845) + (32 * _2541) + 160
            _2685 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1797 + (32 * _1845) + (32 * _2541) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1797 + (32 * _1845) + (32 * _2541) + 192 len 32 * _2685] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2685]
            return memory
              from mem[64]
               len _1797 + (32 * _1845) + (32 * _2541) + (32 * _2685) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
        if ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
        mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
        if not ('cd', 4).length:
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1754 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1822 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1885 = mem[_1822]
                require mem[_1822] == mem[_1822 + 18 len 14]
                _1942 = mem[_1822 + 32]
                require mem[_1822 + 32] == mem[_1822 + 50 len 14]
                require mem[_1822 + 64] == mem[_1822 + 92 len 4]
                require ext_code.size(address(_1754))
                staticcall address(_1754).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2110 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2158 = mem[_2110]
                require mem[_2110] == mem[_2110 + 12 len 20]
                require ext_code.size(address(_1754))
                staticcall address(_1754).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2230 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2254 = mem[_2230]
                require mem[_2230] == mem[_2230 + 12 len 20]
                if Mask(112, 0, _1885) <= Mask(112, 0, _1942):
                    if Mask(112, 0, _1942) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1885):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2158)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2254)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1885)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1942)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1942)) / Mask(112, 0, _1885))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1942)) / Mask(112, 0, _1885))
                    t = _2254
                    t = _2158
                    t = _1942
                    t = _1885
                    t = _1754
                    continue 
                if Mask(112, 0, _1885) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1942):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2158)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2254)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1885)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1942)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1885)) / Mask(112, 0, _1942))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1885)) / Mask(112, 0, _1942))
                t = _2254
                t = _2158
                t = _1942
                t = _1885
                t = _1754
                continue 
            _1798 = mem[64]
            mem[mem[64]] = 96
            _1846 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1846:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _1846) + 128
            _2542 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1798 + (32 * _1846) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1798 + (32 * _1846) + 160
            while idx < _2542:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1798 + 64] = (32 * _1846) + (32 * _2542) + 160
            _2686 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1798 + (32 * _1846) + (32 * _2542) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1798 + (32 * _1846) + (32 * _2542) + 192 len 32 * _2686] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2686]
            return memory
              from mem[64]
               len _1798 + (32 * _1846) + (32 * _2542) + (32 * _2686) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        idx = 0
        s = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _1757 = mem[(32 * idx) + 128]
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1823 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1887 = mem[_1823]
            require mem[_1823] == mem[_1823 + 18 len 14]
            _1943 = mem[_1823 + 32]
            require mem[_1823 + 32] == mem[_1823 + 50 len 14]
            require mem[_1823 + 64] == mem[_1823 + 92 len 4]
            require ext_code.size(address(_1757))
            staticcall address(_1757).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2111 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2159 = mem[_2111]
            require mem[_2111] == mem[_2111 + 12 len 20]
            require ext_code.size(address(_1757))
            staticcall address(_1757).token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2231 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2255 = mem[_2231]
            require mem[_2231] == mem[_2231 + 12 len 20]
            if Mask(112, 0, _1887) <= Mask(112, 0, _1943):
                if Mask(112, 0, _1943) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1887):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2159)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2255)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1887)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1943)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1943)) / Mask(112, 0, _1887))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1943)) / Mask(112, 0, _1887))
                t = _2255
                t = _2159
                t = _1943
                t = _1887
                t = _1757
                continue 
            if Mask(112, 0, _1887) > 0x4189374bc6a7ef9db22d0e5604:
                revert with 0, 17
            if not Mask(112, 0, _1943):
                revert with 0, 18
            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2159)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2255)
            if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1887)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1943)
            if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1887)) / Mask(112, 0, _1943))
            if 2 > !s:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 2
            t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1887)) / Mask(112, 0, _1943))
            t = _2255
            t = _2159
            t = _1943
            t = _1887
            t = _1757
            continue 
        _1799 = mem[64]
        mem[mem[64]] = 96
        _1847 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 128
        while idx < _1847:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _1847) + 128
        _2543 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        mem[_1799 + (32 * _1847) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
        t = _1799 + (32 * _1847) + 160
        while idx < _2543:
            mem[t] = mem[s + 18 len 14]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_1799 + 64] = (32 * _1847) + (32 * _2543) + 160
        _2687 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1799 + (32 * _1847) + (32 * _2543) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1799 + (32 * _1847) + (32 * _2543) + 192 len 32 * _2687] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2687]
        return memory
          from mem[64]
           len _1799 + (32 * _1847) + (32 * _2543) + (32 * _2687) + -mem[64] + 192
    mem[0] = msg.sender
    mem[32] = 3
    if bool(stor3[msg.sender]) != 1:
        revert with 0, 'Not authorized'
    if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
        revert with 0, 17
    if 2 * ('cd', 4).length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = 2 * ('cd', 4).length
    if not uint255(('cd', 4).length):
        if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
            revert with 0, 17
        if 2 * ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129] = 2 * ('cd', 4).length
        if not uint255(('cd', 4).length):
            if ('cd', 4).length > test266151307():
                revert with 0, 65
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
            mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
            if not ('cd', 4).length:
                idx = 0
                s = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                t = 0
                while idx < ('cd', 4).length:
                    if idx >= mem[96]:
                        revert with 0, 50
                    _1760 = mem[(32 * idx) + 128]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1824 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1889 = mem[_1824]
                    require mem[_1824] == mem[_1824 + 18 len 14]
                    _1944 = mem[_1824 + 32]
                    require mem[_1824 + 32] == mem[_1824 + 50 len 14]
                    require mem[_1824 + 64] == mem[_1824 + 92 len 4]
                    require ext_code.size(address(_1760))
                    staticcall address(_1760).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2112 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2160 = mem[_2112]
                    require mem[_2112] == mem[_2112 + 12 len 20]
                    require ext_code.size(address(_1760))
                    staticcall address(_1760).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2232 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2256 = mem[_2232]
                    require mem[_2232] == mem[_2232 + 12 len 20]
                    if Mask(112, 0, _1889) <= Mask(112, 0, _1944):
                        if Mask(112, 0, _1944) > 0x4189374bc6a7ef9db22d0e5604:
                            revert with 0, 17
                        if not Mask(112, 0, _1889):
                            revert with 0, 18
                        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2160)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2256)
                        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1889)
                        if 1 > !s:
                            revert with 0, 17
                        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                            revert with 0, 50
                        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1944)
                        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                            revert with 0, 50
                        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1944)) / Mask(112, 0, _1889))
                        if 2 > !s:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + 2
                        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1944)) / Mask(112, 0, _1889))
                        t = _2256
                        t = _2160
                        t = _1944
                        t = _1889
                        t = _1760
                        continue 
                    if Mask(112, 0, _1889) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1944):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2160)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2256)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1889)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1944)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1889)) / Mask(112, 0, _1944))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1889)) / Mask(112, 0, _1944))
                    t = _2256
                    t = _2160
                    t = _1944
                    t = _1889
                    t = _1760
                    continue 
                _1800 = mem[64]
                mem[mem[64]] = 96
                _1848 = mem[ceil32(32 * ('cd', 4).length) + 97]
                mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + 129
                t = mem[64] + 128
                while idx < _1848:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1800 + 32] = (32 * _1848) + 128
                _2544 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                mem[_1800 + (32 * _1848) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
                idx = 0
                s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
                t = _1800 + (32 * _1848) + 160
                while idx < _2544:
                    mem[t] = mem[s + 18 len 14]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[_1800 + 64] = (32 * _1848) + (32 * _2544) + 160
                _2688 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1800 + (32 * _1848) + (32 * _2544) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
                mem[_1800 + (32 * _1848) + (32 * _2544) + 192 len 32 * _2688] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2688]
                return memory
                  from mem[64]
                   len _1800 + (32 * _1848) + (32 * _2544) + (32 * _2688) + -mem[64] + 192
            mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1763 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1825 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1891 = mem[_1825]
                require mem[_1825] == mem[_1825 + 18 len 14]
                _1945 = mem[_1825 + 32]
                require mem[_1825 + 32] == mem[_1825 + 50 len 14]
                require mem[_1825 + 64] == mem[_1825 + 92 len 4]
                require ext_code.size(address(_1763))
                staticcall address(_1763).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2113 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2161 = mem[_2113]
                require mem[_2113] == mem[_2113 + 12 len 20]
                require ext_code.size(address(_1763))
                staticcall address(_1763).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2233 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2257 = mem[_2233]
                require mem[_2233] == mem[_2233 + 12 len 20]
                if Mask(112, 0, _1891) <= Mask(112, 0, _1945):
                    if Mask(112, 0, _1945) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1891):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2161)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2257)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1891)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1945)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1945)) / Mask(112, 0, _1891))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1945)) / Mask(112, 0, _1891))
                    t = _2257
                    t = _2161
                    t = _1945
                    t = _1891
                    t = _1763
                    continue 
                if Mask(112, 0, _1891) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1945):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2161)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2257)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1891)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1945)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1891)) / Mask(112, 0, _1945))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1891)) / Mask(112, 0, _1945))
                t = _2257
                t = _2161
                t = _1945
                t = _1891
                t = _1763
                continue 
            _1801 = mem[64]
            mem[mem[64]] = 96
            _1849 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1849:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1801 + 32] = (32 * _1849) + 128
            _2545 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1801 + (32 * _1849) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1801 + (32 * _1849) + 160
            while idx < _2545:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1801 + 64] = (32 * _1849) + (32 * _2545) + 160
            _2689 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1801 + (32 * _1849) + (32 * _2545) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1801 + (32 * _1849) + (32 * _2545) + 192 len 32 * _2689] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2689]
            return memory
              from mem[64]
               len _1801 + (32 * _1849) + (32 * _2545) + (32 * _2689) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
        if ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
        mem[64] = ceil32(32 * ('cd', 4).length) + (163 * ('cd', 4).length) + 193
        if not ('cd', 4).length:
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1766 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1826 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1893 = mem[_1826]
                require mem[_1826] == mem[_1826 + 18 len 14]
                _1946 = mem[_1826 + 32]
                require mem[_1826 + 32] == mem[_1826 + 50 len 14]
                require mem[_1826 + 64] == mem[_1826 + 92 len 4]
                require ext_code.size(address(_1766))
                staticcall address(_1766).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2114 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2162 = mem[_2114]
                require mem[_2114] == mem[_2114 + 12 len 20]
                require ext_code.size(address(_1766))
                staticcall address(_1766).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2234 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2258 = mem[_2234]
                require mem[_2234] == mem[_2234 + 12 len 20]
                if Mask(112, 0, _1893) <= Mask(112, 0, _1946):
                    if Mask(112, 0, _1946) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1893):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2162)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2258)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1893)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1946)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1946)) / Mask(112, 0, _1893))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1946)) / Mask(112, 0, _1893))
                    t = _2258
                    t = _2162
                    t = _1946
                    t = _1893
                    t = _1766
                    continue 
                if Mask(112, 0, _1893) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1946):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2162)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2258)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1893)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1946)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1893)) / Mask(112, 0, _1946))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1893)) / Mask(112, 0, _1946))
                t = _2258
                t = _2162
                t = _1946
                t = _1893
                t = _1766
                continue 
            _1802 = mem[64]
            mem[mem[64]] = 96
            _1850 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1850:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1802 + 32] = (32 * _1850) + 128
            _2546 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1802 + (32 * _1850) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1802 + (32 * _1850) + 160
            while idx < _2546:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1802 + 64] = (32 * _1850) + (32 * _2546) + 160
            _2690 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1802 + (32 * _1850) + (32 * _2546) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1802 + (32 * _1850) + (32 * _2546) + 192 len 32 * _2690] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2690]
            return memory
              from mem[64]
               len _1802 + (32 * _1850) + (32 * _2546) + (32 * _2690) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        idx = 0
        s = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _1769 = mem[(32 * idx) + 128]
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1827 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1895 = mem[_1827]
            require mem[_1827] == mem[_1827 + 18 len 14]
            _1947 = mem[_1827 + 32]
            require mem[_1827 + 32] == mem[_1827 + 50 len 14]
            require mem[_1827 + 64] == mem[_1827 + 92 len 4]
            require ext_code.size(address(_1769))
            staticcall address(_1769).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2115 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2163 = mem[_2115]
            require mem[_2115] == mem[_2115 + 12 len 20]
            require ext_code.size(address(_1769))
            staticcall address(_1769).token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2235 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2259 = mem[_2235]
            require mem[_2235] == mem[_2235 + 12 len 20]
            if Mask(112, 0, _1895) <= Mask(112, 0, _1947):
                if Mask(112, 0, _1947) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1895):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2163)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2259)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1895)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1947)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1947)) / Mask(112, 0, _1895))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1947)) / Mask(112, 0, _1895))
                t = _2259
                t = _2163
                t = _1947
                t = _1895
                t = _1769
                continue 
            if Mask(112, 0, _1895) > 0x4189374bc6a7ef9db22d0e5604:
                revert with 0, 17
            if not Mask(112, 0, _1947):
                revert with 0, 18
            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2163)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2259)
            if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1895)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1947)
            if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1895)) / Mask(112, 0, _1947))
            if 2 > !s:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 2
            t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1895)) / Mask(112, 0, _1947))
            t = _2259
            t = _2163
            t = _1947
            t = _1895
            t = _1769
            continue 
        _1803 = mem[64]
        mem[mem[64]] = 96
        _1851 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 128
        while idx < _1851:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _1851) + 128
        _2547 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        mem[_1803 + (32 * _1851) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
        t = _1803 + (32 * _1851) + 160
        while idx < _2547:
            mem[t] = mem[s + 18 len 14]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_1803 + 64] = (32 * _1851) + (32 * _2547) + 160
        _2691 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1803 + (32 * _1851) + (32 * _2547) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1803 + (32 * _1851) + (32 * _2547) + 192 len 32 * _2691] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2691]
        return memory
          from mem[64]
           len _1803 + (32 * _1851) + (32 * _2547) + (32 * _2691) + -mem[64] + 192
    mem[ceil32(32 * ('cd', 4).length) + 129 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
    if ('cd', 4).length > 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff:
        revert with 0, 17
    if 2 * ('cd', 4).length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129] = 2 * ('cd', 4).length
    if not uint255(('cd', 4).length):
        if ('cd', 4).length > test266151307():
            revert with 0, 65
        mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
        mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
        if not ('cd', 4).length:
            idx = 0
            s = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            t = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _1772 = mem[(32 * idx) + 128]
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1828 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1897 = mem[_1828]
                require mem[_1828] == mem[_1828 + 18 len 14]
                _1948 = mem[_1828 + 32]
                require mem[_1828 + 32] == mem[_1828 + 50 len 14]
                require mem[_1828 + 64] == mem[_1828 + 92 len 4]
                require ext_code.size(address(_1772))
                staticcall address(_1772).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2116 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2164 = mem[_2116]
                require mem[_2116] == mem[_2116 + 12 len 20]
                require ext_code.size(address(_1772))
                staticcall address(_1772).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2236 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2260 = mem[_2236]
                require mem[_2236] == mem[_2236 + 12 len 20]
                if Mask(112, 0, _1897) <= Mask(112, 0, _1948):
                    if Mask(112, 0, _1948) > 0x4189374bc6a7ef9db22d0e5604:
                        revert with 0, 17
                    if not Mask(112, 0, _1897):
                        revert with 0, 18
                    if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2164)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2260)
                    if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1897)
                    if 1 > !s:
                        revert with 0, 17
                    if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                        revert with 0, 50
                    mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1948)
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                        revert with 0, 50
                    mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1948)) / Mask(112, 0, _1897))
                    if 2 > !s:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + 2
                    t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1948)) / Mask(112, 0, _1897))
                    t = _2260
                    t = _2164
                    t = _1948
                    t = _1897
                    t = _1772
                    continue 
                if Mask(112, 0, _1897) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1948):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2164)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2260)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1897)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1948)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1897)) / Mask(112, 0, _1948))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1897)) / Mask(112, 0, _1948))
                t = _2260
                t = _2164
                t = _1948
                t = _1897
                t = _1772
                continue 
            _1804 = mem[64]
            mem[mem[64]] = 96
            _1852 = mem[ceil32(32 * ('cd', 4).length) + 97]
            mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + 129
            t = mem[64] + 128
            while idx < _1852:
                mem[t] = mem[s + 12 len 20]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[mem[64] + 32] = (32 * _1852) + 128
            _2548 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            mem[_1804 + (32 * _1852) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
            idx = 0
            s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
            t = _1804 + (32 * _1852) + 160
            while idx < _2548:
                mem[t] = mem[s + 18 len 14]
                idx = idx + 1
                s = s + 32
                t = t + 32
                continue 
            mem[_1804 + 64] = (32 * _1852) + (32 * _2548) + 160
            _2692 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1804 + (32 * _1852) + (32 * _2548) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
            mem[_1804 + (32 * _1852) + (32 * _2548) + 192 len 32 * _2692] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2692]
            return memory
              from mem[64]
               len _1804 + (32 * _1852) + (32 * _2548) + (32 * _2692) + -mem[64] + 192
        mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
        idx = 0
        s = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _1775 = mem[(32 * idx) + 128]
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1829 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1899 = mem[_1829]
            require mem[_1829] == mem[_1829 + 18 len 14]
            _1949 = mem[_1829 + 32]
            require mem[_1829 + 32] == mem[_1829 + 50 len 14]
            require mem[_1829 + 64] == mem[_1829 + 92 len 4]
            require ext_code.size(address(_1775))
            staticcall address(_1775).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2117 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2165 = mem[_2117]
            require mem[_2117] == mem[_2117 + 12 len 20]
            require ext_code.size(address(_1775))
            staticcall address(_1775).token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2237 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2261 = mem[_2237]
            require mem[_2237] == mem[_2237 + 12 len 20]
            if Mask(112, 0, _1899) <= Mask(112, 0, _1949):
                if Mask(112, 0, _1949) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1899):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2165)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2261)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1899)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1949)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1949)) / Mask(112, 0, _1899))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1949)) / Mask(112, 0, _1899))
                t = _2261
                t = _2165
                t = _1949
                t = _1899
                t = _1775
                continue 
            if Mask(112, 0, _1899) > 0x4189374bc6a7ef9db22d0e5604:
                revert with 0, 17
            if not Mask(112, 0, _1949):
                revert with 0, 18
            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2165)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2261)
            if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1899)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1949)
            if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1899)) / Mask(112, 0, _1949))
            if 2 > !s:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 2
            t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1899)) / Mask(112, 0, _1949))
            t = _2261
            t = _2165
            t = _1949
            t = _1899
            t = _1775
            continue 
        _1805 = mem[64]
        mem[mem[64]] = 96
        _1853 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 128
        while idx < _1853:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[mem[64] + 32] = (32 * _1853) + 128
        _2549 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        mem[_1805 + (32 * _1853) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
        t = _1805 + (32 * _1853) + 160
        while idx < _2549:
            mem[t] = mem[s + 18 len 14]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_1805 + 64] = (32 * _1853) + (32 * _2549) + 160
        _2693 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1805 + (32 * _1853) + (32 * _2549) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1805 + (32 * _1853) + (32 * _2549) + 192 len 32 * _2693] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2693]
        return memory
          from mem[64]
           len _1805 + (32 * _1853) + (32 * _2549) + (32 * _2693) + -mem[64] + 192
    mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161 len 64 * ('cd', 4).length] = call.data[calldata.size len 64 * ('cd', 4).length]
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161] = ('cd', 4).length
    mem[64] = ceil32(32 * ('cd', 4).length) + (162 * ('cd', 4).length) + 193
    if not ('cd', 4).length:
        idx = 0
        s = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        t = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _1778 = mem[(32 * idx) + 128]
            require ext_code.size(mem[(32 * idx) + 140 len 20])
            staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1830 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1901 = mem[_1830]
            require mem[_1830] == mem[_1830 + 18 len 14]
            _1950 = mem[_1830 + 32]
            require mem[_1830 + 32] == mem[_1830 + 50 len 14]
            require mem[_1830 + 64] == mem[_1830 + 92 len 4]
            require ext_code.size(address(_1778))
            staticcall address(_1778).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2118 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2166 = mem[_2118]
            require mem[_2118] == mem[_2118 + 12 len 20]
            require ext_code.size(address(_1778))
            staticcall address(_1778).token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2238 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2262 = mem[_2238]
            require mem[_2238] == mem[_2238 + 12 len 20]
            if Mask(112, 0, _1901) <= Mask(112, 0, _1950):
                if Mask(112, 0, _1950) > 0x4189374bc6a7ef9db22d0e5604:
                    revert with 0, 17
                if not Mask(112, 0, _1901):
                    revert with 0, 18
                if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2166)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2262)
                if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1901)
                if 1 > !s:
                    revert with 0, 17
                if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                    revert with 0, 50
                mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1950)
                if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                    revert with 0, 50
                mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1950)) / Mask(112, 0, _1901))
                if 2 > !s:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + 2
                t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1950)) / Mask(112, 0, _1901))
                t = _2262
                t = _2166
                t = _1950
                t = _1901
                t = _1778
                continue 
            if Mask(112, 0, _1901) > 0x4189374bc6a7ef9db22d0e5604:
                revert with 0, 17
            if not Mask(112, 0, _1950):
                revert with 0, 18
            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2166)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2262)
            if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1901)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1950)
            if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1901)) / Mask(112, 0, _1950))
            if 2 > !s:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 2
            t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1901)) / Mask(112, 0, _1950))
            t = _2262
            t = _2166
            t = _1950
            t = _1901
            t = _1778
            continue 
        _1806 = mem[64]
        mem[mem[64]] = 96
        _1854 = mem[ceil32(32 * ('cd', 4).length) + 97]
        mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + 129
        t = mem[64] + 128
        while idx < _1854:
            mem[t] = mem[s + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_1806 + 32] = (32 * _1854) + 128
        _2550 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        mem[_1806 + (32 * _1854) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
        idx = 0
        s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
        t = _1806 + (32 * _1854) + 160
        while idx < _2550:
            mem[t] = mem[s + 18 len 14]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        mem[_1806 + 64] = (32 * _1854) + (32 * _2550) + 160
        _2694 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1806 + (32 * _1854) + (32 * _2550) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
        mem[_1806 + (32 * _1854) + (32 * _2550) + 192 len 32 * _2694] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2694]
        return memory
          from mem[64]
           len _1806 + (32 * _1854) + (32 * _2550) + (32 * _2694) + -mem[64] + 192
    mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    idx = 0
    s = 0
    t = 0
    t = 0
    t = 0
    t = 0
    t = 0
    t = 0
    while idx < ('cd', 4).length:
        if idx >= mem[96]:
            revert with 0, 50
        _1781 = mem[(32 * idx) + 128]
        require ext_code.size(mem[(32 * idx) + 140 len 20])
        staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1831 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _1903 = mem[_1831]
        require mem[_1831] == mem[_1831 + 18 len 14]
        _1951 = mem[_1831 + 32]
        require mem[_1831 + 32] == mem[_1831 + 50 len 14]
        require mem[_1831 + 64] == mem[_1831 + 92 len 4]
        require ext_code.size(address(_1781))
        staticcall address(_1781).token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2119 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2167 = mem[_2119]
        require mem[_2119] == mem[_2119 + 12 len 20]
        require ext_code.size(address(_1781))
        staticcall address(_1781).token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2239 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2263 = mem[_2239]
        require mem[_2239] == mem[_2239 + 12 len 20]
        if Mask(112, 0, _1903) <= Mask(112, 0, _1951):
            if Mask(112, 0, _1951) > 0x4189374bc6a7ef9db22d0e5604:
                revert with 0, 17
            if not Mask(112, 0, _1903):
                revert with 0, 18
            if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2167)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2263)
            if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1903)
            if 1 > !s:
                revert with 0, 17
            if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
                revert with 0, 50
            mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1951)
            if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
                revert with 0, 50
            mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1951)) / Mask(112, 0, _1903))
            if 2 > !s:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + 2
            t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1951)) / Mask(112, 0, _1903))
            t = _2263
            t = _2167
            t = _1951
            t = _1903
            t = _1781
            continue 
        if Mask(112, 0, _1903) > 0x4189374bc6a7ef9db22d0e5604:
            revert with 0, 17
        if not Mask(112, 0, _1951):
            revert with 0, 18
        if s >= mem[ceil32(32 * ('cd', 4).length) + 97]:
            revert with 0, 50
        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + 129] = address(_2167)
        if 1 > !s:
            revert with 0, 17
        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
            revert with 0, 50
        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + 129] = address(_2263)
        if s >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
            revert with 0, 50
        mem[(32 * s) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1903)
        if 1 > !s:
            revert with 0, 17
        if s + 1 >= mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]:
            revert with 0, 50
        mem[(32 * s + 1) + ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161] = Mask(112, 0, _1951)
        if idx >= mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]:
            revert with 0, 50
        mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193] = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1903)) / Mask(112, 0, _1951))
        if 2 > !s:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + 2
        t = Mask(112, 0, Mask(112, 0, 1000 * Mask(112, 0, _1903)) / Mask(112, 0, _1951))
        t = _2263
        t = _2167
        t = _1951
        t = _1903
        t = _1781
        continue 
    _1807 = mem[64]
    mem[mem[64]] = 96
    _1855 = mem[ceil32(32 * ('cd', 4).length) + 97]
    mem[mem[64] + 96] = mem[ceil32(32 * ('cd', 4).length) + 97]
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + 129
    t = mem[64] + 128
    while idx < _1855:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 32] = (32 * _1855) + 128
    _2551 = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
    mem[_1807 + (32 * _1855) + 128] = mem[ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 129]
    idx = 0
    s = ceil32(32 * ('cd', 4).length) + (64 * ('cd', 4).length) + 161
    t = _1807 + (32 * _1855) + 160
    while idx < _2551:
        mem[t] = mem[s + 18 len 14]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[_1807 + 64] = (32 * _1855) + (32 * _2551) + 160
    _2695 = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
    mem[_1807 + (32 * _1855) + (32 * _2551) + 160] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 161]
    mem[_1807 + (32 * _1855) + (32 * _2551) + 192 len 32 * _2695] = mem[ceil32(32 * ('cd', 4).length) + (128 * ('cd', 4).length) + 193 len 32 * _2695]
    return memory
      from mem[64]
       len _1807 + (32 * _1855) + (32 * _2551) + (32 * _2695) + -mem[64] + 192
}

function sub_114994cd(?) {
    require calldata.size - 4 >= 224
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 == address(arg3)
    require arg4 == address(arg4)
    require arg7 == address(arg7)
    if msg.sender == stor0:
        if arg5 > 0x480ebe7b9d58566c87ce9b80a5fb05082bd371c8651c7b299b30:
            revert with 0, 17
        if msg.sender == stor0:
            if not address(arg3):
                revert with 0, 'Set router'
            mem[100] = this.address
            require ext_code.size(address(arg2))
            staticcall address(arg2).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            mem[ceil32(return_data.size) + 100] = this.address
            require ext_code.size(address(arg1))
            staticcall address(arg1).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] < 10^15 * arg5:
                revert with 0, 'Refill amountIn'
            mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
            mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
            require ext_code.size(address(arg1))
            call address(arg1).approve(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg3), 10^15 * arg5
            mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == bool(ext_call.return_data[0])
            if not address(arg4):
                mem[(4 * ceil32(return_data.size)) + 96] = 2
                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                mem[(4 * ceil32(return_data.size)) + 228] = arg6
                mem[(4 * ceil32(return_data.size)) + 260] = 160
                mem[(4 * ceil32(return_data.size)) + 356] = 2
                idx = 0
                s = (4 * ceil32(return_data.size)) + 128
                t = (4 * ceil32(return_data.size)) + 388
                while idx < 2:
                    mem[t] = mem[s + 12 len 20]
                    idx = idx + 1
                    s = s + 32
                    t = t + 32
                    continue 
                mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                require ext_code.size(address(arg3))
                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                     gas gas_remaining wei
                    args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (6 * ceil32(return_data.size)) + 192
                require return_data.size >= 32
                _1065 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                _1101 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                    revert with 0, 65
                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                    revert with 0, 65
                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                mem[(6 * ceil32(return_data.size)) + 192] = _1101
                require _1065 + (32 * _1101) + 32 <= return_data.size
                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1101] = mem[(4 * ceil32(return_data.size)) + _1065 + 224 len 32 * _1101]
                mem[mem[64] + 4] = address(arg3)
                mem[mem[64] + 36] = 0
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg3), 0
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1677 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                require mem[_1677] == bool(mem[_1677])
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1821 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                if mem[_1821] < ext_call.return_data[0]:
                    revert with 0, 17
                mem[mem[64]] = mem[_1821] - ext_call.return_data[0]
            else:
                if address(arg1) == address(arg4):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                    mem[(4 * ceil32(return_data.size)) + 228] = arg6
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1062 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                    _1098 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _1098
                    require _1062 + (32 * _1098) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1098] = mem[(4 * ceil32(return_data.size)) + _1062 + 224 len 32 * _1098]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1674 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1674] == bool(mem[_1674])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1818 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1818] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_1818] - ext_call.return_data[0]
                else:
                    if address(arg2) == address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1064 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1100 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1100
                        require _1064 + (32 * _1100) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1100] = mem[(4 * ceil32(return_data.size)) + _1064 + 224 len 32 * _1100]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1676 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1676] == bool(mem[_1676])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1820 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1820] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1820] - ext_call.return_data[0]
                    else:
                        mem[(4 * ceil32(return_data.size)) + 96] = 3
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                        mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 260] = arg6
                        mem[(4 * ceil32(return_data.size)) + 292] = 160
                        mem[(4 * ceil32(return_data.size)) + 388] = 3
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 420
                        while idx < 3:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 224
                        require return_data.size >= 32
                        _1063 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                        _1099 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                        mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                        require _1063 + (32 * _1099) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1099] = mem[(4 * ceil32(return_data.size)) + _1063 + 256 len 32 * _1099]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1675 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1675] == bool(mem[_1675])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1819 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1819] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1819] - ext_call.return_data[0]
        else:
            if msg.sender == stor1:
                if not address(arg3):
                    revert with 0, 'Set router'
                mem[100] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < 10^15 * arg5:
                    revert with 0, 'Refill amountIn'
                mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
                mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg3), 10^15 * arg5
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not address(arg4):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                    mem[(4 * ceil32(return_data.size)) + 228] = arg6
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1069 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                    _1105 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _1105
                    require _1069 + (32 * _1105) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1105] = mem[(4 * ceil32(return_data.size)) + _1069 + 224 len 32 * _1105]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1681 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1681] == bool(mem[_1681])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1825 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1825] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_1825] - ext_call.return_data[0]
                else:
                    if address(arg1) == address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1066 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1102 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1102
                        require _1066 + (32 * _1102) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1102] = mem[(4 * ceil32(return_data.size)) + _1066 + 224 len 32 * _1102]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1678 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1678] == bool(mem[_1678])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1822 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1822] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1822] - ext_call.return_data[0]
                    else:
                        if address(arg2) == address(arg4):
                            mem[(4 * ceil32(return_data.size)) + 96] = 2
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 228] = arg6
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _1068 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                            _1104 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = _1104
                            require _1068 + (32 * _1104) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1104] = mem[(4 * ceil32(return_data.size)) + _1068 + 224 len 32 * _1104]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1680 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1680] == bool(mem[_1680])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1824 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1824] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1824] - ext_call.return_data[0]
                        else:
                            mem[(4 * ceil32(return_data.size)) + 96] = 3
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                            mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 260] = arg6
                            mem[(4 * ceil32(return_data.size)) + 292] = 160
                            mem[(4 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _1067 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                            _1103 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                            require _1067 + (32 * _1103) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1103] = mem[(4 * ceil32(return_data.size)) + _1067 + 256 len 32 * _1103]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1679 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1679] == bool(mem[_1679])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1823 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1823] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1823] - ext_call.return_data[0]
            else:
                if stor2 != msg.sender:
                    revert with 0, 'Not authorized'
                if not address(arg3):
                    revert with 0, 'Set router'
                mem[100] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < 10^15 * arg5:
                    revert with 0, 'Refill amountIn'
                mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
                mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg3), 10^15 * arg5
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not address(arg4):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                    mem[(4 * ceil32(return_data.size)) + 228] = arg6
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1073 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                    _1109 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _1109
                    require _1073 + (32 * _1109) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1109] = mem[(4 * ceil32(return_data.size)) + _1073 + 224 len 32 * _1109]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1685 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1685] == bool(mem[_1685])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1829 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1829] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_1829] - ext_call.return_data[0]
                else:
                    if address(arg1) == address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1070 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1106 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1106
                        require _1070 + (32 * _1106) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1106] = mem[(4 * ceil32(return_data.size)) + _1070 + 224 len 32 * _1106]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1682 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1682] == bool(mem[_1682])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1826 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1826] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1826] - ext_call.return_data[0]
                    else:
                        if address(arg2) == address(arg4):
                            mem[(4 * ceil32(return_data.size)) + 96] = 2
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 228] = arg6
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _1072 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                            _1108 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = _1108
                            require _1072 + (32 * _1108) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1108] = mem[(4 * ceil32(return_data.size)) + _1072 + 224 len 32 * _1108]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1684 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1684] == bool(mem[_1684])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1828 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1828] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1828] - ext_call.return_data[0]
                        else:
                            mem[(4 * ceil32(return_data.size)) + 96] = 3
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                            mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 260] = arg6
                            mem[(4 * ceil32(return_data.size)) + 292] = 160
                            mem[(4 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _1071 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                            _1107 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                            require _1071 + (32 * _1107) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1107] = mem[(4 * ceil32(return_data.size)) + _1071 + 256 len 32 * _1107]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1683 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1683] == bool(mem[_1683])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1827 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1827] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1827] - ext_call.return_data[0]
    else:
        if msg.sender == stor1:
            if arg5 > 0x480ebe7b9d58566c87ce9b80a5fb05082bd371c8651c7b299b30:
                revert with 0, 17
            if msg.sender == stor0:
                if not address(arg3):
                    revert with 0, 'Set router'
                mem[100] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < 10^15 * arg5:
                    revert with 0, 'Refill amountIn'
                mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
                mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg3), 10^15 * arg5
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not address(arg4):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                    mem[(4 * ceil32(return_data.size)) + 228] = arg6
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1077 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                    _1113 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _1113
                    require _1077 + (32 * _1113) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1113] = mem[(4 * ceil32(return_data.size)) + _1077 + 224 len 32 * _1113]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1689 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1689] == bool(mem[_1689])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1833 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1833] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_1833] - ext_call.return_data[0]
                else:
                    if address(arg1) == address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1074 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1110 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1110
                        require _1074 + (32 * _1110) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1110] = mem[(4 * ceil32(return_data.size)) + _1074 + 224 len 32 * _1110]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1686 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1686] == bool(mem[_1686])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1830 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1830] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1830] - ext_call.return_data[0]
                    else:
                        if address(arg2) == address(arg4):
                            mem[(4 * ceil32(return_data.size)) + 96] = 2
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 228] = arg6
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _1076 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                            _1112 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = _1112
                            require _1076 + (32 * _1112) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1112] = mem[(4 * ceil32(return_data.size)) + _1076 + 224 len 32 * _1112]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1688 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1688] == bool(mem[_1688])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1832 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1832] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1832] - ext_call.return_data[0]
                        else:
                            mem[(4 * ceil32(return_data.size)) + 96] = 3
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                            mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 260] = arg6
                            mem[(4 * ceil32(return_data.size)) + 292] = 160
                            mem[(4 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _1075 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                            _1111 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                            require _1075 + (32 * _1111) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1111] = mem[(4 * ceil32(return_data.size)) + _1075 + 256 len 32 * _1111]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1687 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1687] == bool(mem[_1687])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1831 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1831] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1831] - ext_call.return_data[0]
            else:
                if msg.sender == stor1:
                    if not address(arg3):
                        revert with 0, 'Set router'
                    mem[100] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(return_data.size) + 100] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] < 10^15 * arg5:
                        revert with 0, 'Refill amountIn'
                    mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
                    mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 10^15 * arg5
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1081 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1117 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1117
                        require _1081 + (32 * _1117) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1117] = mem[(4 * ceil32(return_data.size)) + _1081 + 224 len 32 * _1117]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1693 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1693] == bool(mem[_1693])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1837 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1837] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1837] - ext_call.return_data[0]
                    else:
                        if address(arg1) == address(arg4):
                            mem[(4 * ceil32(return_data.size)) + 96] = 2
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 228] = arg6
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _1078 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                            _1114 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = _1114
                            require _1078 + (32 * _1114) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1114] = mem[(4 * ceil32(return_data.size)) + _1078 + 224 len 32 * _1114]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1690 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1690] == bool(mem[_1690])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1834 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1834] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1834] - ext_call.return_data[0]
                        else:
                            if address(arg2) == address(arg4):
                                mem[(4 * ceil32(return_data.size)) + 96] = 2
                                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                                mem[(4 * ceil32(return_data.size)) + 228] = arg6
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 128
                                t = (4 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(address(arg3))
                                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _1080 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                                _1116 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = _1116
                                require _1080 + (32 * _1116) + 32 <= return_data.size
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1116] = mem[(4 * ceil32(return_data.size)) + _1080 + 224 len 32 * _1116]
                                mem[mem[64] + 4] = address(arg3)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(arg1))
                                call address(arg1).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(arg3), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1692 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1692] == bool(mem[_1692])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(arg2))
                                staticcall address(arg2).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1836 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_1836] < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = mem[_1836] - ext_call.return_data[0]
                            else:
                                mem[(4 * ceil32(return_data.size)) + 96] = 3
                                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                                mem[(4 * ceil32(return_data.size)) + 260] = arg6
                                mem[(4 * ceil32(return_data.size)) + 292] = 160
                                mem[(4 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 128
                                t = (4 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                                mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(address(arg3))
                                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _1079 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                                _1115 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                                require _1079 + (32 * _1115) + 32 <= return_data.size
                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1115] = mem[(4 * ceil32(return_data.size)) + _1079 + 256 len 32 * _1115]
                                mem[mem[64] + 4] = address(arg3)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(arg1))
                                call address(arg1).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(arg3), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1691 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1691] == bool(mem[_1691])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(arg2))
                                staticcall address(arg2).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1835 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_1835] < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = mem[_1835] - ext_call.return_data[0]
                else:
                    if stor2 != msg.sender:
                        revert with 0, 'Not authorized'
                    if not address(arg3):
                        revert with 0, 'Set router'
                    mem[100] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(return_data.size) + 100] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] < 10^15 * arg5:
                        revert with 0, 'Refill amountIn'
                    mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
                    mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 10^15 * arg5
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1085 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1121 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1121
                        require _1085 + (32 * _1121) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1121] = mem[(4 * ceil32(return_data.size)) + _1085 + 224 len 32 * _1121]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1697 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1697] == bool(mem[_1697])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1841 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1841] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1841] - ext_call.return_data[0]
                    else:
                        if address(arg1) == address(arg4):
                            mem[(4 * ceil32(return_data.size)) + 96] = 2
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 228] = arg6
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _1082 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                            _1118 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = _1118
                            require _1082 + (32 * _1118) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1118] = mem[(4 * ceil32(return_data.size)) + _1082 + 224 len 32 * _1118]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1694 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1694] == bool(mem[_1694])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1838 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1838] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1838] - ext_call.return_data[0]
                        else:
                            if address(arg2) == address(arg4):
                                mem[(4 * ceil32(return_data.size)) + 96] = 2
                                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                                mem[(4 * ceil32(return_data.size)) + 228] = arg6
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 128
                                t = (4 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(address(arg3))
                                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _1084 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                                _1120 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = _1120
                                require _1084 + (32 * _1120) + 32 <= return_data.size
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1120] = mem[(4 * ceil32(return_data.size)) + _1084 + 224 len 32 * _1120]
                                mem[mem[64] + 4] = address(arg3)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(arg1))
                                call address(arg1).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(arg3), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1696 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1696] == bool(mem[_1696])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(arg2))
                                staticcall address(arg2).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1840 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_1840] < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = mem[_1840] - ext_call.return_data[0]
                            else:
                                mem[(4 * ceil32(return_data.size)) + 96] = 3
                                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                                mem[(4 * ceil32(return_data.size)) + 260] = arg6
                                mem[(4 * ceil32(return_data.size)) + 292] = 160
                                mem[(4 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 128
                                t = (4 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                                mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(address(arg3))
                                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _1083 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                                _1119 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                                require _1083 + (32 * _1119) + 32 <= return_data.size
                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1119] = mem[(4 * ceil32(return_data.size)) + _1083 + 256 len 32 * _1119]
                                mem[mem[64] + 4] = address(arg3)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(arg1))
                                call address(arg1).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(arg3), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1695 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1695] == bool(mem[_1695])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(arg2))
                                staticcall address(arg2).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1839 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_1839] < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = mem[_1839] - ext_call.return_data[0]
        else:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
            if arg5 > 0x480ebe7b9d58566c87ce9b80a5fb05082bd371c8651c7b299b30:
                revert with 0, 17
            if msg.sender == stor0:
                if not address(arg3):
                    revert with 0, 'Set router'
                mem[100] = this.address
                require ext_code.size(address(arg2))
                staticcall address(arg2).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                mem[ceil32(return_data.size) + 100] = this.address
                require ext_code.size(address(arg1))
                staticcall address(arg1).0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < 10^15 * arg5:
                    revert with 0, 'Refill amountIn'
                mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
                mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
                require ext_code.size(address(arg1))
                call address(arg1).approve(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg3), 10^15 * arg5
                mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                if not address(arg4):
                    mem[(4 * ceil32(return_data.size)) + 96] = 2
                    mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                    mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                    mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                    mem[(4 * ceil32(return_data.size)) + 228] = arg6
                    mem[(4 * ceil32(return_data.size)) + 260] = 160
                    mem[(4 * ceil32(return_data.size)) + 356] = 2
                    idx = 0
                    s = (4 * ceil32(return_data.size)) + 128
                    t = (4 * ceil32(return_data.size)) + 388
                    while idx < 2:
                        mem[t] = mem[s + 12 len 20]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        continue 
                    mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                    mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                    require ext_code.size(address(arg3))
                    call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                         gas gas_remaining wei
                        args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (6 * ceil32(return_data.size)) + 192
                    require return_data.size >= 32
                    _1089 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                    require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                    require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                    _1125 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                    if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                        revert with 0, 65
                    if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                        revert with 0, 65
                    mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                    mem[(6 * ceil32(return_data.size)) + 192] = _1125
                    require _1089 + (32 * _1125) + 32 <= return_data.size
                    mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1125] = mem[(4 * ceil32(return_data.size)) + _1089 + 224 len 32 * _1125]
                    mem[mem[64] + 4] = address(arg3)
                    mem[mem[64] + 36] = 0
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 0
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1701 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_1701] == bool(mem[_1701])
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1845 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_1845] < ext_call.return_data[0]:
                        revert with 0, 17
                    mem[mem[64]] = mem[_1845] - ext_call.return_data[0]
                else:
                    if address(arg1) == address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1086 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1122 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1122
                        require _1086 + (32 * _1122) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1122] = mem[(4 * ceil32(return_data.size)) + _1086 + 224 len 32 * _1122]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1698 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1698] == bool(mem[_1698])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1842 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1842] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1842] - ext_call.return_data[0]
                    else:
                        if address(arg2) == address(arg4):
                            mem[(4 * ceil32(return_data.size)) + 96] = 2
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 228] = arg6
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _1088 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                            _1124 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = _1124
                            require _1088 + (32 * _1124) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1124] = mem[(4 * ceil32(return_data.size)) + _1088 + 224 len 32 * _1124]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1700 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1700] == bool(mem[_1700])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1844 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1844] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1844] - ext_call.return_data[0]
                        else:
                            mem[(4 * ceil32(return_data.size)) + 96] = 3
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                            mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 260] = arg6
                            mem[(4 * ceil32(return_data.size)) + 292] = 160
                            mem[(4 * ceil32(return_data.size)) + 388] = 3
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 420
                            while idx < 3:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 224
                            require return_data.size >= 32
                            _1087 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                            _1123 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                            mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                            require _1087 + (32 * _1123) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1123] = mem[(4 * ceil32(return_data.size)) + _1087 + 256 len 32 * _1123]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1699 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1699] == bool(mem[_1699])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1843 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1843] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1843] - ext_call.return_data[0]
            else:
                if msg.sender == stor1:
                    if not address(arg3):
                        revert with 0, 'Set router'
                    mem[100] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(return_data.size) + 100] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] < 10^15 * arg5:
                        revert with 0, 'Refill amountIn'
                    mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
                    mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 10^15 * arg5
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1093 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1129 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1129
                        require _1093 + (32 * _1129) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1129] = mem[(4 * ceil32(return_data.size)) + _1093 + 224 len 32 * _1129]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1705 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1705] == bool(mem[_1705])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1849 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1849] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1849] - ext_call.return_data[0]
                    else:
                        if address(arg1) == address(arg4):
                            mem[(4 * ceil32(return_data.size)) + 96] = 2
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 228] = arg6
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _1090 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                            _1126 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = _1126
                            require _1090 + (32 * _1126) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1126] = mem[(4 * ceil32(return_data.size)) + _1090 + 224 len 32 * _1126]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1702 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1702] == bool(mem[_1702])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1846 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1846] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1846] - ext_call.return_data[0]
                        else:
                            if address(arg2) == address(arg4):
                                mem[(4 * ceil32(return_data.size)) + 96] = 2
                                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                                mem[(4 * ceil32(return_data.size)) + 228] = arg6
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 128
                                t = (4 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(address(arg3))
                                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _1092 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                                _1128 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = _1128
                                require _1092 + (32 * _1128) + 32 <= return_data.size
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1128] = mem[(4 * ceil32(return_data.size)) + _1092 + 224 len 32 * _1128]
                                mem[mem[64] + 4] = address(arg3)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(arg1))
                                call address(arg1).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(arg3), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1704 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1704] == bool(mem[_1704])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(arg2))
                                staticcall address(arg2).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1848 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_1848] < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = mem[_1848] - ext_call.return_data[0]
                            else:
                                mem[(4 * ceil32(return_data.size)) + 96] = 3
                                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                                mem[(4 * ceil32(return_data.size)) + 260] = arg6
                                mem[(4 * ceil32(return_data.size)) + 292] = 160
                                mem[(4 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 128
                                t = (4 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                                mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(address(arg3))
                                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _1091 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                                _1127 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                                require _1091 + (32 * _1127) + 32 <= return_data.size
                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1127] = mem[(4 * ceil32(return_data.size)) + _1091 + 256 len 32 * _1127]
                                mem[mem[64] + 4] = address(arg3)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(arg1))
                                call address(arg1).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(arg3), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1703 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1703] == bool(mem[_1703])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(arg2))
                                staticcall address(arg2).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1847 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_1847] < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = mem[_1847] - ext_call.return_data[0]
                else:
                    if stor2 != msg.sender:
                        revert with 0, 'Not authorized'
                    if not address(arg3):
                        revert with 0, 'Set router'
                    mem[100] = this.address
                    require ext_code.size(address(arg2))
                    staticcall address(arg2).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[ceil32(return_data.size) + 100] = this.address
                    require ext_code.size(address(arg1))
                    staticcall address(arg1).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] < 10^15 * arg5:
                        revert with 0, 'Refill amountIn'
                    mem[(2 * ceil32(return_data.size)) + 100] = address(arg3)
                    mem[(2 * ceil32(return_data.size)) + 132] = 10^15 * arg5
                    require ext_code.size(address(arg1))
                    call address(arg1).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg3), 10^15 * arg5
                    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                    if not address(arg4):
                        mem[(4 * ceil32(return_data.size)) + 96] = 2
                        mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                        mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                        mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                        mem[(4 * ceil32(return_data.size)) + 228] = arg6
                        mem[(4 * ceil32(return_data.size)) + 260] = 160
                        mem[(4 * ceil32(return_data.size)) + 356] = 2
                        idx = 0
                        s = (4 * ceil32(return_data.size)) + 128
                        t = (4 * ceil32(return_data.size)) + 388
                        while idx < 2:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                        mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                        require ext_code.size(address(arg3))
                        call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                             gas gas_remaining wei
                            args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (6 * ceil32(return_data.size)) + 192
                        require return_data.size >= 32
                        _1097 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                        require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                        require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                        _1133 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                        if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                            revert with 0, 65
                        mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                        mem[(6 * ceil32(return_data.size)) + 192] = _1133
                        require _1097 + (32 * _1133) + 32 <= return_data.size
                        mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1133] = mem[(4 * ceil32(return_data.size)) + _1097 + 224 len 32 * _1133]
                        mem[mem[64] + 4] = address(arg3)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(arg1))
                        call address(arg1).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg3), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1709 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_1709] == bool(mem[_1709])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(arg2))
                        staticcall address(arg2).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1853 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_1853] < ext_call.return_data[0]:
                            revert with 0, 17
                        mem[mem[64]] = mem[_1853] - ext_call.return_data[0]
                    else:
                        if address(arg1) == address(arg4):
                            mem[(4 * ceil32(return_data.size)) + 96] = 2
                            mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                            mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                            mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                            mem[(4 * ceil32(return_data.size)) + 228] = arg6
                            mem[(4 * ceil32(return_data.size)) + 260] = 160
                            mem[(4 * ceil32(return_data.size)) + 356] = 2
                            idx = 0
                            s = (4 * ceil32(return_data.size)) + 128
                            t = (4 * ceil32(return_data.size)) + 388
                            while idx < 2:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                            mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                            require ext_code.size(address(arg3))
                            call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (6 * ceil32(return_data.size)) + 192
                            require return_data.size >= 32
                            _1094 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                            require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                            require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                            _1130 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                            if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                revert with 0, 65
                            mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                            mem[(6 * ceil32(return_data.size)) + 192] = _1130
                            require _1094 + (32 * _1130) + 32 <= return_data.size
                            mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1130] = mem[(4 * ceil32(return_data.size)) + _1094 + 224 len 32 * _1130]
                            mem[mem[64] + 4] = address(arg3)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(arg1))
                            call address(arg1).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg3), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1706 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_1706] == bool(mem[_1706])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(arg2))
                            staticcall address(arg2).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1850 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_1850] < ext_call.return_data[0]:
                                revert with 0, 17
                            mem[mem[64]] = mem[_1850] - ext_call.return_data[0]
                        else:
                            if address(arg2) == address(arg4):
                                mem[(4 * ceil32(return_data.size)) + 96] = 2
                                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 192] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 196] = 10^15 * arg5
                                mem[(4 * ceil32(return_data.size)) + 228] = arg6
                                mem[(4 * ceil32(return_data.size)) + 260] = 160
                                mem[(4 * ceil32(return_data.size)) + 356] = 2
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 128
                                t = (4 * ceil32(return_data.size)) + 388
                                while idx < 2:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 292] = address(arg7)
                                mem[(4 * ceil32(return_data.size)) + 324] = block.timestamp
                                require ext_code.size(address(arg3))
                                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 10^15 * arg5, arg6, Array(len=2, data=mem[(4 * ceil32(return_data.size)) + 388 len 64]), address(arg7), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 192 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 192
                                require return_data.size >= 32
                                _1096 = mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + return_data.size + 192 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 223
                                _1132 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193 > test266151307():
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 192 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 192]) + 193
                                mem[(6 * ceil32(return_data.size)) + 192] = _1132
                                require _1096 + (32 * _1132) + 32 <= return_data.size
                                mem[(6 * ceil32(return_data.size)) + 224 len 32 * _1132] = mem[(4 * ceil32(return_data.size)) + _1096 + 224 len 32 * _1132]
                                mem[mem[64] + 4] = address(arg3)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(arg1))
                                call address(arg1).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(arg3), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1708 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1708] == bool(mem[_1708])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(arg2))
                                staticcall address(arg2).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1852 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_1852] < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = mem[_1852] - ext_call.return_data[0]
                            else:
                                mem[(4 * ceil32(return_data.size)) + 96] = 3
                                mem[(4 * ceil32(return_data.size)) + 128] = address(arg1)
                                mem[(4 * ceil32(return_data.size)) + 160] = address(arg4)
                                mem[(4 * ceil32(return_data.size)) + 192] = address(arg2)
                                mem[(4 * ceil32(return_data.size)) + 224] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(4 * ceil32(return_data.size)) + 228] = 10^15 * arg5
                                mem[(4 * ceil32(return_data.size)) + 260] = arg6
                                mem[(4 * ceil32(return_data.size)) + 292] = 160
                                mem[(4 * ceil32(return_data.size)) + 388] = 3
                                idx = 0
                                s = (4 * ceil32(return_data.size)) + 128
                                t = (4 * ceil32(return_data.size)) + 420
                                while idx < 3:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(4 * ceil32(return_data.size)) + 324] = address(arg7)
                                mem[(4 * ceil32(return_data.size)) + 356] = block.timestamp
                                require ext_code.size(address(arg3))
                                call address(arg3).swapExactTokensForTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                     gas gas_remaining wei
                                    args 10^15 * arg5, arg6, Array(len=3, data=mem[(4 * ceil32(return_data.size)) + 420 len 96]), address(arg7), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(4 * ceil32(return_data.size)) + 224 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (6 * ceil32(return_data.size)) + 224
                                require return_data.size >= 32
                                _1095 = mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32
                                require mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 <= test266151307()
                                require (4 * ceil32(return_data.size)) + return_data.size + 224 > (4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 255
                                _1131 = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                                if mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 1 < 0 or (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225 > test266151307():
                                    revert with 0, 65
                                mem[64] = (6 * ceil32(return_data.size)) + ceil32(32 * mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]) + 225
                                mem[(6 * ceil32(return_data.size)) + 224] = mem[(4 * ceil32(return_data.size)) + mem[(4 * ceil32(return_data.size)) + 224 len 4], Mask(224, 32, 10^15 * arg5) >> 32 + 224]
                                require _1095 + (32 * _1131) + 32 <= return_data.size
                                mem[(6 * ceil32(return_data.size)) + 256 len 32 * _1131] = mem[(4 * ceil32(return_data.size)) + _1095 + 256 len 32 * _1131]
                                mem[mem[64] + 4] = address(arg3)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(arg1))
                                call address(arg1).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(arg3), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1707 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_1707] == bool(mem[_1707])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(arg2))
                                staticcall address(arg2).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1851 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_1851] < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64]] = mem[_1851] - ext_call.return_data[0]
    return memory
      from mem[64]
       len 32
}

function sub_9aadfce5(?) {
    require calldata.size - 4 >= 192
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] == address(cd[100])
    if msg.sender == stor0:
        if ('cd', 4).length != ('cd', 36).length:
            revert with 0, 'Check length1'
        if ('cd', 4).length != ('cd', 68).length:
            revert with 0, 'Check length2'
        idx = 0
        s = 0
        s = 0
        s = 0
        while idx < ('cd', 4).length:
            if idx >= mem[96]:
                revert with 0, 50
            _7068 = mem[(32 * idx) + 128]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            _7075 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                revert with 0, 50
            _7083 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
            if msg.sender == stor0:
                require ext_code.size(mem[(32 * idx) + 140 len 20])
                staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7113 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _7134 = mem[_7113]
                require mem[_7113] == mem[_7113 + 18 len 14]
                _7143 = mem[_7113 + 32]
                require mem[_7113 + 32] == mem[_7113 + 50 len 14]
                require mem[_7113 + 64] == mem[_7113 + 92 len 4]
                require ext_code.size(address(_7068))
                staticcall address(_7068).token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7173 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7185 = mem[_7173]
                require mem[_7173] == mem[_7173 + 12 len 20]
                require ext_code.size(address(_7068))
                staticcall address(_7068).token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _7209 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _7221 = mem[_7209]
                require mem[_7209] == mem[_7209 + 12 len 20]
                if address(_7185) == address(_7075):
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_7075))
                    staticcall address(_7075).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7254 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_7254] < _7083:
                        revert with 0, 'Refill _tokenIn amountIn'
                    if _7083 <= 0:
                        revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                    if address(_7185) != address(_7075):
                        if Mask(112, 0, _7143) <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if Mask(112, 0, _7134) <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if _7083 and 998 > -1 / _7083:
                            revert with 0, 17
                        if 998 * _7083 / 998 != _7083:
                            revert with 0, 'MUL error'
                        if not Mask(112, 0, _7134):
                            if Mask(112, 0, _7143) and 1000 > -1 / Mask(112, 0, _7143):
                                revert with 0, 17
                            if 1000 * Mask(112, 0, _7143) / 1000 != Mask(112, 0, _7143):
                                revert with 0, 'MUL error'
                            if 1000 * Mask(112, 0, _7143) > !(998 * _7083):
                                revert with 0, 17
                            if (1000 * Mask(112, 0, _7143)) + (998 * _7083) < 1000 * Mask(112, 0, _7143):
                                revert with 0, 'Add error'
                            if not (1000 * Mask(112, 0, _7143)) + (998 * _7083):
                                revert with 0, 18
                            if 0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083) < cd[164]:
                                revert with 0, 17
                            if (0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(_7068)
                            mem[mem[64] + 36] = _7083
                            require ext_code.size(address(_7221))
                            call address(_7221).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_7068), _7083
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8133 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8133] == bool(mem[_8133])
                            _8331 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_8331 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_8331 + 36] = (0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164]
                            mem[_8331 + 68] = 0
                            mem[_8331 + 100] = this.address
                            mem[_8331 + 132] = 128
                            mem[_8331 + 164] = mem[_8331]
                            s = 0
                            while s < mem[_8331]:
                                mem[s + _8331 + 196] = mem[_8331 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_8331]) > mem[_8331]:
                                mem[_8331 + mem[_8331] + 196] = 0
                            require ext_code.size(address(_7068))
                            call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164], 0, address(this.address), 128, mem[_8331], mem[_8331 + 196 len ceil32(mem[_8331])]
                        else:
                            if 998 * _7083 and Mask(112, 0, _7134) > -1 / 998 * _7083:
                                revert with 0, 17
                            if not Mask(112, 0, _7134):
                                revert with 0, 18
                            if 998 * _7083 * Mask(112, 0, _7134) / Mask(112, 0, _7134) != 998 * _7083:
                                revert with 0, 'MUL error'
                            if Mask(112, 0, _7143) and 1000 > -1 / Mask(112, 0, _7143):
                                revert with 0, 17
                            if 1000 * Mask(112, 0, _7143) / 1000 != Mask(112, 0, _7143):
                                revert with 0, 'MUL error'
                            if 1000 * Mask(112, 0, _7143) > !(998 * _7083):
                                revert with 0, 17
                            if (1000 * Mask(112, 0, _7143)) + (998 * _7083) < 1000 * Mask(112, 0, _7143):
                                revert with 0, 'Add error'
                            if not (1000 * Mask(112, 0, _7143)) + (998 * _7083):
                                revert with 0, 18
                            if 998 * _7083 * Mask(112, 0, _7134) / (1000 * Mask(112, 0, _7143)) + (998 * _7083) < cd[164]:
                                revert with 0, 17
                            if (998 * _7083 * Mask(112, 0, _7134) / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7134) / (1000 * Mask(112, 0, _7143)) + (998 * _7083):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(_7068)
                            mem[mem[64] + 36] = _7083
                            require ext_code.size(address(_7221))
                            call address(_7221).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_7068), _7083
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8355 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8355] == bool(mem[_8355])
                            _8542 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_8542 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_8542 + 36] = (998 * _7083 * Mask(112, 0, _7134) / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164]
                            mem[_8542 + 68] = 0
                            mem[_8542 + 100] = this.address
                            mem[_8542 + 132] = 128
                            mem[_8542 + 164] = mem[_8542]
                            s = 0
                            while s < mem[_8542]:
                                mem[s + _8542 + 196] = mem[_8542 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_8542]) > mem[_8542]:
                                mem[_8542 + mem[_8542] + 196] = 0
                            require ext_code.size(address(_7068))
                            call address(_7068).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_8542]) + _8542 + -mem[64] + 192]
                    else:
                        if Mask(112, 0, _7134) <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if Mask(112, 0, _7143) <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if _7083 and 998 > -1 / _7083:
                            revert with 0, 17
                        if 998 * _7083 / 998 != _7083:
                            revert with 0, 'MUL error'
                        if not Mask(112, 0, _7143):
                            if Mask(112, 0, _7134) and 1000 > -1 / Mask(112, 0, _7134):
                                revert with 0, 17
                            if 1000 * Mask(112, 0, _7134) / 1000 != Mask(112, 0, _7134):
                                revert with 0, 'MUL error'
                            if 1000 * Mask(112, 0, _7134) > !(998 * _7083):
                                revert with 0, 17
                            if (1000 * Mask(112, 0, _7134)) + (998 * _7083) < 1000 * Mask(112, 0, _7134):
                                revert with 0, 'Add error'
                            if not (1000 * Mask(112, 0, _7134)) + (998 * _7083):
                                revert with 0, 18
                            if 0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083) < cd[164]:
                                revert with 0, 17
                            if (0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(_7068)
                            mem[mem[64] + 36] = _7083
                            require ext_code.size(address(_7185))
                            call address(_7185).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_7068), _7083
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8134 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8134] == bool(mem[_8134])
                            _8332 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_8332 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_8332 + 36] = 0
                            mem[_8332 + 68] = (0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164]
                            mem[_8332 + 100] = this.address
                            mem[_8332 + 132] = 128
                            mem[_8332 + 164] = mem[_8332]
                            s = 0
                            while s < mem[_8332]:
                                mem[s + _8332 + 196] = mem[_8332 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_8332]) > mem[_8332]:
                                mem[_8332 + mem[_8332] + 196] = 0
                            require ext_code.size(address(_7068))
                            call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164], address(this.address), 128, mem[_8332], mem[_8332 + 196 len ceil32(mem[_8332])]
                        else:
                            if 998 * _7083 and Mask(112, 0, _7143) > -1 / 998 * _7083:
                                revert with 0, 17
                            if not Mask(112, 0, _7143):
                                revert with 0, 18
                            if 998 * _7083 * Mask(112, 0, _7143) / Mask(112, 0, _7143) != 998 * _7083:
                                revert with 0, 'MUL error'
                            if Mask(112, 0, _7134) and 1000 > -1 / Mask(112, 0, _7134):
                                revert with 0, 17
                            if 1000 * Mask(112, 0, _7134) / 1000 != Mask(112, 0, _7134):
                                revert with 0, 'MUL error'
                            if 1000 * Mask(112, 0, _7134) > !(998 * _7083):
                                revert with 0, 17
                            if (1000 * Mask(112, 0, _7134)) + (998 * _7083) < 1000 * Mask(112, 0, _7134):
                                revert with 0, 'Add error'
                            if not (1000 * Mask(112, 0, _7134)) + (998 * _7083):
                                revert with 0, 18
                            if 998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083) < cd[164]:
                                revert with 0, 17
                            if (998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(_7068)
                            mem[mem[64] + 36] = _7083
                            require ext_code.size(address(_7185))
                            call address(_7185).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_7068), _7083
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8356 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8356] == bool(mem[_8356])
                            _8544 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_8544 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_8544 + 36] = 0
                            mem[_8544 + 68] = (998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164]
                            mem[_8544 + 100] = this.address
                            mem[_8544 + 132] = 128
                            mem[_8544 + 164] = mem[_8544]
                            s = 0
                            while s < mem[_8544]:
                                mem[s + _8544 + 196] = mem[_8544 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_8544]) > mem[_8544]:
                                mem[_8544 + mem[_8544] + 196] = 0
                            require ext_code.size(address(_7068))
                            call address(_7068).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_8544]) + _8544 + -mem[64] + 192]
                else:
                    if mem[_7209 + 12 len 20] != address(_7075):
                        revert with 0, 'Check pair address'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_7075))
                    staticcall address(_7075).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7275 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_7275] < _7083:
                        revert with 0, 'Refill _tokenIn amountIn'
                    if _7083 <= 0:
                        revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                    if address(_7185) != address(_7075):
                        if Mask(112, 0, _7143) <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if Mask(112, 0, _7134) <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if _7083 and 998 > -1 / _7083:
                            revert with 0, 17
                        if 998 * _7083 / 998 != _7083:
                            revert with 0, 'MUL error'
                        if not Mask(112, 0, _7134):
                            if Mask(112, 0, _7143) and 1000 > -1 / Mask(112, 0, _7143):
                                revert with 0, 17
                            if 1000 * Mask(112, 0, _7143) / 1000 != Mask(112, 0, _7143):
                                revert with 0, 'MUL error'
                            if 1000 * Mask(112, 0, _7143) > !(998 * _7083):
                                revert with 0, 17
                            if (1000 * Mask(112, 0, _7143)) + (998 * _7083) < 1000 * Mask(112, 0, _7143):
                                revert with 0, 'Add error'
                            if not (1000 * Mask(112, 0, _7143)) + (998 * _7083):
                                revert with 0, 18
                            if 0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083) < cd[164]:
                                revert with 0, 17
                            if (0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(_7068)
                            mem[mem[64] + 36] = _7083
                            require ext_code.size(address(_7221))
                            call address(_7221).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_7068), _7083
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8153 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8153] == bool(mem[_8153])
                            _8357 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_8357 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_8357 + 36] = (0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164]
                            mem[_8357 + 68] = 0
                            mem[_8357 + 100] = this.address
                            mem[_8357 + 132] = 128
                            mem[_8357 + 164] = mem[_8357]
                            s = 0
                            while s < mem[_8357]:
                                mem[s + _8357 + 196] = mem[_8357 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_8357]) > mem[_8357]:
                                mem[_8357 + mem[_8357] + 196] = 0
                            require ext_code.size(address(_7068))
                            call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args (0 / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164], 0, address(this.address), 128, mem[_8357], mem[_8357 + 196 len ceil32(mem[_8357])]
                        else:
                            if 998 * _7083 and Mask(112, 0, _7134) > -1 / 998 * _7083:
                                revert with 0, 17
                            if not Mask(112, 0, _7134):
                                revert with 0, 18
                            if 998 * _7083 * Mask(112, 0, _7134) / Mask(112, 0, _7134) != 998 * _7083:
                                revert with 0, 'MUL error'
                            if Mask(112, 0, _7143) and 1000 > -1 / Mask(112, 0, _7143):
                                revert with 0, 17
                            if 1000 * Mask(112, 0, _7143) / 1000 != Mask(112, 0, _7143):
                                revert with 0, 'MUL error'
                            if 1000 * Mask(112, 0, _7143) > !(998 * _7083):
                                revert with 0, 17
                            if (1000 * Mask(112, 0, _7143)) + (998 * _7083) < 1000 * Mask(112, 0, _7143):
                                revert with 0, 'Add error'
                            if not (1000 * Mask(112, 0, _7143)) + (998 * _7083):
                                revert with 0, 18
                            if 998 * _7083 * Mask(112, 0, _7134) / (1000 * Mask(112, 0, _7143)) + (998 * _7083) < cd[164]:
                                revert with 0, 17
                            if (998 * _7083 * Mask(112, 0, _7134) / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7134) / (1000 * Mask(112, 0, _7143)) + (998 * _7083):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(_7068)
                            mem[mem[64] + 36] = _7083
                            require ext_code.size(address(_7221))
                            call address(_7221).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_7068), _7083
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8387 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8387] == bool(mem[_8387])
                            _8562 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_8562 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_8562 + 36] = (998 * _7083 * Mask(112, 0, _7134) / (1000 * Mask(112, 0, _7143)) + (998 * _7083)) - cd[164]
                            mem[_8562 + 68] = 0
                            mem[_8562 + 100] = this.address
                            mem[_8562 + 132] = 128
                            mem[_8562 + 164] = mem[_8562]
                            s = 0
                            while s < mem[_8562]:
                                mem[s + _8562 + 196] = mem[_8562 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_8562]) > mem[_8562]:
                                mem[_8562 + mem[_8562] + 196] = 0
                            require ext_code.size(address(_7068))
                            call address(_7068).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_8562]) + _8562 + -mem[64] + 192]
                    else:
                        if Mask(112, 0, _7134) <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if Mask(112, 0, _7143) <= 0:
                            revert with 0, 'INSUFFICIENT_LIQUIDITY'
                        if _7083 and 998 > -1 / _7083:
                            revert with 0, 17
                        if 998 * _7083 / 998 != _7083:
                            revert with 0, 'MUL error'
                        if not Mask(112, 0, _7143):
                            if Mask(112, 0, _7134) and 1000 > -1 / Mask(112, 0, _7134):
                                revert with 0, 17
                            if 1000 * Mask(112, 0, _7134) / 1000 != Mask(112, 0, _7134):
                                revert with 0, 'MUL error'
                            if 1000 * Mask(112, 0, _7134) > !(998 * _7083):
                                revert with 0, 17
                            if (1000 * Mask(112, 0, _7134)) + (998 * _7083) < 1000 * Mask(112, 0, _7134):
                                revert with 0, 'Add error'
                            if not (1000 * Mask(112, 0, _7134)) + (998 * _7083):
                                revert with 0, 18
                            if 0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083) < cd[164]:
                                revert with 0, 17
                            if (0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(_7068)
                            mem[mem[64] + 36] = _7083
                            require ext_code.size(address(_7185))
                            call address(_7185).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_7068), _7083
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8154 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8154] == bool(mem[_8154])
                            _8358 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_8358 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_8358 + 36] = 0
                            mem[_8358 + 68] = (0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164]
                            mem[_8358 + 100] = this.address
                            mem[_8358 + 132] = 128
                            mem[_8358 + 164] = mem[_8358]
                            s = 0
                            while s < mem[_8358]:
                                mem[s + _8358 + 196] = mem[_8358 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_8358]) > mem[_8358]:
                                mem[_8358 + mem[_8358] + 196] = 0
                            require ext_code.size(address(_7068))
                            call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (0 / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164], address(this.address), 128, mem[_8358], mem[_8358 + 196 len ceil32(mem[_8358])]
                        else:
                            if 998 * _7083 and Mask(112, 0, _7143) > -1 / 998 * _7083:
                                revert with 0, 17
                            if not Mask(112, 0, _7143):
                                revert with 0, 18
                            if 998 * _7083 * Mask(112, 0, _7143) / Mask(112, 0, _7143) != 998 * _7083:
                                revert with 0, 'MUL error'
                            if Mask(112, 0, _7134) and 1000 > -1 / Mask(112, 0, _7134):
                                revert with 0, 17
                            if 1000 * Mask(112, 0, _7134) / 1000 != Mask(112, 0, _7134):
                                revert with 0, 'MUL error'
                            if 1000 * Mask(112, 0, _7134) > !(998 * _7083):
                                revert with 0, 17
                            if (1000 * Mask(112, 0, _7134)) + (998 * _7083) < 1000 * Mask(112, 0, _7134):
                                revert with 0, 'Add error'
                            if not (1000 * Mask(112, 0, _7134)) + (998 * _7083):
                                revert with 0, 18
                            if 998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083) < cd[164]:
                                revert with 0, 17
                            if (998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083):
                                revert with 0, 'SUB error'
                            mem[mem[64] + 4] = address(_7068)
                            mem[mem[64] + 36] = _7083
                            require ext_code.size(address(_7185))
                            call address(_7185).0xa9059cbb with:
                                 gas gas_remaining wei
                                args address(_7068), _7083
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _8388 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_8388] == bool(mem[_8388])
                            _8564 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_8564 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_8564 + 36] = 0
                            mem[_8564 + 68] = (998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164]
                            mem[_8564 + 100] = this.address
                            mem[_8564 + 132] = 128
                            mem[_8564 + 164] = mem[_8564]
                            s = 0
                            while s < mem[_8564]:
                                mem[s + _8564 + 196] = mem[_8564 + s + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_8564]) > mem[_8564]:
                                mem[_8564 + mem[_8564] + 196] = 0
                            require ext_code.size(address(_7068))
                            call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                 gas gas_remaining wei
                                args 0, (998 * _7083 * Mask(112, 0, _7143) / (1000 * Mask(112, 0, _7134)) + (998 * _7083)) - cd[164], address(this.address), 128, mem[_8564], mem[_8564 + 196 len ceil32(mem[_8564])]
            else:
                if msg.sender == stor1:
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7125 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7137 = mem[_7125]
                    require mem[_7125] == mem[_7125 + 18 len 14]
                    _7146 = mem[_7125 + 32]
                    require mem[_7125 + 32] == mem[_7125 + 50 len 14]
                    require mem[_7125 + 64] == mem[_7125 + 92 len 4]
                    require ext_code.size(address(_7068))
                    staticcall address(_7068).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7182 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7191 = mem[_7182]
                    require mem[_7182] == mem[_7182 + 12 len 20]
                    require ext_code.size(address(_7068))
                    staticcall address(_7068).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7218 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7227 = mem[_7218]
                    require mem[_7218] == mem[_7218 + 12 len 20]
                    if address(_7191) == address(_7075):
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_7075))
                        staticcall address(_7075).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7276 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_7276] < _7083:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _7083 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_7191) != address(_7075):
                            if Mask(112, 0, _7146) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7137) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7083 and 998 > -1 / _7083:
                                revert with 0, 17
                            if 998 * _7083 / 998 != _7083:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7137):
                                if Mask(112, 0, _7146) and 1000 > -1 / Mask(112, 0, _7146):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7146) / 1000 != Mask(112, 0, _7146):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7146) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7146)) + (998 * _7083) < 1000 * Mask(112, 0, _7146):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7146)) + (998 * _7083):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7146)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7146)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7227))
                                call address(_7227).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8155 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8155] == bool(mem[_8155])
                                _8359 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8359 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8359 + 36] = (0 / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164]
                                mem[_8359 + 68] = 0
                                mem[_8359 + 100] = this.address
                                mem[_8359 + 132] = 128
                                mem[_8359 + 164] = mem[_8359]
                                s = 0
                                while s < mem[_8359]:
                                    mem[s + _8359 + 196] = mem[_8359 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8359]) > mem[_8359]:
                                    mem[_8359 + mem[_8359] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8359]) + _8359 + -mem[64] + 192]
                            else:
                                if 998 * _7083 and Mask(112, 0, _7137) > -1 / 998 * _7083:
                                    revert with 0, 17
                                if not Mask(112, 0, _7137):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7137) / Mask(112, 0, _7137) != 998 * _7083:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7146) and 1000 > -1 / Mask(112, 0, _7146):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7146) / 1000 != Mask(112, 0, _7146):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7146) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7146)) + (998 * _7083) < 1000 * Mask(112, 0, _7146):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7146)) + (998 * _7083):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7227))
                                call address(_7227).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8389 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8389] == bool(mem[_8389])
                                _8566 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8566 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8566 + 36] = (998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164]
                                mem[_8566 + 68] = 0
                                mem[_8566 + 100] = this.address
                                mem[_8566 + 132] = 128
                                mem[_8566 + 164] = mem[_8566]
                                s = 0
                                while s < mem[_8566]:
                                    mem[s + _8566 + 196] = mem[_8566 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8566]) > mem[_8566]:
                                    mem[_8566 + mem[_8566] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164], 0, address(this.address), 128, mem[_8566], mem[_8566 + 196 len ceil32(mem[_8566])]
                        else:
                            if Mask(112, 0, _7137) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7146) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7083 and 998 > -1 / _7083:
                                revert with 0, 17
                            if 998 * _7083 / 998 != _7083:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7146):
                                if Mask(112, 0, _7137) and 1000 > -1 / Mask(112, 0, _7137):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7137) / 1000 != Mask(112, 0, _7137):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7137) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7137)) + (998 * _7083) < 1000 * Mask(112, 0, _7137):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7137)) + (998 * _7083):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7191))
                                call address(_7191).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8156 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8156] == bool(mem[_8156])
                                _8360 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8360 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8360 + 36] = 0
                                mem[_8360 + 68] = (0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164]
                                mem[_8360 + 100] = this.address
                                mem[_8360 + 132] = 128
                                mem[_8360 + 164] = mem[_8360]
                                s = 0
                                while s < mem[_8360]:
                                    mem[s + _8360 + 196] = mem[_8360 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8360]) > mem[_8360]:
                                    mem[_8360 + mem[_8360] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8360]) + _8360 + -mem[64] + 192]
                            else:
                                if 998 * _7083 and Mask(112, 0, _7146) > -1 / 998 * _7083:
                                    revert with 0, 17
                                if not Mask(112, 0, _7146):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7146) / Mask(112, 0, _7146) != 998 * _7083:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7137) and 1000 > -1 / Mask(112, 0, _7137):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7137) / 1000 != Mask(112, 0, _7137):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7137) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7137)) + (998 * _7083) < 1000 * Mask(112, 0, _7137):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7137)) + (998 * _7083):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7191))
                                call address(_7191).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8390 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8390] == bool(mem[_8390])
                                _8568 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8568 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8568 + 36] = 0
                                mem[_8568 + 68] = (998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164]
                                mem[_8568 + 100] = this.address
                                mem[_8568 + 132] = 128
                                mem[_8568 + 164] = mem[_8568]
                                s = 0
                                while s < mem[_8568]:
                                    mem[s + _8568 + 196] = mem[_8568 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8568]) > mem[_8568]:
                                    mem[_8568 + mem[_8568] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8568]) + _8568 + -mem[64] + 192]
                    else:
                        if mem[_7218 + 12 len 20] != address(_7075):
                            revert with 0, 'Check pair address'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_7075))
                        staticcall address(_7075).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7294 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_7294] < _7083:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _7083 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_7191) != address(_7075):
                            if Mask(112, 0, _7146) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7137) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7083 and 998 > -1 / _7083:
                                revert with 0, 17
                            if 998 * _7083 / 998 != _7083:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7137):
                                if Mask(112, 0, _7146) and 1000 > -1 / Mask(112, 0, _7146):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7146) / 1000 != Mask(112, 0, _7146):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7146) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7146)) + (998 * _7083) < 1000 * Mask(112, 0, _7146):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7146)) + (998 * _7083):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7146)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7146)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7227))
                                call address(_7227).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8183 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8183] == bool(mem[_8183])
                                _8391 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8391 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8391 + 36] = (0 / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164]
                                mem[_8391 + 68] = 0
                                mem[_8391 + 100] = this.address
                                mem[_8391 + 132] = 128
                                mem[_8391 + 164] = mem[_8391]
                                s = 0
                                while s < mem[_8391]:
                                    mem[s + _8391 + 196] = mem[_8391 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8391]) > mem[_8391]:
                                    mem[_8391 + mem[_8391] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8391]) + _8391 + -mem[64] + 192]
                            else:
                                if 998 * _7083 and Mask(112, 0, _7137) > -1 / 998 * _7083:
                                    revert with 0, 17
                                if not Mask(112, 0, _7137):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7137) / Mask(112, 0, _7137) != 998 * _7083:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7146) and 1000 > -1 / Mask(112, 0, _7146):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7146) / 1000 != Mask(112, 0, _7146):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7146) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7146)) + (998 * _7083) < 1000 * Mask(112, 0, _7146):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7146)) + (998 * _7083):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7227))
                                call address(_7227).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8427 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8427] == bool(mem[_8427])
                                _8596 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8596 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8596 + 36] = (998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164]
                                mem[_8596 + 68] = 0
                                mem[_8596 + 100] = this.address
                                mem[_8596 + 132] = 128
                                mem[_8596 + 164] = mem[_8596]
                                s = 0
                                while s < mem[_8596]:
                                    mem[s + _8596 + 196] = mem[_8596 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8596]) > mem[_8596]:
                                    mem[_8596 + mem[_8596] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (998 * _7083 * Mask(112, 0, _7137) / (1000 * Mask(112, 0, _7146)) + (998 * _7083)) - cd[164], 0, address(this.address), 128, mem[_8596], mem[_8596 + 196 len ceil32(mem[_8596])]
                        else:
                            if Mask(112, 0, _7137) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7146) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7083 and 998 > -1 / _7083:
                                revert with 0, 17
                            if 998 * _7083 / 998 != _7083:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7146):
                                if Mask(112, 0, _7137) and 1000 > -1 / Mask(112, 0, _7137):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7137) / 1000 != Mask(112, 0, _7137):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7137) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7137)) + (998 * _7083) < 1000 * Mask(112, 0, _7137):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7137)) + (998 * _7083):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7191))
                                call address(_7191).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8184 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8184] == bool(mem[_8184])
                                _8392 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8392 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8392 + 36] = 0
                                mem[_8392 + 68] = (0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164]
                                mem[_8392 + 100] = this.address
                                mem[_8392 + 132] = 128
                                mem[_8392 + 164] = mem[_8392]
                                s = 0
                                while s < mem[_8392]:
                                    mem[s + _8392 + 196] = mem[_8392 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8392]) > mem[_8392]:
                                    mem[_8392 + mem[_8392] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (0 / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164], address(this.address), 128, mem[_8392], mem[_8392 + 196 len ceil32(mem[_8392])]
                            else:
                                if 998 * _7083 and Mask(112, 0, _7146) > -1 / 998 * _7083:
                                    revert with 0, 17
                                if not Mask(112, 0, _7146):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7146) / Mask(112, 0, _7146) != 998 * _7083:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7137) and 1000 > -1 / Mask(112, 0, _7137):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7137) / 1000 != Mask(112, 0, _7137):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7137) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7137)) + (998 * _7083) < 1000 * Mask(112, 0, _7137):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7137)) + (998 * _7083):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7191))
                                call address(_7191).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8428 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8428] == bool(mem[_8428])
                                _8598 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8598 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8598 + 36] = 0
                                mem[_8598 + 68] = (998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164]
                                mem[_8598 + 100] = this.address
                                mem[_8598 + 132] = 128
                                mem[_8598 + 164] = mem[_8598]
                                s = 0
                                while s < mem[_8598]:
                                    mem[s + _8598 + 196] = mem[_8598 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8598]) > mem[_8598]:
                                    mem[_8598 + mem[_8598] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (998 * _7083 * Mask(112, 0, _7146) / (1000 * Mask(112, 0, _7137)) + (998 * _7083)) - cd[164], address(this.address), 128, mem[_8598], mem[_8598 + 196 len ceil32(mem[_8598])]
                else:
                    if stor2 != msg.sender:
                        revert with 0, 'Not authorized'
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7128 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7140 = mem[_7128]
                    require mem[_7128] == mem[_7128 + 18 len 14]
                    _7150 = mem[_7128 + 32]
                    require mem[_7128 + 32] == mem[_7128 + 50 len 14]
                    require mem[_7128 + 64] == mem[_7128 + 92 len 4]
                    require ext_code.size(address(_7068))
                    staticcall address(_7068).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7186 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7194 = mem[_7186]
                    require mem[_7186] == mem[_7186 + 12 len 20]
                    require ext_code.size(address(_7068))
                    staticcall address(_7068).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7222 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7230 = mem[_7222]
                    require mem[_7222] == mem[_7222 + 12 len 20]
                    if address(_7194) == address(_7075):
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_7075))
                        staticcall address(_7075).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7295 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_7295] < _7083:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _7083 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_7194) != address(_7075):
                            if Mask(112, 0, _7150) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7140) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7083 and 998 > -1 / _7083:
                                revert with 0, 17
                            if 998 * _7083 / 998 != _7083:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7140):
                                if Mask(112, 0, _7150) and 1000 > -1 / Mask(112, 0, _7150):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7150) / 1000 != Mask(112, 0, _7150):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7150) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7150)) + (998 * _7083) < 1000 * Mask(112, 0, _7150):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7150)) + (998 * _7083):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7150)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7150)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7230))
                                call address(_7230).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8185 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8185] == bool(mem[_8185])
                                _8393 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8393 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8393 + 36] = (0 / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164]
                                mem[_8393 + 68] = 0
                                mem[_8393 + 100] = this.address
                                mem[_8393 + 132] = 128
                                mem[_8393 + 164] = mem[_8393]
                                s = 0
                                while s < mem[_8393]:
                                    mem[s + _8393 + 196] = mem[_8393 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8393]) > mem[_8393]:
                                    mem[_8393 + mem[_8393] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8393]) + _8393 + -mem[64] + 192]
                            else:
                                if 998 * _7083 and Mask(112, 0, _7140) > -1 / 998 * _7083:
                                    revert with 0, 17
                                if not Mask(112, 0, _7140):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7140) / Mask(112, 0, _7140) != 998 * _7083:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7150) and 1000 > -1 / Mask(112, 0, _7150):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7150) / 1000 != Mask(112, 0, _7150):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7150) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7150)) + (998 * _7083) < 1000 * Mask(112, 0, _7150):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7150)) + (998 * _7083):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7230))
                                call address(_7230).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8429 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8429] == bool(mem[_8429])
                                _8600 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8600 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8600 + 36] = (998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164]
                                mem[_8600 + 68] = 0
                                mem[_8600 + 100] = this.address
                                mem[_8600 + 132] = 128
                                mem[_8600 + 164] = mem[_8600]
                                s = 0
                                while s < mem[_8600]:
                                    mem[s + _8600 + 196] = mem[_8600 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8600]) > mem[_8600]:
                                    mem[_8600 + mem[_8600] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8600]) + _8600 + -mem[64] + 192]
                        else:
                            if Mask(112, 0, _7140) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7150) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7083 and 998 > -1 / _7083:
                                revert with 0, 17
                            if 998 * _7083 / 998 != _7083:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7150):
                                if Mask(112, 0, _7140) and 1000 > -1 / Mask(112, 0, _7140):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7140) / 1000 != Mask(112, 0, _7140):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7140) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7140)) + (998 * _7083) < 1000 * Mask(112, 0, _7140):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7140)) + (998 * _7083):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7140)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7140)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7194))
                                call address(_7194).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8186 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8186] == bool(mem[_8186])
                                _8394 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8394 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8394 + 36] = 0
                                mem[_8394 + 68] = (0 / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164]
                                mem[_8394 + 100] = this.address
                                mem[_8394 + 132] = 128
                                mem[_8394 + 164] = mem[_8394]
                                s = 0
                                while s < mem[_8394]:
                                    mem[s + _8394 + 196] = mem[_8394 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8394]) > mem[_8394]:
                                    mem[_8394 + mem[_8394] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8394]) + _8394 + -mem[64] + 192]
                            else:
                                if 998 * _7083 and Mask(112, 0, _7150) > -1 / 998 * _7083:
                                    revert with 0, 17
                                if not Mask(112, 0, _7150):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7150) / Mask(112, 0, _7150) != 998 * _7083:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7140) and 1000 > -1 / Mask(112, 0, _7140):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7140) / 1000 != Mask(112, 0, _7140):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7140) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7140)) + (998 * _7083) < 1000 * Mask(112, 0, _7140):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7140)) + (998 * _7083):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7194))
                                call address(_7194).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8430 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8430] == bool(mem[_8430])
                                _8602 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8602 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8602 + 36] = 0
                                mem[_8602 + 68] = (998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164]
                                mem[_8602 + 100] = this.address
                                mem[_8602 + 132] = 128
                                mem[_8602 + 164] = mem[_8602]
                                s = 0
                                while s < mem[_8602]:
                                    mem[s + _8602 + 196] = mem[_8602 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8602]) > mem[_8602]:
                                    mem[_8602 + mem[_8602] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164], address(this.address), 128, mem[_8602], mem[_8602 + 196 len ceil32(mem[_8602])]
                    else:
                        if mem[_7222 + 12 len 20] != address(_7075):
                            revert with 0, 'Check pair address'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_7075))
                        staticcall address(_7075).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7307 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_7307] < _7083:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _7083 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_7194) != address(_7075):
                            if Mask(112, 0, _7150) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7140) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7083 and 998 > -1 / _7083:
                                revert with 0, 17
                            if 998 * _7083 / 998 != _7083:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7140):
                                if Mask(112, 0, _7150) and 1000 > -1 / Mask(112, 0, _7150):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7150) / 1000 != Mask(112, 0, _7150):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7150) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7150)) + (998 * _7083) < 1000 * Mask(112, 0, _7150):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7150)) + (998 * _7083):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7150)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7150)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7230))
                                call address(_7230).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8225 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8225] == bool(mem[_8225])
                                _8431 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8431 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8431 + 36] = (0 / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164]
                                mem[_8431 + 68] = 0
                                mem[_8431 + 100] = this.address
                                mem[_8431 + 132] = 128
                                mem[_8431 + 164] = mem[_8431]
                                s = 0
                                while s < mem[_8431]:
                                    mem[s + _8431 + 196] = mem[_8431 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8431]) > mem[_8431]:
                                    mem[_8431 + mem[_8431] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8431]) + _8431 + -mem[64] + 192]
                            else:
                                if 998 * _7083 and Mask(112, 0, _7140) > -1 / 998 * _7083:
                                    revert with 0, 17
                                if not Mask(112, 0, _7140):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7140) / Mask(112, 0, _7140) != 998 * _7083:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7150) and 1000 > -1 / Mask(112, 0, _7150):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7150) / 1000 != Mask(112, 0, _7150):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7150) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7150)) + (998 * _7083) < 1000 * Mask(112, 0, _7150):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7150)) + (998 * _7083):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7230))
                                call address(_7230).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8467 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8467] == bool(mem[_8467])
                                _8640 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8640 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8640 + 36] = (998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164]
                                mem[_8640 + 68] = 0
                                mem[_8640 + 100] = this.address
                                mem[_8640 + 132] = 128
                                mem[_8640 + 164] = mem[_8640]
                                s = 0
                                while s < mem[_8640]:
                                    mem[s + _8640 + 196] = mem[_8640 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8640]) > mem[_8640]:
                                    mem[_8640 + mem[_8640] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (998 * _7083 * Mask(112, 0, _7140) / (1000 * Mask(112, 0, _7150)) + (998 * _7083)) - cd[164], 0, address(this.address), 128, mem[_8640], mem[_8640 + 196 len ceil32(mem[_8640])]
                        else:
                            if Mask(112, 0, _7140) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7150) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7083 and 998 > -1 / _7083:
                                revert with 0, 17
                            if 998 * _7083 / 998 != _7083:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7150):
                                if Mask(112, 0, _7140) and 1000 > -1 / Mask(112, 0, _7140):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7140) / 1000 != Mask(112, 0, _7140):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7140) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7140)) + (998 * _7083) < 1000 * Mask(112, 0, _7140):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7140)) + (998 * _7083):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7140)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164] > 0 / (1000 * Mask(112, 0, _7140)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7194))
                                call address(_7194).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8226 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8226] == bool(mem[_8226])
                                _8432 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8432 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8432 + 36] = 0
                                mem[_8432 + 68] = (0 / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164]
                                mem[_8432 + 100] = this.address
                                mem[_8432 + 132] = 128
                                mem[_8432 + 164] = mem[_8432]
                                s = 0
                                while s < mem[_8432]:
                                    mem[s + _8432 + 196] = mem[_8432 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8432]) > mem[_8432]:
                                    mem[_8432 + mem[_8432] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8432]) + _8432 + -mem[64] + 192]
                            else:
                                if 998 * _7083 and Mask(112, 0, _7150) > -1 / 998 * _7083:
                                    revert with 0, 17
                                if not Mask(112, 0, _7150):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7150) / Mask(112, 0, _7150) != 998 * _7083:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7140) and 1000 > -1 / Mask(112, 0, _7140):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7140) / 1000 != Mask(112, 0, _7140):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7140) > !(998 * _7083):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7140)) + (998 * _7083) < 1000 * Mask(112, 0, _7140):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7140)) + (998 * _7083):
                                    revert with 0, 18
                                if 998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164] > 998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7068)
                                mem[mem[64] + 36] = _7083
                                require ext_code.size(address(_7194))
                                call address(_7194).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7068), _7083
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8468 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8468] == bool(mem[_8468])
                                _8642 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8642 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8642 + 36] = 0
                                mem[_8642 + 68] = (998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164]
                                mem[_8642 + 100] = this.address
                                mem[_8642 + 132] = 128
                                mem[_8642 + 164] = mem[_8642]
                                s = 0
                                while s < mem[_8642]:
                                    mem[s + _8642 + 196] = mem[_8642 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8642]) > mem[_8642]:
                                    mem[_8642 + mem[_8642] + 196] = 0
                                require ext_code.size(address(_7068))
                                call address(_7068).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (998 * _7083 * Mask(112, 0, _7150) / (1000 * Mask(112, 0, _7140)) + (998 * _7083)) - cd[164], address(this.address), 128, mem[_8642], mem[_8642 + 196 len ceil32(mem[_8642])]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _7083
            s = _7075
            s = _7068
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[100]))
        staticcall address(cd[100]).0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _7074 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_7074] < cd[132]:
            revert with 0, 'Check result'
        mem[mem[64]] = mem[_7074]
    else:
        if msg.sender == stor1:
            if ('cd', 4).length != ('cd', 36).length:
                revert with 0, 'Check length1'
            if ('cd', 4).length != ('cd', 68).length:
                revert with 0, 'Check length2'
            idx = 0
            s = 0
            s = 0
            s = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _7070 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _7078 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                _7084 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                if msg.sender == stor0:
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7117 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7135 = mem[_7117]
                    require mem[_7117] == mem[_7117 + 18 len 14]
                    _7144 = mem[_7117 + 32]
                    require mem[_7117 + 32] == mem[_7117 + 50 len 14]
                    require mem[_7117 + 64] == mem[_7117 + 92 len 4]
                    require ext_code.size(address(_7070))
                    staticcall address(_7070).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7176 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7187 = mem[_7176]
                    require mem[_7176] == mem[_7176 + 12 len 20]
                    require ext_code.size(address(_7070))
                    staticcall address(_7070).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7212 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7223 = mem[_7212]
                    require mem[_7212] == mem[_7212 + 12 len 20]
                    if address(_7187) == address(_7078):
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_7078))
                        staticcall address(_7078).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7261 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_7261] < _7084:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _7084 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_7187) != address(_7078):
                            if Mask(112, 0, _7144) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7135) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7084 and 998 > -1 / _7084:
                                revert with 0, 17
                            if 998 * _7084 / 998 != _7084:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7135):
                                if Mask(112, 0, _7144) and 1000 > -1 / Mask(112, 0, _7144):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7144) / 1000 != Mask(112, 0, _7144):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7144) > !(998 * _7084):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7144)) + (998 * _7084) < 1000 * Mask(112, 0, _7144):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7144)) + (998 * _7084):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7070)
                                mem[mem[64] + 36] = _7084
                                require ext_code.size(address(_7223))
                                call address(_7223).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7070), _7084
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8139 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8139] == bool(mem[_8139])
                                _8339 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8339 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8339 + 36] = (0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164]
                                mem[_8339 + 68] = 0
                                mem[_8339 + 100] = this.address
                                mem[_8339 + 132] = 128
                                mem[_8339 + 164] = mem[_8339]
                                s = 0
                                while s < mem[_8339]:
                                    mem[s + _8339 + 196] = mem[_8339 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8339]) > mem[_8339]:
                                    mem[_8339 + mem[_8339] + 196] = 0
                                require ext_code.size(address(_7070))
                                call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164], 0, address(this.address), 128, mem[_8339], mem[_8339 + 196 len ceil32(mem[_8339])]
                            else:
                                if 998 * _7084 and Mask(112, 0, _7135) > -1 / 998 * _7084:
                                    revert with 0, 17
                                if not Mask(112, 0, _7135):
                                    revert with 0, 18
                                if 998 * _7084 * Mask(112, 0, _7135) / Mask(112, 0, _7135) != 998 * _7084:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7144) and 1000 > -1 / Mask(112, 0, _7144):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7144) / 1000 != Mask(112, 0, _7144):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7144) > !(998 * _7084):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7144)) + (998 * _7084) < 1000 * Mask(112, 0, _7144):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7144)) + (998 * _7084):
                                    revert with 0, 18
                                if 998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7070)
                                mem[mem[64] + 36] = _7084
                                require ext_code.size(address(_7223))
                                call address(_7223).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7070), _7084
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8365 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8365] == bool(mem[_8365])
                                _8548 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8548 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8548 + 36] = (998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164]
                                mem[_8548 + 68] = 0
                                mem[_8548 + 100] = this.address
                                mem[_8548 + 132] = 128
                                mem[_8548 + 164] = mem[_8548]
                                s = 0
                                while s < mem[_8548]:
                                    mem[s + _8548 + 196] = mem[_8548 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8548]) > mem[_8548]:
                                    mem[_8548 + mem[_8548] + 196] = 0
                                require ext_code.size(address(_7070))
                                call address(_7070).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8548]) + _8548 + -mem[64] + 192]
                        else:
                            if Mask(112, 0, _7135) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7144) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7084 and 998 > -1 / _7084:
                                revert with 0, 17
                            if 998 * _7084 / 998 != _7084:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7144):
                                if Mask(112, 0, _7135) and 1000 > -1 / Mask(112, 0, _7135):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7135) / 1000 != Mask(112, 0, _7135):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7135) > !(998 * _7084):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7135)) + (998 * _7084) < 1000 * Mask(112, 0, _7135):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7135)) + (998 * _7084):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7070)
                                mem[mem[64] + 36] = _7084
                                require ext_code.size(address(_7187))
                                call address(_7187).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7070), _7084
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8140 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8140] == bool(mem[_8140])
                                _8340 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8340 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8340 + 36] = 0
                                mem[_8340 + 68] = (0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164]
                                mem[_8340 + 100] = this.address
                                mem[_8340 + 132] = 128
                                mem[_8340 + 164] = mem[_8340]
                                s = 0
                                while s < mem[_8340]:
                                    mem[s + _8340 + 196] = mem[_8340 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8340]) > mem[_8340]:
                                    mem[_8340 + mem[_8340] + 196] = 0
                                require ext_code.size(address(_7070))
                                call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164], address(this.address), 128, mem[_8340], mem[_8340 + 196 len ceil32(mem[_8340])]
                            else:
                                if 998 * _7084 and Mask(112, 0, _7144) > -1 / 998 * _7084:
                                    revert with 0, 17
                                if not Mask(112, 0, _7144):
                                    revert with 0, 18
                                if 998 * _7084 * Mask(112, 0, _7144) / Mask(112, 0, _7144) != 998 * _7084:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7135) and 1000 > -1 / Mask(112, 0, _7135):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7135) / 1000 != Mask(112, 0, _7135):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7135) > !(998 * _7084):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7135)) + (998 * _7084) < 1000 * Mask(112, 0, _7135):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7135)) + (998 * _7084):
                                    revert with 0, 18
                                if 998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7070)
                                mem[mem[64] + 36] = _7084
                                require ext_code.size(address(_7187))
                                call address(_7187).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7070), _7084
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8366 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8366] == bool(mem[_8366])
                                _8550 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8550 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8550 + 36] = 0
                                mem[_8550 + 68] = (998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164]
                                mem[_8550 + 100] = this.address
                                mem[_8550 + 132] = 128
                                mem[_8550 + 164] = mem[_8550]
                                s = 0
                                while s < mem[_8550]:
                                    mem[s + _8550 + 196] = mem[_8550 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8550]) > mem[_8550]:
                                    mem[_8550 + mem[_8550] + 196] = 0
                                require ext_code.size(address(_7070))
                                call address(_7070).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8550]) + _8550 + -mem[64] + 192]
                    else:
                        if mem[_7212 + 12 len 20] != address(_7078):
                            revert with 0, 'Check pair address'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_7078))
                        staticcall address(_7078).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7281 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_7281] < _7084:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _7084 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_7187) != address(_7078):
                            if Mask(112, 0, _7144) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7135) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7084 and 998 > -1 / _7084:
                                revert with 0, 17
                            if 998 * _7084 / 998 != _7084:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7135):
                                if Mask(112, 0, _7144) and 1000 > -1 / Mask(112, 0, _7144):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7144) / 1000 != Mask(112, 0, _7144):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7144) > !(998 * _7084):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7144)) + (998 * _7084) < 1000 * Mask(112, 0, _7144):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7144)) + (998 * _7084):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7070)
                                mem[mem[64] + 36] = _7084
                                require ext_code.size(address(_7223))
                                call address(_7223).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7070), _7084
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8161 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8161] == bool(mem[_8161])
                                _8367 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8367 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8367 + 36] = (0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164]
                                mem[_8367 + 68] = 0
                                mem[_8367 + 100] = this.address
                                mem[_8367 + 132] = 128
                                mem[_8367 + 164] = mem[_8367]
                                s = 0
                                while s < mem[_8367]:
                                    mem[s + _8367 + 196] = mem[_8367 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8367]) > mem[_8367]:
                                    mem[_8367 + mem[_8367] + 196] = 0
                                require ext_code.size(address(_7070))
                                call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (0 / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164], 0, address(this.address), 128, mem[_8367], mem[_8367 + 196 len ceil32(mem[_8367])]
                            else:
                                if 998 * _7084 and Mask(112, 0, _7135) > -1 / 998 * _7084:
                                    revert with 0, 17
                                if not Mask(112, 0, _7135):
                                    revert with 0, 18
                                if 998 * _7084 * Mask(112, 0, _7135) / Mask(112, 0, _7135) != 998 * _7084:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7144) and 1000 > -1 / Mask(112, 0, _7144):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7144) / 1000 != Mask(112, 0, _7144):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7144) > !(998 * _7084):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7144)) + (998 * _7084) < 1000 * Mask(112, 0, _7144):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7144)) + (998 * _7084):
                                    revert with 0, 18
                                if 998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7070)
                                mem[mem[64] + 36] = _7084
                                require ext_code.size(address(_7223))
                                call address(_7223).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7070), _7084
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8399 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8399] == bool(mem[_8399])
                                _8572 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8572 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8572 + 36] = (998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164]
                                mem[_8572 + 68] = 0
                                mem[_8572 + 100] = this.address
                                mem[_8572 + 132] = 128
                                mem[_8572 + 164] = mem[_8572]
                                s = 0
                                while s < mem[_8572]:
                                    mem[s + _8572 + 196] = mem[_8572 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8572]) > mem[_8572]:
                                    mem[_8572 + mem[_8572] + 196] = 0
                                require ext_code.size(address(_7070))
                                call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (998 * _7084 * Mask(112, 0, _7135) / (1000 * Mask(112, 0, _7144)) + (998 * _7084)) - cd[164], 0, address(this.address), 128, mem[_8572], mem[_8572 + 196 len ceil32(mem[_8572])]
                        else:
                            if Mask(112, 0, _7135) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7144) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7084 and 998 > -1 / _7084:
                                revert with 0, 17
                            if 998 * _7084 / 998 != _7084:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7144):
                                if Mask(112, 0, _7135) and 1000 > -1 / Mask(112, 0, _7135):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7135) / 1000 != Mask(112, 0, _7135):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7135) > !(998 * _7084):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7135)) + (998 * _7084) < 1000 * Mask(112, 0, _7135):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7135)) + (998 * _7084):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7070)
                                mem[mem[64] + 36] = _7084
                                require ext_code.size(address(_7187))
                                call address(_7187).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7070), _7084
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8162 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8162] == bool(mem[_8162])
                                _8368 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8368 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8368 + 36] = 0
                                mem[_8368 + 68] = (0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164]
                                mem[_8368 + 100] = this.address
                                mem[_8368 + 132] = 128
                                mem[_8368 + 164] = mem[_8368]
                                s = 0
                                while s < mem[_8368]:
                                    mem[s + _8368 + 196] = mem[_8368 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8368]) > mem[_8368]:
                                    mem[_8368 + mem[_8368] + 196] = 0
                                require ext_code.size(address(_7070))
                                call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (0 / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164], address(this.address), 128, mem[_8368], mem[_8368 + 196 len ceil32(mem[_8368])]
                            else:
                                if 998 * _7084 and Mask(112, 0, _7144) > -1 / 998 * _7084:
                                    revert with 0, 17
                                if not Mask(112, 0, _7144):
                                    revert with 0, 18
                                if 998 * _7084 * Mask(112, 0, _7144) / Mask(112, 0, _7144) != 998 * _7084:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7135) and 1000 > -1 / Mask(112, 0, _7135):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7135) / 1000 != Mask(112, 0, _7135):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7135) > !(998 * _7084):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7135)) + (998 * _7084) < 1000 * Mask(112, 0, _7135):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7135)) + (998 * _7084):
                                    revert with 0, 18
                                if 998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7070)
                                mem[mem[64] + 36] = _7084
                                require ext_code.size(address(_7187))
                                call address(_7187).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7070), _7084
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8400 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8400] == bool(mem[_8400])
                                _8574 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8574 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8574 + 36] = 0
                                mem[_8574 + 68] = (998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164]
                                mem[_8574 + 100] = this.address
                                mem[_8574 + 132] = 128
                                mem[_8574 + 164] = mem[_8574]
                                s = 0
                                while s < mem[_8574]:
                                    mem[s + _8574 + 196] = mem[_8574 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8574]) > mem[_8574]:
                                    mem[_8574 + mem[_8574] + 196] = 0
                                require ext_code.size(address(_7070))
                                call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (998 * _7084 * Mask(112, 0, _7144) / (1000 * Mask(112, 0, _7135)) + (998 * _7084)) - cd[164], address(this.address), 128, mem[_8574], mem[_8574 + 196 len ceil32(mem[_8574])]
                else:
                    if msg.sender == stor1:
                        require ext_code.size(mem[(32 * idx) + 140 len 20])
                        staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7126 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7138 = mem[_7126]
                        require mem[_7126] == mem[_7126 + 18 len 14]
                        _7147 = mem[_7126 + 32]
                        require mem[_7126 + 32] == mem[_7126 + 50 len 14]
                        require mem[_7126 + 64] == mem[_7126 + 92 len 4]
                        require ext_code.size(address(_7070))
                        staticcall address(_7070).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7183 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7192 = mem[_7183]
                        require mem[_7183] == mem[_7183 + 12 len 20]
                        require ext_code.size(address(_7070))
                        staticcall address(_7070).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7219 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7228 = mem[_7219]
                        require mem[_7219] == mem[_7219 + 12 len 20]
                        if address(_7192) == address(_7078):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_7078))
                            staticcall address(_7078).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7282 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_7282] < _7084:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _7084 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_7192) != address(_7078):
                                if Mask(112, 0, _7147) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7138) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7084 and 998 > -1 / _7084:
                                    revert with 0, 17
                                if 998 * _7084 / 998 != _7084:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7138):
                                    if Mask(112, 0, _7147) and 1000 > -1 / Mask(112, 0, _7147):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7147) / 1000 != Mask(112, 0, _7147):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7147) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7147)) + (998 * _7084) < 1000 * Mask(112, 0, _7147):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7147)) + (998 * _7084):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7228))
                                    call address(_7228).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8163 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8163] == bool(mem[_8163])
                                    _8369 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8369 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8369 + 36] = (0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164]
                                    mem[_8369 + 68] = 0
                                    mem[_8369 + 100] = this.address
                                    mem[_8369 + 132] = 128
                                    mem[_8369 + 164] = mem[_8369]
                                    s = 0
                                    while s < mem[_8369]:
                                        mem[s + _8369 + 196] = mem[_8369 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8369]) > mem[_8369]:
                                        mem[_8369 + mem[_8369] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164], 0, address(this.address), 128, mem[_8369], mem[_8369 + 196 len ceil32(mem[_8369])]
                                else:
                                    if 998 * _7084 and Mask(112, 0, _7138) > -1 / 998 * _7084:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7138):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7138) / Mask(112, 0, _7138) != 998 * _7084:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7147) and 1000 > -1 / Mask(112, 0, _7147):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7147) / 1000 != Mask(112, 0, _7147):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7147) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7147)) + (998 * _7084) < 1000 * Mask(112, 0, _7147):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7147)) + (998 * _7084):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7228))
                                    call address(_7228).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8401 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8401] == bool(mem[_8401])
                                    _8576 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8576 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8576 + 36] = (998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164]
                                    mem[_8576 + 68] = 0
                                    mem[_8576 + 100] = this.address
                                    mem[_8576 + 132] = 128
                                    mem[_8576 + 164] = mem[_8576]
                                    s = 0
                                    while s < mem[_8576]:
                                        mem[s + _8576 + 196] = mem[_8576 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8576]) > mem[_8576]:
                                        mem[_8576 + mem[_8576] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164], 0, address(this.address), 128, mem[_8576], mem[_8576 + 196 len ceil32(mem[_8576])]
                            else:
                                if Mask(112, 0, _7138) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7147) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7084 and 998 > -1 / _7084:
                                    revert with 0, 17
                                if 998 * _7084 / 998 != _7084:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7147):
                                    if Mask(112, 0, _7138) and 1000 > -1 / Mask(112, 0, _7138):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7138) / 1000 != Mask(112, 0, _7138):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7138) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7138)) + (998 * _7084) < 1000 * Mask(112, 0, _7138):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7138)) + (998 * _7084):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7192))
                                    call address(_7192).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8164 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8164] == bool(mem[_8164])
                                    _8370 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8370 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8370 + 36] = 0
                                    mem[_8370 + 68] = (0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164]
                                    mem[_8370 + 100] = this.address
                                    mem[_8370 + 132] = 128
                                    mem[_8370 + 164] = mem[_8370]
                                    s = 0
                                    while s < mem[_8370]:
                                        mem[s + _8370 + 196] = mem[_8370 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8370]) > mem[_8370]:
                                        mem[_8370 + mem[_8370] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164], address(this.address), 128, mem[_8370], mem[_8370 + 196 len ceil32(mem[_8370])]
                                else:
                                    if 998 * _7084 and Mask(112, 0, _7147) > -1 / 998 * _7084:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7147):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7147) / Mask(112, 0, _7147) != 998 * _7084:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7138) and 1000 > -1 / Mask(112, 0, _7138):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7138) / 1000 != Mask(112, 0, _7138):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7138) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7138)) + (998 * _7084) < 1000 * Mask(112, 0, _7138):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7138)) + (998 * _7084):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7192))
                                    call address(_7192).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8402 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8402] == bool(mem[_8402])
                                    _8578 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8578 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8578 + 36] = 0
                                    mem[_8578 + 68] = (998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164]
                                    mem[_8578 + 100] = this.address
                                    mem[_8578 + 132] = 128
                                    mem[_8578 + 164] = mem[_8578]
                                    s = 0
                                    while s < mem[_8578]:
                                        mem[s + _8578 + 196] = mem[_8578 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8578]) > mem[_8578]:
                                        mem[_8578 + mem[_8578] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164], address(this.address), 128, mem[_8578], mem[_8578 + 196 len ceil32(mem[_8578])]
                        else:
                            if mem[_7219 + 12 len 20] != address(_7078):
                                revert with 0, 'Check pair address'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_7078))
                            staticcall address(_7078).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7298 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_7298] < _7084:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _7084 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_7192) != address(_7078):
                                if Mask(112, 0, _7147) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7138) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7084 and 998 > -1 / _7084:
                                    revert with 0, 17
                                if 998 * _7084 / 998 != _7084:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7138):
                                    if Mask(112, 0, _7147) and 1000 > -1 / Mask(112, 0, _7147):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7147) / 1000 != Mask(112, 0, _7147):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7147) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7147)) + (998 * _7084) < 1000 * Mask(112, 0, _7147):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7147)) + (998 * _7084):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7228))
                                    call address(_7228).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8195 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8195] == bool(mem[_8195])
                                    _8403 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8403 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8403 + 36] = (0 / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164]
                                    mem[_8403 + 68] = 0
                                    mem[_8403 + 100] = this.address
                                    mem[_8403 + 132] = 128
                                    mem[_8403 + 164] = mem[_8403]
                                    s = 0
                                    while s < mem[_8403]:
                                        mem[s + _8403 + 196] = mem[_8403 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8403]) > mem[_8403]:
                                        mem[_8403 + mem[_8403] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8403]) + _8403 + -mem[64] + 192]
                                else:
                                    if 998 * _7084 and Mask(112, 0, _7138) > -1 / 998 * _7084:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7138):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7138) / Mask(112, 0, _7138) != 998 * _7084:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7147) and 1000 > -1 / Mask(112, 0, _7147):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7147) / 1000 != Mask(112, 0, _7147):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7147) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7147)) + (998 * _7084) < 1000 * Mask(112, 0, _7147):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7147)) + (998 * _7084):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7228))
                                    call address(_7228).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8439 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8439] == bool(mem[_8439])
                                    _8610 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8610 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8610 + 36] = (998 * _7084 * Mask(112, 0, _7138) / (1000 * Mask(112, 0, _7147)) + (998 * _7084)) - cd[164]
                                    mem[_8610 + 68] = 0
                                    mem[_8610 + 100] = this.address
                                    mem[_8610 + 132] = 128
                                    mem[_8610 + 164] = mem[_8610]
                                    s = 0
                                    while s < mem[_8610]:
                                        mem[s + _8610 + 196] = mem[_8610 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8610]) > mem[_8610]:
                                        mem[_8610 + mem[_8610] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8610]) + _8610 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _7138) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7147) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7084 and 998 > -1 / _7084:
                                    revert with 0, 17
                                if 998 * _7084 / 998 != _7084:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7147):
                                    if Mask(112, 0, _7138) and 1000 > -1 / Mask(112, 0, _7138):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7138) / 1000 != Mask(112, 0, _7138):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7138) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7138)) + (998 * _7084) < 1000 * Mask(112, 0, _7138):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7138)) + (998 * _7084):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7192))
                                    call address(_7192).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8196 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8196] == bool(mem[_8196])
                                    _8404 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8404 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8404 + 36] = 0
                                    mem[_8404 + 68] = (0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164]
                                    mem[_8404 + 100] = this.address
                                    mem[_8404 + 132] = 128
                                    mem[_8404 + 164] = mem[_8404]
                                    s = 0
                                    while s < mem[_8404]:
                                        mem[s + _8404 + 196] = mem[_8404 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8404]) > mem[_8404]:
                                        mem[_8404 + mem[_8404] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164], address(this.address), 128, mem[_8404], mem[_8404 + 196 len ceil32(mem[_8404])]
                                else:
                                    if 998 * _7084 and Mask(112, 0, _7147) > -1 / 998 * _7084:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7147):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7147) / Mask(112, 0, _7147) != 998 * _7084:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7138) and 1000 > -1 / Mask(112, 0, _7138):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7138) / 1000 != Mask(112, 0, _7138):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7138) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7138)) + (998 * _7084) < 1000 * Mask(112, 0, _7138):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7138)) + (998 * _7084):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7192))
                                    call address(_7192).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8440 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8440] == bool(mem[_8440])
                                    _8612 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8612 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8612 + 36] = 0
                                    mem[_8612 + 68] = (998 * _7084 * Mask(112, 0, _7147) / (1000 * Mask(112, 0, _7138)) + (998 * _7084)) - cd[164]
                                    mem[_8612 + 100] = this.address
                                    mem[_8612 + 132] = 128
                                    mem[_8612 + 164] = mem[_8612]
                                    s = 0
                                    while s < mem[_8612]:
                                        mem[s + _8612 + 196] = mem[_8612 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8612]) > mem[_8612]:
                                        mem[_8612 + mem[_8612] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8612]) + _8612 + -mem[64] + 192]
                    else:
                        if stor2 != msg.sender:
                            revert with 0, 'Not authorized'
                        require ext_code.size(mem[(32 * idx) + 140 len 20])
                        staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7130 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7141 = mem[_7130]
                        require mem[_7130] == mem[_7130 + 18 len 14]
                        _7152 = mem[_7130 + 32]
                        require mem[_7130 + 32] == mem[_7130 + 50 len 14]
                        require mem[_7130 + 64] == mem[_7130 + 92 len 4]
                        require ext_code.size(address(_7070))
                        staticcall address(_7070).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7188 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7195 = mem[_7188]
                        require mem[_7188] == mem[_7188 + 12 len 20]
                        require ext_code.size(address(_7070))
                        staticcall address(_7070).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7224 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7231 = mem[_7224]
                        require mem[_7224] == mem[_7224 + 12 len 20]
                        if address(_7195) == address(_7078):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_7078))
                            staticcall address(_7078).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7299 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_7299] < _7084:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _7084 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_7195) != address(_7078):
                                if Mask(112, 0, _7152) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7141) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7084 and 998 > -1 / _7084:
                                    revert with 0, 17
                                if 998 * _7084 / 998 != _7084:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7141):
                                    if Mask(112, 0, _7152) and 1000 > -1 / Mask(112, 0, _7152):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7152) / 1000 != Mask(112, 0, _7152):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7152) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7152)) + (998 * _7084) < 1000 * Mask(112, 0, _7152):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7152)) + (998 * _7084):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7152)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7152)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7231))
                                    call address(_7231).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8197 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8197] == bool(mem[_8197])
                                    _8405 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8405 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8405 + 36] = (0 / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164]
                                    mem[_8405 + 68] = 0
                                    mem[_8405 + 100] = this.address
                                    mem[_8405 + 132] = 128
                                    mem[_8405 + 164] = mem[_8405]
                                    s = 0
                                    while s < mem[_8405]:
                                        mem[s + _8405 + 196] = mem[_8405 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8405]) > mem[_8405]:
                                        mem[_8405 + mem[_8405] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8405]) + _8405 + -mem[64] + 192]
                                else:
                                    if 998 * _7084 and Mask(112, 0, _7141) > -1 / 998 * _7084:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7141):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7141) / Mask(112, 0, _7141) != 998 * _7084:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7152) and 1000 > -1 / Mask(112, 0, _7152):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7152) / 1000 != Mask(112, 0, _7152):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7152) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7152)) + (998 * _7084) < 1000 * Mask(112, 0, _7152):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7152)) + (998 * _7084):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7231))
                                    call address(_7231).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8441 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8441] == bool(mem[_8441])
                                    _8614 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8614 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8614 + 36] = (998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164]
                                    mem[_8614 + 68] = 0
                                    mem[_8614 + 100] = this.address
                                    mem[_8614 + 132] = 128
                                    mem[_8614 + 164] = mem[_8614]
                                    s = 0
                                    while s < mem[_8614]:
                                        mem[s + _8614 + 196] = mem[_8614 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8614]) > mem[_8614]:
                                        mem[_8614 + mem[_8614] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164], 0, address(this.address), 128, mem[_8614], mem[_8614 + 196 len ceil32(mem[_8614])]
                            else:
                                if Mask(112, 0, _7141) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7152) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7084 and 998 > -1 / _7084:
                                    revert with 0, 17
                                if 998 * _7084 / 998 != _7084:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7152):
                                    if Mask(112, 0, _7141) and 1000 > -1 / Mask(112, 0, _7141):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7141) / 1000 != Mask(112, 0, _7141):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7141) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7141)) + (998 * _7084) < 1000 * Mask(112, 0, _7141):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7141)) + (998 * _7084):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7195))
                                    call address(_7195).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8198 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8198] == bool(mem[_8198])
                                    _8406 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8406 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8406 + 36] = 0
                                    mem[_8406 + 68] = (0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164]
                                    mem[_8406 + 100] = this.address
                                    mem[_8406 + 132] = 128
                                    mem[_8406 + 164] = mem[_8406]
                                    s = 0
                                    while s < mem[_8406]:
                                        mem[s + _8406 + 196] = mem[_8406 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8406]) > mem[_8406]:
                                        mem[_8406 + mem[_8406] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164], address(this.address), 128, mem[_8406], mem[_8406 + 196 len ceil32(mem[_8406])]
                                else:
                                    if 998 * _7084 and Mask(112, 0, _7152) > -1 / 998 * _7084:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7152):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7152) / Mask(112, 0, _7152) != 998 * _7084:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7141) and 1000 > -1 / Mask(112, 0, _7141):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7141) / 1000 != Mask(112, 0, _7141):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7141) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7141)) + (998 * _7084) < 1000 * Mask(112, 0, _7141):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7141)) + (998 * _7084):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7195))
                                    call address(_7195).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8442 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8442] == bool(mem[_8442])
                                    _8616 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8616 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8616 + 36] = 0
                                    mem[_8616 + 68] = (998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164]
                                    mem[_8616 + 100] = this.address
                                    mem[_8616 + 132] = 128
                                    mem[_8616 + 164] = mem[_8616]
                                    s = 0
                                    while s < mem[_8616]:
                                        mem[s + _8616 + 196] = mem[_8616 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8616]) > mem[_8616]:
                                        mem[_8616 + mem[_8616] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8616]) + _8616 + -mem[64] + 192]
                        else:
                            if mem[_7224 + 12 len 20] != address(_7078):
                                revert with 0, 'Check pair address'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_7078))
                            staticcall address(_7078).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7310 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_7310] < _7084:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _7084 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_7195) != address(_7078):
                                if Mask(112, 0, _7152) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7141) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7084 and 998 > -1 / _7084:
                                    revert with 0, 17
                                if 998 * _7084 / 998 != _7084:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7141):
                                    if Mask(112, 0, _7152) and 1000 > -1 / Mask(112, 0, _7152):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7152) / 1000 != Mask(112, 0, _7152):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7152) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7152)) + (998 * _7084) < 1000 * Mask(112, 0, _7152):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7152)) + (998 * _7084):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7152)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7152)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7231))
                                    call address(_7231).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8241 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8241] == bool(mem[_8241])
                                    _8443 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8443 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8443 + 36] = (0 / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164]
                                    mem[_8443 + 68] = 0
                                    mem[_8443 + 100] = this.address
                                    mem[_8443 + 132] = 128
                                    mem[_8443 + 164] = mem[_8443]
                                    s = 0
                                    while s < mem[_8443]:
                                        mem[s + _8443 + 196] = mem[_8443 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8443]) > mem[_8443]:
                                        mem[_8443 + mem[_8443] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8443]) + _8443 + -mem[64] + 192]
                                else:
                                    if 998 * _7084 and Mask(112, 0, _7141) > -1 / 998 * _7084:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7141):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7141) / Mask(112, 0, _7141) != 998 * _7084:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7152) and 1000 > -1 / Mask(112, 0, _7152):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7152) / 1000 != Mask(112, 0, _7152):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7152) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7152)) + (998 * _7084) < 1000 * Mask(112, 0, _7152):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7152)) + (998 * _7084):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7231))
                                    call address(_7231).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8479 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8479] == bool(mem[_8479])
                                    _8652 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8652 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8652 + 36] = (998 * _7084 * Mask(112, 0, _7141) / (1000 * Mask(112, 0, _7152)) + (998 * _7084)) - cd[164]
                                    mem[_8652 + 68] = 0
                                    mem[_8652 + 100] = this.address
                                    mem[_8652 + 132] = 128
                                    mem[_8652 + 164] = mem[_8652]
                                    s = 0
                                    while s < mem[_8652]:
                                        mem[s + _8652 + 196] = mem[_8652 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8652]) > mem[_8652]:
                                        mem[_8652 + mem[_8652] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8652]) + _8652 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _7141) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7152) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7084 and 998 > -1 / _7084:
                                    revert with 0, 17
                                if 998 * _7084 / 998 != _7084:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7152):
                                    if Mask(112, 0, _7141) and 1000 > -1 / Mask(112, 0, _7141):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7141) / 1000 != Mask(112, 0, _7141):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7141) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7141)) + (998 * _7084) < 1000 * Mask(112, 0, _7141):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7141)) + (998 * _7084):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164] > 0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7195))
                                    call address(_7195).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8242 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8242] == bool(mem[_8242])
                                    _8444 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8444 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8444 + 36] = 0
                                    mem[_8444 + 68] = (0 / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164]
                                    mem[_8444 + 100] = this.address
                                    mem[_8444 + 132] = 128
                                    mem[_8444 + 164] = mem[_8444]
                                    s = 0
                                    while s < mem[_8444]:
                                        mem[s + _8444 + 196] = mem[_8444 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8444]) > mem[_8444]:
                                        mem[_8444 + mem[_8444] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8444]) + _8444 + -mem[64] + 192]
                                else:
                                    if 998 * _7084 and Mask(112, 0, _7152) > -1 / 998 * _7084:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7152):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7152) / Mask(112, 0, _7152) != 998 * _7084:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7141) and 1000 > -1 / Mask(112, 0, _7141):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7141) / 1000 != Mask(112, 0, _7141):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7141) > !(998 * _7084):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7141)) + (998 * _7084) < 1000 * Mask(112, 0, _7141):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7141)) + (998 * _7084):
                                        revert with 0, 18
                                    if 998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164] > 998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7070)
                                    mem[mem[64] + 36] = _7084
                                    require ext_code.size(address(_7195))
                                    call address(_7195).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7070), _7084
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8480 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8480] == bool(mem[_8480])
                                    _8654 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8654 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8654 + 36] = 0
                                    mem[_8654 + 68] = (998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164]
                                    mem[_8654 + 100] = this.address
                                    mem[_8654 + 132] = 128
                                    mem[_8654 + 164] = mem[_8654]
                                    s = 0
                                    while s < mem[_8654]:
                                        mem[s + _8654 + 196] = mem[_8654 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8654]) > mem[_8654]:
                                        mem[_8654 + mem[_8654] + 196] = 0
                                    require ext_code.size(address(_7070))
                                    call address(_7070).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _7084 * Mask(112, 0, _7152) / (1000 * Mask(112, 0, _7141)) + (998 * _7084)) - cd[164], address(this.address), 128, mem[_8654], mem[_8654 + 196 len ceil32(mem[_8654])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _7084
                s = _7078
                s = _7070
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[100]))
            staticcall address(cd[100]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7077 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_7077] < cd[132]:
                revert with 0, 'Check result'
            mem[mem[64]] = mem[_7077]
        else:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
            if ('cd', 4).length != ('cd', 36).length:
                revert with 0, 'Check length1'
            if ('cd', 4).length != ('cd', 68).length:
                revert with 0, 'Check length2'
            idx = 0
            s = 0
            s = 0
            s = 0
            while idx < ('cd', 4).length:
                if idx >= mem[96]:
                    revert with 0, 50
                _7072 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _7081 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                _7085 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                if msg.sender == stor0:
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7121 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _7136 = mem[_7121]
                    require mem[_7121] == mem[_7121 + 18 len 14]
                    _7145 = mem[_7121 + 32]
                    require mem[_7121 + 32] == mem[_7121 + 50 len 14]
                    require mem[_7121 + 64] == mem[_7121 + 92 len 4]
                    require ext_code.size(address(_7072))
                    staticcall address(_7072).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7179 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7189 = mem[_7179]
                    require mem[_7179] == mem[_7179 + 12 len 20]
                    require ext_code.size(address(_7072))
                    staticcall address(_7072).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _7215 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _7225 = mem[_7215]
                    require mem[_7215] == mem[_7215 + 12 len 20]
                    if address(_7189) == address(_7081):
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_7081))
                        staticcall address(_7081).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7268 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_7268] < _7085:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _7085 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_7189) != address(_7081):
                            if Mask(112, 0, _7145) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7136) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7085 and 998 > -1 / _7085:
                                revert with 0, 17
                            if 998 * _7085 / 998 != _7085:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7136):
                                if Mask(112, 0, _7145) and 1000 > -1 / Mask(112, 0, _7145):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7145) / 1000 != Mask(112, 0, _7145):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7145) > !(998 * _7085):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7145)) + (998 * _7085) < 1000 * Mask(112, 0, _7145):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7145)) + (998 * _7085):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7072)
                                mem[mem[64] + 36] = _7085
                                require ext_code.size(address(_7225))
                                call address(_7225).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7072), _7085
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8145 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8145] == bool(mem[_8145])
                                _8347 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8347 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8347 + 36] = (0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164]
                                mem[_8347 + 68] = 0
                                mem[_8347 + 100] = this.address
                                mem[_8347 + 132] = 128
                                mem[_8347 + 164] = mem[_8347]
                                s = 0
                                while s < mem[_8347]:
                                    mem[s + _8347 + 196] = mem[_8347 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8347]) > mem[_8347]:
                                    mem[_8347 + mem[_8347] + 196] = 0
                                require ext_code.size(address(_7072))
                                call address(_7072).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8347]) + _8347 + -mem[64] + 192]
                            else:
                                if 998 * _7085 and Mask(112, 0, _7136) > -1 / 998 * _7085:
                                    revert with 0, 17
                                if not Mask(112, 0, _7136):
                                    revert with 0, 18
                                if 998 * _7085 * Mask(112, 0, _7136) / Mask(112, 0, _7136) != 998 * _7085:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7145) and 1000 > -1 / Mask(112, 0, _7145):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7145) / 1000 != Mask(112, 0, _7145):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7145) > !(998 * _7085):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7145)) + (998 * _7085) < 1000 * Mask(112, 0, _7145):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7145)) + (998 * _7085):
                                    revert with 0, 18
                                if 998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7072)
                                mem[mem[64] + 36] = _7085
                                require ext_code.size(address(_7225))
                                call address(_7225).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7072), _7085
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8375 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8375] == bool(mem[_8375])
                                _8554 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8554 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8554 + 36] = (998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164]
                                mem[_8554 + 68] = 0
                                mem[_8554 + 100] = this.address
                                mem[_8554 + 132] = 128
                                mem[_8554 + 164] = mem[_8554]
                                s = 0
                                while s < mem[_8554]:
                                    mem[s + _8554 + 196] = mem[_8554 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8554]) > mem[_8554]:
                                    mem[_8554 + mem[_8554] + 196] = 0
                                require ext_code.size(address(_7072))
                                call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164], 0, address(this.address), 128, mem[_8554], mem[_8554 + 196 len ceil32(mem[_8554])]
                        else:
                            if Mask(112, 0, _7136) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7145) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7085 and 998 > -1 / _7085:
                                revert with 0, 17
                            if 998 * _7085 / 998 != _7085:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7145):
                                if Mask(112, 0, _7136) and 1000 > -1 / Mask(112, 0, _7136):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7136) / 1000 != Mask(112, 0, _7136):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7136) > !(998 * _7085):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7136)) + (998 * _7085) < 1000 * Mask(112, 0, _7136):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7136)) + (998 * _7085):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7136)) + (998 * _7085) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7136)) + (998 * _7085):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7072)
                                mem[mem[64] + 36] = _7085
                                require ext_code.size(address(_7189))
                                call address(_7189).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7072), _7085
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8146 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8146] == bool(mem[_8146])
                                _8348 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8348 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8348 + 36] = 0
                                mem[_8348 + 68] = (0 / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164]
                                mem[_8348 + 100] = this.address
                                mem[_8348 + 132] = 128
                                mem[_8348 + 164] = mem[_8348]
                                s = 0
                                while s < mem[_8348]:
                                    mem[s + _8348 + 196] = mem[_8348 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8348]) > mem[_8348]:
                                    mem[_8348 + mem[_8348] + 196] = 0
                                require ext_code.size(address(_7072))
                                call address(_7072).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8348]) + _8348 + -mem[64] + 192]
                            else:
                                if 998 * _7085 and Mask(112, 0, _7145) > -1 / 998 * _7085:
                                    revert with 0, 17
                                if not Mask(112, 0, _7145):
                                    revert with 0, 18
                                if 998 * _7085 * Mask(112, 0, _7145) / Mask(112, 0, _7145) != 998 * _7085:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7136) and 1000 > -1 / Mask(112, 0, _7136):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7136) / 1000 != Mask(112, 0, _7136):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7136) > !(998 * _7085):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7136)) + (998 * _7085) < 1000 * Mask(112, 0, _7136):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7136)) + (998 * _7085):
                                    revert with 0, 18
                                if 998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7072)
                                mem[mem[64] + 36] = _7085
                                require ext_code.size(address(_7189))
                                call address(_7189).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7072), _7085
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8376 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8376] == bool(mem[_8376])
                                _8556 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8556 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8556 + 36] = 0
                                mem[_8556 + 68] = (998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164]
                                mem[_8556 + 100] = this.address
                                mem[_8556 + 132] = 128
                                mem[_8556 + 164] = mem[_8556]
                                s = 0
                                while s < mem[_8556]:
                                    mem[s + _8556 + 196] = mem[_8556 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8556]) > mem[_8556]:
                                    mem[_8556 + mem[_8556] + 196] = 0
                                require ext_code.size(address(_7072))
                                call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164], address(this.address), 128, mem[_8556], mem[_8556 + 196 len ceil32(mem[_8556])]
                    else:
                        if mem[_7215 + 12 len 20] != address(_7081):
                            revert with 0, 'Check pair address'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_7081))
                        staticcall address(_7081).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7287 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_7287] < _7085:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _7085 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_7189) != address(_7081):
                            if Mask(112, 0, _7145) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7136) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7085 and 998 > -1 / _7085:
                                revert with 0, 17
                            if 998 * _7085 / 998 != _7085:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7136):
                                if Mask(112, 0, _7145) and 1000 > -1 / Mask(112, 0, _7145):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7145) / 1000 != Mask(112, 0, _7145):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7145) > !(998 * _7085):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7145)) + (998 * _7085) < 1000 * Mask(112, 0, _7145):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7145)) + (998 * _7085):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7072)
                                mem[mem[64] + 36] = _7085
                                require ext_code.size(address(_7225))
                                call address(_7225).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7072), _7085
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8169 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8169] == bool(mem[_8169])
                                _8377 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8377 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8377 + 36] = (0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164]
                                mem[_8377 + 68] = 0
                                mem[_8377 + 100] = this.address
                                mem[_8377 + 132] = 128
                                mem[_8377 + 164] = mem[_8377]
                                s = 0
                                while s < mem[_8377]:
                                    mem[s + _8377 + 196] = mem[_8377 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8377]) > mem[_8377]:
                                    mem[_8377 + mem[_8377] + 196] = 0
                                require ext_code.size(address(_7072))
                                call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (0 / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164], 0, address(this.address), 128, mem[_8377], mem[_8377 + 196 len ceil32(mem[_8377])]
                            else:
                                if 998 * _7085 and Mask(112, 0, _7136) > -1 / 998 * _7085:
                                    revert with 0, 17
                                if not Mask(112, 0, _7136):
                                    revert with 0, 18
                                if 998 * _7085 * Mask(112, 0, _7136) / Mask(112, 0, _7136) != 998 * _7085:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7145) and 1000 > -1 / Mask(112, 0, _7145):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7145) / 1000 != Mask(112, 0, _7145):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7145) > !(998 * _7085):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7145)) + (998 * _7085) < 1000 * Mask(112, 0, _7145):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7145)) + (998 * _7085):
                                    revert with 0, 18
                                if 998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7072)
                                mem[mem[64] + 36] = _7085
                                require ext_code.size(address(_7225))
                                call address(_7225).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7072), _7085
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8411 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8411] == bool(mem[_8411])
                                _8582 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8582 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8582 + 36] = (998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164]
                                mem[_8582 + 68] = 0
                                mem[_8582 + 100] = this.address
                                mem[_8582 + 132] = 128
                                mem[_8582 + 164] = mem[_8582]
                                s = 0
                                while s < mem[_8582]:
                                    mem[s + _8582 + 196] = mem[_8582 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8582]) > mem[_8582]:
                                    mem[_8582 + mem[_8582] + 196] = 0
                                require ext_code.size(address(_7072))
                                call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (998 * _7085 * Mask(112, 0, _7136) / (1000 * Mask(112, 0, _7145)) + (998 * _7085)) - cd[164], 0, address(this.address), 128, mem[_8582], mem[_8582 + 196 len ceil32(mem[_8582])]
                        else:
                            if Mask(112, 0, _7136) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _7145) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _7085 and 998 > -1 / _7085:
                                revert with 0, 17
                            if 998 * _7085 / 998 != _7085:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _7145):
                                if Mask(112, 0, _7136) and 1000 > -1 / Mask(112, 0, _7136):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7136) / 1000 != Mask(112, 0, _7136):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7136) > !(998 * _7085):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7136)) + (998 * _7085) < 1000 * Mask(112, 0, _7136):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7136)) + (998 * _7085):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _7136)) + (998 * _7085) < cd[164]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7136)) + (998 * _7085):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7072)
                                mem[mem[64] + 36] = _7085
                                require ext_code.size(address(_7189))
                                call address(_7189).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7072), _7085
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8170 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8170] == bool(mem[_8170])
                                _8378 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8378 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8378 + 36] = 0
                                mem[_8378 + 68] = (0 / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164]
                                mem[_8378 + 100] = this.address
                                mem[_8378 + 132] = 128
                                mem[_8378 + 164] = mem[_8378]
                                s = 0
                                while s < mem[_8378]:
                                    mem[s + _8378 + 196] = mem[_8378 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8378]) > mem[_8378]:
                                    mem[_8378 + mem[_8378] + 196] = 0
                                require ext_code.size(address(_7072))
                                call address(_7072).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_8378]) + _8378 + -mem[64] + 192]
                            else:
                                if 998 * _7085 and Mask(112, 0, _7145) > -1 / 998 * _7085:
                                    revert with 0, 17
                                if not Mask(112, 0, _7145):
                                    revert with 0, 18
                                if 998 * _7085 * Mask(112, 0, _7145) / Mask(112, 0, _7145) != 998 * _7085:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _7136) and 1000 > -1 / Mask(112, 0, _7136):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _7136) / 1000 != Mask(112, 0, _7136):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _7136) > !(998 * _7085):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _7136)) + (998 * _7085) < 1000 * Mask(112, 0, _7136):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _7136)) + (998 * _7085):
                                    revert with 0, 18
                                if 998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085) < cd[164]:
                                    revert with 0, 17
                                if (998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_7072)
                                mem[mem[64] + 36] = _7085
                                require ext_code.size(address(_7189))
                                call address(_7189).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_7072), _7085
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _8412 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_8412] == bool(mem[_8412])
                                _8584 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_8584 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_8584 + 36] = 0
                                mem[_8584 + 68] = (998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164]
                                mem[_8584 + 100] = this.address
                                mem[_8584 + 132] = 128
                                mem[_8584 + 164] = mem[_8584]
                                s = 0
                                while s < mem[_8584]:
                                    mem[s + _8584 + 196] = mem[_8584 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_8584]) > mem[_8584]:
                                    mem[_8584 + mem[_8584] + 196] = 0
                                require ext_code.size(address(_7072))
                                call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (998 * _7085 * Mask(112, 0, _7145) / (1000 * Mask(112, 0, _7136)) + (998 * _7085)) - cd[164], address(this.address), 128, mem[_8584], mem[_8584 + 196 len ceil32(mem[_8584])]
                else:
                    if msg.sender == stor1:
                        require ext_code.size(mem[(32 * idx) + 140 len 20])
                        staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7127 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7139 = mem[_7127]
                        require mem[_7127] == mem[_7127 + 18 len 14]
                        _7148 = mem[_7127 + 32]
                        require mem[_7127 + 32] == mem[_7127 + 50 len 14]
                        require mem[_7127 + 64] == mem[_7127 + 92 len 4]
                        require ext_code.size(address(_7072))
                        staticcall address(_7072).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7184 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7193 = mem[_7184]
                        require mem[_7184] == mem[_7184 + 12 len 20]
                        require ext_code.size(address(_7072))
                        staticcall address(_7072).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7229 = mem[_7220]
                        require mem[_7220] == mem[_7220 + 12 len 20]
                        if address(_7193) == address(_7081):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_7081))
                            staticcall address(_7081).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7288 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_7288] < _7085:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _7085 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_7193) != address(_7081):
                                if Mask(112, 0, _7148) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7139) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7085 and 998 > -1 / _7085:
                                    revert with 0, 17
                                if 998 * _7085 / 998 != _7085:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7139):
                                    if Mask(112, 0, _7148) and 1000 > -1 / Mask(112, 0, _7148):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7148) / 1000 != Mask(112, 0, _7148):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7148) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7148)) + (998 * _7085) < 1000 * Mask(112, 0, _7148):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7148)) + (998 * _7085):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7229))
                                    call address(_7229).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8171 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8171] == bool(mem[_8171])
                                    _8379 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8379 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8379 + 36] = (0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164]
                                    mem[_8379 + 68] = 0
                                    mem[_8379 + 100] = this.address
                                    mem[_8379 + 132] = 128
                                    mem[_8379 + 164] = mem[_8379]
                                    s = 0
                                    while s < mem[_8379]:
                                        mem[s + _8379 + 196] = mem[_8379 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8379]) > mem[_8379]:
                                        mem[_8379 + mem[_8379] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8379]) + _8379 + -mem[64] + 192]
                                else:
                                    if 998 * _7085 and Mask(112, 0, _7139) > -1 / 998 * _7085:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7139):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7139) / Mask(112, 0, _7139) != 998 * _7085:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7148) and 1000 > -1 / Mask(112, 0, _7148):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7148) / 1000 != Mask(112, 0, _7148):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7148) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7148)) + (998 * _7085) < 1000 * Mask(112, 0, _7148):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7148)) + (998 * _7085):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7139) / (1000 * Mask(112, 0, _7148)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7085 * Mask(112, 0, _7139) / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7139) / (1000 * Mask(112, 0, _7148)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7229))
                                    call address(_7229).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8413 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8413] == bool(mem[_8413])
                                    _8586 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8586 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8586 + 36] = (998 * _7085 * Mask(112, 0, _7139) / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164]
                                    mem[_8586 + 68] = 0
                                    mem[_8586 + 100] = this.address
                                    mem[_8586 + 132] = 128
                                    mem[_8586 + 164] = mem[_8586]
                                    s = 0
                                    while s < mem[_8586]:
                                        mem[s + _8586 + 196] = mem[_8586 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8586]) > mem[_8586]:
                                        mem[_8586 + mem[_8586] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8586]) + _8586 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _7139) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7148) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7085 and 998 > -1 / _7085:
                                    revert with 0, 17
                                if 998 * _7085 / 998 != _7085:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7148):
                                    if Mask(112, 0, _7139) and 1000 > -1 / Mask(112, 0, _7139):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7139) / 1000 != Mask(112, 0, _7139):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7139) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7139)) + (998 * _7085) < 1000 * Mask(112, 0, _7139):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7139)) + (998 * _7085):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7193))
                                    call address(_7193).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8172 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8172] == bool(mem[_8172])
                                    _8380 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8380 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8380 + 36] = 0
                                    mem[_8380 + 68] = (0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164]
                                    mem[_8380 + 100] = this.address
                                    mem[_8380 + 132] = 128
                                    mem[_8380 + 164] = mem[_8380]
                                    s = 0
                                    while s < mem[_8380]:
                                        mem[s + _8380 + 196] = mem[_8380 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8380]) > mem[_8380]:
                                        mem[_8380 + mem[_8380] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8380]) + _8380 + -mem[64] + 192]
                                else:
                                    if 998 * _7085 and Mask(112, 0, _7148) > -1 / 998 * _7085:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7148):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7148) / Mask(112, 0, _7148) != 998 * _7085:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7139) and 1000 > -1 / Mask(112, 0, _7139):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7139) / 1000 != Mask(112, 0, _7139):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7139) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7139)) + (998 * _7085) < 1000 * Mask(112, 0, _7139):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7139)) + (998 * _7085):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7193))
                                    call address(_7193).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8414 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8414] == bool(mem[_8414])
                                    _8588 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8588 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8588 + 36] = 0
                                    mem[_8588 + 68] = (998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164]
                                    mem[_8588 + 100] = this.address
                                    mem[_8588 + 132] = 128
                                    mem[_8588 + 164] = mem[_8588]
                                    s = 0
                                    while s < mem[_8588]:
                                        mem[s + _8588 + 196] = mem[_8588 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8588]) > mem[_8588]:
                                        mem[_8588 + mem[_8588] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8588]) + _8588 + -mem[64] + 192]
                        else:
                            if mem[_7220 + 12 len 20] != address(_7081):
                                revert with 0, 'Check pair address'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_7081))
                            staticcall address(_7081).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7302 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_7302] < _7085:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _7085 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_7193) != address(_7081):
                                if Mask(112, 0, _7148) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7139) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7085 and 998 > -1 / _7085:
                                    revert with 0, 17
                                if 998 * _7085 / 998 != _7085:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7139):
                                    if Mask(112, 0, _7148) and 1000 > -1 / Mask(112, 0, _7148):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7148) / 1000 != Mask(112, 0, _7148):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7148) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7148)) + (998 * _7085) < 1000 * Mask(112, 0, _7148):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7148)) + (998 * _7085):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7229))
                                    call address(_7229).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8207 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8207] == bool(mem[_8207])
                                    _8415 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8415 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8415 + 36] = (0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164]
                                    mem[_8415 + 68] = 0
                                    mem[_8415 + 100] = this.address
                                    mem[_8415 + 132] = 128
                                    mem[_8415 + 164] = mem[_8415]
                                    s = 0
                                    while s < mem[_8415]:
                                        mem[s + _8415 + 196] = mem[_8415 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8415]) > mem[_8415]:
                                        mem[_8415 + mem[_8415] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (0 / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164], 0, address(this.address), 128, mem[_8415], mem[_8415 + 196 len ceil32(mem[_8415])]
                                else:
                                    if 998 * _7085 and Mask(112, 0, _7139) > -1 / 998 * _7085:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7139):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7139) / Mask(112, 0, _7139) != 998 * _7085:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7148) and 1000 > -1 / Mask(112, 0, _7148):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7148) / 1000 != Mask(112, 0, _7148):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7148) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7148)) + (998 * _7085) < 1000 * Mask(112, 0, _7148):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7148)) + (998 * _7085):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7139) / (1000 * Mask(112, 0, _7148)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7085 * Mask(112, 0, _7139) / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7139) / (1000 * Mask(112, 0, _7148)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7229))
                                    call address(_7229).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8451 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8451] == bool(mem[_8451])
                                    _8624 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8624 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8624 + 36] = (998 * _7085 * Mask(112, 0, _7139) / (1000 * Mask(112, 0, _7148)) + (998 * _7085)) - cd[164]
                                    mem[_8624 + 68] = 0
                                    mem[_8624 + 100] = this.address
                                    mem[_8624 + 132] = 128
                                    mem[_8624 + 164] = mem[_8624]
                                    s = 0
                                    while s < mem[_8624]:
                                        mem[s + _8624 + 196] = mem[_8624 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8624]) > mem[_8624]:
                                        mem[_8624 + mem[_8624] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8624]) + _8624 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _7139) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7148) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7085 and 998 > -1 / _7085:
                                    revert with 0, 17
                                if 998 * _7085 / 998 != _7085:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7148):
                                    if Mask(112, 0, _7139) and 1000 > -1 / Mask(112, 0, _7139):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7139) / 1000 != Mask(112, 0, _7139):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7139) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7139)) + (998 * _7085) < 1000 * Mask(112, 0, _7139):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7139)) + (998 * _7085):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7193))
                                    call address(_7193).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8208 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8208] == bool(mem[_8208])
                                    _8416 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8416 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8416 + 36] = 0
                                    mem[_8416 + 68] = (0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164]
                                    mem[_8416 + 100] = this.address
                                    mem[_8416 + 132] = 128
                                    mem[_8416 + 164] = mem[_8416]
                                    s = 0
                                    while s < mem[_8416]:
                                        mem[s + _8416 + 196] = mem[_8416 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8416]) > mem[_8416]:
                                        mem[_8416 + mem[_8416] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164], address(this.address), 128, mem[_8416], mem[_8416 + 196 len ceil32(mem[_8416])]
                                else:
                                    if 998 * _7085 and Mask(112, 0, _7148) > -1 / 998 * _7085:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7148):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7148) / Mask(112, 0, _7148) != 998 * _7085:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7139) and 1000 > -1 / Mask(112, 0, _7139):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7139) / 1000 != Mask(112, 0, _7139):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7139) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7139)) + (998 * _7085) < 1000 * Mask(112, 0, _7139):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7139)) + (998 * _7085):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7193))
                                    call address(_7193).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8452 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8452] == bool(mem[_8452])
                                    _8626 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8626 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8626 + 36] = 0
                                    mem[_8626 + 68] = (998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164]
                                    mem[_8626 + 100] = this.address
                                    mem[_8626 + 132] = 128
                                    mem[_8626 + 164] = mem[_8626]
                                    s = 0
                                    while s < mem[_8626]:
                                        mem[s + _8626 + 196] = mem[_8626 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8626]) > mem[_8626]:
                                        mem[_8626 + mem[_8626] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _7085 * Mask(112, 0, _7148) / (1000 * Mask(112, 0, _7139)) + (998 * _7085)) - cd[164], address(this.address), 128, mem[_8626], mem[_8626 + 196 len ceil32(mem[_8626])]
                    else:
                        if stor2 != msg.sender:
                            revert with 0, 'Not authorized'
                        require ext_code.size(mem[(32 * idx) + 140 len 20])
                        staticcall mem[(32 * idx) + 140 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7132 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _7142 = mem[_7132]
                        require mem[_7132] == mem[_7132 + 18 len 14]
                        _7154 = mem[_7132 + 32]
                        require mem[_7132 + 32] == mem[_7132 + 50 len 14]
                        require mem[_7132 + 64] == mem[_7132 + 92 len 4]
                        require ext_code.size(address(_7072))
                        staticcall address(_7072).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7190 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7196 = mem[_7190]
                        require mem[_7190] == mem[_7190 + 12 len 20]
                        require ext_code.size(address(_7072))
                        staticcall address(_7072).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _7226 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _7232 = mem[_7226]
                        require mem[_7226] == mem[_7226 + 12 len 20]
                        if address(_7196) == address(_7081):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_7081))
                            staticcall address(_7081).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7303 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_7303] < _7085:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _7085 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_7196) != address(_7081):
                                if Mask(112, 0, _7154) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7142) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7085 and 998 > -1 / _7085:
                                    revert with 0, 17
                                if 998 * _7085 / 998 != _7085:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7142):
                                    if Mask(112, 0, _7154) and 1000 > -1 / Mask(112, 0, _7154):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7154) / 1000 != Mask(112, 0, _7154):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7154) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7154)) + (998 * _7085) < 1000 * Mask(112, 0, _7154):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7154)) + (998 * _7085):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7232))
                                    call address(_7232).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8209 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8209] == bool(mem[_8209])
                                    _8417 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8417 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8417 + 36] = (0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164]
                                    mem[_8417 + 68] = 0
                                    mem[_8417 + 100] = this.address
                                    mem[_8417 + 132] = 128
                                    mem[_8417 + 164] = mem[_8417]
                                    s = 0
                                    while s < mem[_8417]:
                                        mem[s + _8417 + 196] = mem[_8417 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8417]) > mem[_8417]:
                                        mem[_8417 + mem[_8417] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164], 0, address(this.address), 128, mem[_8417], mem[_8417 + 196 len ceil32(mem[_8417])]
                                else:
                                    if 998 * _7085 and Mask(112, 0, _7142) > -1 / 998 * _7085:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7142):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7142) / Mask(112, 0, _7142) != 998 * _7085:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7154) and 1000 > -1 / Mask(112, 0, _7154):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7154) / 1000 != Mask(112, 0, _7154):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7154) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7154)) + (998 * _7085) < 1000 * Mask(112, 0, _7154):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7154)) + (998 * _7085):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7142) / (1000 * Mask(112, 0, _7154)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7085 * Mask(112, 0, _7142) / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7142) / (1000 * Mask(112, 0, _7154)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7232))
                                    call address(_7232).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8453 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8453] == bool(mem[_8453])
                                    _8628 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8628 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8628 + 36] = (998 * _7085 * Mask(112, 0, _7142) / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164]
                                    mem[_8628 + 68] = 0
                                    mem[_8628 + 100] = this.address
                                    mem[_8628 + 132] = 128
                                    mem[_8628 + 164] = mem[_8628]
                                    s = 0
                                    while s < mem[_8628]:
                                        mem[s + _8628 + 196] = mem[_8628 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8628]) > mem[_8628]:
                                        mem[_8628 + mem[_8628] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8628]) + _8628 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _7142) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7154) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7085 and 998 > -1 / _7085:
                                    revert with 0, 17
                                if 998 * _7085 / 998 != _7085:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7154):
                                    if Mask(112, 0, _7142) and 1000 > -1 / Mask(112, 0, _7142):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7142) / 1000 != Mask(112, 0, _7142):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7142) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7142)) + (998 * _7085) < 1000 * Mask(112, 0, _7142):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7142)) + (998 * _7085):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7142)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7142)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7142)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7196))
                                    call address(_7196).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8210 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8210] == bool(mem[_8210])
                                    _8418 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8418 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8418 + 36] = 0
                                    mem[_8418 + 68] = (0 / (1000 * Mask(112, 0, _7142)) + (998 * _7085)) - cd[164]
                                    mem[_8418 + 100] = this.address
                                    mem[_8418 + 132] = 128
                                    mem[_8418 + 164] = mem[_8418]
                                    s = 0
                                    while s < mem[_8418]:
                                        mem[s + _8418 + 196] = mem[_8418 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8418]) > mem[_8418]:
                                        mem[_8418 + mem[_8418] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8418]) + _8418 + -mem[64] + 192]
                                else:
                                    if 998 * _7085 and Mask(112, 0, _7154) > -1 / 998 * _7085:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7154):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7154) / Mask(112, 0, _7154) != 998 * _7085:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7142) and 1000 > -1 / Mask(112, 0, _7142):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7142) / 1000 != Mask(112, 0, _7142):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7142) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7142)) + (998 * _7085) < 1000 * Mask(112, 0, _7142):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7142)) + (998 * _7085):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7154) / (1000 * Mask(112, 0, _7142)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7085 * Mask(112, 0, _7154) / (1000 * Mask(112, 0, _7142)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7154) / (1000 * Mask(112, 0, _7142)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7196))
                                    call address(_7196).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8454 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8454] == bool(mem[_8454])
                                    _8630 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8630 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8630 + 36] = 0
                                    mem[_8630 + 68] = (998 * _7085 * Mask(112, 0, _7154) / (1000 * Mask(112, 0, _7142)) + (998 * _7085)) - cd[164]
                                    mem[_8630 + 100] = this.address
                                    mem[_8630 + 132] = 128
                                    mem[_8630 + 164] = mem[_8630]
                                    s = 0
                                    while s < mem[_8630]:
                                        mem[s + _8630 + 196] = mem[_8630 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8630]) > mem[_8630]:
                                        mem[_8630 + mem[_8630] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8630]) + _8630 + -mem[64] + 192]
                        else:
                            if mem[_7226 + 12 len 20] != address(_7081):
                                revert with 0, 'Check pair address'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_7081))
                            staticcall address(_7081).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _7313 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_7313] < _7085:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _7085 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_7196) != address(_7081):
                                if Mask(112, 0, _7154) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7142) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7085 and 998 > -1 / _7085:
                                    revert with 0, 17
                                if 998 * _7085 / 998 != _7085:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7142):
                                    if Mask(112, 0, _7154) and 1000 > -1 / Mask(112, 0, _7154):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7154) / 1000 != Mask(112, 0, _7154):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7154) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7154)) + (998 * _7085) < 1000 * Mask(112, 0, _7154):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7154)) + (998 * _7085):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7232))
                                    call address(_7232).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8257 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8257] == bool(mem[_8257])
                                    _8455 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8455 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8455 + 36] = (0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164]
                                    mem[_8455 + 68] = 0
                                    mem[_8455 + 100] = this.address
                                    mem[_8455 + 132] = 128
                                    mem[_8455 + 164] = mem[_8455]
                                    s = 0
                                    while s < mem[_8455]:
                                        mem[s + _8455 + 196] = mem[_8455 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8455]) > mem[_8455]:
                                        mem[_8455 + mem[_8455] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (0 / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164], 0, address(this.address), 128, mem[_8455], mem[_8455 + 196 len ceil32(mem[_8455])]
                                else:
                                    if 998 * _7085 and Mask(112, 0, _7142) > -1 / 998 * _7085:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7142):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7142) / Mask(112, 0, _7142) != 998 * _7085:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7154) and 1000 > -1 / Mask(112, 0, _7154):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7154) / 1000 != Mask(112, 0, _7154):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7154) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7154)) + (998 * _7085) < 1000 * Mask(112, 0, _7154):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7154)) + (998 * _7085):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7142) / (1000 * Mask(112, 0, _7154)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7085 * Mask(112, 0, _7142) / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7142) / (1000 * Mask(112, 0, _7154)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7232))
                                    call address(_7232).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8491 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8491] == bool(mem[_8491])
                                    _8664 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8664 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8664 + 36] = (998 * _7085 * Mask(112, 0, _7142) / (1000 * Mask(112, 0, _7154)) + (998 * _7085)) - cd[164]
                                    mem[_8664 + 68] = 0
                                    mem[_8664 + 100] = this.address
                                    mem[_8664 + 132] = 128
                                    mem[_8664 + 164] = mem[_8664]
                                    s = 0
                                    while s < mem[_8664]:
                                        mem[s + _8664 + 196] = mem[_8664 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8664]) > mem[_8664]:
                                        mem[_8664 + mem[_8664] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8664]) + _8664 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _7142) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _7154) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _7085 and 998 > -1 / _7085:
                                    revert with 0, 17
                                if 998 * _7085 / 998 != _7085:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _7154):
                                    if Mask(112, 0, _7142) and 1000 > -1 / Mask(112, 0, _7142):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7142) / 1000 != Mask(112, 0, _7142):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7142) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7142)) + (998 * _7085) < 1000 * Mask(112, 0, _7142):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7142)) + (998 * _7085):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _7142)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _7142)) + (998 * _7085)) - cd[164] > 0 / (1000 * Mask(112, 0, _7142)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7196))
                                    call address(_7196).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8258 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8258] == bool(mem[_8258])
                                    _8456 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8456 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8456 + 36] = 0
                                    mem[_8456 + 68] = (0 / (1000 * Mask(112, 0, _7142)) + (998 * _7085)) - cd[164]
                                    mem[_8456 + 100] = this.address
                                    mem[_8456 + 132] = 128
                                    mem[_8456 + 164] = mem[_8456]
                                    s = 0
                                    while s < mem[_8456]:
                                        mem[s + _8456 + 196] = mem[_8456 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8456]) > mem[_8456]:
                                        mem[_8456 + mem[_8456] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8456]) + _8456 + -mem[64] + 192]
                                else:
                                    if 998 * _7085 and Mask(112, 0, _7154) > -1 / 998 * _7085:
                                        revert with 0, 17
                                    if not Mask(112, 0, _7154):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7154) / Mask(112, 0, _7154) != 998 * _7085:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _7142) and 1000 > -1 / Mask(112, 0, _7142):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _7142) / 1000 != Mask(112, 0, _7142):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _7142) > !(998 * _7085):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _7142)) + (998 * _7085) < 1000 * Mask(112, 0, _7142):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _7142)) + (998 * _7085):
                                        revert with 0, 18
                                    if 998 * _7085 * Mask(112, 0, _7154) / (1000 * Mask(112, 0, _7142)) + (998 * _7085) < cd[164]:
                                        revert with 0, 17
                                    if (998 * _7085 * Mask(112, 0, _7154) / (1000 * Mask(112, 0, _7142)) + (998 * _7085)) - cd[164] > 998 * _7085 * Mask(112, 0, _7154) / (1000 * Mask(112, 0, _7142)) + (998 * _7085):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_7072)
                                    mem[mem[64] + 36] = _7085
                                    require ext_code.size(address(_7196))
                                    call address(_7196).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_7072), _7085
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _8492 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_8492] == bool(mem[_8492])
                                    _8666 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_8666 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_8666 + 36] = 0
                                    mem[_8666 + 68] = (998 * _7085 * Mask(112, 0, _7154) / (1000 * Mask(112, 0, _7142)) + (998 * _7085)) - cd[164]
                                    mem[_8666 + 100] = this.address
                                    mem[_8666 + 132] = 128
                                    mem[_8666 + 164] = mem[_8666]
                                    s = 0
                                    while s < mem[_8666]:
                                        mem[s + _8666 + 196] = mem[_8666 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_8666]) > mem[_8666]:
                                        mem[_8666 + mem[_8666] + 196] = 0
                                    require ext_code.size(address(_7072))
                                    call address(_7072).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_8666]) + _8666 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _7085
                s = _7081
                s = _7072
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[100]))
            staticcall address(cd[100]).0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _7080 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_7080] < cd[132]:
                revert with 0, 'Check result'
            mem[mem[64]] = mem[_7080]
    return memory
      from mem[64]
       len 32
}

function sub_a64a49a0(?) {
    require calldata.size - 4 >= 320
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    if ('cd', 4).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 4).length) + 97 < 96 or ceil32(32 * ('cd', 4).length) + 97 > test266151307():
        revert with 0, 65
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    if ('cd', 36).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 36).length) + 98 < 97 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + 97] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = ceil32(32 * ('cd', 4).length) + 129
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    if ('cd', 68).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 68).length) + 99 < 98 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130
    while idx < ('cd', 68).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    if ('cd', 100).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 100).length) + 100 < 99 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99] = ('cd', 100).length
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 0
    s = cd[100] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131
    while idx < ('cd', 100).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[132] <= test266151307()
    require cd[132] + 35 < calldata.size
    if ('cd', 132).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 132).length) + 101 < 100 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 101 > test266151307():
        revert with 0, 65
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100] = ('cd', 132).length
    require cd[132] + (32 * ('cd', 132).length) + 36 <= calldata.size
    idx = 0
    s = cd[132] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 132
    while idx < ('cd', 132).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[164] <= test266151307()
    require cd[164] + 35 < calldata.size
    if ('cd', 164).length > test266151307():
        revert with 0, 65
    if ceil32(32 * ('cd', 164).length) + 102 < 101 or ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + ceil32(32 * ('cd', 164).length) + 102 > test266151307():
        revert with 0, 65
    mem[64] = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + ceil32(32 * ('cd', 164).length) + 102
    mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 101] = ('cd', 164).length
    require cd[164] + (32 * ('cd', 164).length) + 36 <= calldata.size
    idx = 0
    s = cd[164] + 36
    t = ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 133
    while idx < ('cd', 164).length:
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[292] == address(cd[292])
    if msg.sender == stor0:
        if ('cd', 100).length != ('cd', 36).length:
            revert with 0, 'Check length1'
        if ('cd', 100).length != ('cd', 4).length:
            revert with 0, 'Check length2'
        if ('cd', 100).length != ('cd', 164).length:
            revert with 0, 'Check length3'
        idx = 0
        s = 0
        s = 0
        while idx < ('cd', 100).length:
            if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                revert with 0, 50
            _18286 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
            if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 101]:
                revert with 0, 50
            _18292 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 133]
            if idx >= mem[96]:
                revert with 0, 50
            if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]:
                _18309 = mem[(32 * idx) + 128]
                if msg.sender == stor0:
                    require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                    staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _18356 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _18402 = mem[_18356]
                    require mem[_18356] == mem[_18356 + 18 len 14]
                    _18447 = mem[_18356 + 32]
                    require mem[_18356 + 32] == mem[_18356 + 50 len 14]
                    require mem[_18356 + 64] == mem[_18356 + 92 len 4]
                    require ext_code.size(address(_18286))
                    staticcall address(_18286).token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _18518 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _18544 = mem[_18518]
                    require mem[_18518] == mem[_18518 + 12 len 20]
                    require ext_code.size(address(_18286))
                    staticcall address(_18286).token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _18608 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _18625 = mem[_18608]
                    require mem[_18608] == mem[_18608 + 12 len 20]
                    if address(_18544) == address(_18309):
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18309))
                        staticcall address(_18309).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18735 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_18735] < _18292:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _18292 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_18544) != address(_18309):
                            if Mask(112, 0, _18447) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _18402) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _18292 and 998 > -1 / _18292:
                                revert with 0, 17
                            if 998 * _18292 / 998 != _18292:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _18402):
                                if Mask(112, 0, _18447) and 1000 > -1 / Mask(112, 0, _18447):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _18447) / 1000 != Mask(112, 0, _18447):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _18447) > !(998 * _18292):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _18447)) + (998 * _18292) < 1000 * Mask(112, 0, _18447):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _18447)) + (998 * _18292):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _18447)) + (998 * _18292) < cd[260]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18447)) + (998 * _18292):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_18286)
                                mem[mem[64] + 36] = _18292
                                require ext_code.size(address(_18625))
                                call address(_18625).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_18286), _18292
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _20266 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_20266] == bool(mem[_20266])
                                _20464 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_20464 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_20464 + 36] = (0 / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260]
                                mem[_20464 + 68] = 0
                                mem[_20464 + 100] = this.address
                                mem[_20464 + 132] = 128
                                mem[_20464 + 164] = mem[_20464]
                                s = 0
                                while s < mem[_20464]:
                                    mem[s + _20464 + 196] = mem[_20464 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_20464]) > mem[_20464]:
                                    mem[_20464 + mem[_20464] + 196] = 0
                                require ext_code.size(address(_18286))
                                call address(_18286).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_20464]) + _20464 + -mem[64] + 192]
                            else:
                                if 998 * _18292 and Mask(112, 0, _18402) > -1 / 998 * _18292:
                                    revert with 0, 17
                                if not Mask(112, 0, _18402):
                                    revert with 0, 18
                                if 998 * _18292 * Mask(112, 0, _18402) / Mask(112, 0, _18402) != 998 * _18292:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _18447) and 1000 > -1 / Mask(112, 0, _18447):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _18447) / 1000 != Mask(112, 0, _18447):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _18447) > !(998 * _18292):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _18447)) + (998 * _18292) < 1000 * Mask(112, 0, _18447):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _18447)) + (998 * _18292):
                                    revert with 0, 18
                                if 998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292) < cd[260]:
                                    revert with 0, 17
                                if (998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_18286)
                                mem[mem[64] + 36] = _18292
                                require ext_code.size(address(_18625))
                                call address(_18625).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_18286), _18292
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _20488 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_20488] == bool(mem[_20488])
                                _20675 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_20675 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_20675 + 36] = (998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260]
                                mem[_20675 + 68] = 0
                                mem[_20675 + 100] = this.address
                                mem[_20675 + 132] = 128
                                mem[_20675 + 164] = mem[_20675]
                                s = 0
                                while s < mem[_20675]:
                                    mem[s + _20675 + 196] = mem[_20675 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_20675]) > mem[_20675]:
                                    mem[_20675 + mem[_20675] + 196] = 0
                                require ext_code.size(address(_18286))
                                call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260], 0, address(this.address), 128, mem[_20675], mem[_20675 + 196 len ceil32(mem[_20675])]
                        else:
                            if Mask(112, 0, _18402) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _18447) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _18292 and 998 > -1 / _18292:
                                revert with 0, 17
                            if 998 * _18292 / 998 != _18292:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _18447):
                                if Mask(112, 0, _18402) and 1000 > -1 / Mask(112, 0, _18402):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _18402) / 1000 != Mask(112, 0, _18402):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _18402) > !(998 * _18292):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _18402)) + (998 * _18292) < 1000 * Mask(112, 0, _18402):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _18402)) + (998 * _18292):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292) < cd[260]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_18286)
                                mem[mem[64] + 36] = _18292
                                require ext_code.size(address(_18544))
                                call address(_18544).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_18286), _18292
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _20267 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_20267] == bool(mem[_20267])
                                _20465 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_20465 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_20465 + 36] = 0
                                mem[_20465 + 68] = (0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260]
                                mem[_20465 + 100] = this.address
                                mem[_20465 + 132] = 128
                                mem[_20465 + 164] = mem[_20465]
                                s = 0
                                while s < mem[_20465]:
                                    mem[s + _20465 + 196] = mem[_20465 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_20465]) > mem[_20465]:
                                    mem[_20465 + mem[_20465] + 196] = 0
                                require ext_code.size(address(_18286))
                                call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20465], mem[_20465 + 196 len ceil32(mem[_20465])]
                            else:
                                if 998 * _18292 and Mask(112, 0, _18447) > -1 / 998 * _18292:
                                    revert with 0, 17
                                if not Mask(112, 0, _18447):
                                    revert with 0, 18
                                if 998 * _18292 * Mask(112, 0, _18447) / Mask(112, 0, _18447) != 998 * _18292:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _18402) and 1000 > -1 / Mask(112, 0, _18402):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _18402) / 1000 != Mask(112, 0, _18402):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _18402) > !(998 * _18292):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _18402)) + (998 * _18292) < 1000 * Mask(112, 0, _18402):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _18402)) + (998 * _18292):
                                    revert with 0, 18
                                if 998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292) < cd[260]:
                                    revert with 0, 17
                                if (998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_18286)
                                mem[mem[64] + 36] = _18292
                                require ext_code.size(address(_18544))
                                call address(_18544).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_18286), _18292
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _20489 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_20489] == bool(mem[_20489])
                                _20677 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_20677 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_20677 + 36] = 0
                                mem[_20677 + 68] = (998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260]
                                mem[_20677 + 100] = this.address
                                mem[_20677 + 132] = 128
                                mem[_20677 + 164] = mem[_20677]
                                s = 0
                                while s < mem[_20677]:
                                    mem[s + _20677 + 196] = mem[_20677 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_20677]) > mem[_20677]:
                                    mem[_20677 + mem[_20677] + 196] = 0
                                require ext_code.size(address(_18286))
                                call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20677], mem[_20677 + 196 len ceil32(mem[_20677])]
                    else:
                        if mem[_18608 + 12 len 20] != address(_18309):
                            revert with 0, 'Check pair address'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18309))
                        staticcall address(_18309).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18779 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_18779] < _18292:
                            revert with 0, 'Refill _tokenIn amountIn'
                        if _18292 <= 0:
                            revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                        if address(_18544) != address(_18309):
                            if Mask(112, 0, _18447) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _18402) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _18292 and 998 > -1 / _18292:
                                revert with 0, 17
                            if 998 * _18292 / 998 != _18292:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _18402):
                                if Mask(112, 0, _18447) and 1000 > -1 / Mask(112, 0, _18447):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _18447) / 1000 != Mask(112, 0, _18447):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _18447) > !(998 * _18292):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _18447)) + (998 * _18292) < 1000 * Mask(112, 0, _18447):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _18447)) + (998 * _18292):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _18447)) + (998 * _18292) < cd[260]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18447)) + (998 * _18292):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_18286)
                                mem[mem[64] + 36] = _18292
                                require ext_code.size(address(_18625))
                                call address(_18625).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_18286), _18292
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _20286 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_20286] == bool(mem[_20286])
                                _20490 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_20490 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_20490 + 36] = (0 / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260]
                                mem[_20490 + 68] = 0
                                mem[_20490 + 100] = this.address
                                mem[_20490 + 132] = 128
                                mem[_20490 + 164] = mem[_20490]
                                s = 0
                                while s < mem[_20490]:
                                    mem[s + _20490 + 196] = mem[_20490 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_20490]) > mem[_20490]:
                                    mem[_20490 + mem[_20490] + 196] = 0
                                require ext_code.size(address(_18286))
                                call address(_18286).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_20490]) + _20490 + -mem[64] + 192]
                            else:
                                if 998 * _18292 and Mask(112, 0, _18402) > -1 / 998 * _18292:
                                    revert with 0, 17
                                if not Mask(112, 0, _18402):
                                    revert with 0, 18
                                if 998 * _18292 * Mask(112, 0, _18402) / Mask(112, 0, _18402) != 998 * _18292:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _18447) and 1000 > -1 / Mask(112, 0, _18447):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _18447) / 1000 != Mask(112, 0, _18447):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _18447) > !(998 * _18292):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _18447)) + (998 * _18292) < 1000 * Mask(112, 0, _18447):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _18447)) + (998 * _18292):
                                    revert with 0, 18
                                if 998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292) < cd[260]:
                                    revert with 0, 17
                                if (998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_18286)
                                mem[mem[64] + 36] = _18292
                                require ext_code.size(address(_18625))
                                call address(_18625).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_18286), _18292
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _20520 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_20520] == bool(mem[_20520])
                                _20695 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_20695 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_20695 + 36] = (998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260]
                                mem[_20695 + 68] = 0
                                mem[_20695 + 100] = this.address
                                mem[_20695 + 132] = 128
                                mem[_20695 + 164] = mem[_20695]
                                s = 0
                                while s < mem[_20695]:
                                    mem[s + _20695 + 196] = mem[_20695 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_20695]) > mem[_20695]:
                                    mem[_20695 + mem[_20695] + 196] = 0
                                require ext_code.size(address(_18286))
                                call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args (998 * _18292 * Mask(112, 0, _18402) / (1000 * Mask(112, 0, _18447)) + (998 * _18292)) - cd[260], 0, address(this.address), 128, mem[_20695], mem[_20695 + 196 len ceil32(mem[_20695])]
                        else:
                            if Mask(112, 0, _18402) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if Mask(112, 0, _18447) <= 0:
                                revert with 0, 'INSUFFICIENT_LIQUIDITY'
                            if _18292 and 998 > -1 / _18292:
                                revert with 0, 17
                            if 998 * _18292 / 998 != _18292:
                                revert with 0, 'MUL error'
                            if not Mask(112, 0, _18447):
                                if Mask(112, 0, _18402) and 1000 > -1 / Mask(112, 0, _18402):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _18402) / 1000 != Mask(112, 0, _18402):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _18402) > !(998 * _18292):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _18402)) + (998 * _18292) < 1000 * Mask(112, 0, _18402):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _18402)) + (998 * _18292):
                                    revert with 0, 18
                                if 0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292) < cd[260]:
                                    revert with 0, 17
                                if (0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_18286)
                                mem[mem[64] + 36] = _18292
                                require ext_code.size(address(_18544))
                                call address(_18544).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_18286), _18292
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _20287 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_20287] == bool(mem[_20287])
                                _20491 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_20491 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_20491 + 36] = 0
                                mem[_20491 + 68] = (0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260]
                                mem[_20491 + 100] = this.address
                                mem[_20491 + 132] = 128
                                mem[_20491 + 164] = mem[_20491]
                                s = 0
                                while s < mem[_20491]:
                                    mem[s + _20491 + 196] = mem[_20491 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_20491]) > mem[_20491]:
                                    mem[_20491 + mem[_20491] + 196] = 0
                                require ext_code.size(address(_18286))
                                call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                     gas gas_remaining wei
                                    args 0, (0 / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20491], mem[_20491 + 196 len ceil32(mem[_20491])]
                            else:
                                if 998 * _18292 and Mask(112, 0, _18447) > -1 / 998 * _18292:
                                    revert with 0, 17
                                if not Mask(112, 0, _18447):
                                    revert with 0, 18
                                if 998 * _18292 * Mask(112, 0, _18447) / Mask(112, 0, _18447) != 998 * _18292:
                                    revert with 0, 'MUL error'
                                if Mask(112, 0, _18402) and 1000 > -1 / Mask(112, 0, _18402):
                                    revert with 0, 17
                                if 1000 * Mask(112, 0, _18402) / 1000 != Mask(112, 0, _18402):
                                    revert with 0, 'MUL error'
                                if 1000 * Mask(112, 0, _18402) > !(998 * _18292):
                                    revert with 0, 17
                                if (1000 * Mask(112, 0, _18402)) + (998 * _18292) < 1000 * Mask(112, 0, _18402):
                                    revert with 0, 'Add error'
                                if not (1000 * Mask(112, 0, _18402)) + (998 * _18292):
                                    revert with 0, 18
                                if 998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292) < cd[260]:
                                    revert with 0, 17
                                if (998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292):
                                    revert with 0, 'SUB error'
                                mem[mem[64] + 4] = address(_18286)
                                mem[mem[64] + 36] = _18292
                                require ext_code.size(address(_18544))
                                call address(_18544).0xa9059cbb with:
                                     gas gas_remaining wei
                                    args address(_18286), _18292
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _20521 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_20521] == bool(mem[_20521])
                                _20697 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_20697 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_20697 + 36] = 0
                                mem[_20697 + 68] = (998 * _18292 * Mask(112, 0, _18447) / (1000 * Mask(112, 0, _18402)) + (998 * _18292)) - cd[260]
                                mem[_20697 + 100] = this.address
                                mem[_20697 + 132] = 128
                                mem[_20697 + 164] = mem[_20697]
                                s = 0
                                while s < mem[_20697]:
                                    mem[s + _20697 + 196] = mem[_20697 + s + 32]
                                    s = s + 32
                                    continue 
                                if ceil32(mem[_20697]) > mem[_20697]:
                                    mem[_20697 + mem[_20697] + 196] = 0
                                require ext_code.size(address(_18286))
                                call address(_18286).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_20697]) + _20697 + -mem[64] + 192]
                else:
                    if msg.sender == stor1:
                        require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                        staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18371 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _18420 = mem[_18371]
                        require mem[_18371] == mem[_18371 + 18 len 14]
                        _18457 = mem[_18371 + 32]
                        require mem[_18371 + 32] == mem[_18371 + 50 len 14]
                        require mem[_18371 + 64] == mem[_18371 + 92 len 4]
                        require ext_code.size(address(_18286))
                        staticcall address(_18286).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18532 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18560 = mem[_18532]
                        require mem[_18532] == mem[_18532 + 12 len 20]
                        require ext_code.size(address(_18286))
                        staticcall address(_18286).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18620 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18631 = mem[_18620]
                        require mem[_18620] == mem[_18620 + 12 len 20]
                        if address(_18560) == address(_18309):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18309))
                            staticcall address(_18309).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18780 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18780] < _18292:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _18292 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_18560) != address(_18309):
                                if Mask(112, 0, _18457) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18420) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18292 and 998 > -1 / _18292:
                                    revert with 0, 17
                                if 998 * _18292 / 998 != _18292:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18420):
                                    if Mask(112, 0, _18457) and 1000 > -1 / Mask(112, 0, _18457):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18457) / 1000 != Mask(112, 0, _18457):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18457) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18457)) + (998 * _18292) < 1000 * Mask(112, 0, _18457):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18457)) + (998 * _18292):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18457)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18457)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18457)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18631))
                                    call address(_18631).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20288 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20288] == bool(mem[_20288])
                                    _20492 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20492 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20492 + 36] = (0 / (1000 * Mask(112, 0, _18457)) + (998 * _18292)) - cd[260]
                                    mem[_20492 + 68] = 0
                                    mem[_20492 + 100] = this.address
                                    mem[_20492 + 132] = 128
                                    mem[_20492 + 164] = mem[_20492]
                                    s = 0
                                    while s < mem[_20492]:
                                        mem[s + _20492 + 196] = mem[_20492 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20492]) > mem[_20492]:
                                        mem[_20492 + mem[_20492] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20492]) + _20492 + -mem[64] + 192]
                                else:
                                    if 998 * _18292 and Mask(112, 0, _18420) > -1 / 998 * _18292:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18420):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18420) / Mask(112, 0, _18420) != 998 * _18292:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18457) and 1000 > -1 / Mask(112, 0, _18457):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18457) / 1000 != Mask(112, 0, _18457):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18457) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18457)) + (998 * _18292) < 1000 * Mask(112, 0, _18457):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18457)) + (998 * _18292):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18420) / (1000 * Mask(112, 0, _18457)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18292 * Mask(112, 0, _18420) / (1000 * Mask(112, 0, _18457)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18420) / (1000 * Mask(112, 0, _18457)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18631))
                                    call address(_18631).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20522 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20522] == bool(mem[_20522])
                                    _20699 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20699 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20699 + 36] = (998 * _18292 * Mask(112, 0, _18420) / (1000 * Mask(112, 0, _18457)) + (998 * _18292)) - cd[260]
                                    mem[_20699 + 68] = 0
                                    mem[_20699 + 100] = this.address
                                    mem[_20699 + 132] = 128
                                    mem[_20699 + 164] = mem[_20699]
                                    s = 0
                                    while s < mem[_20699]:
                                        mem[s + _20699 + 196] = mem[_20699 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20699]) > mem[_20699]:
                                        mem[_20699 + mem[_20699] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20699]) + _20699 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _18420) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18457) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18292 and 998 > -1 / _18292:
                                    revert with 0, 17
                                if 998 * _18292 / 998 != _18292:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18457):
                                    if Mask(112, 0, _18420) and 1000 > -1 / Mask(112, 0, _18420):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18420) / 1000 != Mask(112, 0, _18420):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18420) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18420)) + (998 * _18292) < 1000 * Mask(112, 0, _18420):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18420)) + (998 * _18292):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18560))
                                    call address(_18560).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20289 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20289] == bool(mem[_20289])
                                    _20493 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20493 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20493 + 36] = 0
                                    mem[_20493 + 68] = (0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260]
                                    mem[_20493 + 100] = this.address
                                    mem[_20493 + 132] = 128
                                    mem[_20493 + 164] = mem[_20493]
                                    s = 0
                                    while s < mem[_20493]:
                                        mem[s + _20493 + 196] = mem[_20493 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20493]) > mem[_20493]:
                                        mem[_20493 + mem[_20493] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20493], mem[_20493 + 196 len ceil32(mem[_20493])]
                                else:
                                    if 998 * _18292 and Mask(112, 0, _18457) > -1 / 998 * _18292:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18457):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18457) / Mask(112, 0, _18457) != 998 * _18292:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18420) and 1000 > -1 / Mask(112, 0, _18420):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18420) / 1000 != Mask(112, 0, _18420):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18420) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18420)) + (998 * _18292) < 1000 * Mask(112, 0, _18420):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18420)) + (998 * _18292):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18560))
                                    call address(_18560).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20523 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20523] == bool(mem[_20523])
                                    _20701 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20701 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20701 + 36] = 0
                                    mem[_20701 + 68] = (998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260]
                                    mem[_20701 + 100] = this.address
                                    mem[_20701 + 132] = 128
                                    mem[_20701 + 164] = mem[_20701]
                                    s = 0
                                    while s < mem[_20701]:
                                        mem[s + _20701 + 196] = mem[_20701 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20701]) > mem[_20701]:
                                        mem[_20701 + mem[_20701] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20701]) + _20701 + -mem[64] + 192]
                        else:
                            if mem[_18620 + 12 len 20] != address(_18309):
                                revert with 0, 'Check pair address'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18309))
                            staticcall address(_18309).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18819 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18819] < _18292:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _18292 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_18560) != address(_18309):
                                if Mask(112, 0, _18457) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18420) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18292 and 998 > -1 / _18292:
                                    revert with 0, 17
                                if 998 * _18292 / 998 != _18292:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18420):
                                    if Mask(112, 0, _18457) and 1000 > -1 / Mask(112, 0, _18457):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18457) / 1000 != Mask(112, 0, _18457):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18457) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18457)) + (998 * _18292) < 1000 * Mask(112, 0, _18457):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18457)) + (998 * _18292):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18457)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18457)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18457)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18631))
                                    call address(_18631).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20316 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20316] == bool(mem[_20316])
                                    _20524 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20524 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20524 + 36] = (0 / (1000 * Mask(112, 0, _18457)) + (998 * _18292)) - cd[260]
                                    mem[_20524 + 68] = 0
                                    mem[_20524 + 100] = this.address
                                    mem[_20524 + 132] = 128
                                    mem[_20524 + 164] = mem[_20524]
                                    s = 0
                                    while s < mem[_20524]:
                                        mem[s + _20524 + 196] = mem[_20524 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20524]) > mem[_20524]:
                                        mem[_20524 + mem[_20524] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20524]) + _20524 + -mem[64] + 192]
                                else:
                                    if 998 * _18292 and Mask(112, 0, _18420) > -1 / 998 * _18292:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18420):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18420) / Mask(112, 0, _18420) != 998 * _18292:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18457) and 1000 > -1 / Mask(112, 0, _18457):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18457) / 1000 != Mask(112, 0, _18457):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18457) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18457)) + (998 * _18292) < 1000 * Mask(112, 0, _18457):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18457)) + (998 * _18292):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18420) / (1000 * Mask(112, 0, _18457)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18292 * Mask(112, 0, _18420) / (1000 * Mask(112, 0, _18457)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18420) / (1000 * Mask(112, 0, _18457)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18631))
                                    call address(_18631).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20560 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20560] == bool(mem[_20560])
                                    _20729 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20729 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20729 + 36] = (998 * _18292 * Mask(112, 0, _18420) / (1000 * Mask(112, 0, _18457)) + (998 * _18292)) - cd[260]
                                    mem[_20729 + 68] = 0
                                    mem[_20729 + 100] = this.address
                                    mem[_20729 + 132] = 128
                                    mem[_20729 + 164] = mem[_20729]
                                    s = 0
                                    while s < mem[_20729]:
                                        mem[s + _20729 + 196] = mem[_20729 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20729]) > mem[_20729]:
                                        mem[_20729 + mem[_20729] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20729]) + _20729 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _18420) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18457) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18292 and 998 > -1 / _18292:
                                    revert with 0, 17
                                if 998 * _18292 / 998 != _18292:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18457):
                                    if Mask(112, 0, _18420) and 1000 > -1 / Mask(112, 0, _18420):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18420) / 1000 != Mask(112, 0, _18420):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18420) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18420)) + (998 * _18292) < 1000 * Mask(112, 0, _18420):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18420)) + (998 * _18292):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18560))
                                    call address(_18560).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20317 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20317] == bool(mem[_20317])
                                    _20525 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20525 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20525 + 36] = 0
                                    mem[_20525 + 68] = (0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260]
                                    mem[_20525 + 100] = this.address
                                    mem[_20525 + 132] = 128
                                    mem[_20525 + 164] = mem[_20525]
                                    s = 0
                                    while s < mem[_20525]:
                                        mem[s + _20525 + 196] = mem[_20525 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20525]) > mem[_20525]:
                                        mem[_20525 + mem[_20525] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20525], mem[_20525 + 196 len ceil32(mem[_20525])]
                                else:
                                    if 998 * _18292 and Mask(112, 0, _18457) > -1 / 998 * _18292:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18457):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18457) / Mask(112, 0, _18457) != 998 * _18292:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18420) and 1000 > -1 / Mask(112, 0, _18420):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18420) / 1000 != Mask(112, 0, _18420):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18420) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18420)) + (998 * _18292) < 1000 * Mask(112, 0, _18420):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18420)) + (998 * _18292):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18560))
                                    call address(_18560).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20561 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20561] == bool(mem[_20561])
                                    _20731 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20731 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20731 + 36] = 0
                                    mem[_20731 + 68] = (998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260]
                                    mem[_20731 + 100] = this.address
                                    mem[_20731 + 132] = 128
                                    mem[_20731 + 164] = mem[_20731]
                                    s = 0
                                    while s < mem[_20731]:
                                        mem[s + _20731 + 196] = mem[_20731 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20731]) > mem[_20731]:
                                        mem[_20731 + mem[_20731] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _18292 * Mask(112, 0, _18457) / (1000 * Mask(112, 0, _18420)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20731], mem[_20731 + 196 len ceil32(mem[_20731])]
                    else:
                        if stor2 != msg.sender:
                            revert with 0, 'Not authorized'
                        require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                        staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18381 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _18436 = mem[_18381]
                        require mem[_18381] == mem[_18381 + 18 len 14]
                        _18470 = mem[_18381 + 32]
                        require mem[_18381 + 32] == mem[_18381 + 50 len 14]
                        require mem[_18381 + 64] == mem[_18381 + 92 len 4]
                        require ext_code.size(address(_18286))
                        staticcall address(_18286).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18545 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18573 = mem[_18545]
                        require mem[_18545] == mem[_18545 + 12 len 20]
                        require ext_code.size(address(_18286))
                        staticcall address(_18286).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18626 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18634 = mem[_18626]
                        require mem[_18626] == mem[_18626 + 12 len 20]
                        if address(_18573) == address(_18309):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18309))
                            staticcall address(_18309).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18820 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18820] < _18292:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _18292 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_18573) != address(_18309):
                                if Mask(112, 0, _18470) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18436) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18292 and 998 > -1 / _18292:
                                    revert with 0, 17
                                if 998 * _18292 / 998 != _18292:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18436):
                                    if Mask(112, 0, _18470) and 1000 > -1 / Mask(112, 0, _18470):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18470) / 1000 != Mask(112, 0, _18470):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18470) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18470)) + (998 * _18292) < 1000 * Mask(112, 0, _18470):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18470)) + (998 * _18292):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18634))
                                    call address(_18634).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20318 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20318] == bool(mem[_20318])
                                    _20526 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20526 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20526 + 36] = (0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260]
                                    mem[_20526 + 68] = 0
                                    mem[_20526 + 100] = this.address
                                    mem[_20526 + 132] = 128
                                    mem[_20526 + 164] = mem[_20526]
                                    s = 0
                                    while s < mem[_20526]:
                                        mem[s + _20526 + 196] = mem[_20526 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20526]) > mem[_20526]:
                                        mem[_20526 + mem[_20526] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20526]) + _20526 + -mem[64] + 192]
                                else:
                                    if 998 * _18292 and Mask(112, 0, _18436) > -1 / 998 * _18292:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18436):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18436) / Mask(112, 0, _18436) != 998 * _18292:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18470) and 1000 > -1 / Mask(112, 0, _18470):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18470) / 1000 != Mask(112, 0, _18470):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18470) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18470)) + (998 * _18292) < 1000 * Mask(112, 0, _18470):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18470)) + (998 * _18292):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18634))
                                    call address(_18634).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20562 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20562] == bool(mem[_20562])
                                    _20733 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20733 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20733 + 36] = (998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260]
                                    mem[_20733 + 68] = 0
                                    mem[_20733 + 100] = this.address
                                    mem[_20733 + 132] = 128
                                    mem[_20733 + 164] = mem[_20733]
                                    s = 0
                                    while s < mem[_20733]:
                                        mem[s + _20733 + 196] = mem[_20733 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20733]) > mem[_20733]:
                                        mem[_20733 + mem[_20733] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260], 0, address(this.address), 128, mem[_20733], mem[_20733 + 196 len ceil32(mem[_20733])]
                            else:
                                if Mask(112, 0, _18436) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18470) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18292 and 998 > -1 / _18292:
                                    revert with 0, 17
                                if 998 * _18292 / 998 != _18292:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18470):
                                    if Mask(112, 0, _18436) and 1000 > -1 / Mask(112, 0, _18436):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18436) / 1000 != Mask(112, 0, _18436):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18436) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18436)) + (998 * _18292) < 1000 * Mask(112, 0, _18436):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18436)) + (998 * _18292):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18573))
                                    call address(_18573).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20319 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20319] == bool(mem[_20319])
                                    _20527 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20527 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20527 + 36] = 0
                                    mem[_20527 + 68] = (0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260]
                                    mem[_20527 + 100] = this.address
                                    mem[_20527 + 132] = 128
                                    mem[_20527 + 164] = mem[_20527]
                                    s = 0
                                    while s < mem[_20527]:
                                        mem[s + _20527 + 196] = mem[_20527 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20527]) > mem[_20527]:
                                        mem[_20527 + mem[_20527] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20527], mem[_20527 + 196 len ceil32(mem[_20527])]
                                else:
                                    if 998 * _18292 and Mask(112, 0, _18470) > -1 / 998 * _18292:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18470):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18470) / Mask(112, 0, _18470) != 998 * _18292:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18436) and 1000 > -1 / Mask(112, 0, _18436):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18436) / 1000 != Mask(112, 0, _18436):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18436) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18436)) + (998 * _18292) < 1000 * Mask(112, 0, _18436):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18436)) + (998 * _18292):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18573))
                                    call address(_18573).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20563 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20563] == bool(mem[_20563])
                                    _20735 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20735 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20735 + 36] = 0
                                    mem[_20735 + 68] = (998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260]
                                    mem[_20735 + 100] = this.address
                                    mem[_20735 + 132] = 128
                                    mem[_20735 + 164] = mem[_20735]
                                    s = 0
                                    while s < mem[_20735]:
                                        mem[s + _20735 + 196] = mem[_20735 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20735]) > mem[_20735]:
                                        mem[_20735 + mem[_20735] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20735], mem[_20735 + 196 len ceil32(mem[_20735])]
                        else:
                            if mem[_18626 + 12 len 20] != address(_18309):
                                revert with 0, 'Check pair address'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18309))
                            staticcall address(_18309).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18852 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18852] < _18292:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _18292 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_18573) != address(_18309):
                                if Mask(112, 0, _18470) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18436) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18292 and 998 > -1 / _18292:
                                    revert with 0, 17
                                if 998 * _18292 / 998 != _18292:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18436):
                                    if Mask(112, 0, _18470) and 1000 > -1 / Mask(112, 0, _18470):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18470) / 1000 != Mask(112, 0, _18470):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18470) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18470)) + (998 * _18292) < 1000 * Mask(112, 0, _18470):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18470)) + (998 * _18292):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18634))
                                    call address(_18634).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20358 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20358] == bool(mem[_20358])
                                    _20564 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20564 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20564 + 36] = (0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260]
                                    mem[_20564 + 68] = 0
                                    mem[_20564 + 100] = this.address
                                    mem[_20564 + 132] = 128
                                    mem[_20564 + 164] = mem[_20564]
                                    s = 0
                                    while s < mem[_20564]:
                                        mem[s + _20564 + 196] = mem[_20564 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20564]) > mem[_20564]:
                                        mem[_20564 + mem[_20564] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (0 / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260], 0, address(this.address), 128, mem[_20564], mem[_20564 + 196 len ceil32(mem[_20564])]
                                else:
                                    if 998 * _18292 and Mask(112, 0, _18436) > -1 / 998 * _18292:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18436):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18436) / Mask(112, 0, _18436) != 998 * _18292:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18470) and 1000 > -1 / Mask(112, 0, _18470):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18470) / 1000 != Mask(112, 0, _18470):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18470) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18470)) + (998 * _18292) < 1000 * Mask(112, 0, _18470):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18470)) + (998 * _18292):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18634))
                                    call address(_18634).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20600 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20600] == bool(mem[_20600])
                                    _20773 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20773 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20773 + 36] = (998 * _18292 * Mask(112, 0, _18436) / (1000 * Mask(112, 0, _18470)) + (998 * _18292)) - cd[260]
                                    mem[_20773 + 68] = 0
                                    mem[_20773 + 100] = this.address
                                    mem[_20773 + 132] = 128
                                    mem[_20773 + 164] = mem[_20773]
                                    s = 0
                                    while s < mem[_20773]:
                                        mem[s + _20773 + 196] = mem[_20773 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20773]) > mem[_20773]:
                                        mem[_20773 + mem[_20773] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20773]) + _20773 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _18436) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18470) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18292 and 998 > -1 / _18292:
                                    revert with 0, 17
                                if 998 * _18292 / 998 != _18292:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18470):
                                    if Mask(112, 0, _18436) and 1000 > -1 / Mask(112, 0, _18436):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18436) / 1000 != Mask(112, 0, _18436):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18436) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18436)) + (998 * _18292) < 1000 * Mask(112, 0, _18436):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18436)) + (998 * _18292):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260] > 0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18573))
                                    call address(_18573).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20359 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20359] == bool(mem[_20359])
                                    _20565 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20565 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20565 + 36] = 0
                                    mem[_20565 + 68] = (0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260]
                                    mem[_20565 + 100] = this.address
                                    mem[_20565 + 132] = 128
                                    mem[_20565 + 164] = mem[_20565]
                                    s = 0
                                    while s < mem[_20565]:
                                        mem[s + _20565 + 196] = mem[_20565 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20565]) > mem[_20565]:
                                        mem[_20565 + mem[_20565] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20565], mem[_20565 + 196 len ceil32(mem[_20565])]
                                else:
                                    if 998 * _18292 and Mask(112, 0, _18470) > -1 / 998 * _18292:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18470):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18470) / Mask(112, 0, _18470) != 998 * _18292:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18436) and 1000 > -1 / Mask(112, 0, _18436):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18436) / 1000 != Mask(112, 0, _18436):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18436) > !(998 * _18292):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18436)) + (998 * _18292) < 1000 * Mask(112, 0, _18436):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18436)) + (998 * _18292):
                                        revert with 0, 18
                                    if 998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260] > 998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18286)
                                    mem[mem[64] + 36] = _18292
                                    require ext_code.size(address(_18573))
                                    call address(_18573).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18286), _18292
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20601 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20601] == bool(mem[_20601])
                                    _20775 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20775 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20775 + 36] = 0
                                    mem[_20775 + 68] = (998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260]
                                    mem[_20775 + 100] = this.address
                                    mem[_20775 + 132] = 128
                                    mem[_20775 + 164] = mem[_20775]
                                    s = 0
                                    while s < mem[_20775]:
                                        mem[s + _20775 + 196] = mem[_20775 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20775]) > mem[_20775]:
                                        mem[_20775 + mem[_20775] + 196] = 0
                                    require ext_code.size(address(_18286))
                                    call address(_18286).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _18292 * Mask(112, 0, _18470) / (1000 * Mask(112, 0, _18436)) + (998 * _18292)) - cd[260], address(this.address), 128, mem[_20775], mem[_20775 + 196 len ceil32(mem[_20775])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            else:
                _18307 = mem[(32 * idx) + 128]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                    revert with 0, 50
                _18322 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                    revert with 0, 50
                _18329 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100]:
                    revert with 0, 50
                _18337 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 132]
                if msg.sender == stor0:
                    if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                        revert with 0, 'Set router'
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_18322))
                    staticcall address(_18322).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _18415 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _18445 = mem[_18415]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_18307))
                    staticcall address(_18307).0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _18481 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    if mem[_18481] < _18292:
                        revert with 0, 'Refill amountIn'
                    mem[mem[64] + 4] = address(_18329)
                    mem[mem[64] + 36] = _18292
                    require ext_code.size(address(_18307))
                    call address(_18307).approve(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(_18329), _18292
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _18580 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    require mem[_18580] == bool(mem[_18580])
                    if not address(_18337):
                        _18637 = mem[64]
                        mem[mem[64]] = 2
                        mem[64] = mem[64] + 96
                        if 0 >= mem[_18637]:
                            revert with 0, 50
                        mem[_18637 + 32] = address(_18307)
                        if 1 >= mem[_18637]:
                            revert with 0, 50
                        mem[_18637 + 64] = address(_18322)
                        mem[_18637 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[_18637 + 100] = _18292
                        mem[_18637 + 132] = cd[196]
                        mem[_18637 + 164] = 160
                        mem[_18637 + 260] = mem[_18637]
                        s = 0
                        t = _18637 + 32
                        u = _18637 + 292
                        while s < mem[_18637]:
                            mem[u] = mem[t + 12 len 20]
                            s = s + 1
                            t = t + 32
                            u = u + 32
                            continue 
                        mem[_18637 + 196] = address(cd[292])
                        mem[_18637 + 228] = block.timestamp
                        require ext_code.size(address(_18329))
                        call address(_18329).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len _18637 + (32 * mem[_18637]) + -mem[64] + 288]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21151 = mem[64]
                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _21259 = mem[_21151]
                        require mem[_21151] <= test266151307()
                        require _21151 + return_data.size > _21151 + mem[_21151] + 31
                        _21295 = mem[_21151 + mem[_21151]]
                        if mem[_21151 + mem[_21151]] > test266151307():
                            revert with 0, 65
                        if ceil32(32 * mem[_21151 + mem[_21151]]) + 1 < 0 or _21151 + ceil32(return_data.size) + ceil32(32 * mem[_21151 + mem[_21151]]) + 1 > test266151307():
                            revert with 0, 65
                        mem[64] = _21151 + ceil32(return_data.size) + ceil32(32 * mem[_21151 + mem[_21151]]) + 1
                        mem[_21151 + ceil32(return_data.size)] = _21295
                        require _21259 + (32 * _21295) + 32 <= return_data.size
                        t = _21151 + _21259 + 32
                        u = _21151 + ceil32(return_data.size) + 32
                        s = 0
                        while s < _21295:
                            mem[u] = mem[t]
                            t = t + 32
                            u = u + 32
                            s = s + 1
                            continue 
                        mem[mem[64] + 4] = address(_18329)
                        mem[mem[64] + 36] = 0
                        require ext_code.size(address(_18307))
                        call address(_18307).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(_18329), 0
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21799 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_21799] == bool(mem[_21799])
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18322))
                        staticcall address(_18322).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _21943 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_21943] < _18445:
                            revert with 0, 17
                    else:
                        if address(_18307) == address(_18337):
                            _18643 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_18643]:
                                revert with 0, 50
                            mem[_18643 + 32] = address(_18307)
                            if 1 >= mem[_18643]:
                                revert with 0, 50
                            mem[_18643 + 64] = address(_18322)
                            mem[_18643 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_18643 + 100] = _18292
                            mem[_18643 + 132] = cd[196]
                            mem[_18643 + 164] = 160
                            mem[_18643 + 260] = mem[_18643]
                            s = 0
                            t = _18643 + 32
                            u = _18643 + 292
                            while s < mem[_18643]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_18643 + 196] = address(cd[292])
                            mem[_18643 + 228] = block.timestamp
                            require ext_code.size(address(_18329))
                            call address(_18329).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _18643 + (32 * mem[_18643]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21148 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _21256 = mem[_21148]
                            require mem[_21148] <= test266151307()
                            require _21148 + return_data.size > _21148 + mem[_21148] + 31
                            _21292 = mem[_21148 + mem[_21148]]
                            if mem[_21148 + mem[_21148]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_21148 + mem[_21148]]) + 1 < 0 or _21148 + ceil32(return_data.size) + ceil32(32 * mem[_21148 + mem[_21148]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _21148 + ceil32(return_data.size) + ceil32(32 * mem[_21148 + mem[_21148]]) + 1
                            mem[_21148 + ceil32(return_data.size)] = _21292
                            require _21256 + (32 * _21292) + 32 <= return_data.size
                            t = _21148 + _21256 + 32
                            u = _21148 + ceil32(return_data.size) + 32
                            s = 0
                            while s < _21292:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
                            mem[mem[64] + 4] = address(_18329)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(_18307))
                            call address(_18307).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18329), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21796 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_21796] == bool(mem[_21796])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18322))
                            staticcall address(_18322).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21940 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_21940] < _18445:
                                revert with 0, 17
                        else:
                            if address(_18322) == address(_18337):
                                _18659 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18659]:
                                    revert with 0, 50
                                mem[_18659 + 32] = address(_18307)
                                if 1 >= mem[_18659]:
                                    revert with 0, 50
                                mem[_18659 + 64] = address(_18322)
                                mem[_18659 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18659 + 100] = _18292
                                mem[_18659 + 132] = cd[196]
                                mem[_18659 + 164] = 160
                                mem[_18659 + 260] = mem[_18659]
                                s = 0
                                t = _18659 + 32
                                u = _18659 + 292
                                while s < mem[_18659]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18659 + 196] = address(cd[292])
                                mem[_18659 + 228] = block.timestamp
                                require ext_code.size(address(_18329))
                                call address(_18329).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18659 + (32 * mem[_18659]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21150 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21258 = mem[_21150]
                                require mem[_21150] <= test266151307()
                                require _21150 + return_data.size > _21150 + mem[_21150] + 31
                                _21294 = mem[_21150 + mem[_21150]]
                                if mem[_21150 + mem[_21150]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21150 + mem[_21150]]) + 1 < 0 or _21150 + ceil32(return_data.size) + ceil32(32 * mem[_21150 + mem[_21150]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21150 + ceil32(return_data.size) + ceil32(32 * mem[_21150 + mem[_21150]]) + 1
                                mem[_21150 + ceil32(return_data.size)] = _21294
                                require _21258 + (32 * _21294) + 32 <= return_data.size
                                t = _21150 + _21258 + 32
                                u = _21150 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21294:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18329)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18307))
                                call address(_18307).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18329), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21798 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21798] == bool(mem[_21798])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18322))
                                staticcall address(_18322).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21942 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21942] < _18445:
                                    revert with 0, 17
                            else:
                                _18644 = mem[64]
                                mem[mem[64]] = 3
                                mem[64] = mem[64] + 128
                                if 0 >= mem[_18644]:
                                    revert with 0, 50
                                mem[_18644 + 32] = address(_18307)
                                if 1 >= mem[_18644]:
                                    revert with 0, 50
                                mem[_18644 + 64] = address(_18337)
                                if 2 >= mem[_18644]:
                                    revert with 0, 50
                                mem[_18644 + 96] = address(_18322)
                                mem[_18644 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18644 + 132] = _18292
                                mem[_18644 + 164] = cd[196]
                                mem[_18644 + 196] = 160
                                mem[_18644 + 292] = mem[_18644]
                                s = 0
                                t = _18644 + 32
                                u = _18644 + 324
                                while s < mem[_18644]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18644 + 228] = address(cd[292])
                                mem[_18644 + 260] = block.timestamp
                                require ext_code.size(address(_18329))
                                call address(_18329).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18644 + (32 * mem[_18644]) + -mem[64] + 320]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21149 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21257 = mem[_21149]
                                require mem[_21149] <= test266151307()
                                require _21149 + return_data.size > _21149 + mem[_21149] + 31
                                _21293 = mem[_21149 + mem[_21149]]
                                if mem[_21149 + mem[_21149]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21149 + mem[_21149]]) + 1 < 0 or _21149 + ceil32(return_data.size) + ceil32(32 * mem[_21149 + mem[_21149]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21149 + ceil32(return_data.size) + ceil32(32 * mem[_21149 + mem[_21149]]) + 1
                                mem[_21149 + ceil32(return_data.size)] = _21293
                                require _21257 + (32 * _21293) + 32 <= return_data.size
                                t = _21149 + _21257 + 32
                                u = _21149 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21293:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18329)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18307))
                                call address(_18307).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18329), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21797 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21797] == bool(mem[_21797])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18322))
                                staticcall address(_18322).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21941 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21941] < _18445:
                                    revert with 0, 17
                else:
                    if msg.sender == stor1:
                        if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                            revert with 0, 'Set router'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18322))
                        staticcall address(_18322).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18433 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18456 = mem[_18433]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18307))
                        staticcall address(_18307).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18493 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_18493] < _18292:
                            revert with 0, 'Refill amountIn'
                        mem[mem[64] + 4] = address(_18329)
                        mem[mem[64] + 36] = _18292
                        require ext_code.size(address(_18307))
                        call address(_18307).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(_18329), _18292
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18586 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_18586] == bool(mem[_18586])
                        if not address(_18337):
                            _18640 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_18640]:
                                revert with 0, 50
                            mem[_18640 + 32] = address(_18307)
                            if 1 >= mem[_18640]:
                                revert with 0, 50
                            mem[_18640 + 64] = address(_18322)
                            mem[_18640 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_18640 + 100] = _18292
                            mem[_18640 + 132] = cd[196]
                            mem[_18640 + 164] = 160
                            mem[_18640 + 260] = mem[_18640]
                            s = 0
                            t = _18640 + 32
                            u = _18640 + 292
                            while s < mem[_18640]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_18640 + 196] = address(cd[292])
                            mem[_18640 + 228] = block.timestamp
                            require ext_code.size(address(_18329))
                            call address(_18329).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _18640 + (32 * mem[_18640]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21155 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _21263 = mem[_21155]
                            require mem[_21155] <= test266151307()
                            require _21155 + return_data.size > _21155 + mem[_21155] + 31
                            _21299 = mem[_21155 + mem[_21155]]
                            if mem[_21155 + mem[_21155]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_21155 + mem[_21155]]) + 1 < 0 or _21155 + ceil32(return_data.size) + ceil32(32 * mem[_21155 + mem[_21155]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _21155 + ceil32(return_data.size) + ceil32(32 * mem[_21155 + mem[_21155]]) + 1
                            mem[_21155 + ceil32(return_data.size)] = _21299
                            require _21263 + (32 * _21299) + 32 <= return_data.size
                            t = _21155 + _21263 + 32
                            u = _21155 + ceil32(return_data.size) + 32
                            s = 0
                            while s < _21299:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
                            mem[mem[64] + 4] = address(_18329)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(_18307))
                            call address(_18307).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18329), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21803 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_21803] == bool(mem[_21803])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18322))
                            staticcall address(_18322).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21947 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_21947] < _18456:
                                revert with 0, 17
                        else:
                            if address(_18307) == address(_18337):
                                _18661 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18661]:
                                    revert with 0, 50
                                mem[_18661 + 32] = address(_18307)
                                if 1 >= mem[_18661]:
                                    revert with 0, 50
                                mem[_18661 + 64] = address(_18322)
                                mem[_18661 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18661 + 100] = _18292
                                mem[_18661 + 132] = cd[196]
                                mem[_18661 + 164] = 160
                                mem[_18661 + 260] = mem[_18661]
                                s = 0
                                t = _18661 + 32
                                u = _18661 + 292
                                while s < mem[_18661]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18661 + 196] = address(cd[292])
                                mem[_18661 + 228] = block.timestamp
                                require ext_code.size(address(_18329))
                                call address(_18329).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18661 + (32 * mem[_18661]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21152 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21260 = mem[_21152]
                                require mem[_21152] <= test266151307()
                                require _21152 + return_data.size > _21152 + mem[_21152] + 31
                                _21296 = mem[_21152 + mem[_21152]]
                                if mem[_21152 + mem[_21152]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21152 + mem[_21152]]) + 1 < 0 or _21152 + ceil32(return_data.size) + ceil32(32 * mem[_21152 + mem[_21152]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21152 + ceil32(return_data.size) + ceil32(32 * mem[_21152 + mem[_21152]]) + 1
                                mem[_21152 + ceil32(return_data.size)] = _21296
                                require _21260 + (32 * _21296) + 32 <= return_data.size
                                t = _21152 + _21260 + 32
                                u = _21152 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21296:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18329)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18307))
                                call address(_18307).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18329), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21800 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21800] == bool(mem[_21800])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18322))
                                staticcall address(_18322).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21944 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21944] < _18456:
                                    revert with 0, 17
                            else:
                                if address(_18322) == address(_18337):
                                    _18688 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_18688]:
                                        revert with 0, 50
                                    mem[_18688 + 32] = address(_18307)
                                    if 1 >= mem[_18688]:
                                        revert with 0, 50
                                    mem[_18688 + 64] = address(_18322)
                                    mem[_18688 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18688 + 100] = _18292
                                    mem[_18688 + 132] = cd[196]
                                    mem[_18688 + 164] = 160
                                    mem[_18688 + 260] = mem[_18688]
                                    s = 0
                                    t = _18688 + 32
                                    u = _18688 + 292
                                    while s < mem[_18688]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18688 + 196] = address(cd[292])
                                    mem[_18688 + 228] = block.timestamp
                                    require ext_code.size(address(_18329))
                                    call address(_18329).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18688 + (32 * mem[_18688]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21154 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21262 = mem[_21154]
                                    require mem[_21154] <= test266151307()
                                    require _21154 + return_data.size > _21154 + mem[_21154] + 31
                                    _21298 = mem[_21154 + mem[_21154]]
                                    if mem[_21154 + mem[_21154]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21154 + mem[_21154]]) + 1 < 0 or _21154 + ceil32(return_data.size) + ceil32(32 * mem[_21154 + mem[_21154]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21154 + ceil32(return_data.size) + ceil32(32 * mem[_21154 + mem[_21154]]) + 1
                                    mem[_21154 + ceil32(return_data.size)] = _21298
                                    require _21262 + (32 * _21298) + 32 <= return_data.size
                                    t = _21154 + _21262 + 32
                                    u = _21154 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21298:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18329)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18307))
                                    call address(_18307).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18329), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21802 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21802] == bool(mem[_21802])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18322))
                                    staticcall address(_18322).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21946 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21946] < _18456:
                                        revert with 0, 17
                                else:
                                    _18662 = mem[64]
                                    mem[mem[64]] = 3
                                    mem[64] = mem[64] + 128
                                    if 0 >= mem[_18662]:
                                        revert with 0, 50
                                    mem[_18662 + 32] = address(_18307)
                                    if 1 >= mem[_18662]:
                                        revert with 0, 50
                                    mem[_18662 + 64] = address(_18337)
                                    if 2 >= mem[_18662]:
                                        revert with 0, 50
                                    mem[_18662 + 96] = address(_18322)
                                    mem[_18662 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18662 + 132] = _18292
                                    mem[_18662 + 164] = cd[196]
                                    mem[_18662 + 196] = 160
                                    mem[_18662 + 292] = mem[_18662]
                                    s = 0
                                    t = _18662 + 32
                                    u = _18662 + 324
                                    while s < mem[_18662]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18662 + 228] = address(cd[292])
                                    mem[_18662 + 260] = block.timestamp
                                    require ext_code.size(address(_18329))
                                    call address(_18329).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18662 + (32 * mem[_18662]) + -mem[64] + 320]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21153 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21261 = mem[_21153]
                                    require mem[_21153] <= test266151307()
                                    require _21153 + return_data.size > _21153 + mem[_21153] + 31
                                    _21297 = mem[_21153 + mem[_21153]]
                                    if mem[_21153 + mem[_21153]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21153 + mem[_21153]]) + 1 < 0 or _21153 + ceil32(return_data.size) + ceil32(32 * mem[_21153 + mem[_21153]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21153 + ceil32(return_data.size) + ceil32(32 * mem[_21153 + mem[_21153]]) + 1
                                    mem[_21153 + ceil32(return_data.size)] = _21297
                                    require _21261 + (32 * _21297) + 32 <= return_data.size
                                    t = _21153 + _21261 + 32
                                    u = _21153 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21297:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18329)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18307))
                                    call address(_18307).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18329), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21801 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21801] == bool(mem[_21801])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18322))
                                    staticcall address(_18322).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21945 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21945] < _18456:
                                        revert with 0, 17
                    else:
                        if stor2 != msg.sender:
                            revert with 0, 'Not authorized'
                        if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                            revert with 0, 'Set router'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18322))
                        staticcall address(_18322).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18446 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18468 = mem[_18446]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18307))
                        staticcall address(_18307).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18506 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_18506] < _18292:
                            revert with 0, 'Refill amountIn'
                        mem[mem[64] + 4] = address(_18329)
                        mem[mem[64] + 36] = _18292
                        require ext_code.size(address(_18307))
                        call address(_18307).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(_18329), _18292
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18596 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_18596] == bool(mem[_18596])
                        if not address(_18337):
                            _18647 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_18647]:
                                revert with 0, 50
                            mem[_18647 + 32] = address(_18307)
                            if 1 >= mem[_18647]:
                                revert with 0, 50
                            mem[_18647 + 64] = address(_18322)
                            mem[_18647 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_18647 + 100] = _18292
                            mem[_18647 + 132] = cd[196]
                            mem[_18647 + 164] = 160
                            mem[_18647 + 260] = mem[_18647]
                            s = 0
                            t = _18647 + 32
                            u = _18647 + 292
                            while s < mem[_18647]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_18647 + 196] = address(cd[292])
                            mem[_18647 + 228] = block.timestamp
                            require ext_code.size(address(_18329))
                            call address(_18329).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _18647 + (32 * mem[_18647]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21159 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _21267 = mem[_21159]
                            require mem[_21159] <= test266151307()
                            require _21159 + return_data.size > _21159 + mem[_21159] + 31
                            _21303 = mem[_21159 + mem[_21159]]
                            if mem[_21159 + mem[_21159]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_21159 + mem[_21159]]) + 1 < 0 or _21159 + ceil32(return_data.size) + ceil32(32 * mem[_21159 + mem[_21159]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _21159 + ceil32(return_data.size) + ceil32(32 * mem[_21159 + mem[_21159]]) + 1
                            mem[_21159 + ceil32(return_data.size)] = _21303
                            require _21267 + (32 * _21303) + 32 <= return_data.size
                            t = _21159 + _21267 + 32
                            u = _21159 + ceil32(return_data.size) + 32
                            s = 0
                            while s < _21303:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
                            mem[mem[64] + 4] = address(_18329)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(_18307))
                            call address(_18307).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18329), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21807 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_21807] == bool(mem[_21807])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18322))
                            staticcall address(_18322).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21951 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_21951] < _18468:
                                revert with 0, 17
                        else:
                            if address(_18307) == address(_18337):
                                _18690 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18690]:
                                    revert with 0, 50
                                mem[_18690 + 32] = address(_18307)
                                if 1 >= mem[_18690]:
                                    revert with 0, 50
                                mem[_18690 + 64] = address(_18322)
                                mem[_18690 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18690 + 100] = _18292
                                mem[_18690 + 132] = cd[196]
                                mem[_18690 + 164] = 160
                                mem[_18690 + 260] = mem[_18690]
                                s = 0
                                t = _18690 + 32
                                u = _18690 + 292
                                while s < mem[_18690]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18690 + 196] = address(cd[292])
                                mem[_18690 + 228] = block.timestamp
                                require ext_code.size(address(_18329))
                                call address(_18329).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18690 + (32 * mem[_18690]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21156 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21264 = mem[_21156]
                                require mem[_21156] <= test266151307()
                                require _21156 + return_data.size > _21156 + mem[_21156] + 31
                                _21300 = mem[_21156 + mem[_21156]]
                                if mem[_21156 + mem[_21156]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21156 + mem[_21156]]) + 1 < 0 or _21156 + ceil32(return_data.size) + ceil32(32 * mem[_21156 + mem[_21156]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21156 + ceil32(return_data.size) + ceil32(32 * mem[_21156 + mem[_21156]]) + 1
                                mem[_21156 + ceil32(return_data.size)] = _21300
                                require _21264 + (32 * _21300) + 32 <= return_data.size
                                t = _21156 + _21264 + 32
                                u = _21156 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21300:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18329)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18307))
                                call address(_18307).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18329), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21804 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21804] == bool(mem[_21804])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18322))
                                staticcall address(_18322).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21948 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21948] < _18468:
                                    revert with 0, 17
                            else:
                                if address(_18322) == address(_18337):
                                    _18733 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_18733]:
                                        revert with 0, 50
                                    mem[_18733 + 32] = address(_18307)
                                    if 1 >= mem[_18733]:
                                        revert with 0, 50
                                    mem[_18733 + 64] = address(_18322)
                                    mem[_18733 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18733 + 100] = _18292
                                    mem[_18733 + 132] = cd[196]
                                    mem[_18733 + 164] = 160
                                    mem[_18733 + 260] = mem[_18733]
                                    s = 0
                                    t = _18733 + 32
                                    u = _18733 + 292
                                    while s < mem[_18733]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18733 + 196] = address(cd[292])
                                    mem[_18733 + 228] = block.timestamp
                                    require ext_code.size(address(_18329))
                                    call address(_18329).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18733 + (32 * mem[_18733]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21158 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21266 = mem[_21158]
                                    require mem[_21158] <= test266151307()
                                    require _21158 + return_data.size > _21158 + mem[_21158] + 31
                                    _21302 = mem[_21158 + mem[_21158]]
                                    if mem[_21158 + mem[_21158]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21158 + mem[_21158]]) + 1 < 0 or _21158 + ceil32(return_data.size) + ceil32(32 * mem[_21158 + mem[_21158]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21158 + ceil32(return_data.size) + ceil32(32 * mem[_21158 + mem[_21158]]) + 1
                                    mem[_21158 + ceil32(return_data.size)] = _21302
                                    require _21266 + (32 * _21302) + 32 <= return_data.size
                                    t = _21158 + _21266 + 32
                                    u = _21158 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21302:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18329)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18307))
                                    call address(_18307).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18329), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21806 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21806] == bool(mem[_21806])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18322))
                                    staticcall address(_18322).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21950 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21950] < _18468:
                                        revert with 0, 17
                                else:
                                    _18691 = mem[64]
                                    mem[mem[64]] = 3
                                    mem[64] = mem[64] + 128
                                    if 0 >= mem[_18691]:
                                        revert with 0, 50
                                    mem[_18691 + 32] = address(_18307)
                                    if 1 >= mem[_18691]:
                                        revert with 0, 50
                                    mem[_18691 + 64] = address(_18337)
                                    if 2 >= mem[_18691]:
                                        revert with 0, 50
                                    mem[_18691 + 96] = address(_18322)
                                    mem[_18691 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18691 + 132] = _18292
                                    mem[_18691 + 164] = cd[196]
                                    mem[_18691 + 196] = 160
                                    mem[_18691 + 292] = mem[_18691]
                                    s = 0
                                    t = _18691 + 32
                                    u = _18691 + 324
                                    while s < mem[_18691]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18691 + 228] = address(cd[292])
                                    mem[_18691 + 260] = block.timestamp
                                    require ext_code.size(address(_18329))
                                    call address(_18329).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18691 + (32 * mem[_18691]) + -mem[64] + 320]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21157 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21265 = mem[_21157]
                                    require mem[_21157] <= test266151307()
                                    require _21157 + return_data.size > _21157 + mem[_21157] + 31
                                    _21301 = mem[_21157 + mem[_21157]]
                                    if mem[_21157 + mem[_21157]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21157 + mem[_21157]]) + 1 < 0 or _21157 + ceil32(return_data.size) + ceil32(32 * mem[_21157 + mem[_21157]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21157 + ceil32(return_data.size) + ceil32(32 * mem[_21157 + mem[_21157]]) + 1
                                    mem[_21157 + ceil32(return_data.size)] = _21301
                                    require _21265 + (32 * _21301) + 32 <= return_data.size
                                    t = _21157 + _21265 + 32
                                    u = _21157 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21301:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18329)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18307))
                                    call address(_18307).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18329), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21805 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21805] == bool(mem[_21805])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18322))
                                    staticcall address(_18322).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21949 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21949] < _18468:
                                        revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = _18292
            s = _18286
            continue 
        if ('cd', 100).length < 1:
            revert with 0, 17
        if ('cd', 100).length - 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
            revert with 0, 50
        mem[mem[64] + 4] = this.address
        require ext_code.size(mem[(32 * ('cd', 100).length - 1) + ceil32(32 * ('cd', 4).length) + 141 len 20])
        staticcall mem[(32 * ('cd', 100).length - 1) + ceil32(32 * ('cd', 4).length) + 141 len 20].0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _18328 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_18328] <= cd[228]:
            revert with 0, 'Check result'
        mem[mem[64]] = mem[_18328]
    else:
        if msg.sender == stor1:
            if ('cd', 100).length != ('cd', 36).length:
                revert with 0, 'Check length1'
            if ('cd', 100).length != ('cd', 4).length:
                revert with 0, 'Check length2'
            if ('cd', 100).length != ('cd', 164).length:
                revert with 0, 'Check length3'
            idx = 0
            s = 0
            s = 0
            while idx < ('cd', 100).length:
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                _18288 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 101]:
                    revert with 0, 50
                _18293 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 133]
                if idx >= mem[96]:
                    revert with 0, 50
                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]:
                    _18315 = mem[(32 * idx) + 128]
                    if msg.sender == stor0:
                        require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                        staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18361 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _18408 = mem[_18361]
                        require mem[_18361] == mem[_18361 + 18 len 14]
                        _18450 = mem[_18361 + 32]
                        require mem[_18361 + 32] == mem[_18361 + 50 len 14]
                        require mem[_18361 + 64] == mem[_18361 + 92 len 4]
                        require ext_code.size(address(_18288))
                        staticcall address(_18288).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18522 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18549 = mem[_18522]
                        require mem[_18522] == mem[_18522 + 12 len 20]
                        require ext_code.size(address(_18288))
                        staticcall address(_18288).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18612 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18627 = mem[_18612]
                        require mem[_18612] == mem[_18612 + 12 len 20]
                        if address(_18549) == address(_18315):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18315))
                            staticcall address(_18315).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18750 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18750] < _18293:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _18293 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_18549) != address(_18315):
                                if Mask(112, 0, _18450) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18408) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18293 and 998 > -1 / _18293:
                                    revert with 0, 17
                                if 998 * _18293 / 998 != _18293:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18408):
                                    if Mask(112, 0, _18450) and 1000 > -1 / Mask(112, 0, _18450):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18450) / 1000 != Mask(112, 0, _18450):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18450) > !(998 * _18293):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18450)) + (998 * _18293) < 1000 * Mask(112, 0, _18450):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18450)) + (998 * _18293):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18288)
                                    mem[mem[64] + 36] = _18293
                                    require ext_code.size(address(_18627))
                                    call address(_18627).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18288), _18293
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20272 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20272] == bool(mem[_20272])
                                    _20472 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20472 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20472 + 36] = (0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260]
                                    mem[_20472 + 68] = 0
                                    mem[_20472 + 100] = this.address
                                    mem[_20472 + 132] = 128
                                    mem[_20472 + 164] = mem[_20472]
                                    s = 0
                                    while s < mem[_20472]:
                                        mem[s + _20472 + 196] = mem[_20472 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20472]) > mem[_20472]:
                                        mem[_20472 + mem[_20472] + 196] = 0
                                    require ext_code.size(address(_18288))
                                    call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260], 0, address(this.address), 128, mem[_20472], mem[_20472 + 196 len ceil32(mem[_20472])]
                                else:
                                    if 998 * _18293 and Mask(112, 0, _18408) > -1 / 998 * _18293:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18408):
                                        revert with 0, 18
                                    if 998 * _18293 * Mask(112, 0, _18408) / Mask(112, 0, _18408) != 998 * _18293:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18450) and 1000 > -1 / Mask(112, 0, _18450):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18450) / 1000 != Mask(112, 0, _18450):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18450) > !(998 * _18293):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18450)) + (998 * _18293) < 1000 * Mask(112, 0, _18450):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18450)) + (998 * _18293):
                                        revert with 0, 18
                                    if 998 * _18293 * Mask(112, 0, _18408) / (1000 * Mask(112, 0, _18450)) + (998 * _18293) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18293 * Mask(112, 0, _18408) / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18408) / (1000 * Mask(112, 0, _18450)) + (998 * _18293):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18288)
                                    mem[mem[64] + 36] = _18293
                                    require ext_code.size(address(_18627))
                                    call address(_18627).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18288), _18293
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20498 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20498] == bool(mem[_20498])
                                    _20681 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20681 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20681 + 36] = (998 * _18293 * Mask(112, 0, _18408) / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260]
                                    mem[_20681 + 68] = 0
                                    mem[_20681 + 100] = this.address
                                    mem[_20681 + 132] = 128
                                    mem[_20681 + 164] = mem[_20681]
                                    s = 0
                                    while s < mem[_20681]:
                                        mem[s + _20681 + 196] = mem[_20681 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20681]) > mem[_20681]:
                                        mem[_20681 + mem[_20681] + 196] = 0
                                    require ext_code.size(address(_18288))
                                    call address(_18288).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20681]) + _20681 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _18408) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18450) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18293 and 998 > -1 / _18293:
                                    revert with 0, 17
                                if 998 * _18293 / 998 != _18293:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18450):
                                    if Mask(112, 0, _18408) and 1000 > -1 / Mask(112, 0, _18408):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18408) / 1000 != Mask(112, 0, _18408):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18408) > !(998 * _18293):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18408)) + (998 * _18293) < 1000 * Mask(112, 0, _18408):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18408)) + (998 * _18293):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18288)
                                    mem[mem[64] + 36] = _18293
                                    require ext_code.size(address(_18549))
                                    call address(_18549).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18288), _18293
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20273 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20273] == bool(mem[_20273])
                                    _20473 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20473 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20473 + 36] = 0
                                    mem[_20473 + 68] = (0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260]
                                    mem[_20473 + 100] = this.address
                                    mem[_20473 + 132] = 128
                                    mem[_20473 + 164] = mem[_20473]
                                    s = 0
                                    while s < mem[_20473]:
                                        mem[s + _20473 + 196] = mem[_20473 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20473]) > mem[_20473]:
                                        mem[_20473 + mem[_20473] + 196] = 0
                                    require ext_code.size(address(_18288))
                                    call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260], address(this.address), 128, mem[_20473], mem[_20473 + 196 len ceil32(mem[_20473])]
                                else:
                                    if 998 * _18293 and Mask(112, 0, _18450) > -1 / 998 * _18293:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18450):
                                        revert with 0, 18
                                    if 998 * _18293 * Mask(112, 0, _18450) / Mask(112, 0, _18450) != 998 * _18293:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18408) and 1000 > -1 / Mask(112, 0, _18408):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18408) / 1000 != Mask(112, 0, _18408):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18408) > !(998 * _18293):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18408)) + (998 * _18293) < 1000 * Mask(112, 0, _18408):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18408)) + (998 * _18293):
                                        revert with 0, 18
                                    if 998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18288)
                                    mem[mem[64] + 36] = _18293
                                    require ext_code.size(address(_18549))
                                    call address(_18549).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18288), _18293
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20499 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20499] == bool(mem[_20499])
                                    _20683 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20683 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20683 + 36] = 0
                                    mem[_20683 + 68] = (998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260]
                                    mem[_20683 + 100] = this.address
                                    mem[_20683 + 132] = 128
                                    mem[_20683 + 164] = mem[_20683]
                                    s = 0
                                    while s < mem[_20683]:
                                        mem[s + _20683 + 196] = mem[_20683 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20683]) > mem[_20683]:
                                        mem[_20683 + mem[_20683] + 196] = 0
                                    require ext_code.size(address(_18288))
                                    call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260], address(this.address), 128, mem[_20683], mem[_20683 + 196 len ceil32(mem[_20683])]
                        else:
                            if mem[_18612 + 12 len 20] != address(_18315):
                                revert with 0, 'Check pair address'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18315))
                            staticcall address(_18315).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18792 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18792] < _18293:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _18293 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_18549) != address(_18315):
                                if Mask(112, 0, _18450) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18408) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18293 and 998 > -1 / _18293:
                                    revert with 0, 17
                                if 998 * _18293 / 998 != _18293:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18408):
                                    if Mask(112, 0, _18450) and 1000 > -1 / Mask(112, 0, _18450):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18450) / 1000 != Mask(112, 0, _18450):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18450) > !(998 * _18293):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18450)) + (998 * _18293) < 1000 * Mask(112, 0, _18450):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18450)) + (998 * _18293):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18288)
                                    mem[mem[64] + 36] = _18293
                                    require ext_code.size(address(_18627))
                                    call address(_18627).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18288), _18293
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20294 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20294] == bool(mem[_20294])
                                    _20500 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20500 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20500 + 36] = (0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260]
                                    mem[_20500 + 68] = 0
                                    mem[_20500 + 100] = this.address
                                    mem[_20500 + 132] = 128
                                    mem[_20500 + 164] = mem[_20500]
                                    s = 0
                                    while s < mem[_20500]:
                                        mem[s + _20500 + 196] = mem[_20500 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20500]) > mem[_20500]:
                                        mem[_20500 + mem[_20500] + 196] = 0
                                    require ext_code.size(address(_18288))
                                    call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (0 / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260], 0, address(this.address), 128, mem[_20500], mem[_20500 + 196 len ceil32(mem[_20500])]
                                else:
                                    if 998 * _18293 and Mask(112, 0, _18408) > -1 / 998 * _18293:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18408):
                                        revert with 0, 18
                                    if 998 * _18293 * Mask(112, 0, _18408) / Mask(112, 0, _18408) != 998 * _18293:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18450) and 1000 > -1 / Mask(112, 0, _18450):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18450) / 1000 != Mask(112, 0, _18450):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18450) > !(998 * _18293):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18450)) + (998 * _18293) < 1000 * Mask(112, 0, _18450):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18450)) + (998 * _18293):
                                        revert with 0, 18
                                    if 998 * _18293 * Mask(112, 0, _18408) / (1000 * Mask(112, 0, _18450)) + (998 * _18293) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18293 * Mask(112, 0, _18408) / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18408) / (1000 * Mask(112, 0, _18450)) + (998 * _18293):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18288)
                                    mem[mem[64] + 36] = _18293
                                    require ext_code.size(address(_18627))
                                    call address(_18627).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18288), _18293
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20532 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20532] == bool(mem[_20532])
                                    _20705 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20705 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20705 + 36] = (998 * _18293 * Mask(112, 0, _18408) / (1000 * Mask(112, 0, _18450)) + (998 * _18293)) - cd[260]
                                    mem[_20705 + 68] = 0
                                    mem[_20705 + 100] = this.address
                                    mem[_20705 + 132] = 128
                                    mem[_20705 + 164] = mem[_20705]
                                    s = 0
                                    while s < mem[_20705]:
                                        mem[s + _20705 + 196] = mem[_20705 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20705]) > mem[_20705]:
                                        mem[_20705 + mem[_20705] + 196] = 0
                                    require ext_code.size(address(_18288))
                                    call address(_18288).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20705]) + _20705 + -mem[64] + 192]
                            else:
                                if Mask(112, 0, _18408) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18450) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18293 and 998 > -1 / _18293:
                                    revert with 0, 17
                                if 998 * _18293 / 998 != _18293:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18450):
                                    if Mask(112, 0, _18408) and 1000 > -1 / Mask(112, 0, _18408):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18408) / 1000 != Mask(112, 0, _18408):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18408) > !(998 * _18293):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18408)) + (998 * _18293) < 1000 * Mask(112, 0, _18408):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18408)) + (998 * _18293):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18288)
                                    mem[mem[64] + 36] = _18293
                                    require ext_code.size(address(_18549))
                                    call address(_18549).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18288), _18293
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20295 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20295] == bool(mem[_20295])
                                    _20501 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20501 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20501 + 36] = 0
                                    mem[_20501 + 68] = (0 / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260]
                                    mem[_20501 + 100] = this.address
                                    mem[_20501 + 132] = 128
                                    mem[_20501 + 164] = mem[_20501]
                                    s = 0
                                    while s < mem[_20501]:
                                        mem[s + _20501 + 196] = mem[_20501 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20501]) > mem[_20501]:
                                        mem[_20501 + mem[_20501] + 196] = 0
                                    require ext_code.size(address(_18288))
                                    call address(_18288).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20501]) + _20501 + -mem[64] + 192]
                                else:
                                    if 998 * _18293 and Mask(112, 0, _18450) > -1 / 998 * _18293:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18450):
                                        revert with 0, 18
                                    if 998 * _18293 * Mask(112, 0, _18450) / Mask(112, 0, _18450) != 998 * _18293:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18408) and 1000 > -1 / Mask(112, 0, _18408):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18408) / 1000 != Mask(112, 0, _18408):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18408) > !(998 * _18293):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18408)) + (998 * _18293) < 1000 * Mask(112, 0, _18408):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18408)) + (998 * _18293):
                                        revert with 0, 18
                                    if 998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18288)
                                    mem[mem[64] + 36] = _18293
                                    require ext_code.size(address(_18549))
                                    call address(_18549).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18288), _18293
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20533 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20533] == bool(mem[_20533])
                                    _20707 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20707 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20707 + 36] = 0
                                    mem[_20707 + 68] = (998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260]
                                    mem[_20707 + 100] = this.address
                                    mem[_20707 + 132] = 128
                                    mem[_20707 + 164] = mem[_20707]
                                    s = 0
                                    while s < mem[_20707]:
                                        mem[s + _20707 + 196] = mem[_20707 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20707]) > mem[_20707]:
                                        mem[_20707 + mem[_20707] + 196] = 0
                                    require ext_code.size(address(_18288))
                                    call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _18293 * Mask(112, 0, _18450) / (1000 * Mask(112, 0, _18408)) + (998 * _18293)) - cd[260], address(this.address), 128, mem[_20707], mem[_20707 + 196 len ceil32(mem[_20707])]
                    else:
                        if msg.sender == stor1:
                            require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                            staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18373 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _18426 = mem[_18373]
                            require mem[_18373] == mem[_18373 + 18 len 14]
                            _18461 = mem[_18373 + 32]
                            require mem[_18373 + 32] == mem[_18373 + 50 len 14]
                            require mem[_18373 + 64] == mem[_18373 + 92 len 4]
                            require ext_code.size(address(_18288))
                            staticcall address(_18288).token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18536 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18565 = mem[_18536]
                            require mem[_18536] == mem[_18536 + 12 len 20]
                            require ext_code.size(address(_18288))
                            staticcall address(_18288).token1() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18622 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18632 = mem[_18622]
                            require mem[_18622] == mem[_18622 + 12 len 20]
                            if address(_18565) == address(_18315):
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18315))
                                staticcall address(_18315).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _18793 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_18793] < _18293:
                                    revert with 0, 'Refill _tokenIn amountIn'
                                if _18293 <= 0:
                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                if address(_18565) != address(_18315):
                                    if Mask(112, 0, _18461) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18426) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18293 and 998 > -1 / _18293:
                                        revert with 0, 17
                                    if 998 * _18293 / 998 != _18293:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18426):
                                        if Mask(112, 0, _18461) and 1000 > -1 / Mask(112, 0, _18461):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18461) / 1000 != Mask(112, 0, _18461):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18461) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18461)) + (998 * _18293) < 1000 * Mask(112, 0, _18461):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18461)) + (998 * _18293):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18461)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18461)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18461)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18632))
                                        call address(_18632).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20296 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20296] == bool(mem[_20296])
                                        _20502 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20502 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20502 + 36] = (0 / (1000 * Mask(112, 0, _18461)) + (998 * _18293)) - cd[260]
                                        mem[_20502 + 68] = 0
                                        mem[_20502 + 100] = this.address
                                        mem[_20502 + 132] = 128
                                        mem[_20502 + 164] = mem[_20502]
                                        s = 0
                                        while s < mem[_20502]:
                                            mem[s + _20502 + 196] = mem[_20502 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20502]) > mem[_20502]:
                                            mem[_20502 + mem[_20502] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20502]) + _20502 + -mem[64] + 192]
                                    else:
                                        if 998 * _18293 and Mask(112, 0, _18426) > -1 / 998 * _18293:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18426):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18426) / Mask(112, 0, _18426) != 998 * _18293:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18461) and 1000 > -1 / Mask(112, 0, _18461):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18461) / 1000 != Mask(112, 0, _18461):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18461) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18461)) + (998 * _18293) < 1000 * Mask(112, 0, _18461):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18461)) + (998 * _18293):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18426) / (1000 * Mask(112, 0, _18461)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18293 * Mask(112, 0, _18426) / (1000 * Mask(112, 0, _18461)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18426) / (1000 * Mask(112, 0, _18461)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18632))
                                        call address(_18632).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20534 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20534] == bool(mem[_20534])
                                        _20709 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20709 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20709 + 36] = (998 * _18293 * Mask(112, 0, _18426) / (1000 * Mask(112, 0, _18461)) + (998 * _18293)) - cd[260]
                                        mem[_20709 + 68] = 0
                                        mem[_20709 + 100] = this.address
                                        mem[_20709 + 132] = 128
                                        mem[_20709 + 164] = mem[_20709]
                                        s = 0
                                        while s < mem[_20709]:
                                            mem[s + _20709 + 196] = mem[_20709 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20709]) > mem[_20709]:
                                            mem[_20709 + mem[_20709] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20709]) + _20709 + -mem[64] + 192]
                                else:
                                    if Mask(112, 0, _18426) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18461) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18293 and 998 > -1 / _18293:
                                        revert with 0, 17
                                    if 998 * _18293 / 998 != _18293:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18461):
                                        if Mask(112, 0, _18426) and 1000 > -1 / Mask(112, 0, _18426):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18426) / 1000 != Mask(112, 0, _18426):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18426) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18426)) + (998 * _18293) < 1000 * Mask(112, 0, _18426):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18426)) + (998 * _18293):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18565))
                                        call address(_18565).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20297 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20297] == bool(mem[_20297])
                                        _20503 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20503 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20503 + 36] = 0
                                        mem[_20503 + 68] = (0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260]
                                        mem[_20503 + 100] = this.address
                                        mem[_20503 + 132] = 128
                                        mem[_20503 + 164] = mem[_20503]
                                        s = 0
                                        while s < mem[_20503]:
                                            mem[s + _20503 + 196] = mem[_20503 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20503]) > mem[_20503]:
                                            mem[_20503 + mem[_20503] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260], address(this.address), 128, mem[_20503], mem[_20503 + 196 len ceil32(mem[_20503])]
                                    else:
                                        if 998 * _18293 and Mask(112, 0, _18461) > -1 / 998 * _18293:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18461):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18461) / Mask(112, 0, _18461) != 998 * _18293:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18426) and 1000 > -1 / Mask(112, 0, _18426):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18426) / 1000 != Mask(112, 0, _18426):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18426) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18426)) + (998 * _18293) < 1000 * Mask(112, 0, _18426):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18426)) + (998 * _18293):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18565))
                                        call address(_18565).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20535 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20535] == bool(mem[_20535])
                                        _20711 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20711 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20711 + 36] = 0
                                        mem[_20711 + 68] = (998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260]
                                        mem[_20711 + 100] = this.address
                                        mem[_20711 + 132] = 128
                                        mem[_20711 + 164] = mem[_20711]
                                        s = 0
                                        while s < mem[_20711]:
                                            mem[s + _20711 + 196] = mem[_20711 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20711]) > mem[_20711]:
                                            mem[_20711 + mem[_20711] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20711]) + _20711 + -mem[64] + 192]
                            else:
                                if mem[_18622 + 12 len 20] != address(_18315):
                                    revert with 0, 'Check pair address'
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18315))
                                staticcall address(_18315).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _18830 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_18830] < _18293:
                                    revert with 0, 'Refill _tokenIn amountIn'
                                if _18293 <= 0:
                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                if address(_18565) != address(_18315):
                                    if Mask(112, 0, _18461) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18426) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18293 and 998 > -1 / _18293:
                                        revert with 0, 17
                                    if 998 * _18293 / 998 != _18293:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18426):
                                        if Mask(112, 0, _18461) and 1000 > -1 / Mask(112, 0, _18461):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18461) / 1000 != Mask(112, 0, _18461):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18461) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18461)) + (998 * _18293) < 1000 * Mask(112, 0, _18461):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18461)) + (998 * _18293):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18461)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18461)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18461)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18632))
                                        call address(_18632).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20328 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20328] == bool(mem[_20328])
                                        _20536 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20536 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20536 + 36] = (0 / (1000 * Mask(112, 0, _18461)) + (998 * _18293)) - cd[260]
                                        mem[_20536 + 68] = 0
                                        mem[_20536 + 100] = this.address
                                        mem[_20536 + 132] = 128
                                        mem[_20536 + 164] = mem[_20536]
                                        s = 0
                                        while s < mem[_20536]:
                                            mem[s + _20536 + 196] = mem[_20536 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20536]) > mem[_20536]:
                                            mem[_20536 + mem[_20536] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20536]) + _20536 + -mem[64] + 192]
                                    else:
                                        if 998 * _18293 and Mask(112, 0, _18426) > -1 / 998 * _18293:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18426):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18426) / Mask(112, 0, _18426) != 998 * _18293:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18461) and 1000 > -1 / Mask(112, 0, _18461):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18461) / 1000 != Mask(112, 0, _18461):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18461) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18461)) + (998 * _18293) < 1000 * Mask(112, 0, _18461):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18461)) + (998 * _18293):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18426) / (1000 * Mask(112, 0, _18461)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18293 * Mask(112, 0, _18426) / (1000 * Mask(112, 0, _18461)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18426) / (1000 * Mask(112, 0, _18461)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18632))
                                        call address(_18632).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20572 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20572] == bool(mem[_20572])
                                        _20743 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20743 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20743 + 36] = (998 * _18293 * Mask(112, 0, _18426) / (1000 * Mask(112, 0, _18461)) + (998 * _18293)) - cd[260]
                                        mem[_20743 + 68] = 0
                                        mem[_20743 + 100] = this.address
                                        mem[_20743 + 132] = 128
                                        mem[_20743 + 164] = mem[_20743]
                                        s = 0
                                        while s < mem[_20743]:
                                            mem[s + _20743 + 196] = mem[_20743 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20743]) > mem[_20743]:
                                            mem[_20743 + mem[_20743] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20743]) + _20743 + -mem[64] + 192]
                                else:
                                    if Mask(112, 0, _18426) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18461) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18293 and 998 > -1 / _18293:
                                        revert with 0, 17
                                    if 998 * _18293 / 998 != _18293:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18461):
                                        if Mask(112, 0, _18426) and 1000 > -1 / Mask(112, 0, _18426):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18426) / 1000 != Mask(112, 0, _18426):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18426) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18426)) + (998 * _18293) < 1000 * Mask(112, 0, _18426):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18426)) + (998 * _18293):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18565))
                                        call address(_18565).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20329 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20329] == bool(mem[_20329])
                                        _20537 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20537 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20537 + 36] = 0
                                        mem[_20537 + 68] = (0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260]
                                        mem[_20537 + 100] = this.address
                                        mem[_20537 + 132] = 128
                                        mem[_20537 + 164] = mem[_20537]
                                        s = 0
                                        while s < mem[_20537]:
                                            mem[s + _20537 + 196] = mem[_20537 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20537]) > mem[_20537]:
                                            mem[_20537 + mem[_20537] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (0 / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260], address(this.address), 128, mem[_20537], mem[_20537 + 196 len ceil32(mem[_20537])]
                                    else:
                                        if 998 * _18293 and Mask(112, 0, _18461) > -1 / 998 * _18293:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18461):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18461) / Mask(112, 0, _18461) != 998 * _18293:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18426) and 1000 > -1 / Mask(112, 0, _18426):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18426) / 1000 != Mask(112, 0, _18426):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18426) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18426)) + (998 * _18293) < 1000 * Mask(112, 0, _18426):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18426)) + (998 * _18293):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18565))
                                        call address(_18565).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20573 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20573] == bool(mem[_20573])
                                        _20745 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20745 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20745 + 36] = 0
                                        mem[_20745 + 68] = (998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260]
                                        mem[_20745 + 100] = this.address
                                        mem[_20745 + 132] = 128
                                        mem[_20745 + 164] = mem[_20745]
                                        s = 0
                                        while s < mem[_20745]:
                                            mem[s + _20745 + 196] = mem[_20745 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20745]) > mem[_20745]:
                                            mem[_20745 + mem[_20745] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (998 * _18293 * Mask(112, 0, _18461) / (1000 * Mask(112, 0, _18426)) + (998 * _18293)) - cd[260], address(this.address), 128, mem[_20745], mem[_20745 + 196 len ceil32(mem[_20745])]
                        else:
                            if stor2 != msg.sender:
                                revert with 0, 'Not authorized'
                            require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                            staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18388 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _18440 = mem[_18388]
                            require mem[_18388] == mem[_18388 + 18 len 14]
                            _18475 = mem[_18388 + 32]
                            require mem[_18388 + 32] == mem[_18388 + 50 len 14]
                            require mem[_18388 + 64] == mem[_18388 + 92 len 4]
                            require ext_code.size(address(_18288))
                            staticcall address(_18288).token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18550 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18576 = mem[_18550]
                            require mem[_18550] == mem[_18550 + 12 len 20]
                            require ext_code.size(address(_18288))
                            staticcall address(_18288).token1() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18628 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18635 = mem[_18628]
                            require mem[_18628] == mem[_18628 + 12 len 20]
                            if address(_18576) == address(_18315):
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18315))
                                staticcall address(_18315).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _18831 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_18831] < _18293:
                                    revert with 0, 'Refill _tokenIn amountIn'
                                if _18293 <= 0:
                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                if address(_18576) != address(_18315):
                                    if Mask(112, 0, _18475) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18440) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18293 and 998 > -1 / _18293:
                                        revert with 0, 17
                                    if 998 * _18293 / 998 != _18293:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18440):
                                        if Mask(112, 0, _18475) and 1000 > -1 / Mask(112, 0, _18475):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18475) / 1000 != Mask(112, 0, _18475):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18475) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18475)) + (998 * _18293) < 1000 * Mask(112, 0, _18475):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18475)) + (998 * _18293):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18635))
                                        call address(_18635).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20330 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20330] == bool(mem[_20330])
                                        _20538 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20538 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20538 + 36] = (0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260]
                                        mem[_20538 + 68] = 0
                                        mem[_20538 + 100] = this.address
                                        mem[_20538 + 132] = 128
                                        mem[_20538 + 164] = mem[_20538]
                                        s = 0
                                        while s < mem[_20538]:
                                            mem[s + _20538 + 196] = mem[_20538 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20538]) > mem[_20538]:
                                            mem[_20538 + mem[_20538] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260], 0, address(this.address), 128, mem[_20538], mem[_20538 + 196 len ceil32(mem[_20538])]
                                    else:
                                        if 998 * _18293 and Mask(112, 0, _18440) > -1 / 998 * _18293:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18440):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18440) / Mask(112, 0, _18440) != 998 * _18293:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18475) and 1000 > -1 / Mask(112, 0, _18475):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18475) / 1000 != Mask(112, 0, _18475):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18475) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18475)) + (998 * _18293) < 1000 * Mask(112, 0, _18475):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18475)) + (998 * _18293):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18635))
                                        call address(_18635).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20574 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20574] == bool(mem[_20574])
                                        _20747 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20747 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20747 + 36] = (998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260]
                                        mem[_20747 + 68] = 0
                                        mem[_20747 + 100] = this.address
                                        mem[_20747 + 132] = 128
                                        mem[_20747 + 164] = mem[_20747]
                                        s = 0
                                        while s < mem[_20747]:
                                            mem[s + _20747 + 196] = mem[_20747 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20747]) > mem[_20747]:
                                            mem[_20747 + mem[_20747] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260], 0, address(this.address), 128, mem[_20747], mem[_20747 + 196 len ceil32(mem[_20747])]
                                else:
                                    if Mask(112, 0, _18440) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18475) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18293 and 998 > -1 / _18293:
                                        revert with 0, 17
                                    if 998 * _18293 / 998 != _18293:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18475):
                                        if Mask(112, 0, _18440) and 1000 > -1 / Mask(112, 0, _18440):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18440) / 1000 != Mask(112, 0, _18440):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18440) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18440)) + (998 * _18293) < 1000 * Mask(112, 0, _18440):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18440)) + (998 * _18293):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18576))
                                        call address(_18576).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20331 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20331] == bool(mem[_20331])
                                        _20539 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20539 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20539 + 36] = 0
                                        mem[_20539 + 68] = (0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260]
                                        mem[_20539 + 100] = this.address
                                        mem[_20539 + 132] = 128
                                        mem[_20539 + 164] = mem[_20539]
                                        s = 0
                                        while s < mem[_20539]:
                                            mem[s + _20539 + 196] = mem[_20539 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20539]) > mem[_20539]:
                                            mem[_20539 + mem[_20539] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260], address(this.address), 128, mem[_20539], mem[_20539 + 196 len ceil32(mem[_20539])]
                                    else:
                                        if 998 * _18293 and Mask(112, 0, _18475) > -1 / 998 * _18293:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18475):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18475) / Mask(112, 0, _18475) != 998 * _18293:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18440) and 1000 > -1 / Mask(112, 0, _18440):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18440) / 1000 != Mask(112, 0, _18440):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18440) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18440)) + (998 * _18293) < 1000 * Mask(112, 0, _18440):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18440)) + (998 * _18293):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18576))
                                        call address(_18576).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20575 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20575] == bool(mem[_20575])
                                        _20749 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20749 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20749 + 36] = 0
                                        mem[_20749 + 68] = (998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260]
                                        mem[_20749 + 100] = this.address
                                        mem[_20749 + 132] = 128
                                        mem[_20749 + 164] = mem[_20749]
                                        s = 0
                                        while s < mem[_20749]:
                                            mem[s + _20749 + 196] = mem[_20749 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20749]) > mem[_20749]:
                                            mem[_20749 + mem[_20749] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260], address(this.address), 128, mem[_20749], mem[_20749 + 196 len ceil32(mem[_20749])]
                            else:
                                if mem[_18628 + 12 len 20] != address(_18315):
                                    revert with 0, 'Check pair address'
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18315))
                                staticcall address(_18315).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _18861 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_18861] < _18293:
                                    revert with 0, 'Refill _tokenIn amountIn'
                                if _18293 <= 0:
                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                if address(_18576) != address(_18315):
                                    if Mask(112, 0, _18475) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18440) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18293 and 998 > -1 / _18293:
                                        revert with 0, 17
                                    if 998 * _18293 / 998 != _18293:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18440):
                                        if Mask(112, 0, _18475) and 1000 > -1 / Mask(112, 0, _18475):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18475) / 1000 != Mask(112, 0, _18475):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18475) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18475)) + (998 * _18293) < 1000 * Mask(112, 0, _18475):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18475)) + (998 * _18293):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18635))
                                        call address(_18635).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20374 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20374] == bool(mem[_20374])
                                        _20576 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20576 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20576 + 36] = (0 / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260]
                                        mem[_20576 + 68] = 0
                                        mem[_20576 + 100] = this.address
                                        mem[_20576 + 132] = 128
                                        mem[_20576 + 164] = mem[_20576]
                                        s = 0
                                        while s < mem[_20576]:
                                            mem[s + _20576 + 196] = mem[_20576 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20576]) > mem[_20576]:
                                            mem[_20576 + mem[_20576] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20576]) + _20576 + -mem[64] + 192]
                                    else:
                                        if 998 * _18293 and Mask(112, 0, _18440) > -1 / 998 * _18293:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18440):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18440) / Mask(112, 0, _18440) != 998 * _18293:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18475) and 1000 > -1 / Mask(112, 0, _18475):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18475) / 1000 != Mask(112, 0, _18475):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18475) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18475)) + (998 * _18293) < 1000 * Mask(112, 0, _18475):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18475)) + (998 * _18293):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18635))
                                        call address(_18635).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20612 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20612] == bool(mem[_20612])
                                        _20785 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20785 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20785 + 36] = (998 * _18293 * Mask(112, 0, _18440) / (1000 * Mask(112, 0, _18475)) + (998 * _18293)) - cd[260]
                                        mem[_20785 + 68] = 0
                                        mem[_20785 + 100] = this.address
                                        mem[_20785 + 132] = 128
                                        mem[_20785 + 164] = mem[_20785]
                                        s = 0
                                        while s < mem[_20785]:
                                            mem[s + _20785 + 196] = mem[_20785 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20785]) > mem[_20785]:
                                            mem[_20785 + mem[_20785] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20785]) + _20785 + -mem[64] + 192]
                                else:
                                    if Mask(112, 0, _18440) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18475) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18293 and 998 > -1 / _18293:
                                        revert with 0, 17
                                    if 998 * _18293 / 998 != _18293:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18475):
                                        if Mask(112, 0, _18440) and 1000 > -1 / Mask(112, 0, _18440):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18440) / 1000 != Mask(112, 0, _18440):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18440) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18440)) + (998 * _18293) < 1000 * Mask(112, 0, _18440):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18440)) + (998 * _18293):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260] > 0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18576))
                                        call address(_18576).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20375 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20375] == bool(mem[_20375])
                                        _20577 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20577 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20577 + 36] = 0
                                        mem[_20577 + 68] = (0 / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260]
                                        mem[_20577 + 100] = this.address
                                        mem[_20577 + 132] = 128
                                        mem[_20577 + 164] = mem[_20577]
                                        s = 0
                                        while s < mem[_20577]:
                                            mem[s + _20577 + 196] = mem[_20577 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20577]) > mem[_20577]:
                                            mem[_20577 + mem[_20577] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20577]) + _20577 + -mem[64] + 192]
                                    else:
                                        if 998 * _18293 and Mask(112, 0, _18475) > -1 / 998 * _18293:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18475):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18475) / Mask(112, 0, _18475) != 998 * _18293:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18440) and 1000 > -1 / Mask(112, 0, _18440):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18440) / 1000 != Mask(112, 0, _18440):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18440) > !(998 * _18293):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18440)) + (998 * _18293) < 1000 * Mask(112, 0, _18440):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18440)) + (998 * _18293):
                                            revert with 0, 18
                                        if 998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260] > 998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18288)
                                        mem[mem[64] + 36] = _18293
                                        require ext_code.size(address(_18576))
                                        call address(_18576).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18288), _18293
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20613 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20613] == bool(mem[_20613])
                                        _20787 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20787 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20787 + 36] = 0
                                        mem[_20787 + 68] = (998 * _18293 * Mask(112, 0, _18475) / (1000 * Mask(112, 0, _18440)) + (998 * _18293)) - cd[260]
                                        mem[_20787 + 100] = this.address
                                        mem[_20787 + 132] = 128
                                        mem[_20787 + 164] = mem[_20787]
                                        s = 0
                                        while s < mem[_20787]:
                                            mem[s + _20787 + 196] = mem[_20787 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20787]) > mem[_20787]:
                                            mem[_20787 + mem[_20787] + 196] = 0
                                        require ext_code.size(address(_18288))
                                        call address(_18288).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20787]) + _20787 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    _18313 = mem[(32 * idx) + 128]
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    _18324 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                        revert with 0, 50
                    _18332 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131]
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100]:
                        revert with 0, 50
                    _18338 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 132]
                    if msg.sender == stor0:
                        if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                            revert with 0, 'Set router'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18324))
                        staticcall address(_18324).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18421 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18448 = mem[_18421]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18313))
                        staticcall address(_18313).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18485 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_18485] < _18293:
                            revert with 0, 'Refill amountIn'
                        mem[mem[64] + 4] = address(_18332)
                        mem[mem[64] + 36] = _18293
                        require ext_code.size(address(_18313))
                        call address(_18313).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(_18332), _18293
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18582 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_18582] == bool(mem[_18582])
                        if not address(_18338):
                            _18638 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_18638]:
                                revert with 0, 50
                            mem[_18638 + 32] = address(_18313)
                            if 1 >= mem[_18638]:
                                revert with 0, 50
                            mem[_18638 + 64] = address(_18324)
                            mem[_18638 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_18638 + 100] = _18293
                            mem[_18638 + 132] = cd[196]
                            mem[_18638 + 164] = 160
                            mem[_18638 + 260] = mem[_18638]
                            s = 0
                            t = _18638 + 32
                            u = _18638 + 292
                            while s < mem[_18638]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_18638 + 196] = address(cd[292])
                            mem[_18638 + 228] = block.timestamp
                            require ext_code.size(address(_18332))
                            call address(_18332).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _18638 + (32 * mem[_18638]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21187 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _21271 = mem[_21187]
                            require mem[_21187] <= test266151307()
                            require _21187 + return_data.size > _21187 + mem[_21187] + 31
                            _21307 = mem[_21187 + mem[_21187]]
                            if mem[_21187 + mem[_21187]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_21187 + mem[_21187]]) + 1 < 0 or _21187 + ceil32(return_data.size) + ceil32(32 * mem[_21187 + mem[_21187]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _21187 + ceil32(return_data.size) + ceil32(32 * mem[_21187 + mem[_21187]]) + 1
                            mem[_21187 + ceil32(return_data.size)] = _21307
                            require _21271 + (32 * _21307) + 32 <= return_data.size
                            t = _21187 + _21271 + 32
                            u = _21187 + ceil32(return_data.size) + 32
                            s = 0
                            while s < _21307:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
                            mem[mem[64] + 4] = address(_18332)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(_18313))
                            call address(_18313).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18332), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21811 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_21811] == bool(mem[_21811])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18324))
                            staticcall address(_18324).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21955 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_21955] < _18448:
                                revert with 0, 17
                        else:
                            if address(_18313) == address(_18338):
                                _18648 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18648]:
                                    revert with 0, 50
                                mem[_18648 + 32] = address(_18313)
                                if 1 >= mem[_18648]:
                                    revert with 0, 50
                                mem[_18648 + 64] = address(_18324)
                                mem[_18648 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18648 + 100] = _18293
                                mem[_18648 + 132] = cd[196]
                                mem[_18648 + 164] = 160
                                mem[_18648 + 260] = mem[_18648]
                                s = 0
                                t = _18648 + 32
                                u = _18648 + 292
                                while s < mem[_18648]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18648 + 196] = address(cd[292])
                                mem[_18648 + 228] = block.timestamp
                                require ext_code.size(address(_18332))
                                call address(_18332).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18648 + (32 * mem[_18648]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21184 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21268 = mem[_21184]
                                require mem[_21184] <= test266151307()
                                require _21184 + return_data.size > _21184 + mem[_21184] + 31
                                _21304 = mem[_21184 + mem[_21184]]
                                if mem[_21184 + mem[_21184]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21184 + mem[_21184]]) + 1 < 0 or _21184 + ceil32(return_data.size) + ceil32(32 * mem[_21184 + mem[_21184]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21184 + ceil32(return_data.size) + ceil32(32 * mem[_21184 + mem[_21184]]) + 1
                                mem[_21184 + ceil32(return_data.size)] = _21304
                                require _21268 + (32 * _21304) + 32 <= return_data.size
                                t = _21184 + _21268 + 32
                                u = _21184 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21304:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18332)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18313))
                                call address(_18313).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18332), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21808 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21808] == bool(mem[_21808])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18324))
                                staticcall address(_18324).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21952 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21952] < _18448:
                                    revert with 0, 17
                            else:
                                if address(_18324) == address(_18338):
                                    _18668 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_18668]:
                                        revert with 0, 50
                                    mem[_18668 + 32] = address(_18313)
                                    if 1 >= mem[_18668]:
                                        revert with 0, 50
                                    mem[_18668 + 64] = address(_18324)
                                    mem[_18668 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18668 + 100] = _18293
                                    mem[_18668 + 132] = cd[196]
                                    mem[_18668 + 164] = 160
                                    mem[_18668 + 260] = mem[_18668]
                                    s = 0
                                    t = _18668 + 32
                                    u = _18668 + 292
                                    while s < mem[_18668]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18668 + 196] = address(cd[292])
                                    mem[_18668 + 228] = block.timestamp
                                    require ext_code.size(address(_18332))
                                    call address(_18332).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18668 + (32 * mem[_18668]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21186 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21270 = mem[_21186]
                                    require mem[_21186] <= test266151307()
                                    require _21186 + return_data.size > _21186 + mem[_21186] + 31
                                    _21306 = mem[_21186 + mem[_21186]]
                                    if mem[_21186 + mem[_21186]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21186 + mem[_21186]]) + 1 < 0 or _21186 + ceil32(return_data.size) + ceil32(32 * mem[_21186 + mem[_21186]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21186 + ceil32(return_data.size) + ceil32(32 * mem[_21186 + mem[_21186]]) + 1
                                    mem[_21186 + ceil32(return_data.size)] = _21306
                                    require _21270 + (32 * _21306) + 32 <= return_data.size
                                    t = _21186 + _21270 + 32
                                    u = _21186 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21306:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18332)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18313))
                                    call address(_18313).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18332), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21810 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21810] == bool(mem[_21810])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18324))
                                    staticcall address(_18324).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21954 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21954] < _18448:
                                        revert with 0, 17
                                else:
                                    _18649 = mem[64]
                                    mem[mem[64]] = 3
                                    mem[64] = mem[64] + 128
                                    if 0 >= mem[_18649]:
                                        revert with 0, 50
                                    mem[_18649 + 32] = address(_18313)
                                    if 1 >= mem[_18649]:
                                        revert with 0, 50
                                    mem[_18649 + 64] = address(_18338)
                                    if 2 >= mem[_18649]:
                                        revert with 0, 50
                                    mem[_18649 + 96] = address(_18324)
                                    mem[_18649 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18649 + 132] = _18293
                                    mem[_18649 + 164] = cd[196]
                                    mem[_18649 + 196] = 160
                                    mem[_18649 + 292] = mem[_18649]
                                    s = 0
                                    t = _18649 + 32
                                    u = _18649 + 324
                                    while s < mem[_18649]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18649 + 228] = address(cd[292])
                                    mem[_18649 + 260] = block.timestamp
                                    require ext_code.size(address(_18332))
                                    call address(_18332).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18649 + (32 * mem[_18649]) + -mem[64] + 320]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21185 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21269 = mem[_21185]
                                    require mem[_21185] <= test266151307()
                                    require _21185 + return_data.size > _21185 + mem[_21185] + 31
                                    _21305 = mem[_21185 + mem[_21185]]
                                    if mem[_21185 + mem[_21185]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21185 + mem[_21185]]) + 1 < 0 or _21185 + ceil32(return_data.size) + ceil32(32 * mem[_21185 + mem[_21185]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21185 + ceil32(return_data.size) + ceil32(32 * mem[_21185 + mem[_21185]]) + 1
                                    mem[_21185 + ceil32(return_data.size)] = _21305
                                    require _21269 + (32 * _21305) + 32 <= return_data.size
                                    t = _21185 + _21269 + 32
                                    u = _21185 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21305:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18332)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18313))
                                    call address(_18313).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18332), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21809 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21809] == bool(mem[_21809])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18324))
                                    staticcall address(_18324).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21953 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21953] < _18448:
                                        revert with 0, 17
                    else:
                        if msg.sender == stor1:
                            if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                                revert with 0, 'Set router'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18324))
                            staticcall address(_18324).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18437 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18460 = mem[_18437]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18313))
                            staticcall address(_18313).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18497 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18497] < _18293:
                                revert with 0, 'Refill amountIn'
                            mem[mem[64] + 4] = address(_18332)
                            mem[mem[64] + 36] = _18293
                            require ext_code.size(address(_18313))
                            call address(_18313).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18332), _18293
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18589 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_18589] == bool(mem[_18589])
                            if not address(_18338):
                                _18641 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18641]:
                                    revert with 0, 50
                                mem[_18641 + 32] = address(_18313)
                                if 1 >= mem[_18641]:
                                    revert with 0, 50
                                mem[_18641 + 64] = address(_18324)
                                mem[_18641 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18641 + 100] = _18293
                                mem[_18641 + 132] = cd[196]
                                mem[_18641 + 164] = 160
                                mem[_18641 + 260] = mem[_18641]
                                s = 0
                                t = _18641 + 32
                                u = _18641 + 292
                                while s < mem[_18641]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18641 + 196] = address(cd[292])
                                mem[_18641 + 228] = block.timestamp
                                require ext_code.size(address(_18332))
                                call address(_18332).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18641 + (32 * mem[_18641]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21191 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21275 = mem[_21191]
                                require mem[_21191] <= test266151307()
                                require _21191 + return_data.size > _21191 + mem[_21191] + 31
                                _21311 = mem[_21191 + mem[_21191]]
                                if mem[_21191 + mem[_21191]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21191 + mem[_21191]]) + 1 < 0 or _21191 + ceil32(return_data.size) + ceil32(32 * mem[_21191 + mem[_21191]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21191 + ceil32(return_data.size) + ceil32(32 * mem[_21191 + mem[_21191]]) + 1
                                mem[_21191 + ceil32(return_data.size)] = _21311
                                require _21275 + (32 * _21311) + 32 <= return_data.size
                                t = _21191 + _21275 + 32
                                u = _21191 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21311:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18332)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18313))
                                call address(_18313).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18332), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21815 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21815] == bool(mem[_21815])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18324))
                                staticcall address(_18324).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21959 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21959] < _18460:
                                    revert with 0, 17
                            else:
                                if address(_18313) == address(_18338):
                                    _18670 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_18670]:
                                        revert with 0, 50
                                    mem[_18670 + 32] = address(_18313)
                                    if 1 >= mem[_18670]:
                                        revert with 0, 50
                                    mem[_18670 + 64] = address(_18324)
                                    mem[_18670 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18670 + 100] = _18293
                                    mem[_18670 + 132] = cd[196]
                                    mem[_18670 + 164] = 160
                                    mem[_18670 + 260] = mem[_18670]
                                    s = 0
                                    t = _18670 + 32
                                    u = _18670 + 292
                                    while s < mem[_18670]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18670 + 196] = address(cd[292])
                                    mem[_18670 + 228] = block.timestamp
                                    require ext_code.size(address(_18332))
                                    call address(_18332).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18670 + (32 * mem[_18670]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21188 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21272 = mem[_21188]
                                    require mem[_21188] <= test266151307()
                                    require _21188 + return_data.size > _21188 + mem[_21188] + 31
                                    _21308 = mem[_21188 + mem[_21188]]
                                    if mem[_21188 + mem[_21188]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21188 + mem[_21188]]) + 1 < 0 or _21188 + ceil32(return_data.size) + ceil32(32 * mem[_21188 + mem[_21188]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21188 + ceil32(return_data.size) + ceil32(32 * mem[_21188 + mem[_21188]]) + 1
                                    mem[_21188 + ceil32(return_data.size)] = _21308
                                    require _21272 + (32 * _21308) + 32 <= return_data.size
                                    t = _21188 + _21272 + 32
                                    u = _21188 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21308:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18332)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18313))
                                    call address(_18313).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18332), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21812 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21812] == bool(mem[_21812])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18324))
                                    staticcall address(_18324).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21956 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21956] < _18460:
                                        revert with 0, 17
                                else:
                                    if address(_18324) == address(_18338):
                                        _18702 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        if 0 >= mem[_18702]:
                                            revert with 0, 50
                                        mem[_18702 + 32] = address(_18313)
                                        if 1 >= mem[_18702]:
                                            revert with 0, 50
                                        mem[_18702 + 64] = address(_18324)
                                        mem[_18702 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_18702 + 100] = _18293
                                        mem[_18702 + 132] = cd[196]
                                        mem[_18702 + 164] = 160
                                        mem[_18702 + 260] = mem[_18702]
                                        s = 0
                                        t = _18702 + 32
                                        u = _18702 + 292
                                        while s < mem[_18702]:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_18702 + 196] = address(cd[292])
                                        mem[_18702 + 228] = block.timestamp
                                        require ext_code.size(address(_18332))
                                        call address(_18332).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _18702 + (32 * mem[_18702]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21190 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21274 = mem[_21190]
                                        require mem[_21190] <= test266151307()
                                        require _21190 + return_data.size > _21190 + mem[_21190] + 31
                                        _21310 = mem[_21190 + mem[_21190]]
                                        if mem[_21190 + mem[_21190]] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[_21190 + mem[_21190]]) + 1 < 0 or _21190 + ceil32(return_data.size) + ceil32(32 * mem[_21190 + mem[_21190]]) + 1 > test266151307():
                                            revert with 0, 65
                                        mem[64] = _21190 + ceil32(return_data.size) + ceil32(32 * mem[_21190 + mem[_21190]]) + 1
                                        mem[_21190 + ceil32(return_data.size)] = _21310
                                        require _21274 + (32 * _21310) + 32 <= return_data.size
                                        t = _21190 + _21274 + 32
                                        u = _21190 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _21310:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = address(_18332)
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(address(_18313))
                                        call address(_18313).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(_18332), 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21814 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21814] == bool(mem[_21814])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_18324))
                                        staticcall address(_18324).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21958 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_21958] < _18460:
                                            revert with 0, 17
                                    else:
                                        _18671 = mem[64]
                                        mem[mem[64]] = 3
                                        mem[64] = mem[64] + 128
                                        if 0 >= mem[_18671]:
                                            revert with 0, 50
                                        mem[_18671 + 32] = address(_18313)
                                        if 1 >= mem[_18671]:
                                            revert with 0, 50
                                        mem[_18671 + 64] = address(_18338)
                                        if 2 >= mem[_18671]:
                                            revert with 0, 50
                                        mem[_18671 + 96] = address(_18324)
                                        mem[_18671 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_18671 + 132] = _18293
                                        mem[_18671 + 164] = cd[196]
                                        mem[_18671 + 196] = 160
                                        mem[_18671 + 292] = mem[_18671]
                                        s = 0
                                        t = _18671 + 32
                                        u = _18671 + 324
                                        while s < mem[_18671]:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_18671 + 228] = address(cd[292])
                                        mem[_18671 + 260] = block.timestamp
                                        require ext_code.size(address(_18332))
                                        call address(_18332).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _18671 + (32 * mem[_18671]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21189 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21273 = mem[_21189]
                                        require mem[_21189] <= test266151307()
                                        require _21189 + return_data.size > _21189 + mem[_21189] + 31
                                        _21309 = mem[_21189 + mem[_21189]]
                                        if mem[_21189 + mem[_21189]] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[_21189 + mem[_21189]]) + 1 < 0 or _21189 + ceil32(return_data.size) + ceil32(32 * mem[_21189 + mem[_21189]]) + 1 > test266151307():
                                            revert with 0, 65
                                        mem[64] = _21189 + ceil32(return_data.size) + ceil32(32 * mem[_21189 + mem[_21189]]) + 1
                                        mem[_21189 + ceil32(return_data.size)] = _21309
                                        require _21273 + (32 * _21309) + 32 <= return_data.size
                                        t = _21189 + _21273 + 32
                                        u = _21189 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _21309:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = address(_18332)
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(address(_18313))
                                        call address(_18313).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(_18332), 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21813 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21813] == bool(mem[_21813])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_18324))
                                        staticcall address(_18324).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21957 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_21957] < _18460:
                                            revert with 0, 17
                        else:
                            if stor2 != msg.sender:
                                revert with 0, 'Not authorized'
                            if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                                revert with 0, 'Set router'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18324))
                            staticcall address(_18324).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18449 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18473 = mem[_18449]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18313))
                            staticcall address(_18313).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18510 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18510] < _18293:
                                revert with 0, 'Refill amountIn'
                            mem[mem[64] + 4] = address(_18332)
                            mem[mem[64] + 36] = _18293
                            require ext_code.size(address(_18313))
                            call address(_18313).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18332), _18293
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18600 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_18600] == bool(mem[_18600])
                            if not address(_18338):
                                _18652 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18652]:
                                    revert with 0, 50
                                mem[_18652 + 32] = address(_18313)
                                if 1 >= mem[_18652]:
                                    revert with 0, 50
                                mem[_18652 + 64] = address(_18324)
                                mem[_18652 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18652 + 100] = _18293
                                mem[_18652 + 132] = cd[196]
                                mem[_18652 + 164] = 160
                                mem[_18652 + 260] = mem[_18652]
                                s = 0
                                t = _18652 + 32
                                u = _18652 + 292
                                while s < mem[_18652]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18652 + 196] = address(cd[292])
                                mem[_18652 + 228] = block.timestamp
                                require ext_code.size(address(_18332))
                                call address(_18332).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18652 + (32 * mem[_18652]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21195 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21279 = mem[_21195]
                                require mem[_21195] <= test266151307()
                                require _21195 + return_data.size > _21195 + mem[_21195] + 31
                                _21315 = mem[_21195 + mem[_21195]]
                                if mem[_21195 + mem[_21195]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21195 + mem[_21195]]) + 1 < 0 or _21195 + ceil32(return_data.size) + ceil32(32 * mem[_21195 + mem[_21195]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21195 + ceil32(return_data.size) + ceil32(32 * mem[_21195 + mem[_21195]]) + 1
                                mem[_21195 + ceil32(return_data.size)] = _21315
                                require _21279 + (32 * _21315) + 32 <= return_data.size
                                t = _21195 + _21279 + 32
                                u = _21195 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21315:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18332)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18313))
                                call address(_18313).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18332), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21819 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21819] == bool(mem[_21819])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18324))
                                staticcall address(_18324).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21963 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21963] < _18473:
                                    revert with 0, 17
                            else:
                                if address(_18313) == address(_18338):
                                    _18704 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_18704]:
                                        revert with 0, 50
                                    mem[_18704 + 32] = address(_18313)
                                    if 1 >= mem[_18704]:
                                        revert with 0, 50
                                    mem[_18704 + 64] = address(_18324)
                                    mem[_18704 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18704 + 100] = _18293
                                    mem[_18704 + 132] = cd[196]
                                    mem[_18704 + 164] = 160
                                    mem[_18704 + 260] = mem[_18704]
                                    s = 0
                                    t = _18704 + 32
                                    u = _18704 + 292
                                    while s < mem[_18704]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18704 + 196] = address(cd[292])
                                    mem[_18704 + 228] = block.timestamp
                                    require ext_code.size(address(_18332))
                                    call address(_18332).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18704 + (32 * mem[_18704]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21192 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21276 = mem[_21192]
                                    require mem[_21192] <= test266151307()
                                    require _21192 + return_data.size > _21192 + mem[_21192] + 31
                                    _21312 = mem[_21192 + mem[_21192]]
                                    if mem[_21192 + mem[_21192]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21192 + mem[_21192]]) + 1 < 0 or _21192 + ceil32(return_data.size) + ceil32(32 * mem[_21192 + mem[_21192]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21192 + ceil32(return_data.size) + ceil32(32 * mem[_21192 + mem[_21192]]) + 1
                                    mem[_21192 + ceil32(return_data.size)] = _21312
                                    require _21276 + (32 * _21312) + 32 <= return_data.size
                                    t = _21192 + _21276 + 32
                                    u = _21192 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21312:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18332)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18313))
                                    call address(_18313).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18332), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21816 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21816] == bool(mem[_21816])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18324))
                                    staticcall address(_18324).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21960 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21960] < _18473:
                                        revert with 0, 17
                                else:
                                    if address(_18324) == address(_18338):
                                        _18748 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        if 0 >= mem[_18748]:
                                            revert with 0, 50
                                        mem[_18748 + 32] = address(_18313)
                                        if 1 >= mem[_18748]:
                                            revert with 0, 50
                                        mem[_18748 + 64] = address(_18324)
                                        mem[_18748 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_18748 + 100] = _18293
                                        mem[_18748 + 132] = cd[196]
                                        mem[_18748 + 164] = 160
                                        mem[_18748 + 260] = mem[_18748]
                                        s = 0
                                        t = _18748 + 32
                                        u = _18748 + 292
                                        while s < mem[_18748]:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_18748 + 196] = address(cd[292])
                                        mem[_18748 + 228] = block.timestamp
                                        require ext_code.size(address(_18332))
                                        call address(_18332).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _18748 + (32 * mem[_18748]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21194 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21278 = mem[_21194]
                                        require mem[_21194] <= test266151307()
                                        require _21194 + return_data.size > _21194 + mem[_21194] + 31
                                        _21314 = mem[_21194 + mem[_21194]]
                                        if mem[_21194 + mem[_21194]] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[_21194 + mem[_21194]]) + 1 < 0 or _21194 + ceil32(return_data.size) + ceil32(32 * mem[_21194 + mem[_21194]]) + 1 > test266151307():
                                            revert with 0, 65
                                        mem[64] = _21194 + ceil32(return_data.size) + ceil32(32 * mem[_21194 + mem[_21194]]) + 1
                                        mem[_21194 + ceil32(return_data.size)] = _21314
                                        require _21278 + (32 * _21314) + 32 <= return_data.size
                                        t = _21194 + _21278 + 32
                                        u = _21194 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _21314:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = address(_18332)
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(address(_18313))
                                        call address(_18313).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(_18332), 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21818 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21818] == bool(mem[_21818])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_18324))
                                        staticcall address(_18324).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21962 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_21962] < _18473:
                                            revert with 0, 17
                                    else:
                                        _18705 = mem[64]
                                        mem[mem[64]] = 3
                                        mem[64] = mem[64] + 128
                                        if 0 >= mem[_18705]:
                                            revert with 0, 50
                                        mem[_18705 + 32] = address(_18313)
                                        if 1 >= mem[_18705]:
                                            revert with 0, 50
                                        mem[_18705 + 64] = address(_18338)
                                        if 2 >= mem[_18705]:
                                            revert with 0, 50
                                        mem[_18705 + 96] = address(_18324)
                                        mem[_18705 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_18705 + 132] = _18293
                                        mem[_18705 + 164] = cd[196]
                                        mem[_18705 + 196] = 160
                                        mem[_18705 + 292] = mem[_18705]
                                        s = 0
                                        t = _18705 + 32
                                        u = _18705 + 324
                                        while s < mem[_18705]:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_18705 + 228] = address(cd[292])
                                        mem[_18705 + 260] = block.timestamp
                                        require ext_code.size(address(_18332))
                                        call address(_18332).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _18705 + (32 * mem[_18705]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21193 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21277 = mem[_21193]
                                        require mem[_21193] <= test266151307()
                                        require _21193 + return_data.size > _21193 + mem[_21193] + 31
                                        _21313 = mem[_21193 + mem[_21193]]
                                        if mem[_21193 + mem[_21193]] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[_21193 + mem[_21193]]) + 1 < 0 or _21193 + ceil32(return_data.size) + ceil32(32 * mem[_21193 + mem[_21193]]) + 1 > test266151307():
                                            revert with 0, 65
                                        mem[64] = _21193 + ceil32(return_data.size) + ceil32(32 * mem[_21193 + mem[_21193]]) + 1
                                        mem[_21193 + ceil32(return_data.size)] = _21313
                                        require _21277 + (32 * _21313) + 32 <= return_data.size
                                        t = _21193 + _21277 + 32
                                        u = _21193 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _21313:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = address(_18332)
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(address(_18313))
                                        call address(_18313).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(_18332), 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21817 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21817] == bool(mem[_21817])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_18324))
                                        staticcall address(_18324).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21961 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_21961] < _18473:
                                            revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _18293
                s = _18288
                continue 
            if ('cd', 100).length < 1:
                revert with 0, 17
            if ('cd', 100).length - 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[64] + 4] = this.address
            require ext_code.size(mem[(32 * ('cd', 100).length - 1) + ceil32(32 * ('cd', 4).length) + 141 len 20])
            staticcall mem[(32 * ('cd', 100).length - 1) + ceil32(32 * ('cd', 4).length) + 141 len 20].0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _18331 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_18331] <= cd[228]:
                revert with 0, 'Check result'
            mem[mem[64]] = mem[_18331]
        else:
            if stor2 != msg.sender:
                revert with 0, 'Not authorized'
            if ('cd', 100).length != ('cd', 36).length:
                revert with 0, 'Check length1'
            if ('cd', 100).length != ('cd', 4).length:
                revert with 0, 'Check length2'
            if ('cd', 100).length != ('cd', 164).length:
                revert with 0, 'Check length3'
            idx = 0
            s = 0
            s = 0
            while idx < ('cd', 100).length:
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 98]:
                    revert with 0, 50
                _18290 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 130]
                if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 101]:
                    revert with 0, 50
                _18294 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + ceil32(32 * ('cd', 132).length) + 133]
                if idx >= mem[96]:
                    revert with 0, 50
                if mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20]:
                    _18321 = mem[(32 * idx) + 128]
                    if msg.sender == stor0:
                        require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                        staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                                gas gas_remaining wei
                        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18366 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _18414 = mem[_18366]
                        require mem[_18366] == mem[_18366 + 18 len 14]
                        _18453 = mem[_18366 + 32]
                        require mem[_18366 + 32] == mem[_18366 + 50 len 14]
                        require mem[_18366 + 64] == mem[_18366 + 92 len 4]
                        require ext_code.size(address(_18290))
                        staticcall address(_18290).token0() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18526 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18554 = mem[_18526]
                        require mem[_18526] == mem[_18526 + 12 len 20]
                        require ext_code.size(address(_18290))
                        staticcall address(_18290).token1() with:
                                gas gas_remaining wei
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18616 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18629 = mem[_18616]
                        require mem[_18616] == mem[_18616 + 12 len 20]
                        if address(_18554) == address(_18321):
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18321))
                            staticcall address(_18321).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18765 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18765] < _18294:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _18294 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_18554) != address(_18321):
                                if Mask(112, 0, _18453) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18414) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18294 and 998 > -1 / _18294:
                                    revert with 0, 17
                                if 998 * _18294 / 998 != _18294:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18414):
                                    if Mask(112, 0, _18453) and 1000 > -1 / Mask(112, 0, _18453):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18453) / 1000 != Mask(112, 0, _18453):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18453) > !(998 * _18294):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18453)) + (998 * _18294) < 1000 * Mask(112, 0, _18453):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18453)) + (998 * _18294):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18290)
                                    mem[mem[64] + 36] = _18294
                                    require ext_code.size(address(_18629))
                                    call address(_18629).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18290), _18294
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20278 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20278] == bool(mem[_20278])
                                    _20480 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20480 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20480 + 36] = (0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260]
                                    mem[_20480 + 68] = 0
                                    mem[_20480 + 100] = this.address
                                    mem[_20480 + 132] = 128
                                    mem[_20480 + 164] = mem[_20480]
                                    s = 0
                                    while s < mem[_20480]:
                                        mem[s + _20480 + 196] = mem[_20480 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20480]) > mem[_20480]:
                                        mem[_20480 + mem[_20480] + 196] = 0
                                    require ext_code.size(address(_18290))
                                    call address(_18290).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20480]) + _20480 + -mem[64] + 192]
                                else:
                                    if 998 * _18294 and Mask(112, 0, _18414) > -1 / 998 * _18294:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18414):
                                        revert with 0, 18
                                    if 998 * _18294 * Mask(112, 0, _18414) / Mask(112, 0, _18414) != 998 * _18294:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18453) and 1000 > -1 / Mask(112, 0, _18453):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18453) / 1000 != Mask(112, 0, _18453):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18453) > !(998 * _18294):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18453)) + (998 * _18294) < 1000 * Mask(112, 0, _18453):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18453)) + (998 * _18294):
                                        revert with 0, 18
                                    if 998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18290)
                                    mem[mem[64] + 36] = _18294
                                    require ext_code.size(address(_18629))
                                    call address(_18629).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18290), _18294
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20508 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20508] == bool(mem[_20508])
                                    _20687 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20687 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20687 + 36] = (998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260]
                                    mem[_20687 + 68] = 0
                                    mem[_20687 + 100] = this.address
                                    mem[_20687 + 132] = 128
                                    mem[_20687 + 164] = mem[_20687]
                                    s = 0
                                    while s < mem[_20687]:
                                        mem[s + _20687 + 196] = mem[_20687 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20687]) > mem[_20687]:
                                        mem[_20687 + mem[_20687] + 196] = 0
                                    require ext_code.size(address(_18290))
                                    call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260], 0, address(this.address), 128, mem[_20687], mem[_20687 + 196 len ceil32(mem[_20687])]
                            else:
                                if Mask(112, 0, _18414) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18453) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18294 and 998 > -1 / _18294:
                                    revert with 0, 17
                                if 998 * _18294 / 998 != _18294:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18453):
                                    if Mask(112, 0, _18414) and 1000 > -1 / Mask(112, 0, _18414):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18414) / 1000 != Mask(112, 0, _18414):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18414) > !(998 * _18294):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18414)) + (998 * _18294) < 1000 * Mask(112, 0, _18414):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18414)) + (998 * _18294):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18290)
                                    mem[mem[64] + 36] = _18294
                                    require ext_code.size(address(_18554))
                                    call address(_18554).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18290), _18294
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20279 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20279] == bool(mem[_20279])
                                    _20481 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20481 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20481 + 36] = 0
                                    mem[_20481 + 68] = (0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260]
                                    mem[_20481 + 100] = this.address
                                    mem[_20481 + 132] = 128
                                    mem[_20481 + 164] = mem[_20481]
                                    s = 0
                                    while s < mem[_20481]:
                                        mem[s + _20481 + 196] = mem[_20481 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20481]) > mem[_20481]:
                                        mem[_20481 + mem[_20481] + 196] = 0
                                    require ext_code.size(address(_18290))
                                    call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260], address(this.address), 128, mem[_20481], mem[_20481 + 196 len ceil32(mem[_20481])]
                                else:
                                    if 998 * _18294 and Mask(112, 0, _18453) > -1 / 998 * _18294:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18453):
                                        revert with 0, 18
                                    if 998 * _18294 * Mask(112, 0, _18453) / Mask(112, 0, _18453) != 998 * _18294:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18414) and 1000 > -1 / Mask(112, 0, _18414):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18414) / 1000 != Mask(112, 0, _18414):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18414) > !(998 * _18294):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18414)) + (998 * _18294) < 1000 * Mask(112, 0, _18414):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18414)) + (998 * _18294):
                                        revert with 0, 18
                                    if 998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18290)
                                    mem[mem[64] + 36] = _18294
                                    require ext_code.size(address(_18554))
                                    call address(_18554).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18290), _18294
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20509 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20509] == bool(mem[_20509])
                                    _20689 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20689 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20689 + 36] = 0
                                    mem[_20689 + 68] = (998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260]
                                    mem[_20689 + 100] = this.address
                                    mem[_20689 + 132] = 128
                                    mem[_20689 + 164] = mem[_20689]
                                    s = 0
                                    while s < mem[_20689]:
                                        mem[s + _20689 + 196] = mem[_20689 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20689]) > mem[_20689]:
                                        mem[_20689 + mem[_20689] + 196] = 0
                                    require ext_code.size(address(_18290))
                                    call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260], address(this.address), 128, mem[_20689], mem[_20689 + 196 len ceil32(mem[_20689])]
                        else:
                            if mem[_18616 + 12 len 20] != address(_18321):
                                revert with 0, 'Check pair address'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18321))
                            staticcall address(_18321).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18805 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18805] < _18294:
                                revert with 0, 'Refill _tokenIn amountIn'
                            if _18294 <= 0:
                                revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                            if address(_18554) != address(_18321):
                                if Mask(112, 0, _18453) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18414) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18294 and 998 > -1 / _18294:
                                    revert with 0, 17
                                if 998 * _18294 / 998 != _18294:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18414):
                                    if Mask(112, 0, _18453) and 1000 > -1 / Mask(112, 0, _18453):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18453) / 1000 != Mask(112, 0, _18453):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18453) > !(998 * _18294):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18453)) + (998 * _18294) < 1000 * Mask(112, 0, _18453):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18453)) + (998 * _18294):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18290)
                                    mem[mem[64] + 36] = _18294
                                    require ext_code.size(address(_18629))
                                    call address(_18629).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18290), _18294
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20302 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20302] == bool(mem[_20302])
                                    _20510 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20510 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20510 + 36] = (0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260]
                                    mem[_20510 + 68] = 0
                                    mem[_20510 + 100] = this.address
                                    mem[_20510 + 132] = 128
                                    mem[_20510 + 164] = mem[_20510]
                                    s = 0
                                    while s < mem[_20510]:
                                        mem[s + _20510 + 196] = mem[_20510 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20510]) > mem[_20510]:
                                        mem[_20510 + mem[_20510] + 196] = 0
                                    require ext_code.size(address(_18290))
                                    call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (0 / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260], 0, address(this.address), 128, mem[_20510], mem[_20510 + 196 len ceil32(mem[_20510])]
                                else:
                                    if 998 * _18294 and Mask(112, 0, _18414) > -1 / 998 * _18294:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18414):
                                        revert with 0, 18
                                    if 998 * _18294 * Mask(112, 0, _18414) / Mask(112, 0, _18414) != 998 * _18294:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18453) and 1000 > -1 / Mask(112, 0, _18453):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18453) / 1000 != Mask(112, 0, _18453):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18453) > !(998 * _18294):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18453)) + (998 * _18294) < 1000 * Mask(112, 0, _18453):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18453)) + (998 * _18294):
                                        revert with 0, 18
                                    if 998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18290)
                                    mem[mem[64] + 36] = _18294
                                    require ext_code.size(address(_18629))
                                    call address(_18629).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18290), _18294
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20544 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20544] == bool(mem[_20544])
                                    _20715 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20715 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20715 + 36] = (998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260]
                                    mem[_20715 + 68] = 0
                                    mem[_20715 + 100] = this.address
                                    mem[_20715 + 132] = 128
                                    mem[_20715 + 164] = mem[_20715]
                                    s = 0
                                    while s < mem[_20715]:
                                        mem[s + _20715 + 196] = mem[_20715 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20715]) > mem[_20715]:
                                        mem[_20715 + mem[_20715] + 196] = 0
                                    require ext_code.size(address(_18290))
                                    call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args (998 * _18294 * Mask(112, 0, _18414) / (1000 * Mask(112, 0, _18453)) + (998 * _18294)) - cd[260], 0, address(this.address), 128, mem[_20715], mem[_20715 + 196 len ceil32(mem[_20715])]
                            else:
                                if Mask(112, 0, _18414) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if Mask(112, 0, _18453) <= 0:
                                    revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                if _18294 and 998 > -1 / _18294:
                                    revert with 0, 17
                                if 998 * _18294 / 998 != _18294:
                                    revert with 0, 'MUL error'
                                if not Mask(112, 0, _18453):
                                    if Mask(112, 0, _18414) and 1000 > -1 / Mask(112, 0, _18414):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18414) / 1000 != Mask(112, 0, _18414):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18414) > !(998 * _18294):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18414)) + (998 * _18294) < 1000 * Mask(112, 0, _18414):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18414)) + (998 * _18294):
                                        revert with 0, 18
                                    if 0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294) < cd[260]:
                                        revert with 0, 17
                                    if (0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18290)
                                    mem[mem[64] + 36] = _18294
                                    require ext_code.size(address(_18554))
                                    call address(_18554).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18290), _18294
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20303 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20303] == bool(mem[_20303])
                                    _20511 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20511 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20511 + 36] = 0
                                    mem[_20511 + 68] = (0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260]
                                    mem[_20511 + 100] = this.address
                                    mem[_20511 + 132] = 128
                                    mem[_20511 + 164] = mem[_20511]
                                    s = 0
                                    while s < mem[_20511]:
                                        mem[s + _20511 + 196] = mem[_20511 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20511]) > mem[_20511]:
                                        mem[_20511 + mem[_20511] + 196] = 0
                                    require ext_code.size(address(_18290))
                                    call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                         gas gas_remaining wei
                                        args 0, (0 / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260], address(this.address), 128, mem[_20511], mem[_20511 + 196 len ceil32(mem[_20511])]
                                else:
                                    if 998 * _18294 and Mask(112, 0, _18453) > -1 / 998 * _18294:
                                        revert with 0, 17
                                    if not Mask(112, 0, _18453):
                                        revert with 0, 18
                                    if 998 * _18294 * Mask(112, 0, _18453) / Mask(112, 0, _18453) != 998 * _18294:
                                        revert with 0, 'MUL error'
                                    if Mask(112, 0, _18414) and 1000 > -1 / Mask(112, 0, _18414):
                                        revert with 0, 17
                                    if 1000 * Mask(112, 0, _18414) / 1000 != Mask(112, 0, _18414):
                                        revert with 0, 'MUL error'
                                    if 1000 * Mask(112, 0, _18414) > !(998 * _18294):
                                        revert with 0, 17
                                    if (1000 * Mask(112, 0, _18414)) + (998 * _18294) < 1000 * Mask(112, 0, _18414):
                                        revert with 0, 'Add error'
                                    if not (1000 * Mask(112, 0, _18414)) + (998 * _18294):
                                        revert with 0, 18
                                    if 998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294) < cd[260]:
                                        revert with 0, 17
                                    if (998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294):
                                        revert with 0, 'SUB error'
                                    mem[mem[64] + 4] = address(_18290)
                                    mem[mem[64] + 36] = _18294
                                    require ext_code.size(address(_18554))
                                    call address(_18554).0xa9059cbb with:
                                         gas gas_remaining wei
                                        args address(_18290), _18294
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _20545 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_20545] == bool(mem[_20545])
                                    _20717 = mem[64]
                                    mem[mem[64]] = 0
                                    mem[64] = mem[64] + 32
                                    mem[_20717 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                    mem[_20717 + 36] = 0
                                    mem[_20717 + 68] = (998 * _18294 * Mask(112, 0, _18453) / (1000 * Mask(112, 0, _18414)) + (998 * _18294)) - cd[260]
                                    mem[_20717 + 100] = this.address
                                    mem[_20717 + 132] = 128
                                    mem[_20717 + 164] = mem[_20717]
                                    s = 0
                                    while s < mem[_20717]:
                                        mem[s + _20717 + 196] = mem[_20717 + s + 32]
                                        s = s + 32
                                        continue 
                                    if ceil32(mem[_20717]) > mem[_20717]:
                                        mem[_20717 + mem[_20717] + 196] = 0
                                    require ext_code.size(address(_18290))
                                    call address(_18290).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len ceil32(mem[_20717]) + _20717 + -mem[64] + 192]
                    else:
                        if msg.sender == stor1:
                            require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                            staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18375 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _18432 = mem[_18375]
                            require mem[_18375] == mem[_18375 + 18 len 14]
                            _18465 = mem[_18375 + 32]
                            require mem[_18375 + 32] == mem[_18375 + 50 len 14]
                            require mem[_18375 + 64] == mem[_18375 + 92 len 4]
                            require ext_code.size(address(_18290))
                            staticcall address(_18290).token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18540 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18570 = mem[_18540]
                            require mem[_18540] == mem[_18540 + 12 len 20]
                            require ext_code.size(address(_18290))
                            staticcall address(_18290).token1() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18624 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18633 = mem[_18624]
                            require mem[_18624] == mem[_18624 + 12 len 20]
                            if address(_18570) == address(_18321):
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18321))
                                staticcall address(_18321).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _18806 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_18806] < _18294:
                                    revert with 0, 'Refill _tokenIn amountIn'
                                if _18294 <= 0:
                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                if address(_18570) != address(_18321):
                                    if Mask(112, 0, _18465) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18432) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18294 and 998 > -1 / _18294:
                                        revert with 0, 17
                                    if 998 * _18294 / 998 != _18294:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18432):
                                        if Mask(112, 0, _18465) and 1000 > -1 / Mask(112, 0, _18465):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18465) / 1000 != Mask(112, 0, _18465):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18465) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18465)) + (998 * _18294) < 1000 * Mask(112, 0, _18465):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18465)) + (998 * _18294):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18465)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18465)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18633))
                                        call address(_18633).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20304 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20304] == bool(mem[_20304])
                                        _20512 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20512 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20512 + 36] = (0 / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260]
                                        mem[_20512 + 68] = 0
                                        mem[_20512 + 100] = this.address
                                        mem[_20512 + 132] = 128
                                        mem[_20512 + 164] = mem[_20512]
                                        s = 0
                                        while s < mem[_20512]:
                                            mem[s + _20512 + 196] = mem[_20512 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20512]) > mem[_20512]:
                                            mem[_20512 + mem[_20512] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20512]) + _20512 + -mem[64] + 192]
                                    else:
                                        if 998 * _18294 and Mask(112, 0, _18432) > -1 / 998 * _18294:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18432):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18432) / Mask(112, 0, _18432) != 998 * _18294:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18465) and 1000 > -1 / Mask(112, 0, _18465):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18465) / 1000 != Mask(112, 0, _18465):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18465) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18465)) + (998 * _18294) < 1000 * Mask(112, 0, _18465):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18465)) + (998 * _18294):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18633))
                                        call address(_18633).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20546 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20546] == bool(mem[_20546])
                                        _20719 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20719 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20719 + 36] = (998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260]
                                        mem[_20719 + 68] = 0
                                        mem[_20719 + 100] = this.address
                                        mem[_20719 + 132] = 128
                                        mem[_20719 + 164] = mem[_20719]
                                        s = 0
                                        while s < mem[_20719]:
                                            mem[s + _20719 + 196] = mem[_20719 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20719]) > mem[_20719]:
                                            mem[_20719 + mem[_20719] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20719]) + _20719 + -mem[64] + 192]
                                else:
                                    if Mask(112, 0, _18432) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18465) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18294 and 998 > -1 / _18294:
                                        revert with 0, 17
                                    if 998 * _18294 / 998 != _18294:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18465):
                                        if Mask(112, 0, _18432) and 1000 > -1 / Mask(112, 0, _18432):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18432) / 1000 != Mask(112, 0, _18432):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18432) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18432)) + (998 * _18294) < 1000 * Mask(112, 0, _18432):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18432)) + (998 * _18294):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18570))
                                        call address(_18570).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20305 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20305] == bool(mem[_20305])
                                        _20513 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20513 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20513 + 36] = 0
                                        mem[_20513 + 68] = (0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260]
                                        mem[_20513 + 100] = this.address
                                        mem[_20513 + 132] = 128
                                        mem[_20513 + 164] = mem[_20513]
                                        s = 0
                                        while s < mem[_20513]:
                                            mem[s + _20513 + 196] = mem[_20513 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20513]) > mem[_20513]:
                                            mem[_20513 + mem[_20513] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20513]) + _20513 + -mem[64] + 192]
                                    else:
                                        if 998 * _18294 and Mask(112, 0, _18465) > -1 / 998 * _18294:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18465):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18465) / Mask(112, 0, _18465) != 998 * _18294:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18432) and 1000 > -1 / Mask(112, 0, _18432):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18432) / 1000 != Mask(112, 0, _18432):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18432) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18432)) + (998 * _18294) < 1000 * Mask(112, 0, _18432):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18432)) + (998 * _18294):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18570))
                                        call address(_18570).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20547 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20547] == bool(mem[_20547])
                                        _20721 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20721 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20721 + 36] = 0
                                        mem[_20721 + 68] = (998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260]
                                        mem[_20721 + 100] = this.address
                                        mem[_20721 + 132] = 128
                                        mem[_20721 + 164] = mem[_20721]
                                        s = 0
                                        while s < mem[_20721]:
                                            mem[s + _20721 + 196] = mem[_20721 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20721]) > mem[_20721]:
                                            mem[_20721 + mem[_20721] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20721]) + _20721 + -mem[64] + 192]
                            else:
                                if mem[_18624 + 12 len 20] != address(_18321):
                                    revert with 0, 'Check pair address'
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18321))
                                staticcall address(_18321).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _18841 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_18841] < _18294:
                                    revert with 0, 'Refill _tokenIn amountIn'
                                if _18294 <= 0:
                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                if address(_18570) != address(_18321):
                                    if Mask(112, 0, _18465) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18432) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18294 and 998 > -1 / _18294:
                                        revert with 0, 17
                                    if 998 * _18294 / 998 != _18294:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18432):
                                        if Mask(112, 0, _18465) and 1000 > -1 / Mask(112, 0, _18465):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18465) / 1000 != Mask(112, 0, _18465):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18465) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18465)) + (998 * _18294) < 1000 * Mask(112, 0, _18465):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18465)) + (998 * _18294):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18465)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18465)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18633))
                                        call address(_18633).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20340 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20340] == bool(mem[_20340])
                                        _20548 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20548 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20548 + 36] = (0 / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260]
                                        mem[_20548 + 68] = 0
                                        mem[_20548 + 100] = this.address
                                        mem[_20548 + 132] = 128
                                        mem[_20548 + 164] = mem[_20548]
                                        s = 0
                                        while s < mem[_20548]:
                                            mem[s + _20548 + 196] = mem[_20548 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20548]) > mem[_20548]:
                                            mem[_20548 + mem[_20548] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20548]) + _20548 + -mem[64] + 192]
                                    else:
                                        if 998 * _18294 and Mask(112, 0, _18432) > -1 / 998 * _18294:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18432):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18432) / Mask(112, 0, _18432) != 998 * _18294:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18465) and 1000 > -1 / Mask(112, 0, _18465):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18465) / 1000 != Mask(112, 0, _18465):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18465) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18465)) + (998 * _18294) < 1000 * Mask(112, 0, _18465):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18465)) + (998 * _18294):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18633))
                                        call address(_18633).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20584 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20584] == bool(mem[_20584])
                                        _20757 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20757 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20757 + 36] = (998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260]
                                        mem[_20757 + 68] = 0
                                        mem[_20757 + 100] = this.address
                                        mem[_20757 + 132] = 128
                                        mem[_20757 + 164] = mem[_20757]
                                        s = 0
                                        while s < mem[_20757]:
                                            mem[s + _20757 + 196] = mem[_20757 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20757]) > mem[_20757]:
                                            mem[_20757 + mem[_20757] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (998 * _18294 * Mask(112, 0, _18432) / (1000 * Mask(112, 0, _18465)) + (998 * _18294)) - cd[260], 0, address(this.address), 128, mem[_20757], mem[_20757 + 196 len ceil32(mem[_20757])]
                                else:
                                    if Mask(112, 0, _18432) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18465) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18294 and 998 > -1 / _18294:
                                        revert with 0, 17
                                    if 998 * _18294 / 998 != _18294:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18465):
                                        if Mask(112, 0, _18432) and 1000 > -1 / Mask(112, 0, _18432):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18432) / 1000 != Mask(112, 0, _18432):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18432) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18432)) + (998 * _18294) < 1000 * Mask(112, 0, _18432):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18432)) + (998 * _18294):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18570))
                                        call address(_18570).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20341 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20341] == bool(mem[_20341])
                                        _20549 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20549 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20549 + 36] = 0
                                        mem[_20549 + 68] = (0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260]
                                        mem[_20549 + 100] = this.address
                                        mem[_20549 + 132] = 128
                                        mem[_20549 + 164] = mem[_20549]
                                        s = 0
                                        while s < mem[_20549]:
                                            mem[s + _20549 + 196] = mem[_20549 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20549]) > mem[_20549]:
                                            mem[_20549 + mem[_20549] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (0 / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260], address(this.address), 128, mem[_20549], mem[_20549 + 196 len ceil32(mem[_20549])]
                                    else:
                                        if 998 * _18294 and Mask(112, 0, _18465) > -1 / 998 * _18294:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18465):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18465) / Mask(112, 0, _18465) != 998 * _18294:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18432) and 1000 > -1 / Mask(112, 0, _18432):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18432) / 1000 != Mask(112, 0, _18432):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18432) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18432)) + (998 * _18294) < 1000 * Mask(112, 0, _18432):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18432)) + (998 * _18294):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18570))
                                        call address(_18570).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20585 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20585] == bool(mem[_20585])
                                        _20759 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20759 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20759 + 36] = 0
                                        mem[_20759 + 68] = (998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260]
                                        mem[_20759 + 100] = this.address
                                        mem[_20759 + 132] = 128
                                        mem[_20759 + 164] = mem[_20759]
                                        s = 0
                                        while s < mem[_20759]:
                                            mem[s + _20759 + 196] = mem[_20759 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20759]) > mem[_20759]:
                                            mem[_20759 + mem[_20759] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (998 * _18294 * Mask(112, 0, _18465) / (1000 * Mask(112, 0, _18432)) + (998 * _18294)) - cd[260], address(this.address), 128, mem[_20759], mem[_20759 + 196 len ceil32(mem[_20759])]
                        else:
                            if stor2 != msg.sender:
                                revert with 0, 'Not authorized'
                            require ext_code.size(mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20])
                            staticcall mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + 142 len 20].getReserves() with:
                                    gas gas_remaining wei
                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18395 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 96
                            _18444 = mem[_18395]
                            require mem[_18395] == mem[_18395 + 18 len 14]
                            _18480 = mem[_18395 + 32]
                            require mem[_18395 + 32] == mem[_18395 + 50 len 14]
                            require mem[_18395 + 64] == mem[_18395 + 92 len 4]
                            require ext_code.size(address(_18290))
                            staticcall address(_18290).token0() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18555 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18579 = mem[_18555]
                            require mem[_18555] == mem[_18555 + 12 len 20]
                            require ext_code.size(address(_18290))
                            staticcall address(_18290).token1() with:
                                    gas gas_remaining wei
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18630 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18636 = mem[_18630]
                            require mem[_18630] == mem[_18630 + 12 len 20]
                            if address(_18579) == address(_18321):
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18321))
                                staticcall address(_18321).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _18842 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_18842] < _18294:
                                    revert with 0, 'Refill _tokenIn amountIn'
                                if _18294 <= 0:
                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                if address(_18579) != address(_18321):
                                    if Mask(112, 0, _18480) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18444) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18294 and 998 > -1 / _18294:
                                        revert with 0, 17
                                    if 998 * _18294 / 998 != _18294:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18444):
                                        if Mask(112, 0, _18480) and 1000 > -1 / Mask(112, 0, _18480):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18480) / 1000 != Mask(112, 0, _18480):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18480) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18480)) + (998 * _18294) < 1000 * Mask(112, 0, _18480):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18480)) + (998 * _18294):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18636))
                                        call address(_18636).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20342 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20342] == bool(mem[_20342])
                                        _20550 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20550 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20550 + 36] = (0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260]
                                        mem[_20550 + 68] = 0
                                        mem[_20550 + 100] = this.address
                                        mem[_20550 + 132] = 128
                                        mem[_20550 + 164] = mem[_20550]
                                        s = 0
                                        while s < mem[_20550]:
                                            mem[s + _20550 + 196] = mem[_20550 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20550]) > mem[_20550]:
                                            mem[_20550 + mem[_20550] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20550]) + _20550 + -mem[64] + 192]
                                    else:
                                        if 998 * _18294 and Mask(112, 0, _18444) > -1 / 998 * _18294:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18444):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18444) / Mask(112, 0, _18444) != 998 * _18294:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18480) and 1000 > -1 / Mask(112, 0, _18480):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18480) / 1000 != Mask(112, 0, _18480):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18480) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18480)) + (998 * _18294) < 1000 * Mask(112, 0, _18480):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18480)) + (998 * _18294):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18636))
                                        call address(_18636).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20586 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20586] == bool(mem[_20586])
                                        _20761 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20761 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20761 + 36] = (998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260]
                                        mem[_20761 + 68] = 0
                                        mem[_20761 + 100] = this.address
                                        mem[_20761 + 132] = 128
                                        mem[_20761 + 164] = mem[_20761]
                                        s = 0
                                        while s < mem[_20761]:
                                            mem[s + _20761 + 196] = mem[_20761 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20761]) > mem[_20761]:
                                            mem[_20761 + mem[_20761] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260], 0, address(this.address), 128, mem[_20761], mem[_20761 + 196 len ceil32(mem[_20761])]
                                else:
                                    if Mask(112, 0, _18444) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18480) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18294 and 998 > -1 / _18294:
                                        revert with 0, 17
                                    if 998 * _18294 / 998 != _18294:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18480):
                                        if Mask(112, 0, _18444) and 1000 > -1 / Mask(112, 0, _18444):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18444) / 1000 != Mask(112, 0, _18444):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18444) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18444)) + (998 * _18294) < 1000 * Mask(112, 0, _18444):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18444)) + (998 * _18294):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18444)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18444)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18579))
                                        call address(_18579).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20343 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20343] == bool(mem[_20343])
                                        _20551 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20551 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20551 + 36] = 0
                                        mem[_20551 + 68] = (0 / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260]
                                        mem[_20551 + 100] = this.address
                                        mem[_20551 + 132] = 128
                                        mem[_20551 + 164] = mem[_20551]
                                        s = 0
                                        while s < mem[_20551]:
                                            mem[s + _20551 + 196] = mem[_20551 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20551]) > mem[_20551]:
                                            mem[_20551 + mem[_20551] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20551]) + _20551 + -mem[64] + 192]
                                    else:
                                        if 998 * _18294 and Mask(112, 0, _18480) > -1 / 998 * _18294:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18480):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18480) / Mask(112, 0, _18480) != 998 * _18294:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18444) and 1000 > -1 / Mask(112, 0, _18444):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18444) / 1000 != Mask(112, 0, _18444):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18444) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18444)) + (998 * _18294) < 1000 * Mask(112, 0, _18444):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18444)) + (998 * _18294):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18579))
                                        call address(_18579).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20587 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20587] == bool(mem[_20587])
                                        _20763 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20763 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20763 + 36] = 0
                                        mem[_20763 + 68] = (998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260]
                                        mem[_20763 + 100] = this.address
                                        mem[_20763 + 132] = 128
                                        mem[_20763 + 164] = mem[_20763]
                                        s = 0
                                        while s < mem[_20763]:
                                            mem[s + _20763 + 196] = mem[_20763 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20763]) > mem[_20763]:
                                            mem[_20763 + mem[_20763] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args 0, (998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260], address(this.address), 128, mem[_20763], mem[_20763 + 196 len ceil32(mem[_20763])]
                            else:
                                if mem[_18630 + 12 len 20] != address(_18321):
                                    revert with 0, 'Check pair address'
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18321))
                                staticcall address(_18321).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _18870 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_18870] < _18294:
                                    revert with 0, 'Refill _tokenIn amountIn'
                                if _18294 <= 0:
                                    revert with 0, 'INSUFFICIENT_INPUT_AMOUNT'
                                if address(_18579) != address(_18321):
                                    if Mask(112, 0, _18480) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18444) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18294 and 998 > -1 / _18294:
                                        revert with 0, 17
                                    if 998 * _18294 / 998 != _18294:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18444):
                                        if Mask(112, 0, _18480) and 1000 > -1 / Mask(112, 0, _18480):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18480) / 1000 != Mask(112, 0, _18480):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18480) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18480)) + (998 * _18294) < 1000 * Mask(112, 0, _18480):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18480)) + (998 * _18294):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18636))
                                        call address(_18636).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20390 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20390] == bool(mem[_20390])
                                        _20588 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20588 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20588 + 36] = (0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260]
                                        mem[_20588 + 68] = 0
                                        mem[_20588 + 100] = this.address
                                        mem[_20588 + 132] = 128
                                        mem[_20588 + 164] = mem[_20588]
                                        s = 0
                                        while s < mem[_20588]:
                                            mem[s + _20588 + 196] = mem[_20588 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20588]) > mem[_20588]:
                                            mem[_20588 + mem[_20588] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).swap(uint256 arg1, uint256 arg2, address arg3, bytes arg4) with:
                                             gas gas_remaining wei
                                            args (0 / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260], 0, address(this.address), 128, mem[_20588], mem[_20588 + 196 len ceil32(mem[_20588])]
                                    else:
                                        if 998 * _18294 and Mask(112, 0, _18444) > -1 / 998 * _18294:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18444):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18444) / Mask(112, 0, _18444) != 998 * _18294:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18480) and 1000 > -1 / Mask(112, 0, _18480):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18480) / 1000 != Mask(112, 0, _18480):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18480) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18480)) + (998 * _18294) < 1000 * Mask(112, 0, _18480):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18480)) + (998 * _18294):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18636))
                                        call address(_18636).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20624 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20624] == bool(mem[_20624])
                                        _20797 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20797 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20797 + 36] = (998 * _18294 * Mask(112, 0, _18444) / (1000 * Mask(112, 0, _18480)) + (998 * _18294)) - cd[260]
                                        mem[_20797 + 68] = 0
                                        mem[_20797 + 100] = this.address
                                        mem[_20797 + 132] = 128
                                        mem[_20797 + 164] = mem[_20797]
                                        s = 0
                                        while s < mem[_20797]:
                                            mem[s + _20797 + 196] = mem[_20797 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20797]) > mem[_20797]:
                                            mem[_20797 + mem[_20797] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20797]) + _20797 + -mem[64] + 192]
                                else:
                                    if Mask(112, 0, _18444) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if Mask(112, 0, _18480) <= 0:
                                        revert with 0, 'INSUFFICIENT_LIQUIDITY'
                                    if _18294 and 998 > -1 / _18294:
                                        revert with 0, 17
                                    if 998 * _18294 / 998 != _18294:
                                        revert with 0, 'MUL error'
                                    if not Mask(112, 0, _18480):
                                        if Mask(112, 0, _18444) and 1000 > -1 / Mask(112, 0, _18444):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18444) / 1000 != Mask(112, 0, _18444):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18444) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18444)) + (998 * _18294) < 1000 * Mask(112, 0, _18444):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18444)) + (998 * _18294):
                                            revert with 0, 18
                                        if 0 / (1000 * Mask(112, 0, _18444)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (0 / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260] > 0 / (1000 * Mask(112, 0, _18444)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18579))
                                        call address(_18579).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20391 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20391] == bool(mem[_20391])
                                        _20589 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20589 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20589 + 36] = 0
                                        mem[_20589 + 68] = (0 / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260]
                                        mem[_20589 + 100] = this.address
                                        mem[_20589 + 132] = 128
                                        mem[_20589 + 164] = mem[_20589]
                                        s = 0
                                        while s < mem[_20589]:
                                            mem[s + _20589 + 196] = mem[_20589 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20589]) > mem[_20589]:
                                            mem[_20589 + mem[_20589] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20589]) + _20589 + -mem[64] + 192]
                                    else:
                                        if 998 * _18294 and Mask(112, 0, _18480) > -1 / 998 * _18294:
                                            revert with 0, 17
                                        if not Mask(112, 0, _18480):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18480) / Mask(112, 0, _18480) != 998 * _18294:
                                            revert with 0, 'MUL error'
                                        if Mask(112, 0, _18444) and 1000 > -1 / Mask(112, 0, _18444):
                                            revert with 0, 17
                                        if 1000 * Mask(112, 0, _18444) / 1000 != Mask(112, 0, _18444):
                                            revert with 0, 'MUL error'
                                        if 1000 * Mask(112, 0, _18444) > !(998 * _18294):
                                            revert with 0, 17
                                        if (1000 * Mask(112, 0, _18444)) + (998 * _18294) < 1000 * Mask(112, 0, _18444):
                                            revert with 0, 'Add error'
                                        if not (1000 * Mask(112, 0, _18444)) + (998 * _18294):
                                            revert with 0, 18
                                        if 998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294) < cd[260]:
                                            revert with 0, 17
                                        if (998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260] > 998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294):
                                            revert with 0, 'SUB error'
                                        mem[mem[64] + 4] = address(_18290)
                                        mem[mem[64] + 36] = _18294
                                        require ext_code.size(address(_18579))
                                        call address(_18579).0xa9059cbb with:
                                             gas gas_remaining wei
                                            args address(_18290), _18294
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _20625 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_20625] == bool(mem[_20625])
                                        _20799 = mem[64]
                                        mem[mem[64]] = 0
                                        mem[64] = mem[64] + 32
                                        mem[_20799 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                        mem[_20799 + 36] = 0
                                        mem[_20799 + 68] = (998 * _18294 * Mask(112, 0, _18480) / (1000 * Mask(112, 0, _18444)) + (998 * _18294)) - cd[260]
                                        mem[_20799 + 100] = this.address
                                        mem[_20799 + 132] = 128
                                        mem[_20799 + 164] = mem[_20799]
                                        s = 0
                                        while s < mem[_20799]:
                                            mem[s + _20799 + 196] = mem[_20799 + s + 32]
                                            s = s + 32
                                            continue 
                                        if ceil32(mem[_20799]) > mem[_20799]:
                                            mem[_20799 + mem[_20799] + 196] = 0
                                        require ext_code.size(address(_18290))
                                        call address(_18290).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len ceil32(mem[_20799]) + _20799 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    _18319 = mem[(32 * idx) + 128]
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                        revert with 0, 50
                    _18326 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + 129]
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 99]:
                        revert with 0, 50
                    _18335 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 131]
                    if idx >= mem[ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 100]:
                        revert with 0, 50
                    _18339 = mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + ceil32(32 * ('cd', 100).length) + 132]
                    if msg.sender == stor0:
                        if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                            revert with 0, 'Set router'
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18326))
                        staticcall address(_18326).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18427 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _18451 = mem[_18427]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_18319))
                        staticcall address(_18319).0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18489 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        if mem[_18489] < _18294:
                            revert with 0, 'Refill amountIn'
                        mem[mem[64] + 4] = address(_18335)
                        mem[mem[64] + 36] = _18294
                        require ext_code.size(address(_18319))
                        call address(_18319).approve(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(_18335), _18294
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _18584 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        require mem[_18584] == bool(mem[_18584])
                        if not address(_18339):
                            _18639 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            if 0 >= mem[_18639]:
                                revert with 0, 50
                            mem[_18639 + 32] = address(_18319)
                            if 1 >= mem[_18639]:
                                revert with 0, 50
                            mem[_18639 + 64] = address(_18326)
                            mem[_18639 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[_18639 + 100] = _18294
                            mem[_18639 + 132] = cd[196]
                            mem[_18639 + 164] = 160
                            mem[_18639 + 260] = mem[_18639]
                            s = 0
                            t = _18639 + 32
                            u = _18639 + 292
                            while s < mem[_18639]:
                                mem[u] = mem[t + 12 len 20]
                                s = s + 1
                                t = t + 32
                                u = u + 32
                                continue 
                            mem[_18639 + 196] = address(cd[292])
                            mem[_18639 + 228] = block.timestamp
                            require ext_code.size(address(_18335))
                            call address(_18335).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len _18639 + (32 * mem[_18639]) + -mem[64] + 288]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21223 = mem[64]
                            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _21283 = mem[_21223]
                            require mem[_21223] <= test266151307()
                            require _21223 + return_data.size > _21223 + mem[_21223] + 31
                            _21319 = mem[_21223 + mem[_21223]]
                            if mem[_21223 + mem[_21223]] > test266151307():
                                revert with 0, 65
                            if ceil32(32 * mem[_21223 + mem[_21223]]) + 1 < 0 or _21223 + ceil32(return_data.size) + ceil32(32 * mem[_21223 + mem[_21223]]) + 1 > test266151307():
                                revert with 0, 65
                            mem[64] = _21223 + ceil32(return_data.size) + ceil32(32 * mem[_21223 + mem[_21223]]) + 1
                            mem[_21223 + ceil32(return_data.size)] = _21319
                            require _21283 + (32 * _21319) + 32 <= return_data.size
                            t = _21223 + _21283 + 32
                            u = _21223 + ceil32(return_data.size) + 32
                            s = 0
                            while s < _21319:
                                mem[u] = mem[t]
                                t = t + 32
                                u = u + 32
                                s = s + 1
                                continue 
                            mem[mem[64] + 4] = address(_18335)
                            mem[mem[64] + 36] = 0
                            require ext_code.size(address(_18319))
                            call address(_18319).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18335), 0
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21823 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_21823] == bool(mem[_21823])
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18326))
                            staticcall address(_18326).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _21967 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_21967] < _18451:
                                revert with 0, 17
                        else:
                            if address(_18319) == address(_18339):
                                _18653 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18653]:
                                    revert with 0, 50
                                mem[_18653 + 32] = address(_18319)
                                if 1 >= mem[_18653]:
                                    revert with 0, 50
                                mem[_18653 + 64] = address(_18326)
                                mem[_18653 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18653 + 100] = _18294
                                mem[_18653 + 132] = cd[196]
                                mem[_18653 + 164] = 160
                                mem[_18653 + 260] = mem[_18653]
                                s = 0
                                t = _18653 + 32
                                u = _18653 + 292
                                while s < mem[_18653]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18653 + 196] = address(cd[292])
                                mem[_18653 + 228] = block.timestamp
                                require ext_code.size(address(_18335))
                                call address(_18335).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18653 + (32 * mem[_18653]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21220 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21280 = mem[_21220]
                                require mem[_21220] <= test266151307()
                                require _21220 + return_data.size > _21220 + mem[_21220] + 31
                                _21316 = mem[_21220 + mem[_21220]]
                                if mem[_21220 + mem[_21220]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21220 + mem[_21220]]) + 1 < 0 or _21220 + ceil32(return_data.size) + ceil32(32 * mem[_21220 + mem[_21220]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21220 + ceil32(return_data.size) + ceil32(32 * mem[_21220 + mem[_21220]]) + 1
                                mem[_21220 + ceil32(return_data.size)] = _21316
                                require _21280 + (32 * _21316) + 32 <= return_data.size
                                t = _21220 + _21280 + 32
                                u = _21220 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21316:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18335)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18319))
                                call address(_18319).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18335), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21820 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21820] == bool(mem[_21820])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18326))
                                staticcall address(_18326).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21964 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21964] < _18451:
                                    revert with 0, 17
                            else:
                                if address(_18326) == address(_18339):
                                    _18677 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_18677]:
                                        revert with 0, 50
                                    mem[_18677 + 32] = address(_18319)
                                    if 1 >= mem[_18677]:
                                        revert with 0, 50
                                    mem[_18677 + 64] = address(_18326)
                                    mem[_18677 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18677 + 100] = _18294
                                    mem[_18677 + 132] = cd[196]
                                    mem[_18677 + 164] = 160
                                    mem[_18677 + 260] = mem[_18677]
                                    s = 0
                                    t = _18677 + 32
                                    u = _18677 + 292
                                    while s < mem[_18677]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18677 + 196] = address(cd[292])
                                    mem[_18677 + 228] = block.timestamp
                                    require ext_code.size(address(_18335))
                                    call address(_18335).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18677 + (32 * mem[_18677]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21222 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21282 = mem[_21222]
                                    require mem[_21222] <= test266151307()
                                    require _21222 + return_data.size > _21222 + mem[_21222] + 31
                                    _21318 = mem[_21222 + mem[_21222]]
                                    if mem[_21222 + mem[_21222]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21222 + mem[_21222]]) + 1 < 0 or _21222 + ceil32(return_data.size) + ceil32(32 * mem[_21222 + mem[_21222]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21222 + ceil32(return_data.size) + ceil32(32 * mem[_21222 + mem[_21222]]) + 1
                                    mem[_21222 + ceil32(return_data.size)] = _21318
                                    require _21282 + (32 * _21318) + 32 <= return_data.size
                                    t = _21222 + _21282 + 32
                                    u = _21222 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21318:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18335)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18319))
                                    call address(_18319).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18335), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21822 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21822] == bool(mem[_21822])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18326))
                                    staticcall address(_18326).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21966 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21966] < _18451:
                                        revert with 0, 17
                                else:
                                    _18654 = mem[64]
                                    mem[mem[64]] = 3
                                    mem[64] = mem[64] + 128
                                    if 0 >= mem[_18654]:
                                        revert with 0, 50
                                    mem[_18654 + 32] = address(_18319)
                                    if 1 >= mem[_18654]:
                                        revert with 0, 50
                                    mem[_18654 + 64] = address(_18339)
                                    if 2 >= mem[_18654]:
                                        revert with 0, 50
                                    mem[_18654 + 96] = address(_18326)
                                    mem[_18654 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18654 + 132] = _18294
                                    mem[_18654 + 164] = cd[196]
                                    mem[_18654 + 196] = 160
                                    mem[_18654 + 292] = mem[_18654]
                                    s = 0
                                    t = _18654 + 32
                                    u = _18654 + 324
                                    while s < mem[_18654]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18654 + 228] = address(cd[292])
                                    mem[_18654 + 260] = block.timestamp
                                    require ext_code.size(address(_18335))
                                    call address(_18335).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18654 + (32 * mem[_18654]) + -mem[64] + 320]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21221 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21281 = mem[_21221]
                                    require mem[_21221] <= test266151307()
                                    require _21221 + return_data.size > _21221 + mem[_21221] + 31
                                    _21317 = mem[_21221 + mem[_21221]]
                                    if mem[_21221 + mem[_21221]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21221 + mem[_21221]]) + 1 < 0 or _21221 + ceil32(return_data.size) + ceil32(32 * mem[_21221 + mem[_21221]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21221 + ceil32(return_data.size) + ceil32(32 * mem[_21221 + mem[_21221]]) + 1
                                    mem[_21221 + ceil32(return_data.size)] = _21317
                                    require _21281 + (32 * _21317) + 32 <= return_data.size
                                    t = _21221 + _21281 + 32
                                    u = _21221 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21317:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18335)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18319))
                                    call address(_18319).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18335), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21821 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21821] == bool(mem[_21821])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18326))
                                    staticcall address(_18326).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21965 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21965] < _18451:
                                        revert with 0, 17
                    else:
                        if msg.sender == stor1:
                            if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                                revert with 0, 'Set router'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18326))
                            staticcall address(_18326).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18441 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18464 = mem[_18441]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18319))
                            staticcall address(_18319).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18501 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18501] < _18294:
                                revert with 0, 'Refill amountIn'
                            mem[mem[64] + 4] = address(_18335)
                            mem[mem[64] + 36] = _18294
                            require ext_code.size(address(_18319))
                            call address(_18319).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18335), _18294
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18592 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_18592] == bool(mem[_18592])
                            if not address(_18339):
                                _18642 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18642]:
                                    revert with 0, 50
                                mem[_18642 + 32] = address(_18319)
                                if 1 >= mem[_18642]:
                                    revert with 0, 50
                                mem[_18642 + 64] = address(_18326)
                                mem[_18642 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18642 + 100] = _18294
                                mem[_18642 + 132] = cd[196]
                                mem[_18642 + 164] = 160
                                mem[_18642 + 260] = mem[_18642]
                                s = 0
                                t = _18642 + 32
                                u = _18642 + 292
                                while s < mem[_18642]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18642 + 196] = address(cd[292])
                                mem[_18642 + 228] = block.timestamp
                                require ext_code.size(address(_18335))
                                call address(_18335).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18642 + (32 * mem[_18642]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21227 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21287 = mem[_21227]
                                require mem[_21227] <= test266151307()
                                require _21227 + return_data.size > _21227 + mem[_21227] + 31
                                _21323 = mem[_21227 + mem[_21227]]
                                if mem[_21227 + mem[_21227]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21227 + mem[_21227]]) + 1 < 0 or _21227 + ceil32(return_data.size) + ceil32(32 * mem[_21227 + mem[_21227]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21227 + ceil32(return_data.size) + ceil32(32 * mem[_21227 + mem[_21227]]) + 1
                                mem[_21227 + ceil32(return_data.size)] = _21323
                                require _21287 + (32 * _21323) + 32 <= return_data.size
                                t = _21227 + _21287 + 32
                                u = _21227 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21323:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18335)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18319))
                                call address(_18319).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18335), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21827 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21827] == bool(mem[_21827])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18326))
                                staticcall address(_18326).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21971 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21971] < _18464:
                                    revert with 0, 17
                            else:
                                if address(_18319) == address(_18339):
                                    _18679 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_18679]:
                                        revert with 0, 50
                                    mem[_18679 + 32] = address(_18319)
                                    if 1 >= mem[_18679]:
                                        revert with 0, 50
                                    mem[_18679 + 64] = address(_18326)
                                    mem[_18679 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18679 + 100] = _18294
                                    mem[_18679 + 132] = cd[196]
                                    mem[_18679 + 164] = 160
                                    mem[_18679 + 260] = mem[_18679]
                                    s = 0
                                    t = _18679 + 32
                                    u = _18679 + 292
                                    while s < mem[_18679]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18679 + 196] = address(cd[292])
                                    mem[_18679 + 228] = block.timestamp
                                    require ext_code.size(address(_18335))
                                    call address(_18335).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18679 + (32 * mem[_18679]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21224 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21284 = mem[_21224]
                                    require mem[_21224] <= test266151307()
                                    require _21224 + return_data.size > _21224 + mem[_21224] + 31
                                    _21320 = mem[_21224 + mem[_21224]]
                                    if mem[_21224 + mem[_21224]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21224 + mem[_21224]]) + 1 < 0 or _21224 + ceil32(return_data.size) + ceil32(32 * mem[_21224 + mem[_21224]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21224 + ceil32(return_data.size) + ceil32(32 * mem[_21224 + mem[_21224]]) + 1
                                    mem[_21224 + ceil32(return_data.size)] = _21320
                                    require _21284 + (32 * _21320) + 32 <= return_data.size
                                    t = _21224 + _21284 + 32
                                    u = _21224 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21320:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18335)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18319))
                                    call address(_18319).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18335), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21824 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21824] == bool(mem[_21824])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18326))
                                    staticcall address(_18326).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21968 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21968] < _18464:
                                        revert with 0, 17
                                else:
                                    if address(_18326) == address(_18339):
                                        _18716 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        if 0 >= mem[_18716]:
                                            revert with 0, 50
                                        mem[_18716 + 32] = address(_18319)
                                        if 1 >= mem[_18716]:
                                            revert with 0, 50
                                        mem[_18716 + 64] = address(_18326)
                                        mem[_18716 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_18716 + 100] = _18294
                                        mem[_18716 + 132] = cd[196]
                                        mem[_18716 + 164] = 160
                                        mem[_18716 + 260] = mem[_18716]
                                        s = 0
                                        t = _18716 + 32
                                        u = _18716 + 292
                                        while s < mem[_18716]:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_18716 + 196] = address(cd[292])
                                        mem[_18716 + 228] = block.timestamp
                                        require ext_code.size(address(_18335))
                                        call address(_18335).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _18716 + (32 * mem[_18716]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21226 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21286 = mem[_21226]
                                        require mem[_21226] <= test266151307()
                                        require _21226 + return_data.size > _21226 + mem[_21226] + 31
                                        _21322 = mem[_21226 + mem[_21226]]
                                        if mem[_21226 + mem[_21226]] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[_21226 + mem[_21226]]) + 1 < 0 or _21226 + ceil32(return_data.size) + ceil32(32 * mem[_21226 + mem[_21226]]) + 1 > test266151307():
                                            revert with 0, 65
                                        mem[64] = _21226 + ceil32(return_data.size) + ceil32(32 * mem[_21226 + mem[_21226]]) + 1
                                        mem[_21226 + ceil32(return_data.size)] = _21322
                                        require _21286 + (32 * _21322) + 32 <= return_data.size
                                        t = _21226 + _21286 + 32
                                        u = _21226 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _21322:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = address(_18335)
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(address(_18319))
                                        call address(_18319).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(_18335), 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21826 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21826] == bool(mem[_21826])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_18326))
                                        staticcall address(_18326).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21970 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_21970] < _18464:
                                            revert with 0, 17
                                    else:
                                        _18680 = mem[64]
                                        mem[mem[64]] = 3
                                        mem[64] = mem[64] + 128
                                        if 0 >= mem[_18680]:
                                            revert with 0, 50
                                        mem[_18680 + 32] = address(_18319)
                                        if 1 >= mem[_18680]:
                                            revert with 0, 50
                                        mem[_18680 + 64] = address(_18339)
                                        if 2 >= mem[_18680]:
                                            revert with 0, 50
                                        mem[_18680 + 96] = address(_18326)
                                        mem[_18680 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_18680 + 132] = _18294
                                        mem[_18680 + 164] = cd[196]
                                        mem[_18680 + 196] = 160
                                        mem[_18680 + 292] = mem[_18680]
                                        s = 0
                                        t = _18680 + 32
                                        u = _18680 + 324
                                        while s < mem[_18680]:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_18680 + 228] = address(cd[292])
                                        mem[_18680 + 260] = block.timestamp
                                        require ext_code.size(address(_18335))
                                        call address(_18335).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _18680 + (32 * mem[_18680]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21225 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21285 = mem[_21225]
                                        require mem[_21225] <= test266151307()
                                        require _21225 + return_data.size > _21225 + mem[_21225] + 31
                                        _21321 = mem[_21225 + mem[_21225]]
                                        if mem[_21225 + mem[_21225]] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[_21225 + mem[_21225]]) + 1 < 0 or _21225 + ceil32(return_data.size) + ceil32(32 * mem[_21225 + mem[_21225]]) + 1 > test266151307():
                                            revert with 0, 65
                                        mem[64] = _21225 + ceil32(return_data.size) + ceil32(32 * mem[_21225 + mem[_21225]]) + 1
                                        mem[_21225 + ceil32(return_data.size)] = _21321
                                        require _21285 + (32 * _21321) + 32 <= return_data.size
                                        t = _21225 + _21285 + 32
                                        u = _21225 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _21321:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = address(_18335)
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(address(_18319))
                                        call address(_18319).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(_18335), 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21825 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21825] == bool(mem[_21825])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_18326))
                                        staticcall address(_18326).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21969 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_21969] < _18464:
                                            revert with 0, 17
                        else:
                            if stor2 != msg.sender:
                                revert with 0, 'Not authorized'
                            if not mem[(32 * idx) + ceil32(32 * ('cd', 4).length) + ceil32(32 * ('cd', 36).length) + ceil32(32 * ('cd', 68).length) + 143 len 20]:
                                revert with 0, 'Set router'
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18326))
                            staticcall address(_18326).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18452 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _18478 = mem[_18452]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_18319))
                            staticcall address(_18319).0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18514 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            if mem[_18514] < _18294:
                                revert with 0, 'Refill amountIn'
                            mem[mem[64] + 4] = address(_18335)
                            mem[mem[64] + 36] = _18294
                            require ext_code.size(address(_18319))
                            call address(_18319).approve(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(_18335), _18294
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _18604 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            require mem[_18604] == bool(mem[_18604])
                            if not address(_18339):
                                _18657 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                if 0 >= mem[_18657]:
                                    revert with 0, 50
                                mem[_18657 + 32] = address(_18319)
                                if 1 >= mem[_18657]:
                                    revert with 0, 50
                                mem[_18657 + 64] = address(_18326)
                                mem[_18657 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[_18657 + 100] = _18294
                                mem[_18657 + 132] = cd[196]
                                mem[_18657 + 164] = 160
                                mem[_18657 + 260] = mem[_18657]
                                s = 0
                                t = _18657 + 32
                                u = _18657 + 292
                                while s < mem[_18657]:
                                    mem[u] = mem[t + 12 len 20]
                                    s = s + 1
                                    t = t + 32
                                    u = u + 32
                                    continue 
                                mem[_18657 + 196] = address(cd[292])
                                mem[_18657 + 228] = block.timestamp
                                require ext_code.size(address(_18335))
                                call address(_18335).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len _18657 + (32 * mem[_18657]) + -mem[64] + 288]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21231 = mem[64]
                                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _21291 = mem[_21231]
                                require mem[_21231] <= test266151307()
                                require _21231 + return_data.size > _21231 + mem[_21231] + 31
                                _21327 = mem[_21231 + mem[_21231]]
                                if mem[_21231 + mem[_21231]] > test266151307():
                                    revert with 0, 65
                                if ceil32(32 * mem[_21231 + mem[_21231]]) + 1 < 0 or _21231 + ceil32(return_data.size) + ceil32(32 * mem[_21231 + mem[_21231]]) + 1 > test266151307():
                                    revert with 0, 65
                                mem[64] = _21231 + ceil32(return_data.size) + ceil32(32 * mem[_21231 + mem[_21231]]) + 1
                                mem[_21231 + ceil32(return_data.size)] = _21327
                                require _21291 + (32 * _21327) + 32 <= return_data.size
                                t = _21231 + _21291 + 32
                                u = _21231 + ceil32(return_data.size) + 32
                                s = 0
                                while s < _21327:
                                    mem[u] = mem[t]
                                    t = t + 32
                                    u = u + 32
                                    s = s + 1
                                    continue 
                                mem[mem[64] + 4] = address(_18335)
                                mem[mem[64] + 36] = 0
                                require ext_code.size(address(_18319))
                                call address(_18319).approve(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(_18335), 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21831 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_21831] == bool(mem[_21831])
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(_18326))
                                staticcall address(_18326).0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _21975 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                if mem[_21975] < _18478:
                                    revert with 0, 17
                            else:
                                if address(_18319) == address(_18339):
                                    _18718 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    if 0 >= mem[_18718]:
                                        revert with 0, 50
                                    mem[_18718 + 32] = address(_18319)
                                    if 1 >= mem[_18718]:
                                        revert with 0, 50
                                    mem[_18718 + 64] = address(_18326)
                                    mem[_18718 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[_18718 + 100] = _18294
                                    mem[_18718 + 132] = cd[196]
                                    mem[_18718 + 164] = 160
                                    mem[_18718 + 260] = mem[_18718]
                                    s = 0
                                    t = _18718 + 32
                                    u = _18718 + 292
                                    while s < mem[_18718]:
                                        mem[u] = mem[t + 12 len 20]
                                        s = s + 1
                                        t = t + 32
                                        u = u + 32
                                        continue 
                                    mem[_18718 + 196] = address(cd[292])
                                    mem[_18718 + 228] = block.timestamp
                                    require ext_code.size(address(_18335))
                                    call address(_18335).mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len _18718 + (32 * mem[_18718]) + -mem[64] + 288]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21228 = mem[64]
                                    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21288 = mem[_21228]
                                    require mem[_21228] <= test266151307()
                                    require _21228 + return_data.size > _21228 + mem[_21228] + 31
                                    _21324 = mem[_21228 + mem[_21228]]
                                    if mem[_21228 + mem[_21228]] > test266151307():
                                        revert with 0, 65
                                    if ceil32(32 * mem[_21228 + mem[_21228]]) + 1 < 0 or _21228 + ceil32(return_data.size) + ceil32(32 * mem[_21228 + mem[_21228]]) + 1 > test266151307():
                                        revert with 0, 65
                                    mem[64] = _21228 + ceil32(return_data.size) + ceil32(32 * mem[_21228 + mem[_21228]]) + 1
                                    mem[_21228 + ceil32(return_data.size)] = _21324
                                    require _21288 + (32 * _21324) + 32 <= return_data.size
                                    t = _21228 + _21288 + 32
                                    u = _21228 + ceil32(return_data.size) + 32
                                    s = 0
                                    while s < _21324:
                                        mem[u] = mem[t]
                                        t = t + 32
                                        u = u + 32
                                        s = s + 1
                                        continue 
                                    mem[mem[64] + 4] = address(_18335)
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(address(_18319))
                                    call address(_18319).approve(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(_18335), 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21828 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21828] == bool(mem[_21828])
                                    mem[mem[64] + 4] = this.address
                                    require ext_code.size(address(_18326))
                                    staticcall address(_18326).0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21972 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    if mem[_21972] < _18478:
                                        revert with 0, 17
                                else:
                                    if address(_18326) == address(_18339):
                                        _18763 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        if 0 >= mem[_18763]:
                                            revert with 0, 50
                                        mem[_18763 + 32] = address(_18319)
                                        if 1 >= mem[_18763]:
                                            revert with 0, 50
                                        mem[_18763 + 64] = address(_18326)
                                        mem[_18763 + 96] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_18763 + 100] = _18294
                                        mem[_18763 + 132] = cd[196]
                                        mem[_18763 + 164] = 160
                                        mem[_18763 + 260] = mem[_18763]
                                        s = 0
                                        t = _18763 + 32
                                        u = _18763 + 292
                                        while s < mem[_18763]:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_18763 + 196] = address(cd[292])
                                        mem[_18763 + 228] = block.timestamp
                                        require ext_code.size(address(_18335))
                                        call address(_18335).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _18763 + (32 * mem[_18763]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21230 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21290 = mem[_21230]
                                        require mem[_21230] <= test266151307()
                                        require _21230 + return_data.size > _21230 + mem[_21230] + 31
                                        _21326 = mem[_21230 + mem[_21230]]
                                        if mem[_21230 + mem[_21230]] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[_21230 + mem[_21230]]) + 1 < 0 or _21230 + ceil32(return_data.size) + ceil32(32 * mem[_21230 + mem[_21230]]) + 1 > test266151307():
                                            revert with 0, 65
                                        mem[64] = _21230 + ceil32(return_data.size) + ceil32(32 * mem[_21230 + mem[_21230]]) + 1
                                        mem[_21230 + ceil32(return_data.size)] = _21326
                                        require _21290 + (32 * _21326) + 32 <= return_data.size
                                        t = _21230 + _21290 + 32
                                        u = _21230 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _21326:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = address(_18335)
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(address(_18319))
                                        call address(_18319).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(_18335), 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21830 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21830] == bool(mem[_21830])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_18326))
                                        staticcall address(_18326).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21974 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_21974] < _18478:
                                            revert with 0, 17
                                    else:
                                        _18719 = mem[64]
                                        mem[mem[64]] = 3
                                        mem[64] = mem[64] + 128
                                        if 0 >= mem[_18719]:
                                            revert with 0, 50
                                        mem[_18719 + 32] = address(_18319)
                                        if 1 >= mem[_18719]:
                                            revert with 0, 50
                                        mem[_18719 + 64] = address(_18339)
                                        if 2 >= mem[_18719]:
                                            revert with 0, 50
                                        mem[_18719 + 96] = address(_18326)
                                        mem[_18719 + 128] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                        mem[_18719 + 132] = _18294
                                        mem[_18719 + 164] = cd[196]
                                        mem[_18719 + 196] = 160
                                        mem[_18719 + 292] = mem[_18719]
                                        s = 0
                                        t = _18719 + 32
                                        u = _18719 + 324
                                        while s < mem[_18719]:
                                            mem[u] = mem[t + 12 len 20]
                                            s = s + 1
                                            t = t + 32
                                            u = u + 32
                                            continue 
                                        mem[_18719 + 228] = address(cd[292])
                                        mem[_18719 + 260] = block.timestamp
                                        require ext_code.size(address(_18335))
                                        call address(_18335).mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _18719 + (32 * mem[_18719]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21229 = mem[64]
                                        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21289 = mem[_21229]
                                        require mem[_21229] <= test266151307()
                                        require _21229 + return_data.size > _21229 + mem[_21229] + 31
                                        _21325 = mem[_21229 + mem[_21229]]
                                        if mem[_21229 + mem[_21229]] > test266151307():
                                            revert with 0, 65
                                        if ceil32(32 * mem[_21229 + mem[_21229]]) + 1 < 0 or _21229 + ceil32(return_data.size) + ceil32(32 * mem[_21229 + mem[_21229]]) + 1 > test266151307():
                                            revert with 0, 65
                                        mem[64] = _21229 + ceil32(return_data.size) + ceil32(32 * mem[_21229 + mem[_21229]]) + 1
                                        mem[_21229 + ceil32(return_data.size)] = _21325
                                        require _21289 + (32 * _21325) + 32 <= return_data.size
                                        t = _21229 + _21289 + 32
                                        u = _21229 + ceil32(return_data.size) + 32
                                        s = 0
                                        while s < _21325:
                                            mem[u] = mem[t]
                                            t = t + 32
                                            u = u + 32
                                            s = s + 1
                                            continue 
                                        mem[mem[64] + 4] = address(_18335)
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(address(_18319))
                                        call address(_18319).approve(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(_18335), 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21829 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21829] == bool(mem[_21829])
                                        mem[mem[64] + 4] = this.address
                                        require ext_code.size(address(_18326))
                                        staticcall address(_18326).0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21973 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        if mem[_21973] < _18478:
                                            revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = _18294
                s = _18290
                continue 
            if ('cd', 100).length < 1:
                revert with 0, 17
            if ('cd', 100).length - 1 >= mem[ceil32(32 * ('cd', 4).length) + 97]:
                revert with 0, 50
            mem[mem[64] + 4] = this.address
            require ext_code.size(mem[(32 * ('cd', 100).length - 1) + ceil32(32 * ('cd', 4).length) + 141 len 20])
            staticcall mem[(32 * ('cd', 100).length - 1) + ceil32(32 * ('cd', 4).length) + 141 len 20].0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _18334 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            if mem[_18334] <= cd[228]:
                revert with 0, 'Check result'
            mem[mem[64]] = mem[_18334]
    return memory
      from mem[64]
       len 32
}



}

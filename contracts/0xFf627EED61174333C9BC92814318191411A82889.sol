contract main {




// =====================  Runtime code  =====================


#
#  - sub_05bd85d2(?)
#  - getReward()
#  - seize(address arg1, uint256 arg2)
#
const DURATION = (4320 * 24 * 3600)


uint256 totalSupply;
mapping of uint256 supply;
mapping of uint256 supply;
uint256 stor3;
uint8 stor4;
uint8 breaker; offset 160
uint128 stor21; offset 160
address governanceAddress;
mapping of uint256 sub_59281b1e;
mapping of struct sub_aeb22018;
array of uint256 stor24;
mapping of uint256 stor25;
array of struct stor26;
mapping of uint256 stor27;
address kunAddress;
address mainAddress;
uint256 closingTime;
uint256 openingTime;
mapping of uint256 sub_28bcf07a;
mapping of uint256 sub_3d3b2603;
mapping of uint256 rewardPerTokenStored;
mapping of uint256 userRewardPerTokenPaid;
mapping of uint256 rewards;
mapping of uint256 claimedRewards;
uint256 totalClaimedReward;

function breaker() payable {
    return bool(breaker)
}

function supply(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return supply[address(arg1)][address(arg2)]
}

function totalSupply() payable {
    return totalSupply
}

function supply(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return supply[address(arg1)]
}

function sub_28bcf07a(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_28bcf07a[arg1]
}

function sub_3d3b2603(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_3d3b2603[arg1]
}

function closingTime() payable {
    return closingTime
}

function totalClaimedReward() payable {
    return totalClaimedReward
}

function sub_59281b1e(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == address(arg2)
    return sub_59281b1e[arg1][arg2]
}

function governance() payable {
    return governanceAddress
}

function userRewardPerTokenPaid(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return userRewardPerTokenPaid[arg1][arg2]
}

function kun() payable {
    return kunAddress
}

function rewardPerTokenStored(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return rewardPerTokenStored[arg1]
}

function sub_aeb22018(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return sub_aeb22018[arg1].field_0, sub_aeb22018[arg1].field_256
}

function openingTime() payable {
    return openingTime
}

function claimedRewards(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return claimedRewards[arg1]
}

function main() payable {
    return mainAddress
}

function rewards(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return rewards[arg1][arg2]
}

function _fallback() payable {
    revert
}

function lastTimeRewardApplicable() payable {
    if block.timestamp < closingTime:
        return block.timestamp
    return closingTime
}

function setBreaker(bool arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if governanceAddress != msg.sender:
        revert with 0, '!governance'
    stor21 = Mask(96, 0, arg1)
}

function setGovernance(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if governanceAddress != msg.sender:
        revert with 0, '!governance'
    governanceAddress = arg1
}

function setClosingTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if governanceAddress != msg.sender:
        revert with 0, '!governance'
    if arg1 <= block.timestamp:
        revert with 0, 'Bad newClosingTime'
    closingTime = arg1
}

function sub_e788f2ad(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    if governanceAddress != msg.sender:
        revert with 0, '!governance'
    if not stor25[arg1]:
        stor24.length++
        stor24[stor24.length] = arg1
        stor25[arg1] = stor24.length
    sub_aeb22018[arg1].field_0 = arg2
    sub_aeb22018[arg1].field_256 = arg3
}

function sub_b77ea2d7(?) payable {
    if stor24.length:
        mem[128 len 32 * stor24.length] = code.data[18335 len 32 * stor24.length]
    idx = 0
    while idx < stor24.length:
        if stor24.length <= idx:
            revert with 0, 'EnumerableSet: index out of bounds'
        require idx < stor24.length
        mem[0] = 24
        require idx < stor24.length
        mem[(32 * idx) + 128] = stor24[idx]
        idx = idx + 1
        continue 
    return Array(len=stor24.length, data=mem[128 len 32 * stor24.length])
}

function initialize(address arg1, address arg2, address arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    require arg3 == arg3
    if stor4:
        governanceAddress = arg1
        kunAddress = arg2
        mainAddress = arg3
    else:
        if ext_code.size(this.address):
            if 1 <= stor3:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Contract instance has already been initialized'
        if stor4:
            governanceAddress = arg1
            kunAddress = arg2
            mainAddress = arg3
        else:
            stor4 = 1
            stor3 = 1
            governanceAddress = arg1
            kunAddress = arg2
            mainAddress = arg3
            stor4 = 0
}

function sub_14001716(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if governanceAddress != msg.sender:
        revert with 0, '!governance'
    if openingTime:
        revert with 0, 'duplicated notifyOpeningTime'
    openingTime = arg1
    if openingTime + (4320 * 24 * 3600) < openingTime:
        revert with 0, 'SafeMath: addition overflow'
    closingTime = openingTime + (4320 * 24 * 3600)
    idx = 0
    while idx < stor26.length:
        if stor26.length <= idx:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'EnumerableSet: index out of bounds'
        require idx < stor26.length
        mem[0] = stor26[idx].field_0
        mem[32] = 32
        sub_28bcf07a[stor26[idx].field_0] = openingTime
        idx = idx + 1
        continue 
}

function getTokens() payable {
    mem[96] = stor26.length
    mem[64] = (32 * stor26.length) + 128
    if stor26.length:
        mem[128 len 32 * stor26.length] = code.data[18335 len 32 * stor26.length]
    idx = 0
    while idx < stor26.length:
        if stor26.length <= idx:
            revert with 0, 'EnumerableSet: index out of bounds'
        require idx < stor26.length
        mem[0] = 26
        require idx < stor26.length
        mem[(32 * idx) + 128] = stor26[idx].field_0
        idx = idx + 1
        continue 
    mem[(32 * stor26.length) + 128] = 32
    mem[(32 * stor26.length) + 160] = stor26.length
    idx = 0
    s = 128
    t = mem[64] + 64
    while idx < stor26.length:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * stor26.length) + -mem[64] + 192
}

function sub_510f16ae(?) payable {
    mem[64] = 96
    if totalSupply:
        idx = 0
        while idx < stor24.length:
            if stor24.length <= idx:
                revert with 0, 'EnumerableSet: index out of bounds'
            require idx < stor24.length
            mem[0] = 24
            _18 = mem[64]
            mem[64] = mem[64] + 64
            mem[_18] = 0
            mem[_18 + 32] = 0
            mem[0] = stor24[idx]
            mem[32] = 23
            _21 = mem[64]
            mem[64] = mem[64] + 64
            mem[_21] = sub_aeb22018[stor24[idx]].field_0
            mem[_21 + 32] = sub_aeb22018[stor24[idx]].field_256
            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                idx = idx + 1
                continue 
            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                idx = idx + 1
                continue 
            return stor24[idx]
        return 0
    else:
        return 0
}

function sub_99d0092e(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if governanceAddress != msg.sender:
        revert with 0, '!governance'
    idx = 0
    while idx < stor26.length:
        if stor26.length <= idx:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'EnumerableSet: index out of bounds'
        require idx < stor26.length
        mem[0] = stor26[idx].field_0
        mem[32] = sha3(arg1, 22)
        sub_59281b1e[arg1][stor26[idx].field_0] = 0
        idx = idx + 1
        continue 
    if stor25[arg1]:
        require stor24.length - 1 < stor24.length
        require stor25[arg1] - 1 < stor24.length
        stor24[stor25[arg1]] = stor24[stor24.length]
        stor25[stor24[stor24.length]] = stor25[arg1]
        require stor24.length
        stor24[stor24.length] = 0
        stor24.length--
        stor25[arg1] = 0
    sub_aeb22018[arg1].field_0 = 0
    sub_aeb22018[arg1].field_256 = 0
}

function sub_263179e5(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 <= test266151307() and (32 * ('cd', 4).length) + 128 >= 96
    mem[64] = (32 * ('cd', 4).length) + 128
    mem[96] = ('cd', 4).length
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[4] + cd[s] + 67 < calldata.size
        require cd[(cd[4] + cd[s] + 36)] <= test266151307()
        _23 = mem[64]
        require mem[64] + ceil32(cd[(cd[4] + cd[s] + 36)]) + 32 <= test266151307() and mem[64] + ceil32(cd[(cd[4] + cd[s] + 36)]) + 32 >= mem[64]
        mem[64] = mem[64] + ceil32(cd[(cd[4] + cd[s] + 36)]) + 32
        mem[_23] = cd[(cd[4] + cd[s] + 36)]
        require cd[4] + cd[s] + cd[(cd[4] + cd[s] + 36)] + 68 <= calldata.size
        mem[_23 + 32 len cd[(cd[4] + cd[s] + 36)]] = call.data[cd[4] + cd[s] + 68 len cd[(cd[4] + cd[s] + 36)]]
        mem[_23 + cd[(cd[4] + cd[s] + 36)] + 32] = 0
        mem[t] = _23
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    if governanceAddress != msg.sender:
        revert with 0, '!governance'
    idx = 0
    while idx < mem[96]:
        require idx < mem[96]
        require mem[mem[(32 * idx) + 128]] >= 96
        _41 = mem[mem[(32 * idx) + 128] + 32]
        require mem[mem[(32 * idx) + 128] + 32] == mem[mem[(32 * idx) + 128] + 32]
        _42 = mem[mem[(32 * idx) + 128] + 64]
        require mem[mem[(32 * idx) + 128] + 64] == mem[mem[(32 * idx) + 128] + 76 len 20]
        require mem[mem[(32 * idx) + 128] + 96] == mem[mem[(32 * idx) + 128] + 96]
        mem[0] = mem[mem[(32 * idx) + 128] + 32]
        if not stor25[mem[0]]:
            revert with 0, 'unknown grade'
        sub_59281b1e[_41][address(mem[mem[(32 * idx) + 128] + 64])] = mem[mem[(32 * idx) + 128] + 96]
        mem[0] = mem[mem[(32 * idx) + 128] + 76 len 20]
        mem[32] = 27
        if not stor27[address(_42)]:
            stor26.length++
            stor26[stor26.length].field_0 = address(_42)
            stor26[stor26.length].field_160 = 0
            mem[0] = address(_42)
            mem[32] = 27
            stor27[address(_42)] = stor26.length
        idx = idx + 1
        continue 
}

function rewardPerToken(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not supply[address(arg1)]:
        return rewardPerTokenStored[address(arg1)]
    if block.timestamp < closingTime:
        if sub_28bcf07a[address(arg1)] > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not block.timestamp - sub_28bcf07a[address(arg1)]:
            if supply[address(arg1)] <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            require supply[address(arg1)]
            if rewardPerTokenStored[address(arg1)] + (0 / supply[address(arg1)]) < rewardPerTokenStored[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
            return (rewardPerTokenStored[address(arg1)] + (0 / supply[address(arg1)]))
        require block.timestamp - sub_28bcf07a[address(arg1)]
        if (block.timestamp * sub_3d3b2603[address(arg1)]) - (sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) / block.timestamp - sub_28bcf07a[address(arg1)] != sub_3d3b2603[address(arg1)]:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (block.timestamp * sub_3d3b2603[address(arg1)]) - (sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]):
            if supply[address(arg1)] <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            require supply[address(arg1)]
            if rewardPerTokenStored[address(arg1)] + (0 / supply[address(arg1)]) < rewardPerTokenStored[address(arg1)]:
                revert with 0, 'SafeMath: addition overflow'
            return (rewardPerTokenStored[address(arg1)] + (0 / supply[address(arg1)]))
        require (block.timestamp * sub_3d3b2603[address(arg1)]) - (sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)])
        if (10^18 * block.timestamp * sub_3d3b2603[address(arg1)]) - (10^18 * sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) / (block.timestamp * sub_3d3b2603[address(arg1)]) - (sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if supply[address(arg1)] <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        require supply[address(arg1)]
        if rewardPerTokenStored[address(arg1)] + ((10^18 * block.timestamp * sub_3d3b2603[address(arg1)]) - (10^18 * sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) / supply[address(arg1)]) < rewardPerTokenStored[address(arg1)]:
            revert with 0, 'SafeMath: addition overflow'
        return (rewardPerTokenStored[address(arg1)] + ((10^18 * block.timestamp * sub_3d3b2603[address(arg1)]) - (10^18 * sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) / supply[address(arg1)]))
    if sub_28bcf07a[address(arg1)] > closingTime:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not closingTime - sub_28bcf07a[address(arg1)]:
        if supply[address(arg1)] <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        require supply[address(arg1)]
        if rewardPerTokenStored[address(arg1)] + (0 / supply[address(arg1)]) < rewardPerTokenStored[address(arg1)]:
            revert with 0, 'SafeMath: addition overflow'
        return (rewardPerTokenStored[address(arg1)] + (0 / supply[address(arg1)]))
    require closingTime - sub_28bcf07a[address(arg1)]
    if (closingTime * sub_3d3b2603[address(arg1)]) - (sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) / closingTime - sub_28bcf07a[address(arg1)] != sub_3d3b2603[address(arg1)]:
        revert with 0, 'SafeMath: multiplication overflow'
    if not (closingTime * sub_3d3b2603[address(arg1)]) - (sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]):
        if supply[address(arg1)] <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        require supply[address(arg1)]
        if rewardPerTokenStored[address(arg1)] + (0 / supply[address(arg1)]) < rewardPerTokenStored[address(arg1)]:
            revert with 0, 'SafeMath: addition overflow'
        return (rewardPerTokenStored[address(arg1)] + (0 / supply[address(arg1)]))
    require (closingTime * sub_3d3b2603[address(arg1)]) - (sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)])
    if (10^18 * closingTime * sub_3d3b2603[address(arg1)]) - (10^18 * sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) / (closingTime * sub_3d3b2603[address(arg1)]) - (sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) != 10^18:
        revert with 0, 'SafeMath: multiplication overflow'
    if supply[address(arg1)] <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    require supply[address(arg1)]
    if rewardPerTokenStored[address(arg1)] + ((10^18 * closingTime * sub_3d3b2603[address(arg1)]) - (10^18 * sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) / supply[address(arg1)]) < rewardPerTokenStored[address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    return (rewardPerTokenStored[address(arg1)] + ((10^18 * closingTime * sub_3d3b2603[address(arg1)]) - (10^18 * sub_28bcf07a[address(arg1)] * sub_3d3b2603[address(arg1)]) / supply[address(arg1)]))
}

function earned(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not supply[address(arg2)]:
        if userRewardPerTokenPaid[address(arg1)][address(arg2)] > rewardPerTokenStored[address(arg2)]:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not supply[address(arg1)][address(arg2)]:
            if rewards[address(arg1)][address(arg2)] < 0:
                revert with 0, 'SafeMath: addition overflow'
            return rewards[address(arg1)][address(arg2)]
        require supply[address(arg1)][address(arg2)]
        if (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / supply[address(arg1)][address(arg2)] != rewardPerTokenStored[address(arg2)] - userRewardPerTokenPaid[address(arg1)][address(arg2)]:
            revert with 0, 'SafeMath: multiplication overflow'
        if ((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)] < (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return (((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)])
    if block.timestamp < closingTime:
        if sub_28bcf07a[address(arg2)] > block.timestamp:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not block.timestamp - sub_28bcf07a[address(arg2)]:
            if supply[address(arg2)] <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            require supply[address(arg2)]
            if rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]) < rewardPerTokenStored[address(arg2)]:
                revert with 0, 'SafeMath: addition overflow'
            if userRewardPerTokenPaid[address(arg1)][address(arg2)] > rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not supply[address(arg1)][address(arg2)]:
                if rewards[address(arg1)][address(arg2)] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return rewards[address(arg1)][address(arg2)]
            require supply[address(arg1)][address(arg2)]
            if (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / supply[address(arg1)][address(arg2)] != rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]) - userRewardPerTokenPaid[address(arg1)][address(arg2)]:
                revert with 0, 'SafeMath: multiplication overflow'
            if ((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)] < (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            return (((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)])
        require block.timestamp - sub_28bcf07a[address(arg2)]
        if (block.timestamp * sub_3d3b2603[address(arg2)]) - (sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / block.timestamp - sub_28bcf07a[address(arg2)] != sub_3d3b2603[address(arg2)]:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (block.timestamp * sub_3d3b2603[address(arg2)]) - (sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]):
            if supply[address(arg2)] <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            require supply[address(arg2)]
            if rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]) < rewardPerTokenStored[address(arg2)]:
                revert with 0, 'SafeMath: addition overflow'
            if userRewardPerTokenPaid[address(arg1)][address(arg2)] > rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if not supply[address(arg1)][address(arg2)]:
                if rewards[address(arg1)][address(arg2)] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return rewards[address(arg1)][address(arg2)]
            require supply[address(arg1)][address(arg2)]
            if (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / supply[address(arg1)][address(arg2)] != rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]) - userRewardPerTokenPaid[address(arg1)][address(arg2)]:
                revert with 0, 'SafeMath: multiplication overflow'
            if ((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)] < (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            return (((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)])
        require (block.timestamp * sub_3d3b2603[address(arg2)]) - (sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)])
        if (10^18 * block.timestamp * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / (block.timestamp * sub_3d3b2603[address(arg2)]) - (sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        if supply[address(arg2)] <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        require supply[address(arg2)]
        if rewardPerTokenStored[address(arg2)] + ((10^18 * block.timestamp * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)]) < rewardPerTokenStored[address(arg2)]:
            revert with 0, 'SafeMath: addition overflow'
        if userRewardPerTokenPaid[address(arg1)][address(arg2)] > rewardPerTokenStored[address(arg2)] + ((10^18 * block.timestamp * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)]):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not supply[address(arg1)][address(arg2)]:
            if rewards[address(arg1)][address(arg2)] < 0:
                revert with 0, 'SafeMath: addition overflow'
            return rewards[address(arg1)][address(arg2)]
        require supply[address(arg1)][address(arg2)]
        if (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + ((10^18 * block.timestamp * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / supply[address(arg1)][address(arg2)] != rewardPerTokenStored[address(arg2)] + ((10^18 * block.timestamp * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)]) - userRewardPerTokenPaid[address(arg1)][address(arg2)]:
            revert with 0, 'SafeMath: multiplication overflow'
        if ((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + ((10^18 * block.timestamp * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)] < (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + ((10^18 * block.timestamp * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return (((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + ((10^18 * block.timestamp * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)])
    if sub_28bcf07a[address(arg2)] > closingTime:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not closingTime - sub_28bcf07a[address(arg2)]:
        if supply[address(arg2)] <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        require supply[address(arg2)]
        if rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]) < rewardPerTokenStored[address(arg2)]:
            revert with 0, 'SafeMath: addition overflow'
        if userRewardPerTokenPaid[address(arg1)][address(arg2)] > rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not supply[address(arg1)][address(arg2)]:
            if rewards[address(arg1)][address(arg2)] < 0:
                revert with 0, 'SafeMath: addition overflow'
            return rewards[address(arg1)][address(arg2)]
        require supply[address(arg1)][address(arg2)]
        if (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / supply[address(arg1)][address(arg2)] != rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]) - userRewardPerTokenPaid[address(arg1)][address(arg2)]:
            revert with 0, 'SafeMath: multiplication overflow'
        if ((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)] < (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return (((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)])
    require closingTime - sub_28bcf07a[address(arg2)]
    if (closingTime * sub_3d3b2603[address(arg2)]) - (sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / closingTime - sub_28bcf07a[address(arg2)] != sub_3d3b2603[address(arg2)]:
        revert with 0, 'SafeMath: multiplication overflow'
    if not (closingTime * sub_3d3b2603[address(arg2)]) - (sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]):
        if supply[address(arg2)] <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        require supply[address(arg2)]
        if rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]) < rewardPerTokenStored[address(arg2)]:
            revert with 0, 'SafeMath: addition overflow'
        if userRewardPerTokenPaid[address(arg1)][address(arg2)] > rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if not supply[address(arg1)][address(arg2)]:
            if rewards[address(arg1)][address(arg2)] < 0:
                revert with 0, 'SafeMath: addition overflow'
            return rewards[address(arg1)][address(arg2)]
        require supply[address(arg1)][address(arg2)]
        if (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / supply[address(arg1)][address(arg2)] != rewardPerTokenStored[address(arg2)] + (0 / supply[address(arg2)]) - userRewardPerTokenPaid[address(arg1)][address(arg2)]:
            revert with 0, 'SafeMath: multiplication overflow'
        if ((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)] < (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        return (((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + (0 / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)])
    require (closingTime * sub_3d3b2603[address(arg2)]) - (sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)])
    if (10^18 * closingTime * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / (closingTime * sub_3d3b2603[address(arg2)]) - (sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) != 10^18:
        revert with 0, 'SafeMath: multiplication overflow'
    if supply[address(arg2)] <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    require supply[address(arg2)]
    if rewardPerTokenStored[address(arg2)] + ((10^18 * closingTime * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)]) < rewardPerTokenStored[address(arg2)]:
        revert with 0, 'SafeMath: addition overflow'
    if userRewardPerTokenPaid[address(arg1)][address(arg2)] > rewardPerTokenStored[address(arg2)] + ((10^18 * closingTime * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)]):
        revert with 0, 'SafeMath: subtraction overflow', 0
    if not supply[address(arg1)][address(arg2)]:
        if rewards[address(arg1)][address(arg2)] < 0:
            revert with 0, 'SafeMath: addition overflow'
        return rewards[address(arg1)][address(arg2)]
    require supply[address(arg1)][address(arg2)]
    if (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + ((10^18 * closingTime * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / supply[address(arg1)][address(arg2)] != rewardPerTokenStored[address(arg2)] + ((10^18 * closingTime * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)]) - userRewardPerTokenPaid[address(arg1)][address(arg2)]:
        revert with 0, 'SafeMath: multiplication overflow'
    if ((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + ((10^18 * closingTime * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)] < (rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + ((10^18 * closingTime * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18:
        revert with 0, 'SafeMath: addition overflow'
    return (((rewardPerTokenStored[address(arg2)] * supply[address(arg1)][address(arg2)]) + ((10^18 * closingTime * sub_3d3b2603[address(arg2)]) - (10^18 * sub_28bcf07a[address(arg2)] * sub_3d3b2603[address(arg2)]) / supply[address(arg2)] * supply[address(arg1)][address(arg2)]) - (userRewardPerTokenPaid[address(arg1)][address(arg2)] * supply[address(arg1)][address(arg2)]) / 10^18) + rewards[address(arg1)][address(arg2)])
}

function totalEarned(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    idx = 0
    s = 0
    while idx < stor26.length:
        if stor26.length <= idx:
            revert with 0, 'EnumerableSet: index out of bounds'
        require idx < stor26.length
        mem[0] = stor26[idx].field_0
        if not supply[stor26[idx].field_0]:
            mem[32] = 34
            _229 = mem[64]
            mem[64] = mem[64] + 64
            mem[_229] = 30
            mem[_229 + 32] = 'SafeMath: subtraction overflow'
            if userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] > rewardPerTokenStored[stor26[idx].field_0]:
                _230 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_230 + idx + 68] = mem[_229 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_230 + 98] = 0
                revert with memory
                  from mem[64]
                   len _230 + -mem[64] + 100
            mem[0] = stor26[idx].field_0
            mem[32] = sha3(address(arg1), 1)
            if not supply[address(arg1)][stor26[idx].field_0]:
                _241 = mem[64]
                mem[64] = mem[64] + 64
                mem[_241] = 26
                mem[_241 + 32] = 'SafeMath: division by zero'
                if rewards[address(arg1)][stor26[idx].field_0] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s + rewards[address(arg1)][stor26[idx].field_0] < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + rewards[address(arg1)][stor26[idx].field_0]
                continue 
            require supply[address(arg1)][stor26[idx].field_0]
            if (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / supply[address(arg1)][stor26[idx].field_0] != rewardPerTokenStored[stor26[idx].field_0] - userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0]:
                revert with 0, 'SafeMath: multiplication overflow'
            _243 = mem[64]
            mem[64] = mem[64] + 64
            mem[_243] = 26
            mem[_243 + 32] = 'SafeMath: division by zero'
            if ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            if s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0]
            continue 
        mem[32] = 32
        if block.timestamp < closingTime:
            _234 = mem[64]
            mem[64] = mem[64] + 64
            mem[_234] = 30
            mem[_234 + 32] = 'SafeMath: subtraction overflow'
            if sub_28bcf07a[stor26[idx].field_0] > block.timestamp:
                _236 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_236 + idx + 68] = mem[_234 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_236 + 98] = 0
                revert with memory
                  from mem[64]
                   len _236 + -mem[64] + 100
            if not block.timestamp - sub_28bcf07a[stor26[idx].field_0]:
                _252 = mem[64]
                mem[64] = mem[64] + 64
                mem[_252] = 26
                mem[_252 + 32] = 'SafeMath: division by zero'
                if supply[stor26[idx].field_0] <= 0:
                    _260 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_260 + idx + 68] = mem[_252 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_260 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _260 + -mem[64] + 100
                require supply[stor26[idx].field_0]
                mem[0] = stor26[idx].field_0
                mem[32] = 34
                if rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]) < rewardPerTokenStored[stor26[idx].field_0]:
                    revert with 0, 'SafeMath: addition overflow'
                _297 = mem[64]
                mem[64] = mem[64] + 64
                mem[_297] = 30
                mem[_297 + 32] = 'SafeMath: subtraction overflow'
                if userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] > rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]):
                    _305 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_305 + idx + 68] = mem[_297 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_305 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _305 + -mem[64] + 100
                mem[0] = stor26[idx].field_0
                mem[32] = sha3(address(arg1), 1)
                if not supply[address(arg1)][stor26[idx].field_0]:
                    _354 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_354] = 26
                    mem[_354 + 32] = 'SafeMath: division by zero'
                    if rewards[address(arg1)][stor26[idx].field_0] < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if s + rewards[address(arg1)][stor26[idx].field_0] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = s + rewards[address(arg1)][stor26[idx].field_0]
                    continue 
                require supply[address(arg1)][stor26[idx].field_0]
                if (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / supply[address(arg1)][stor26[idx].field_0] != rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]) - userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _363 = mem[64]
                mem[64] = mem[64] + 64
                mem[_363] = 26
                mem[_363 + 32] = 'SafeMath: division by zero'
                if ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                if s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0]
                continue 
            require block.timestamp - sub_28bcf07a[stor26[idx].field_0]
            if (block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / block.timestamp - sub_28bcf07a[stor26[idx].field_0] != sub_3d3b2603[stor26[idx].field_0]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]):
                _259 = mem[64]
                mem[64] = mem[64] + 64
                mem[_259] = 26
                mem[_259 + 32] = 'SafeMath: division by zero'
                if supply[stor26[idx].field_0] <= 0:
                    _265 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_265 + idx + 68] = mem[_259 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_265 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _265 + -mem[64] + 100
                require supply[stor26[idx].field_0]
                mem[0] = stor26[idx].field_0
                mem[32] = 34
                if rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]) < rewardPerTokenStored[stor26[idx].field_0]:
                    revert with 0, 'SafeMath: addition overflow'
                _303 = mem[64]
                mem[64] = mem[64] + 64
                mem[_303] = 30
                mem[_303 + 32] = 'SafeMath: subtraction overflow'
                if userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] > rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]):
                    _313 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_313 + idx + 68] = mem[_303 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_313 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _313 + -mem[64] + 100
                mem[0] = stor26[idx].field_0
                mem[32] = sha3(address(arg1), 1)
                if not supply[address(arg1)][stor26[idx].field_0]:
                    _361 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_361] = 26
                    mem[_361 + 32] = 'SafeMath: division by zero'
                    if rewards[address(arg1)][stor26[idx].field_0] < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if s + rewards[address(arg1)][stor26[idx].field_0] < s:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = idx + 1
                    s = s + rewards[address(arg1)][stor26[idx].field_0]
                    continue 
                require supply[address(arg1)][stor26[idx].field_0]
                if (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / supply[address(arg1)][stor26[idx].field_0] != rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]) - userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _371 = mem[64]
                mem[64] = mem[64] + 64
                mem[_371] = 26
                mem[_371 + 32] = 'SafeMath: division by zero'
                if ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18:
                    revert with 0, 'SafeMath: addition overflow'
                if s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0]
                continue 
            require (block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0])
            if (10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / (block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) != 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _264 = mem[64]
            mem[64] = mem[64] + 64
            mem[_264] = 26
            mem[_264 + 32] = 'SafeMath: division by zero'
            if supply[stor26[idx].field_0] <= 0:
                _278 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_278 + idx + 68] = mem[_264 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_278 + 94] = 0
                revert with memory
                  from mem[64]
                   len _278 + -mem[64] + 100
            require supply[stor26[idx].field_0]
            mem[0] = stor26[idx].field_0
            mem[32] = 34
            if rewardPerTokenStored[stor26[idx].field_0] + ((10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0]) < rewardPerTokenStored[stor26[idx].field_0]:
                revert with 0, 'SafeMath: addition overflow'
            _311 = mem[64]
            mem[64] = mem[64] + 64
            mem[_311] = 30
            mem[_311 + 32] = 'SafeMath: subtraction overflow'
            if userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] > rewardPerTokenStored[stor26[idx].field_0] + ((10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0]):
                _325 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_325 + idx + 68] = mem[_311 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_325 + 98] = 0
                revert with memory
                  from mem[64]
                   len _325 + -mem[64] + 100
            mem[0] = stor26[idx].field_0
            mem[32] = sha3(address(arg1), 1)
            if not supply[address(arg1)][stor26[idx].field_0]:
                _369 = mem[64]
                mem[64] = mem[64] + 64
                mem[_369] = 26
                mem[_369 + 32] = 'SafeMath: division by zero'
                if rewards[address(arg1)][stor26[idx].field_0] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s + rewards[address(arg1)][stor26[idx].field_0] < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + rewards[address(arg1)][stor26[idx].field_0]
                continue 
            require supply[address(arg1)][stor26[idx].field_0]
            if (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / supply[address(arg1)][stor26[idx].field_0] != rewardPerTokenStored[stor26[idx].field_0] + ((10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0]) - userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0]:
                revert with 0, 'SafeMath: multiplication overflow'
            _377 = mem[64]
            mem[64] = mem[64] + 64
            mem[_377] = 26
            mem[_377 + 32] = 'SafeMath: division by zero'
            if ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            if s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * block.timestamp * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0]
            continue 
        _235 = mem[64]
        mem[64] = mem[64] + 64
        mem[_235] = 30
        mem[_235 + 32] = 'SafeMath: subtraction overflow'
        if sub_28bcf07a[stor26[idx].field_0] > closingTime:
            _237 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_237 + idx + 68] = mem[_235 + idx + 32]
                idx = idx + 32
                continue 
            mem[_237 + 98] = 0
            revert with memory
              from mem[64]
               len _237 + -mem[64] + 100
        if not closingTime - sub_28bcf07a[stor26[idx].field_0]:
            _253 = mem[64]
            mem[64] = mem[64] + 64
            mem[_253] = 26
            mem[_253 + 32] = 'SafeMath: division by zero'
            if supply[stor26[idx].field_0] <= 0:
                _262 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_262 + idx + 68] = mem[_253 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_262 + 94] = 0
                revert with memory
                  from mem[64]
                   len _262 + -mem[64] + 100
            require supply[stor26[idx].field_0]
            mem[0] = stor26[idx].field_0
            mem[32] = 34
            if rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]) < rewardPerTokenStored[stor26[idx].field_0]:
                revert with 0, 'SafeMath: addition overflow'
            _300 = mem[64]
            mem[64] = mem[64] + 64
            mem[_300] = 30
            mem[_300 + 32] = 'SafeMath: subtraction overflow'
            if userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] > rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]):
                _309 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_309 + idx + 68] = mem[_300 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_309 + 98] = 0
                revert with memory
                  from mem[64]
                   len _309 + -mem[64] + 100
            mem[0] = stor26[idx].field_0
            mem[32] = sha3(address(arg1), 1)
            if not supply[address(arg1)][stor26[idx].field_0]:
                _357 = mem[64]
                mem[64] = mem[64] + 64
                mem[_357] = 26
                mem[_357 + 32] = 'SafeMath: division by zero'
                if rewards[address(arg1)][stor26[idx].field_0] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s + rewards[address(arg1)][stor26[idx].field_0] < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + rewards[address(arg1)][stor26[idx].field_0]
                continue 
            require supply[address(arg1)][stor26[idx].field_0]
            if (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / supply[address(arg1)][stor26[idx].field_0] != rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]) - userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0]:
                revert with 0, 'SafeMath: multiplication overflow'
            _366 = mem[64]
            mem[64] = mem[64] + 64
            mem[_366] = 26
            mem[_366 + 32] = 'SafeMath: division by zero'
            if ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            if s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0]
            continue 
        require closingTime - sub_28bcf07a[stor26[idx].field_0]
        if (closingTime * sub_3d3b2603[stor26[idx].field_0]) - (sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / closingTime - sub_28bcf07a[stor26[idx].field_0] != sub_3d3b2603[stor26[idx].field_0]:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (closingTime * sub_3d3b2603[stor26[idx].field_0]) - (sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]):
            _261 = mem[64]
            mem[64] = mem[64] + 64
            mem[_261] = 26
            mem[_261 + 32] = 'SafeMath: division by zero'
            if supply[stor26[idx].field_0] <= 0:
                _268 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_268 + idx + 68] = mem[_261 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_268 + 94] = 0
                revert with memory
                  from mem[64]
                   len _268 + -mem[64] + 100
            require supply[stor26[idx].field_0]
            mem[0] = stor26[idx].field_0
            mem[32] = 34
            if rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]) < rewardPerTokenStored[stor26[idx].field_0]:
                revert with 0, 'SafeMath: addition overflow'
            _307 = mem[64]
            mem[64] = mem[64] + 64
            mem[_307] = 30
            mem[_307 + 32] = 'SafeMath: subtraction overflow'
            if userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] > rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]):
                _317 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_317 + idx + 68] = mem[_307 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_317 + 98] = 0
                revert with memory
                  from mem[64]
                   len _317 + -mem[64] + 100
            mem[0] = stor26[idx].field_0
            mem[32] = sha3(address(arg1), 1)
            if not supply[address(arg1)][stor26[idx].field_0]:
                _364 = mem[64]
                mem[64] = mem[64] + 64
                mem[_364] = 26
                mem[_364 + 32] = 'SafeMath: division by zero'
                if rewards[address(arg1)][stor26[idx].field_0] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if s + rewards[address(arg1)][stor26[idx].field_0] < s:
                    revert with 0, 'SafeMath: addition overflow'
                idx = idx + 1
                s = s + rewards[address(arg1)][stor26[idx].field_0]
                continue 
            require supply[address(arg1)][stor26[idx].field_0]
            if (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / supply[address(arg1)][stor26[idx].field_0] != rewardPerTokenStored[stor26[idx].field_0] + (0 / supply[stor26[idx].field_0]) - userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0]:
                revert with 0, 'SafeMath: multiplication overflow'
            _374 = mem[64]
            mem[64] = mem[64] + 64
            mem[_374] = 26
            mem[_374 + 32] = 'SafeMath: division by zero'
            if ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18:
                revert with 0, 'SafeMath: addition overflow'
            if s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + (0 / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0]
            continue 
        require (closingTime * sub_3d3b2603[stor26[idx].field_0]) - (sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0])
        if (10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / (closingTime * sub_3d3b2603[stor26[idx].field_0]) - (sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) != 10^18:
            revert with 0, 'SafeMath: multiplication overflow'
        _267 = mem[64]
        mem[64] = mem[64] + 64
        mem[_267] = 26
        mem[_267 + 32] = 'SafeMath: division by zero'
        if supply[stor26[idx].field_0] <= 0:
            _279 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_279 + idx + 68] = mem[_267 + idx + 32]
                idx = idx + 32
                continue 
            mem[_279 + 94] = 0
            revert with memory
              from mem[64]
               len _279 + -mem[64] + 100
        require supply[stor26[idx].field_0]
        mem[0] = stor26[idx].field_0
        mem[32] = 34
        if rewardPerTokenStored[stor26[idx].field_0] + ((10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0]) < rewardPerTokenStored[stor26[idx].field_0]:
            revert with 0, 'SafeMath: addition overflow'
        _315 = mem[64]
        mem[64] = mem[64] + 64
        mem[_315] = 30
        mem[_315 + 32] = 'SafeMath: subtraction overflow'
        if userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] > rewardPerTokenStored[stor26[idx].field_0] + ((10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0]):
            _328 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_328 + idx + 68] = mem[_315 + idx + 32]
                idx = idx + 32
                continue 
            mem[_328 + 98] = 0
            revert with memory
              from mem[64]
               len _328 + -mem[64] + 100
        mem[0] = stor26[idx].field_0
        mem[32] = sha3(address(arg1), 1)
        if not supply[address(arg1)][stor26[idx].field_0]:
            _372 = mem[64]
            mem[64] = mem[64] + 64
            mem[_372] = 26
            mem[_372 + 32] = 'SafeMath: division by zero'
            if rewards[address(arg1)][stor26[idx].field_0] < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s + rewards[address(arg1)][stor26[idx].field_0] < s:
                revert with 0, 'SafeMath: addition overflow'
            idx = idx + 1
            s = s + rewards[address(arg1)][stor26[idx].field_0]
            continue 
        require supply[address(arg1)][stor26[idx].field_0]
        if (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / supply[address(arg1)][stor26[idx].field_0] != rewardPerTokenStored[stor26[idx].field_0] + ((10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0]) - userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0]:
            revert with 0, 'SafeMath: multiplication overflow'
        _379 = mem[64]
        mem[64] = mem[64] + 64
        mem[_379] = 26
        mem[_379 + 32] = 'SafeMath: division by zero'
        if ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < (rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18:
            revert with 0, 'SafeMath: addition overflow'
        if s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0] < s:
            revert with 0, 'SafeMath: addition overflow'
        idx = idx + 1
        s = s + ((rewardPerTokenStored[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) + ((10^18 * closingTime * sub_3d3b2603[stor26[idx].field_0]) - (10^18 * sub_28bcf07a[stor26[idx].field_0] * sub_3d3b2603[stor26[idx].field_0]) / supply[stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) - (userRewardPerTokenPaid[address(arg1)][stor26[idx].field_0] * supply[address(arg1)][stor26[idx].field_0]) / 10^18) + rewards[address(arg1)][stor26[idx].field_0]
        continue 
    return s
}

function sub_d5808e3f(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    require arg3.length <= test266151307()
    require ceil32(arg3.length) + 128 <= test266151307() and ceil32(arg3.length) + 128 >= 96
    mem[64] = ceil32(arg3.length) + 128
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    mem[arg3.length + 128] = 0
    if address(arg1) != mainAddress:
        revert with 0, 'unsubscribed publisher'
    mem[ceil32(arg3.length) + 128] = 'open'
    if arg2 != sha3(Mask(32, -(8 * ceil32(arg3.length) + -arg3.length + 4) + 256, 0) >> -(8 * ceil32(arg3.length) + -arg3.length + 4) + 256):
        revert with 0, 'only topic: mint'
    require arg3.length >= 128
    _9 = mem[128]
    require mem[128] == mem[140 len 20]
    _11 = mem[160]
    require mem[160] == mem[172 len 20]
    require mem[192] == mem[192]
    _13 = mem[224]
    require mem[224] == mem[224]
    if stor27[mem[172 len 20]]:
        if block.timestamp >= openingTime:
            if block.timestamp <= closingTime:
                if not supply[address(mem[160])]:
                    if block.timestamp < closingTime:
                        sub_28bcf07a[address(mem[160])] = block.timestamp
                        if not mem[140 len 20]:
                            if totalSupply + mem[224] < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += mem[224]
                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            supply[address(mem[128])][address(mem[160])] += mem[224]
                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            supply[address(mem[160])] += mem[224]
                            if not totalSupply:
                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                            else:
                                idx = 0
                                while idx < stor24.length:
                                    if stor24.length <= idx:
                                        revert with 0, 'EnumerableSet: index out of bounds'
                                    require idx < stor24.length
                                    mem[0] = 24
                                    _9177 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9177] = 0
                                    mem[_9177 + 32] = 0
                                    mem[0] = stor24[idx]
                                    mem[32] = 23
                                    _9553 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9553] = sub_aeb22018[stor24[idx]].field_0
                                    mem[_9553 + 32] = sub_aeb22018[stor24[idx]].field_256
                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                        idx = idx + 1
                                        continue 
                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                        idx = idx + 1
                                        continue 
                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                    emit Mint(_13, address(_9), address(_11));
                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                emit Mint(_13, address(_9), address(_11));
                        else:
                            if not supply[address(mem[160])]:
                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if not supply[address(mem[128])][address(mem[160])]:
                                    mem[64] = ceil32(arg3.length) + 256
                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                    if totalSupply + mem[224] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[224]
                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[224]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9209 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9209] = 0
                                            mem[_9209 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _9637 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9637] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_9637 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_13, address(_9), address(_11));
                                else:
                                    require supply[address(mem[128])][address(mem[160])]
                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[64] = ceil32(arg3.length) + 256
                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                    if totalSupply + mem[224] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[224]
                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[224]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9208 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9208] = 0
                                            mem[_9208 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _9631 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9631] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_9631 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_13, address(_9), address(_11));
                            else:
                                if block.timestamp < closingTime:
                                    if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                        if supply[address(mem[160])] <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        require supply[address(mem[160])]
                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9189 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9189] = 0
                                                    mem[_9189 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9589 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9589] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9589 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9188 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9188] = 0
                                                    mem[_9188 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9583 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9583] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9583 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                    else:
                                        require block.timestamp - sub_28bcf07a[address(mem[160])]
                                        if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9185 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9185] = 0
                                                        mem[_9185 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9577 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9577] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9577 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9183 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9183] = 0
                                                        mem[_9183 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9571 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9571] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9571 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                            if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9179 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9179] = 0
                                                        mem[_9179 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9565 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9565] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9565 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9178 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9178] = 0
                                                        mem[_9178 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9559 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9559] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9559 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                else:
                                    if sub_28bcf07a[address(mem[160])] > closingTime:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if not closingTime - sub_28bcf07a[address(mem[160])]:
                                        if supply[address(mem[160])] <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        require supply[address(mem[160])]
                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9204 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9204] = 0
                                                    mem[_9204 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9625 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9625] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9625 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9203 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9203] = 0
                                                    mem[_9203 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9619 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9619] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9619 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                    else:
                                        require closingTime - sub_28bcf07a[address(mem[160])]
                                        if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9200 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9200] = 0
                                                        mem[_9200 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9613 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9613] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9613 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9198 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9198] = 0
                                                        mem[_9198 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9607 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9607] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9607 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                            if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9194 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9194] = 0
                                                        mem[_9194 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9601 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9601] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9601 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9193 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9193] = 0
                                                        mem[_9193 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9595 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9595] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9595 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                    else:
                        sub_28bcf07a[address(mem[160])] = closingTime
                        if not mem[140 len 20]:
                            if totalSupply + mem[224] < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += mem[224]
                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            supply[address(mem[128])][address(mem[160])] += mem[224]
                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            supply[address(mem[160])] += mem[224]
                            if not totalSupply:
                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                            else:
                                idx = 0
                                while idx < stor24.length:
                                    if stor24.length <= idx:
                                        revert with 0, 'EnumerableSet: index out of bounds'
                                    require idx < stor24.length
                                    mem[0] = 24
                                    _9211 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9211] = 0
                                    mem[_9211 + 32] = 0
                                    mem[0] = stor24[idx]
                                    mem[32] = 23
                                    _9643 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9643] = sub_aeb22018[stor24[idx]].field_0
                                    mem[_9643 + 32] = sub_aeb22018[stor24[idx]].field_256
                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                        idx = idx + 1
                                        continue 
                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                        idx = idx + 1
                                        continue 
                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                    emit Mint(_13, address(_9), address(_11));
                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                emit Mint(_13, address(_9), address(_11));
                        else:
                            if not supply[address(mem[160])]:
                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if not supply[address(mem[128])][address(mem[160])]:
                                    mem[64] = ceil32(arg3.length) + 256
                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                    if totalSupply + mem[224] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[224]
                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[224]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9243 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9243] = 0
                                            mem[_9243 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _9727 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9727] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_9727 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_13, address(_9), address(_11));
                                else:
                                    require supply[address(mem[128])][address(mem[160])]
                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[64] = ceil32(arg3.length) + 256
                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                    if totalSupply + mem[224] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[224]
                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[224]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9242 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9242] = 0
                                            mem[_9242 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _9721 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9721] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_9721 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_13, address(_9), address(_11));
                            else:
                                if block.timestamp < closingTime:
                                    if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                        if supply[address(mem[160])] <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        require supply[address(mem[160])]
                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9223 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9223] = 0
                                                    mem[_9223 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9679 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9679] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9679 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9222 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9222] = 0
                                                    mem[_9222 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9673 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9673] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9673 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                    else:
                                        require block.timestamp - sub_28bcf07a[address(mem[160])]
                                        if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9219 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9219] = 0
                                                        mem[_9219 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9667 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9667] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9667 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9217 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9217] = 0
                                                        mem[_9217 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9661 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9661] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9661 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                            if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9213 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9213] = 0
                                                        mem[_9213 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9655 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9655] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9655 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9212 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9212] = 0
                                                        mem[_9212 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9649 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9649] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9649 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                else:
                                    if sub_28bcf07a[address(mem[160])] > closingTime:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if not closingTime - sub_28bcf07a[address(mem[160])]:
                                        if supply[address(mem[160])] <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        require supply[address(mem[160])]
                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9238 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9238] = 0
                                                    mem[_9238 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9715 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9715] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9715 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9237 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9237] = 0
                                                    mem[_9237 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9709 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9709] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9709 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                    else:
                                        require closingTime - sub_28bcf07a[address(mem[160])]
                                        if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9234 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9234] = 0
                                                        mem[_9234 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9703 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9703] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9703 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9232 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9232] = 0
                                                        mem[_9232 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9697 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9697] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9697 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                            if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9228 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9228] = 0
                                                        mem[_9228 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9691 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9691] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9691 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9227 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9227] = 0
                                                        mem[_9227 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9685 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9685] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9685 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                else:
                    if block.timestamp < closingTime:
                        if sub_28bcf07a[address(mem[160])] > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                            mem[64] = ceil32(arg3.length) + 256
                            if supply[address(mem[160])] <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            require supply[address(mem[160])]
                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            rewardPerTokenStored[address(mem[160])] += 0 / supply[address(mem[160])]
                            if block.timestamp < closingTime:
                                sub_28bcf07a[address(mem[160])] = block.timestamp
                                if not mem[140 len 20]:
                                    if totalSupply + mem[224] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[224]
                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[224]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _8979 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8979] = 0
                                            mem[_8979 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _9349 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9349] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_9349 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_13, address(_9), address(_11));
                                else:
                                    if not supply[address(mem[160])]:
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9001 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9001] = 0
                                                    mem[_9001 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9369 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9369] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9369 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9000 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9000] = 0
                                                    mem[_9000 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9363 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9363] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9363 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if block.timestamp < closingTime:
                                            if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16330 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16330] = 0
                                                            mem[_16330 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16743 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16743] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16743 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16329 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16329] = 0
                                                            mem[_16329 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16737 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16737] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16737 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16328 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16328] = 0
                                                                mem[_16328 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16731 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16731] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16731 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16327 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16327] = 0
                                                                mem[_16327 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16725 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16725] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16725 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16326 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16326] = 0
                                                                mem[_16326 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16719 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16719] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16719 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16325 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16325] = 0
                                                                mem[_16325 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16713 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16713] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16713 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if sub_28bcf07a[address(mem[160])] > closingTime:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16336 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16336] = 0
                                                            mem[_16336 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16779 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16779] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16779 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16335 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16335] = 0
                                                            mem[_16335 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16773 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16773] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16773 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require closingTime - sub_28bcf07a[address(mem[160])]
                                                if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16334 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16334] = 0
                                                                mem[_16334 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16767 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16767] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16767 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16333 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16333] = 0
                                                                mem[_16333 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16761 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16761] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16761 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16332 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16332] = 0
                                                                mem[_16332 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16755 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16755] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16755 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16331 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16331] = 0
                                                                mem[_16331 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16749 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16749] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16749 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                            else:
                                sub_28bcf07a[address(mem[160])] = closingTime
                                if not mem[140 len 20]:
                                    if totalSupply + mem[224] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[224]
                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[224]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9003 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9003] = 0
                                            mem[_9003 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _9375 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9375] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_9375 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_13, address(_9), address(_11));
                                else:
                                    if not supply[address(mem[160])]:
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9025 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9025] = 0
                                                    mem[_9025 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9395 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9395] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9395 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9024 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9024] = 0
                                                    mem[_9024 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9389 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9389] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9389 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if block.timestamp < closingTime:
                                            if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16342 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16342] = 0
                                                            mem[_16342 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16815 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16815] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16815 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16341 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16341] = 0
                                                            mem[_16341 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16809 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16809] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16809 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16340 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16340] = 0
                                                                mem[_16340 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16803 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16803] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16803 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16339 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16339] = 0
                                                                mem[_16339 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16797 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16797] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16797 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16338 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16338] = 0
                                                                mem[_16338 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16791 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16791] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16791 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16337 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16337] = 0
                                                                mem[_16337 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16785 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16785] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16785 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if sub_28bcf07a[address(mem[160])] > closingTime:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16348 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16348] = 0
                                                            mem[_16348 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16851 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16851] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16851 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16347 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16347] = 0
                                                            mem[_16347 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16845 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16845] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16845 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require closingTime - sub_28bcf07a[address(mem[160])]
                                                if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16346 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16346] = 0
                                                                mem[_16346 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16839 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16839] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16839 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16345 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16345] = 0
                                                                mem[_16345 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16833 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16833] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16833 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16344 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16344] = 0
                                                                mem[_16344 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16827 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16827] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16827 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16343 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16343] = 0
                                                                mem[_16343 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16821 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16821] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16821 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                        else:
                            require block.timestamp - sub_28bcf07a[address(mem[160])]
                            if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                mem[64] = ceil32(arg3.length) + 256
                                if supply[address(mem[160])] <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                require supply[address(mem[160])]
                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                rewardPerTokenStored[address(mem[160])] += 0 / supply[address(mem[160])]
                                if block.timestamp < closingTime:
                                    sub_28bcf07a[address(mem[160])] = block.timestamp
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[224] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[224]
                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[224]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _8928 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8928] = 0
                                                mem[_8928 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _9297 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9297] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_9297 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _8951 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8951] = 0
                                                        mem[_8951 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9317 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9317] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9317 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _8949 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8949] = 0
                                                        mem[_8949 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9311 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9311] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9311 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16306 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16306] = 0
                                                                mem[_16306 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16599 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16599] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16599 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16305 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16305] = 0
                                                                mem[_16305 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16593 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16593] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16593 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16304 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16304] = 0
                                                                    mem[_16304 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16587 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16587] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16587 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16303 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16303] = 0
                                                                    mem[_16303 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16581 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16581] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16581 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16302 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16302] = 0
                                                                    mem[_16302 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16575 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16575] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16575 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16301 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16301] = 0
                                                                    mem[_16301 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16569 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16569] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16569 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16312 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16312] = 0
                                                                mem[_16312 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16635 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16635] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16635 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16311 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16311] = 0
                                                                mem[_16311 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16629 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16629] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16629 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16310 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16310] = 0
                                                                    mem[_16310 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16623 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16623] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16623 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16309 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16309] = 0
                                                                    mem[_16309 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16617 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16617] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16617 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16308 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16308] = 0
                                                                    mem[_16308 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16611 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16611] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16611 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16307 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16307] = 0
                                                                    mem[_16307 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16605 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16605] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16605 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                else:
                                    sub_28bcf07a[address(mem[160])] = closingTime
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[224] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[224]
                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[224]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _8953 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8953] = 0
                                                mem[_8953 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _9323 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9323] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_9323 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _8976 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8976] = 0
                                                        mem[_8976 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9343 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9343] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9343 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _8974 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8974] = 0
                                                        mem[_8974 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9337 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9337] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9337 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16318 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16318] = 0
                                                                mem[_16318 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16671 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16671] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16671 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16317 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16317] = 0
                                                                mem[_16317 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16665 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16665] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16665 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16316 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16316] = 0
                                                                    mem[_16316 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16659 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16659] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16659 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16315 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16315] = 0
                                                                    mem[_16315 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16653 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16653] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16653 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16314 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16314] = 0
                                                                    mem[_16314 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16647 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16647] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16647 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16313 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16313] = 0
                                                                    mem[_16313 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16641 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16641] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16641 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16324 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16324] = 0
                                                                mem[_16324 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16707 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16707] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16707 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16323 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16323] = 0
                                                                mem[_16323 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16701 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16701] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16701 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16322 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16322] = 0
                                                                    mem[_16322 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16695 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16695] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16695 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16321 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16321] = 0
                                                                    mem[_16321 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16689 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16689] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16689 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16320 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16320] = 0
                                                                    mem[_16320 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16683 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16683] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16683 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16319 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16319] = 0
                                                                    mem[_16319 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16677 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16677] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16677 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                            else:
                                require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = ceil32(arg3.length) + 256
                                if supply[address(mem[160])] <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                require supply[address(mem[160])]
                                if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                rewardPerTokenStored[address(mem[160])] += (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]
                                if block.timestamp < closingTime:
                                    sub_28bcf07a[address(mem[160])] = block.timestamp
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[224] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[224]
                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[224]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _8881 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8881] = 0
                                                mem[_8881 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _9249 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9249] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_9249 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _8901 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8901] = 0
                                                        mem[_8901 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9267 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9267] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9267 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _8900 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8900] = 0
                                                        mem[_8900 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9261 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9261] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9261 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16282 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16282] = 0
                                                                mem[_16282 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16455 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16455] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16455 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16281 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16281] = 0
                                                                mem[_16281 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16449 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16449] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16449 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16280 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16280] = 0
                                                                    mem[_16280 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16443 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16443] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16443 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16279 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16279] = 0
                                                                    mem[_16279 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16437 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16437] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16437 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16278 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16278] = 0
                                                                    mem[_16278 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16431 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16431] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16431 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16277 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16277] = 0
                                                                    mem[_16277 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16425 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16425] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16425 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16288 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16288] = 0
                                                                mem[_16288 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16491 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16491] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16491 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16287 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16287] = 0
                                                                mem[_16287 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16485 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16485] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16485 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16286 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16286] = 0
                                                                    mem[_16286 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16479 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16479] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16479 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16285 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16285] = 0
                                                                    mem[_16285 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16473 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16473] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16473 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16284 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16284] = 0
                                                                    mem[_16284 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16467 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16467] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16467 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16283 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16283] = 0
                                                                    mem[_16283 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16461 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16461] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16461 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                else:
                                    sub_28bcf07a[address(mem[160])] = closingTime
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[224] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[224]
                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[224]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _8904 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8904] = 0
                                                mem[_8904 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _9273 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9273] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_9273 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _8924 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8924] = 0
                                                        mem[_8924 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9291 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9291] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9291 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _8923 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8923] = 0
                                                        mem[_8923 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9285 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9285] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9285 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16294 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16294] = 0
                                                                mem[_16294 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16527 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16527] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16527 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16293 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16293] = 0
                                                                mem[_16293 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16521 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16521] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16521 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16292 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16292] = 0
                                                                    mem[_16292 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16515 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16515] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16515 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16291 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16291] = 0
                                                                    mem[_16291 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16509 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16509] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16509 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16290 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16290] = 0
                                                                    mem[_16290 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16503 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16503] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16503 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16289 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16289] = 0
                                                                    mem[_16289 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16497 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16497] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16497 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16300 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16300] = 0
                                                                mem[_16300 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16563 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16563] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16563 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16299 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16299] = 0
                                                                mem[_16299 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16557 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16557] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16557 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16298 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16298] = 0
                                                                    mem[_16298 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16551 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16551] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16551 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16297 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16297] = 0
                                                                    mem[_16297 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16545 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16545] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16545 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16296 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16296] = 0
                                                                    mem[_16296 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16539 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16539] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16539 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16295 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16295] = 0
                                                                    mem[_16295 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16533 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16533] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16533 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                    else:
                        if sub_28bcf07a[address(mem[160])] > closingTime:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if not closingTime - sub_28bcf07a[address(mem[160])]:
                            mem[64] = ceil32(arg3.length) + 256
                            if supply[address(mem[160])] <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            require supply[address(mem[160])]
                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            rewardPerTokenStored[address(mem[160])] += 0 / supply[address(mem[160])]
                            if block.timestamp < closingTime:
                                sub_28bcf07a[address(mem[160])] = block.timestamp
                                if not mem[140 len 20]:
                                    if totalSupply + mem[224] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[224]
                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[224]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9127 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9127] = 0
                                            mem[_9127 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _9501 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9501] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_9501 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_13, address(_9), address(_11));
                                else:
                                    if not supply[address(mem[160])]:
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9149 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9149] = 0
                                                    mem[_9149 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9521 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9521] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9521 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9148 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9148] = 0
                                                    mem[_9148 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9515 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9515] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9515 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if block.timestamp < closingTime:
                                            if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16402 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16402] = 0
                                                            mem[_16402 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17175 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17175] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17175 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16401 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16401] = 0
                                                            mem[_16401 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17169 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17169] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17169 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16400 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16400] = 0
                                                                mem[_16400 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17163 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17163] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17163 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16399 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16399] = 0
                                                                mem[_16399 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17157 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17157] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17157 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16398 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16398] = 0
                                                                mem[_16398 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17151 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17151] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17151 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16397 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16397] = 0
                                                                mem[_16397 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17145 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17145] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17145 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if sub_28bcf07a[address(mem[160])] > closingTime:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16408 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16408] = 0
                                                            mem[_16408 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17211 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17211] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17211 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16407 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16407] = 0
                                                            mem[_16407 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17205 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17205] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17205 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require closingTime - sub_28bcf07a[address(mem[160])]
                                                if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16406 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16406] = 0
                                                                mem[_16406 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17199 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17199] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17199 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16405 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16405] = 0
                                                                mem[_16405 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17193 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17193] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17193 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16404 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16404] = 0
                                                                mem[_16404 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17187 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17187] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17187 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16403 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16403] = 0
                                                                mem[_16403 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17181 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17181] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17181 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                            else:
                                sub_28bcf07a[address(mem[160])] = closingTime
                                if not mem[140 len 20]:
                                    if totalSupply + mem[224] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[224]
                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[224]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9151 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9151] = 0
                                            mem[_9151 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _9527 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9527] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_9527 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_13, address(_9), address(_11));
                                else:
                                    if not supply[address(mem[160])]:
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9173 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9173] = 0
                                                    mem[_9173 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9547 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9547] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9547 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[224] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[224]
                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[224]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9172 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9172] = 0
                                                    mem[_9172 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _9541 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9541] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_9541 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if block.timestamp < closingTime:
                                            if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16414 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16414] = 0
                                                            mem[_16414 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17247 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17247] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17247 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16413 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16413] = 0
                                                            mem[_16413 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17241 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17241] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17241 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16412 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16412] = 0
                                                                mem[_16412 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17235 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17235] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17235 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16411 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16411] = 0
                                                                mem[_16411 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17229 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17229] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17229 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16410 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16410] = 0
                                                                mem[_16410 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17223 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17223] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17223 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16409 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16409] = 0
                                                                mem[_16409 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17217 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17217] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17217 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if sub_28bcf07a[address(mem[160])] > closingTime:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16420 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16420] = 0
                                                            mem[_16420 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17283 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17283] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17283 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[224] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[224]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[224]
                                                    if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[224]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16419 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16419] = 0
                                                            mem[_16419 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17277 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17277] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17277 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require closingTime - sub_28bcf07a[address(mem[160])]
                                                if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16418 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16418] = 0
                                                                mem[_16418 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17271 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17271] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17271 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16417 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16417] = 0
                                                                mem[_16417 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17265 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17265] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17265 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16416 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16416] = 0
                                                                mem[_16416 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17259 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17259] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17259 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16415 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16415] = 0
                                                                mem[_16415 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17253 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17253] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17253 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                        else:
                            require closingTime - sub_28bcf07a[address(mem[160])]
                            if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                mem[64] = ceil32(arg3.length) + 256
                                if supply[address(mem[160])] <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                require supply[address(mem[160])]
                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                rewardPerTokenStored[address(mem[160])] += 0 / supply[address(mem[160])]
                                if block.timestamp < closingTime:
                                    sub_28bcf07a[address(mem[160])] = block.timestamp
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[224] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[224]
                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[224]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _9076 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9076] = 0
                                                mem[_9076 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _9449 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9449] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_9449 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9099 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9099] = 0
                                                        mem[_9099 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9469 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9469] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9469 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9097 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9097] = 0
                                                        mem[_9097 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9463 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9463] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9463 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16378 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16378] = 0
                                                                mem[_16378 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17031 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17031] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17031 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16377 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16377] = 0
                                                                mem[_16377 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17025 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17025] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17025 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16376 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16376] = 0
                                                                    mem[_16376 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17019 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17019] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17019 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16375 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16375] = 0
                                                                    mem[_16375 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17013 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17013] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17013 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16374 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16374] = 0
                                                                    mem[_16374 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17007 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17007] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17007 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16373 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16373] = 0
                                                                    mem[_16373 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17001 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17001] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17001 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16384 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16384] = 0
                                                                mem[_16384 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17067 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17067] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17067 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16383 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16383] = 0
                                                                mem[_16383 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17061 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17061] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17061 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16382 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16382] = 0
                                                                    mem[_16382 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17055 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17055] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17055 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16381 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16381] = 0
                                                                    mem[_16381 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17049 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17049] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17049 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16380 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16380] = 0
                                                                    mem[_16380 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17043 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17043] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17043 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16379 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16379] = 0
                                                                    mem[_16379 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17037 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17037] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17037 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                else:
                                    sub_28bcf07a[address(mem[160])] = closingTime
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[224] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[224]
                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[224]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _9101 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9101] = 0
                                                mem[_9101 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _9475 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9475] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_9475 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9124 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9124] = 0
                                                        mem[_9124 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9495 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9495] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9495 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9122 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9122] = 0
                                                        mem[_9122 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9489 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9489] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9489 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16390 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16390] = 0
                                                                mem[_16390 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17103 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17103] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17103 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16389 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16389] = 0
                                                                mem[_16389 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17097 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17097] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17097 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16388 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16388] = 0
                                                                    mem[_16388 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17091 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17091] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17091 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16387 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16387] = 0
                                                                    mem[_16387 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17085 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17085] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17085 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16386 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16386] = 0
                                                                    mem[_16386 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17079 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17079] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17079 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16385 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16385] = 0
                                                                    mem[_16385 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17073 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17073] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17073 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16396 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16396] = 0
                                                                mem[_16396 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17139 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17139] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17139 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16395 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16395] = 0
                                                                mem[_16395 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17133 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17133] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17133 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16394 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16394] = 0
                                                                    mem[_16394 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17127 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17127] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17127 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16393 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16393] = 0
                                                                    mem[_16393 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17121 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17121] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17121 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16392 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16392] = 0
                                                                    mem[_16392 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17115 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17115] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17115 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16391 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16391] = 0
                                                                    mem[_16391 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17109 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17109] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17109 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                            else:
                                require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = ceil32(arg3.length) + 256
                                if supply[address(mem[160])] <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                require supply[address(mem[160])]
                                if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                rewardPerTokenStored[address(mem[160])] += (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]
                                if block.timestamp < closingTime:
                                    sub_28bcf07a[address(mem[160])] = block.timestamp
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[224] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[224]
                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[224]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _9029 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9029] = 0
                                                mem[_9029 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _9401 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9401] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_9401 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9049 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9049] = 0
                                                        mem[_9049 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9419 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9419] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9419 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9048 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9048] = 0
                                                        mem[_9048 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9413 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9413] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9413 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16354 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16354] = 0
                                                                mem[_16354 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16887 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16887] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16887 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16353 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16353] = 0
                                                                mem[_16353 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16881 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16881] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16881 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16352 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16352] = 0
                                                                    mem[_16352 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16875 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16875] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16875 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16351 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16351] = 0
                                                                    mem[_16351 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16869 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16869] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16869 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16350 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16350] = 0
                                                                    mem[_16350 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16863 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16863] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16863 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16349 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16349] = 0
                                                                    mem[_16349 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16857 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16857] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16857 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16360 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16360] = 0
                                                                mem[_16360 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16923 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16923] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16923 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16359 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16359] = 0
                                                                mem[_16359 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16917 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16917] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16917 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16358 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16358] = 0
                                                                    mem[_16358 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16911 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16911] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16911 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16357 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16357] = 0
                                                                    mem[_16357 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16905 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16905] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16905 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16356 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16356] = 0
                                                                    mem[_16356 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16899 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16899] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16899 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16355 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16355] = 0
                                                                    mem[_16355 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16893 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16893] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16893 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                else:
                                    sub_28bcf07a[address(mem[160])] = closingTime
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[224] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[224]
                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[224]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _9052 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9052] = 0
                                                mem[_9052 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _9425 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9425] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_9425 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_13, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_13, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9072 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9072] = 0
                                                        mem[_9072 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9443 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9443] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9443 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[224] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[224]
                                                if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[224]
                                                if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[224]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9071 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9071] = 0
                                                        mem[_9071 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _9437 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9437] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_9437 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_13, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_13, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16366 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16366] = 0
                                                                mem[_16366 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16959 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16959] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16959 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16365 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16365] = 0
                                                                mem[_16365 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16953 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16953] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16953 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16364 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16364] = 0
                                                                    mem[_16364 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16947 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16947] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16947 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16363 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16363] = 0
                                                                    mem[_16363 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16941 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16941] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16941 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16362 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16362] = 0
                                                                    mem[_16362 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16935 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16935] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16935 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16361 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16361] = 0
                                                                    mem[_16361 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16929 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16929] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16929 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16372 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16372] = 0
                                                                mem[_16372 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16995 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16995] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16995 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[224] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[224]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[224]
                                                        if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[224]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16371 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16371] = 0
                                                                mem[_16371 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16989 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16989] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16989 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_13, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16370 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16370] = 0
                                                                    mem[_16370 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16983 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16983] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16983 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16369 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16369] = 0
                                                                    mem[_16369 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16977 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16977] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16977 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16368 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16368] = 0
                                                                    mem[_16368 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16971 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16971] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16971 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[224] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[224]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[224] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[224]
                                                            if supply[address(mem[160])] + mem[224] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[224]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[224], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16367 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16367] = 0
                                                                    mem[_16367 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16965 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16965] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16965 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_13, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_13, address(_9), address(_11));
}

function sub_81322e8c(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    require arg3.length <= test266151307()
    require ceil32(arg3.length) + 128 <= test266151307() and ceil32(arg3.length) + 128 >= 96
    mem[64] = ceil32(arg3.length) + 128
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    mem[arg3.length + 128] = 0
    if address(arg1) != mainAddress:
        revert with 0, 'unsubscribed publisher'
    mem[ceil32(arg3.length) + 128] = 'mint'
    if arg2 != sha3(Mask(32, -(8 * ceil32(arg3.length) + -arg3.length + 4) + 256, 0) >> -(8 * ceil32(arg3.length) + -arg3.length + 4) + 256):
        revert with 0, 'only topic: mint'
    require arg3.length >= 96
    _9 = mem[128]
    require mem[128] == mem[140 len 20]
    _11 = mem[160]
    require mem[160] == mem[172 len 20]
    _12 = mem[192]
    require mem[192] == mem[192]
    if stor27[mem[172 len 20]]:
        if block.timestamp >= openingTime:
            if block.timestamp <= closingTime:
                if not supply[address(mem[160])]:
                    if block.timestamp < closingTime:
                        sub_28bcf07a[address(mem[160])] = block.timestamp
                        if not mem[140 len 20]:
                            if totalSupply + mem[192] < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += mem[192]
                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            supply[address(mem[128])][address(mem[160])] += mem[192]
                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            supply[address(mem[160])] += mem[192]
                            if not totalSupply:
                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                            else:
                                idx = 0
                                while idx < stor24.length:
                                    if stor24.length <= idx:
                                        revert with 0, 'EnumerableSet: index out of bounds'
                                    require idx < stor24.length
                                    mem[0] = 24
                                    _10260 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10260] = 0
                                    mem[_10260 + 32] = 0
                                    mem[0] = stor24[idx]
                                    mem[32] = 23
                                    _10636 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10636] = sub_aeb22018[stor24[idx]].field_0
                                    mem[_10636 + 32] = sub_aeb22018[stor24[idx]].field_256
                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                        idx = idx + 1
                                        continue 
                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                        idx = idx + 1
                                        continue 
                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                    emit Mint(_12, address(_9), address(_11));
                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                emit Mint(_12, address(_9), address(_11));
                        else:
                            if not supply[address(mem[160])]:
                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if not supply[address(mem[128])][address(mem[160])]:
                                    mem[64] = ceil32(arg3.length) + 256
                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                    if totalSupply + mem[192] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[192]
                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[192]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _10288 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10288] = 0
                                            mem[_10288 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _10720 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10720] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_10720 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_12, address(_9), address(_11));
                                else:
                                    require supply[address(mem[128])][address(mem[160])]
                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[64] = ceil32(arg3.length) + 256
                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                    if totalSupply + mem[192] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[192]
                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[192]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _10287 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10287] = 0
                                            mem[_10287 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _10714 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10714] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_10714 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_12, address(_9), address(_11));
                            else:
                                if block.timestamp < closingTime:
                                    if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                        if supply[address(mem[160])] <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        require supply[address(mem[160])]
                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10270 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10270] = 0
                                                    mem[_10270 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10672 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10672] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10672 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10269 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10269] = 0
                                                    mem[_10269 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10666 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10666] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10666 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                    else:
                                        require block.timestamp - sub_28bcf07a[address(mem[160])]
                                        if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10266 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10266] = 0
                                                        mem[_10266 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10660 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10660] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10660 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10265 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10265] = 0
                                                        mem[_10265 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10654 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10654] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10654 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                            if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10262 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10262] = 0
                                                        mem[_10262 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10648 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10648] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10648 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10261 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10261] = 0
                                                        mem[_10261 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10642 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10642] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10642 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                else:
                                    if sub_28bcf07a[address(mem[160])] > closingTime:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if not closingTime - sub_28bcf07a[address(mem[160])]:
                                        if supply[address(mem[160])] <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        require supply[address(mem[160])]
                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10283 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10283] = 0
                                                    mem[_10283 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10708 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10708] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10708 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10282 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10282] = 0
                                                    mem[_10282 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10702 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10702] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10702 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                    else:
                                        require closingTime - sub_28bcf07a[address(mem[160])]
                                        if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10279 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10279] = 0
                                                        mem[_10279 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10696 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10696] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10696 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10278 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10278] = 0
                                                        mem[_10278 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10690 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10690] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10690 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                            if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10275 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10275] = 0
                                                        mem[_10275 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10684 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10684] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10684 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10274 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10274] = 0
                                                        mem[_10274 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10678 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10678] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10678 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                    else:
                        sub_28bcf07a[address(mem[160])] = closingTime
                        if not mem[140 len 20]:
                            if totalSupply + mem[192] < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += mem[192]
                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            supply[address(mem[128])][address(mem[160])] += mem[192]
                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            supply[address(mem[160])] += mem[192]
                            if not totalSupply:
                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                            else:
                                idx = 0
                                while idx < stor24.length:
                                    if stor24.length <= idx:
                                        revert with 0, 'EnumerableSet: index out of bounds'
                                    require idx < stor24.length
                                    mem[0] = 24
                                    _10290 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10290] = 0
                                    mem[_10290 + 32] = 0
                                    mem[0] = stor24[idx]
                                    mem[32] = 23
                                    _10726 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10726] = sub_aeb22018[stor24[idx]].field_0
                                    mem[_10726 + 32] = sub_aeb22018[stor24[idx]].field_256
                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                        idx = idx + 1
                                        continue 
                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                        idx = idx + 1
                                        continue 
                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                    emit Mint(_12, address(_9), address(_11));
                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                emit Mint(_12, address(_9), address(_11));
                        else:
                            if not supply[address(mem[160])]:
                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if not supply[address(mem[128])][address(mem[160])]:
                                    mem[64] = ceil32(arg3.length) + 256
                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                    if totalSupply + mem[192] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[192]
                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[192]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _10318 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10318] = 0
                                            mem[_10318 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _10810 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10810] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_10810 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_12, address(_9), address(_11));
                                else:
                                    require supply[address(mem[128])][address(mem[160])]
                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[64] = ceil32(arg3.length) + 256
                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                        revert with 0, 'SafeMath: addition overflow'
                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                    if totalSupply + mem[192] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[192]
                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[192]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _10317 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10317] = 0
                                            mem[_10317 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _10804 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10804] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_10804 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_12, address(_9), address(_11));
                            else:
                                if block.timestamp < closingTime:
                                    if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                        if supply[address(mem[160])] <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        require supply[address(mem[160])]
                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10300 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10300] = 0
                                                    mem[_10300 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10762 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10762] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10762 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10299 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10299] = 0
                                                    mem[_10299 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10756 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10756] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10756 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                    else:
                                        require block.timestamp - sub_28bcf07a[address(mem[160])]
                                        if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10296 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10296] = 0
                                                        mem[_10296 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10750 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10750] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10750 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10295 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10295] = 0
                                                        mem[_10295 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10744 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10744] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10744 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                            if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10292 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10292] = 0
                                                        mem[_10292 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10738 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10738] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10738 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10291 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10291] = 0
                                                        mem[_10291 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10732 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10732] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10732 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                else:
                                    if sub_28bcf07a[address(mem[160])] > closingTime:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if not closingTime - sub_28bcf07a[address(mem[160])]:
                                        if supply[address(mem[160])] <= 0:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        require supply[address(mem[160])]
                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10313 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10313] = 0
                                                    mem[_10313 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10798 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10798] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10798 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10312 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10312] = 0
                                                    mem[_10312 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10792 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10792] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10792 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                    else:
                                        require closingTime - sub_28bcf07a[address(mem[160])]
                                        if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10309 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10309] = 0
                                                        mem[_10309 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10786 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10786] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10786 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10308 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10308] = 0
                                                        mem[_10308 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10780 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10780] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10780 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                            if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if supply[address(mem[160])] <= 0:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            require supply[address(mem[160])]
                                            if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10305 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10305] = 0
                                                        mem[_10305 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10774 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10774] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10774 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10304 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10304] = 0
                                                        mem[_10304 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10768 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10768] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10768 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                else:
                    if block.timestamp < closingTime:
                        if sub_28bcf07a[address(mem[160])] > block.timestamp:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                            mem[64] = ceil32(arg3.length) + 256
                            if supply[address(mem[160])] <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            require supply[address(mem[160])]
                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            rewardPerTokenStored[address(mem[160])] += 0 / supply[address(mem[160])]
                            if block.timestamp < closingTime:
                                sub_28bcf07a[address(mem[160])] = block.timestamp
                                if not mem[140 len 20]:
                                    if totalSupply + mem[192] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[192]
                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[192]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9942 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9942] = 0
                                            mem[_9942 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _10424 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10424] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_10424 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_12, address(_9), address(_11));
                                else:
                                    if not supply[address(mem[160])]:
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9982 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9982] = 0
                                                    mem[_9982 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10446 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10446] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10446 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _9981 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_9981] = 0
                                                    mem[_9981 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10440 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10440] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10440 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if block.timestamp < closingTime:
                                            if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16573 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16573] = 0
                                                            mem[_16573 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16986 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16986] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16986 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16572 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16572] = 0
                                                            mem[_16572 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _16980 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16980] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_16980 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16571 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16571] = 0
                                                                mem[_16571 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16974 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16974] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16974 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16570 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16570] = 0
                                                                mem[_16570 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16968 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16968] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16968 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16569 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16569] = 0
                                                                mem[_16569 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16962 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16962] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16962 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16568 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16568] = 0
                                                                mem[_16568 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16956 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16956] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16956 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if sub_28bcf07a[address(mem[160])] > closingTime:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16579 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16579] = 0
                                                            mem[_16579 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17022 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17022] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17022 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16578 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16578] = 0
                                                            mem[_16578 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17016 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17016] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17016 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require closingTime - sub_28bcf07a[address(mem[160])]
                                                if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16577 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16577] = 0
                                                                mem[_16577 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17010 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17010] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17010 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16576 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16576] = 0
                                                                mem[_16576 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17004 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17004] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17004 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16575 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16575] = 0
                                                                mem[_16575 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16998 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16998] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16998 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16574 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16574] = 0
                                                                mem[_16574 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16992 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16992] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16992 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                            else:
                                sub_28bcf07a[address(mem[160])] = closingTime
                                if not mem[140 len 20]:
                                    if totalSupply + mem[192] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[192]
                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[192]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _9984 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9984] = 0
                                            mem[_9984 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _10452 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10452] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_10452 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_12, address(_9), address(_11));
                                else:
                                    if not supply[address(mem[160])]:
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10024 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10024] = 0
                                                    mem[_10024 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10474 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10474] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10474 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10023 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10023] = 0
                                                    mem[_10023 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10468 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10468] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10468 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if block.timestamp < closingTime:
                                            if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16585 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16585] = 0
                                                            mem[_16585 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17058 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17058] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17058 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16584 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16584] = 0
                                                            mem[_16584 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17052 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17052] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17052 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16583 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16583] = 0
                                                                mem[_16583 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17046 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17046] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17046 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16582 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16582] = 0
                                                                mem[_16582 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17040 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17040] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17040 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16581 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16581] = 0
                                                                mem[_16581 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17034 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17034] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17034 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16580 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16580] = 0
                                                                mem[_16580 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17028 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17028] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17028 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if sub_28bcf07a[address(mem[160])] > closingTime:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16591 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16591] = 0
                                                            mem[_16591 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17094 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17094] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17094 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16590 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16590] = 0
                                                            mem[_16590 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17088 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17088] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17088 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require closingTime - sub_28bcf07a[address(mem[160])]
                                                if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16589 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16589] = 0
                                                                mem[_16589 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17082 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17082] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17082 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16588 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16588] = 0
                                                                mem[_16588 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17076 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17076] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17076 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16587 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16587] = 0
                                                                mem[_16587 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17070 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17070] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17070 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16586 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16586] = 0
                                                                mem[_16586 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17064 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17064] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17064 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                        else:
                            require block.timestamp - sub_28bcf07a[address(mem[160])]
                            if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                mem[64] = ceil32(arg3.length) + 256
                                if supply[address(mem[160])] <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                require supply[address(mem[160])]
                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                rewardPerTokenStored[address(mem[160])] += 0 / supply[address(mem[160])]
                                if block.timestamp < closingTime:
                                    sub_28bcf07a[address(mem[160])] = block.timestamp
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[192] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[192]
                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[192]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _9861 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9861] = 0
                                                mem[_9861 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _10372 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10372] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_10372 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9899 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9899] = 0
                                                        mem[_9899 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10392 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10392] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10392 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9898 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9898] = 0
                                                        mem[_9898 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10386 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10386] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10386 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16549 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16549] = 0
                                                                mem[_16549 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16842 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16842] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16842 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16548 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16548] = 0
                                                                mem[_16548 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16836 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16836] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16836 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16547 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16547] = 0
                                                                    mem[_16547 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16830 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16830] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16830 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16546 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16546] = 0
                                                                    mem[_16546 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16824 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16824] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16824 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16545 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16545] = 0
                                                                    mem[_16545 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16818 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16818] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16818 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16544 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16544] = 0
                                                                    mem[_16544 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16812 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16812] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16812 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16555 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16555] = 0
                                                                mem[_16555 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16878 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16878] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16878 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16554 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16554] = 0
                                                                mem[_16554 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16872 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16872] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16872 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16553 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16553] = 0
                                                                    mem[_16553 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16866 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16866] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16866 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16552 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16552] = 0
                                                                    mem[_16552 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16860 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16860] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16860 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16551 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16551] = 0
                                                                    mem[_16551 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16854 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16854] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16854 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16550 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16550] = 0
                                                                    mem[_16550 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16848 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16848] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16848 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                else:
                                    sub_28bcf07a[address(mem[160])] = closingTime
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[192] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[192]
                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[192]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _9901 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9901] = 0
                                                mem[_9901 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _10398 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10398] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_10398 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9939 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9939] = 0
                                                        mem[_9939 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10418 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10418] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10418 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9938 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9938] = 0
                                                        mem[_9938 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10412 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10412] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10412 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16561 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16561] = 0
                                                                mem[_16561 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16914 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16914] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16914 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16560 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16560] = 0
                                                                mem[_16560 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16908 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16908] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16908 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16559 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16559] = 0
                                                                    mem[_16559 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16902 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16902] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16902 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16558 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16558] = 0
                                                                    mem[_16558 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16896 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16896] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16896 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16557 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16557] = 0
                                                                    mem[_16557 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16890 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16890] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16890 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16556 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16556] = 0
                                                                    mem[_16556 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16884 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16884] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16884 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16567 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16567] = 0
                                                                mem[_16567 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16950 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16950] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16950 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16566 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16566] = 0
                                                                mem[_16566 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16944 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16944] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16944 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16565 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16565] = 0
                                                                    mem[_16565 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16938 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16938] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16938 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16564 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16564] = 0
                                                                    mem[_16564 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16932 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16932] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16932 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16563 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16563] = 0
                                                                    mem[_16563 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16926 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16926] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16926 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16562 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16562] = 0
                                                                    mem[_16562 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16920 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16920] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16920 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                            else:
                                require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = ceil32(arg3.length) + 256
                                if supply[address(mem[160])] <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                require supply[address(mem[160])]
                                if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                rewardPerTokenStored[address(mem[160])] += (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]
                                if block.timestamp < closingTime:
                                    sub_28bcf07a[address(mem[160])] = block.timestamp
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[192] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[192]
                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[192]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _9796 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9796] = 0
                                                mem[_9796 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _10324 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10324] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_10324 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9826 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9826] = 0
                                                        mem[_9826 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10342 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10342] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10342 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9825 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9825] = 0
                                                        mem[_9825 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10336 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10336] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10336 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16525 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16525] = 0
                                                                mem[_16525 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16698 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16698] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16698 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16524 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16524] = 0
                                                                mem[_16524 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16692 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16692] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16692 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16523 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16523] = 0
                                                                    mem[_16523 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16686 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16686] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16686 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16522 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16522] = 0
                                                                    mem[_16522 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16680 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16680] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16680 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16521 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16521] = 0
                                                                    mem[_16521 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16674 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16674] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16674 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16520 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16520] = 0
                                                                    mem[_16520 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16668 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16668] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16668 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16531 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16531] = 0
                                                                mem[_16531 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16734 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16734] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16734 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16530 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16530] = 0
                                                                mem[_16530 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16728 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16728] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16728 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16529 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16529] = 0
                                                                    mem[_16529 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16722 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16722] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16722 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16528 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16528] = 0
                                                                    mem[_16528 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16716 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16716] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16716 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16527 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16527] = 0
                                                                    mem[_16527 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16710 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16710] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16710 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16526 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16526] = 0
                                                                    mem[_16526 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16704 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16704] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16704 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                else:
                                    sub_28bcf07a[address(mem[160])] = closingTime
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[192] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[192]
                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[192]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _9828 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_9828] = 0
                                                mem[_9828 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _10348 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10348] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_10348 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9858 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9858] = 0
                                                        mem[_9858 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10366 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10366] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10366 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _9857 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_9857] = 0
                                                        mem[_9857 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10360 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10360] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10360 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16537 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16537] = 0
                                                                mem[_16537 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16770 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16770] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16770 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16536 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16536] = 0
                                                                mem[_16536 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16764 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16764] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16764 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16535 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16535] = 0
                                                                    mem[_16535 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16758 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16758] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16758 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16534 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16534] = 0
                                                                    mem[_16534 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16752 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16752] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16752 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16533 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16533] = 0
                                                                    mem[_16533 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16746 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16746] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16746 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16532 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16532] = 0
                                                                    mem[_16532 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16740 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16740] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16740 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16543 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16543] = 0
                                                                mem[_16543 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16806 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16806] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16806 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16542 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16542] = 0
                                                                mem[_16542 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _16800 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16800] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_16800 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16541 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16541] = 0
                                                                    mem[_16541 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16794 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16794] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16794 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16540 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16540] = 0
                                                                    mem[_16540 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16788 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16788] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16788 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16539 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16539] = 0
                                                                    mem[_16539 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16782 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16782] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16782 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16538 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16538] = 0
                                                                    mem[_16538 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _16776 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16776] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_16776 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                    else:
                        if sub_28bcf07a[address(mem[160])] > closingTime:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if not closingTime - sub_28bcf07a[address(mem[160])]:
                            mem[64] = ceil32(arg3.length) + 256
                            if supply[address(mem[160])] <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            require supply[address(mem[160])]
                            if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                revert with 0, 'SafeMath: addition overflow'
                            rewardPerTokenStored[address(mem[160])] += 0 / supply[address(mem[160])]
                            if block.timestamp < closingTime:
                                sub_28bcf07a[address(mem[160])] = block.timestamp
                                if not mem[140 len 20]:
                                    if totalSupply + mem[192] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[192]
                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[192]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _10174 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10174] = 0
                                            mem[_10174 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _10580 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10580] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_10580 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_12, address(_9), address(_11));
                                else:
                                    if not supply[address(mem[160])]:
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10214 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10214] = 0
                                                    mem[_10214 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10602 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10602] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10602 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10213 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10213] = 0
                                                    mem[_10213 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10596 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10596] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10596 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if block.timestamp < closingTime:
                                            if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16645 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16645] = 0
                                                            mem[_16645 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17418 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17418] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17418 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16644 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16644] = 0
                                                            mem[_16644 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17412 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17412] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17412 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16643 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16643] = 0
                                                                mem[_16643 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17406 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17406] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17406 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16642 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16642] = 0
                                                                mem[_16642 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17400 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17400] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17400 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16641 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16641] = 0
                                                                mem[_16641 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17394 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17394] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17394 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16640 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16640] = 0
                                                                mem[_16640 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17388 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17388] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17388 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if sub_28bcf07a[address(mem[160])] > closingTime:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16651 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16651] = 0
                                                            mem[_16651 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17454 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17454] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17454 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16650 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16650] = 0
                                                            mem[_16650 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17448 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17448] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17448 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require closingTime - sub_28bcf07a[address(mem[160])]
                                                if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16649 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16649] = 0
                                                                mem[_16649 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17442 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17442] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17442 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16648 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16648] = 0
                                                                mem[_16648 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17436 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17436] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17436 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16647 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16647] = 0
                                                                mem[_16647 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17430 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17430] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17430 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16646 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16646] = 0
                                                                mem[_16646 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17424 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17424] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17424 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                            else:
                                sub_28bcf07a[address(mem[160])] = closingTime
                                if not mem[140 len 20]:
                                    if totalSupply + mem[192] < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += mem[192]
                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    supply[address(mem[160])] += mem[192]
                                    if not totalSupply:
                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                    else:
                                        idx = 0
                                        while idx < stor24.length:
                                            if stor24.length <= idx:
                                                revert with 0, 'EnumerableSet: index out of bounds'
                                            require idx < stor24.length
                                            mem[0] = 24
                                            _10216 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10216] = 0
                                            mem[_10216 + 32] = 0
                                            mem[0] = stor24[idx]
                                            mem[32] = 23
                                            _10608 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_10608] = sub_aeb22018[stor24[idx]].field_0
                                            mem[_10608 + 32] = sub_aeb22018[stor24[idx]].field_256
                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                idx = idx + 1
                                                continue 
                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                idx = idx + 1
                                                continue 
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                        emit Mint(_12, address(_9), address(_11));
                                else:
                                    if not supply[address(mem[160])]:
                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if not supply[address(mem[128])][address(mem[160])]:
                                            mem[64] = ceil32(arg3.length) + 384
                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                revert with 0, 'SafeMath: addition overflow'
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10256 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10256] = 0
                                                    mem[_10256 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10630 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10630] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10630 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                        else:
                                            require supply[address(mem[128])][address(mem[160])]
                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            mem[64] = ceil32(arg3.length) + 384
                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                revert with 0, 'SafeMath: addition overflow'
                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                            if totalSupply + mem[192] < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += mem[192]
                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            supply[address(mem[160])] += mem[192]
                                            if not totalSupply:
                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                            else:
                                                idx = 0
                                                while idx < stor24.length:
                                                    if stor24.length <= idx:
                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                    require idx < stor24.length
                                                    mem[0] = 24
                                                    _10255 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10255] = 0
                                                    mem[_10255 + 32] = 0
                                                    mem[0] = stor24[idx]
                                                    mem[32] = 23
                                                    _10624 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_10624] = sub_aeb22018[stor24[idx]].field_0
                                                    mem[_10624 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                        idx = idx + 1
                                                        continue 
                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                        idx = idx + 1
                                                        continue 
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if block.timestamp < closingTime:
                                            if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16657 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16657] = 0
                                                            mem[_16657 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17490 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17490] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17490 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16656 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16656] = 0
                                                            mem[_16656 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17484 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17484] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17484 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16655 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16655] = 0
                                                                mem[_16655 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17478 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17478] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17478 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16654 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16654] = 0
                                                                mem[_16654 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17472 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17472] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17472 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16653 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16653] = 0
                                                                mem[_16653 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17466 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17466] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17466 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16652 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16652] = 0
                                                                mem[_16652 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17460 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17460] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17460 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if sub_28bcf07a[address(mem[160])] > closingTime:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                if supply[address(mem[160])] <= 0:
                                                    revert with 0, 'SafeMath: division by zero', 0
                                                require supply[address(mem[160])]
                                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not supply[address(mem[128])][address(mem[160])]:
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if rewards[address(mem[128])][address(mem[160])] < 0:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16663 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16663] = 0
                                                            mem[_16663 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17526 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17526] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17526 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require supply[address(mem[128])][address(mem[160])]
                                                    if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    mem[64] = ceil32(arg3.length) + 512
                                                    if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                    userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                    if totalSupply + mem[192] < totalSupply:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalSupply += mem[192]
                                                    if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[128])][address(mem[160])] += mem[192]
                                                    if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    supply[address(mem[160])] += mem[192]
                                                    if not totalSupply:
                                                        sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                        emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                        emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                    else:
                                                        idx = 0
                                                        while idx < stor24.length:
                                                            if stor24.length <= idx:
                                                                revert with 0, 'EnumerableSet: index out of bounds'
                                                            require idx < stor24.length
                                                            mem[0] = 24
                                                            _16662 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16662] = 0
                                                            mem[_16662 + 32] = 0
                                                            mem[0] = stor24[idx]
                                                            mem[32] = 23
                                                            _17520 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_17520] = sub_aeb22018[stor24[idx]].field_0
                                                            mem[_17520 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                            if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                idx = idx + 1
                                                                continue 
                                                            if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                idx = idx + 1
                                                                continue 
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require closingTime - sub_28bcf07a[address(mem[160])]
                                                if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16661 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16661] = 0
                                                                mem[_16661 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17514 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17514] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17514 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16660 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16660] = 0
                                                                mem[_16660 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17508 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17508] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17508 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                    if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16659 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16659] = 0
                                                                mem[_16659 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17502 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17502] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17502 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16658 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16658] = 0
                                                                mem[_16658 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17496 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17496] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17496 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                        else:
                            require closingTime - sub_28bcf07a[address(mem[160])]
                            if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                mem[64] = ceil32(arg3.length) + 256
                                if supply[address(mem[160])] <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                require supply[address(mem[160])]
                                if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                rewardPerTokenStored[address(mem[160])] += 0 / supply[address(mem[160])]
                                if block.timestamp < closingTime:
                                    sub_28bcf07a[address(mem[160])] = block.timestamp
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[192] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[192]
                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[192]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _10093 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10093] = 0
                                                mem[_10093 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _10528 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10528] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_10528 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10131 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10131] = 0
                                                        mem[_10131 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10548 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10548] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10548 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10130 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10130] = 0
                                                        mem[_10130 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10542 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10542] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10542 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16621 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16621] = 0
                                                                mem[_16621 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17274 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17274] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17274 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16620 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16620] = 0
                                                                mem[_16620 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17268 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17268] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17268 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16619 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16619] = 0
                                                                    mem[_16619 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17262 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17262] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17262 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16618 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16618] = 0
                                                                    mem[_16618 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17256 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17256] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17256 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16617 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16617] = 0
                                                                    mem[_16617 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17250 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17250] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17250 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16616 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16616] = 0
                                                                    mem[_16616 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17244 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17244] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17244 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16627 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16627] = 0
                                                                mem[_16627 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17310 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17310] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17310 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16626 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16626] = 0
                                                                mem[_16626 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17304 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17304] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17304 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16625 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16625] = 0
                                                                    mem[_16625 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17298 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17298] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17298 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16624 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16624] = 0
                                                                    mem[_16624 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17292 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17292] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17292 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16623 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16623] = 0
                                                                    mem[_16623 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17286 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17286] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17286 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16622 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16622] = 0
                                                                    mem[_16622 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17280 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17280] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17280 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                else:
                                    sub_28bcf07a[address(mem[160])] = closingTime
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[192] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[192]
                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[192]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _10133 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10133] = 0
                                                mem[_10133 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _10554 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10554] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_10554 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10171 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10171] = 0
                                                        mem[_10171 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10574 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10574] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10574 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10170 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10170] = 0
                                                        mem[_10170 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10568 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10568] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10568 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16633 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16633] = 0
                                                                mem[_16633 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17346 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17346] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17346 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16632 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16632] = 0
                                                                mem[_16632 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17340 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17340] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17340 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16631 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16631] = 0
                                                                    mem[_16631 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17334 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17334] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17334 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16630 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16630] = 0
                                                                    mem[_16630 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17328 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17328] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17328 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16629 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16629] = 0
                                                                    mem[_16629 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17322 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17322] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17322 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16628 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16628] = 0
                                                                    mem[_16628 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17316 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17316] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17316 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16639 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16639] = 0
                                                                mem[_16639 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17382 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17382] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17382 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16638 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16638] = 0
                                                                mem[_16638 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17376 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17376] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17376 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16637 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16637] = 0
                                                                    mem[_16637 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17370 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17370] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17370 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16636 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16636] = 0
                                                                    mem[_16636 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17364 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17364] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17364 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16635 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16635] = 0
                                                                    mem[_16635 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17358 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17358] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17358 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16634 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16634] = 0
                                                                    mem[_16634 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17352 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17352] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17352 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                            else:
                                require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = ceil32(arg3.length) + 256
                                if supply[address(mem[160])] <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                require supply[address(mem[160])]
                                if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                rewardPerTokenStored[address(mem[160])] += (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]
                                if block.timestamp < closingTime:
                                    sub_28bcf07a[address(mem[160])] = block.timestamp
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[192] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[192]
                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[192]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _10028 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10028] = 0
                                                mem[_10028 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _10480 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10480] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_10480 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10058 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10058] = 0
                                                        mem[_10058 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10498 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10498] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10498 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10057 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10057] = 0
                                                        mem[_10057 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10492 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10492] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10492 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16597 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16597] = 0
                                                                mem[_16597 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17130 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17130] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17130 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16596 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16596] = 0
                                                                mem[_16596 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17124 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17124] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17124 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16595 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16595] = 0
                                                                    mem[_16595 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17118 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17118] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17118 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16594 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16594] = 0
                                                                    mem[_16594 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17112 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17112] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17112 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16593 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16593] = 0
                                                                    mem[_16593 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17106 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17106] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17106 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16592 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16592] = 0
                                                                    mem[_16592 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17100 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17100] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17100 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16603 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16603] = 0
                                                                mem[_16603 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17166 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17166] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17166 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16602 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16602] = 0
                                                                mem[_16602 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17160 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17160] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17160 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16601 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16601] = 0
                                                                    mem[_16601 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17154 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17154] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17154 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16600 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16600] = 0
                                                                    mem[_16600 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17148 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17148] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17148 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16599 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16599] = 0
                                                                    mem[_16599 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17142 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17142] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17142 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16598 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16598] = 0
                                                                    mem[_16598 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17136 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17136] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17136 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                else:
                                    sub_28bcf07a[address(mem[160])] = closingTime
                                    if not mem[140 len 20]:
                                        if totalSupply + mem[192] < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += mem[192]
                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        supply[address(mem[160])] += mem[192]
                                        if not totalSupply:
                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                        else:
                                            idx = 0
                                            while idx < stor24.length:
                                                if stor24.length <= idx:
                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                require idx < stor24.length
                                                mem[0] = 24
                                                _10060 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10060] = 0
                                                mem[_10060 + 32] = 0
                                                mem[0] = stor24[idx]
                                                mem[32] = 23
                                                _10504 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_10504] = sub_aeb22018[stor24[idx]].field_0
                                                mem[_10504 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                    idx = idx + 1
                                                    continue 
                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                    idx = idx + 1
                                                    continue 
                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                emit Mint(_12, address(_9), address(_11));
                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                            emit Mint(_12, address(_9), address(_11));
                                    else:
                                        if not supply[address(mem[160])]:
                                            if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if not supply[address(mem[128])][address(mem[160])]:
                                                mem[64] = ceil32(arg3.length) + 384
                                                if rewards[address(mem[128])][address(mem[160])] < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10090 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10090] = 0
                                                        mem[_10090 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10522 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10522] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10522 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                            else:
                                                require supply[address(mem[128])][address(mem[160])]
                                                if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                mem[64] = ceil32(arg3.length) + 384
                                                if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                if totalSupply + mem[192] < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += mem[192]
                                                if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[128])][address(mem[160])] += mem[192]
                                                if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                supply[address(mem[160])] += mem[192]
                                                if not totalSupply:
                                                    sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                    emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                    emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                else:
                                                    idx = 0
                                                    while idx < stor24.length:
                                                        if stor24.length <= idx:
                                                            revert with 0, 'EnumerableSet: index out of bounds'
                                                        require idx < stor24.length
                                                        mem[0] = 24
                                                        _10089 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10089] = 0
                                                        mem[_10089 + 32] = 0
                                                        mem[0] = stor24[idx]
                                                        mem[32] = 23
                                                        _10516 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_10516] = sub_aeb22018[stor24[idx]].field_0
                                                        mem[_10516 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                        if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                            idx = idx + 1
                                                            continue 
                                                        if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                            idx = idx + 1
                                                            continue 
                                                        sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                        emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                        emit Mint(_12, address(_9), address(_11));
                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                    emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                    emit Mint(_12, address(_9), address(_11));
                                        else:
                                            if block.timestamp < closingTime:
                                                if sub_28bcf07a[address(mem[160])] > block.timestamp:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not block.timestamp - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16609 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16609] = 0
                                                                mem[_16609 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17202 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17202] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17202 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16608 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16608] = 0
                                                                mem[_16608 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17196 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17196] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17196 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require block.timestamp - sub_28bcf07a[address(mem[160])]
                                                    if (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / block.timestamp - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16607 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16607] = 0
                                                                    mem[_16607 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17190 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17190] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17190 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16606 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16606] = 0
                                                                    mem[_16606 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17184 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17184] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17184 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (block.timestamp * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16605 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16605] = 0
                                                                    mem[_16605 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17178 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17178] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17178 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * block.timestamp * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16604 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16604] = 0
                                                                    mem[_16604 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17172 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17172] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17172 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                            else:
                                                if sub_28bcf07a[address(mem[160])] > closingTime:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if not closingTime - sub_28bcf07a[address(mem[160])]:
                                                    if supply[address(mem[160])] <= 0:
                                                        revert with 0, 'SafeMath: division by zero', 0
                                                    require supply[address(mem[160])]
                                                    if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if not supply[address(mem[128])][address(mem[160])]:
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if rewards[address(mem[128])][address(mem[160])] < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16615 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16615] = 0
                                                                mem[_16615 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17238 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17238] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17238 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require supply[address(mem[128])][address(mem[160])]
                                                        if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        mem[64] = ceil32(arg3.length) + 512
                                                        if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                        userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                        if totalSupply + mem[192] < totalSupply:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        totalSupply += mem[192]
                                                        if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[128])][address(mem[160])] += mem[192]
                                                        if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        supply[address(mem[160])] += mem[192]
                                                        if not totalSupply:
                                                            sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                            emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                            emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                        else:
                                                            idx = 0
                                                            while idx < stor24.length:
                                                                if stor24.length <= idx:
                                                                    revert with 0, 'EnumerableSet: index out of bounds'
                                                                require idx < stor24.length
                                                                mem[0] = 24
                                                                _16614 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_16614] = 0
                                                                mem[_16614 + 32] = 0
                                                                mem[0] = stor24[idx]
                                                                mem[32] = 23
                                                                _17232 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_17232] = sub_aeb22018[stor24[idx]].field_0
                                                                mem[_17232 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                    idx = idx + 1
                                                                    continue 
                                                                if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                    idx = idx + 1
                                                                    continue 
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                            sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                            emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                            emit Mint(_12, address(_9), address(_11));
                                                else:
                                                    require closingTime - sub_28bcf07a[address(mem[160])]
                                                    if (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / closingTime - sub_28bcf07a[address(mem[160])] != sub_3d3b2603[address(mem[160])]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]):
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16613 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16613] = 0
                                                                    mem[_16613 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17226 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17226] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17226 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + (0 / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + (0 / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16612 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16612] = 0
                                                                    mem[_16612 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17220 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17220] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17220 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                    else:
                                                        require (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])])
                                                        if (10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / (closingTime * sub_3d3b2603[address(mem[160])]) - (sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) != 10^18:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if supply[address(mem[160])] <= 0:
                                                            revert with 0, 'SafeMath: division by zero', 0
                                                        require supply[address(mem[160])]
                                                        if rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) < rewardPerTokenStored[address(mem[160])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if userRewardPerTokenPaid[address(mem[128])][address(mem[160])] > rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]):
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if not supply[address(mem[128])][address(mem[160])]:
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if rewards[address(mem[128])][address(mem[160])] < 0:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16611 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16611] = 0
                                                                    mem[_16611 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17214 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17214] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17214 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
                                                        else:
                                                            require supply[address(mem[128])][address(mem[160])]
                                                            if (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / supply[address(mem[128])][address(mem[160])] != rewardPerTokenStored[address(mem[160])] + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])]) - userRewardPerTokenPaid[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            mem[64] = ceil32(arg3.length) + 512
                                                            if ((rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18) + rewards[address(mem[128])][address(mem[160])] < (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            rewards[address(mem[128])][address(mem[160])] += (rewardPerTokenStored[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) + ((10^18 * closingTime * sub_3d3b2603[address(mem[160])]) - (10^18 * sub_28bcf07a[address(mem[160])] * sub_3d3b2603[address(mem[160])]) / supply[address(mem[160])] * supply[address(mem[128])][address(mem[160])]) - (userRewardPerTokenPaid[address(mem[128])][address(mem[160])] * supply[address(mem[128])][address(mem[160])]) / 10^18
                                                            userRewardPerTokenPaid[address(mem[128])][address(mem[160])] = rewardPerTokenStored[address(mem[160])]
                                                            if totalSupply + mem[192] < totalSupply:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            totalSupply += mem[192]
                                                            if supply[address(mem[128])][address(mem[160])] + mem[192] < supply[address(mem[128])][address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[128])][address(mem[160])] += mem[192]
                                                            if supply[address(mem[160])] + mem[192] < supply[address(mem[160])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            supply[address(mem[160])] += mem[192]
                                                            if not totalSupply:
                                                                sub_3d3b2603[address(mem[160])] = sub_59281b1e[0][address(mem[160])] / 24 * 3600
                                                                emit 0x4256d14a: address(mem[160]), 0, sub_3d3b2603[address(mem[160])]
                                                                emit Mint(mem[192], mem[140 len 20], mem[172 len 20]);
                                                            else:
                                                                idx = 0
                                                                while idx < stor24.length:
                                                                    if stor24.length <= idx:
                                                                        revert with 0, 'EnumerableSet: index out of bounds'
                                                                    require idx < stor24.length
                                                                    mem[0] = 24
                                                                    _16610 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_16610] = 0
                                                                    mem[_16610 + 32] = 0
                                                                    mem[0] = stor24[idx]
                                                                    mem[32] = 23
                                                                    _17208 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_17208] = sub_aeb22018[stor24[idx]].field_0
                                                                    mem[_17208 + 32] = sub_aeb22018[stor24[idx]].field_256
                                                                    if totalSupply <= sub_aeb22018[stor24[idx]].field_0:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    if totalSupply > sub_aeb22018[stor24[idx]].field_256:
                                                                        idx = idx + 1
                                                                        continue 
                                                                    sub_3d3b2603[address(_11)] = sub_59281b1e[stor24[idx]][address(_11)] / 24 * 3600
                                                                    emit 0x4256d14a: address(_11), stor24[idx], sub_3d3b2603[address(_11)]
                                                                    emit Mint(_12, address(_9), address(_11));
                                                                sub_3d3b2603[address(_11)] = sub_59281b1e[0][address(_11)] / 24 * 3600
                                                                emit 0x4256d14a: address(_11), 0, sub_3d3b2603[address(_11)]
                                                                emit Mint(_12, address(_9), address(_11));
}



}

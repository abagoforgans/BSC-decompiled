contract main {




// =====================  Runtime code  =====================


#
#  - getPairInfoWithFarmTVL(address arg1, address arg2, address arg3)
#  - getPairInfoWithPrice(address arg1, address arg2)
#  - sub_fb212f4e(?)
#
address owner;
array of address sub_27d312da;
address busdAddress;
address usdtAddress;
address usdcAddress;
address daiAddress;
address sub_43b67e4cAddress;
address sub_f9896b88Address;
address wbnbAddress;

function usdcAddress() payable {
    return usdcAddress
}

function sub_27d312da(?) payable {
    require calldata.size - 4 >= 32
    require arg1 < sub_27d312da.length
    return sub_27d312da[arg1]
}

function daiAddress() payable {
    return daiAddress
}

function sub_43b67e4c(?) payable {
    return sub_43b67e4cAddress
}

function wbnbAddress() payable {
    return wbnbAddress
}

function busdAddress() payable {
    return busdAddress
}

function owner() payable {
    return owner
}

function usdtAddress() payable {
    return usdtAddress
}

function sub_f9896b88(?) payable {
    return sub_f9896b88Address
}

function _fallback() payable {
    revert
}

function getUserBalance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    require ext_code.size(arg1)
    staticcall arg1.0x70a08231 with:
            gas gas_remaining wei
           args arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function sub_5e6b57dd(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, '!owner'
    idx = 0
    while idx < sub_27d312da.length:
        mem[0] = 1
        if sub_27d312da[idx] == address(arg1):
            revert with 0, 'address exists!'
        idx = idx + 1
        continue 
    sub_27d312da.length++
    sub_27d312da[sub_27d312da.length] = address(arg1)
}

function sub_11f49a09(?) payable {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 >= 96 and (32 * ('cd', 4).length) + 128 <= test266151307()
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require (32 * ('cd', 36).length) + 160 >= 128 and (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160 <= test266151307()
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 36).length
    require calldata.size >= cd[36] + (32 * ('cd', 36).length) + 36
    s = cd[36] + 36
    t = (32 * ('cd', 4).length) + 160
    idx = 0
    while idx < ('cd', 36).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require ('cd', 4).length <= test266151307()
    mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160] = ('cd', 4).length
    mem[64] = (64 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192
    if not ('cd', 4).length:
        idx = 0
        while idx < ('cd', 4).length:
            require idx < mem[96]
            _99 = mem[(32 * idx) + 128]
            require idx < mem[(32 * ('cd', 4).length) + 128]
            _105 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
            mem[mem[64] + 4] = mem[(32 * idx) + (32 * ('cd', 4).length) + 172 len 20]
            require ext_code.size(address(_99))
            staticcall address(_99).0x70a08231 with:
                    gas gas_remaining wei
                   args address(_105)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _116 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require idx < mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
            mem[(32 * idx) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192] = mem[_116]
            idx = idx + 1
            continue 
        mem[mem[64]] = 32
        _104 = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
        mem[mem[64] + 32] = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
        mem[mem[64] + 64 len 32 * _104] = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192 len 32 * _104]
        return 32, mem[mem[64] + 32 len (32 * _104) + 32]
    mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192 len 32 * ('cd', 4).length] = call.data[calldata.size len 32 * ('cd', 4).length]
    idx = 0
    while idx < ('cd', 4).length:
        require idx < mem[96]
        _102 = mem[(32 * idx) + 128]
        require idx < mem[(32 * ('cd', 4).length) + 128]
        _107 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
        mem[mem[64] + 4] = mem[(32 * idx) + (32 * ('cd', 4).length) + 172 len 20]
        require ext_code.size(address(_102))
        staticcall address(_102).0x70a08231 with:
                gas gas_remaining wei
               args address(_107)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _117 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require idx < mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
        mem[(32 * idx) + (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192] = mem[_117]
        idx = idx + 1
        continue 
    mem[mem[64]] = 32
    _106 = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
    mem[mem[64] + 32] = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160]
    mem[mem[64] + 64 len 32 * _106] = mem[(32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 192 len 32 * _106]
    return 32, mem[mem[64] + 32 len (32 * _106) + 32]
}

function getTokenInfo(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[96] = 0
    mem[128] = 96
    mem[160] = 96
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
    require ext_code.size(arg1)
    staticcall arg1.name() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[352 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _5 = mem[352]
    require mem[352] <= test266151307()
    require return_data.size + 352 > mem[352] + 383
    _6 = mem[mem[352] + 352]
    require mem[mem[352] + 352] <= test266151307()
    require ceil32(mem[mem[352] + 352]) + 32 >= 0 and ceil32(return_data.size) + ceil32(mem[mem[352] + 352]) + 384 <= test266151307()
    mem[64] = ceil32(return_data.size) + ceil32(mem[mem[352] + 352]) + 384
    mem[ceil32(return_data.size) + 352] = mem[mem[352] + 352]
    require _5 + _6 + 32 <= return_data.size
    mem[ceil32(return_data.size) + 384 len ceil32(_6)] = mem[_5 + 384 len ceil32(_6)]
    if ceil32(_6) <= _6:
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(arg1)
        staticcall arg1.0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _204 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _206 = mem[_204]
        require mem[_204] <= test266151307()
        require _204 + return_data.size > _204 + mem[_204] + 31
        _208 = mem[_204 + mem[_204]]
        require mem[_204 + mem[_204]] <= test266151307()
        require ceil32(mem[_204 + mem[_204]]) + 32 >= 0 and _204 + ceil32(return_data.size) + ceil32(mem[_204 + mem[_204]]) + 32 <= test266151307()
        mem[64] = _204 + ceil32(return_data.size) + ceil32(mem[_204 + mem[_204]]) + 32
        mem[_204 + ceil32(return_data.size)] = _208
        require _206 + _208 + 32 <= return_data.size
        mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)] = mem[_204 + _206 + 32 len ceil32(_208)]
        if ceil32(_208) <= _208:
            require ext_code.size(arg1)
            staticcall arg1.0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _400 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _404 = mem[_400]
            require mem[_400] == mem[_400 + 31 len 1]
            require ext_code.size(arg1)
            staticcall arg1.0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _416 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _420 = mem[_416]
            _422 = mem[64]
            mem[64] = mem[64] + 256
            mem[_422] = arg1
            mem[_422 + 32] = ceil32(return_data.size) + 352
            mem[_422 + 64] = _204 + ceil32(return_data.size)
            mem[_422 + 96] = uint8(_404)
            mem[_422 + 128] = 0
            mem[_422 + 160] = _420
            mem[_422 + 192] = 0
            mem[_422 + 224] = 0
            mem[mem[64]] = 32
            mem[mem[64] + 32] = arg1
            mem[mem[64] + 64] = 256
            _436 = mem[ceil32(return_data.size) + 352]
            mem[mem[64] + 288] = mem[ceil32(return_data.size) + 352]
            mem[mem[64] + 320 len ceil32(_436)] = mem[ceil32(return_data.size) + 384 len ceil32(_436)]
            if ceil32(_436) <= _436:
                mem[mem[64] + 96] = ceil32(_436) + 288
                mem[ceil32(_436) + mem[64] + 320] = _208
                mem[ceil32(_436) + mem[64] + 352 len ceil32(_208)] = mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)]
                if ceil32(_208) > _208:
                    mem[ceil32(_436) + mem[64] + _208 + 352] = 0
                return 32, address(arg1), 
                       256,
                       ceil32(_436) + 288,
                       _404 << 248,
                       0,
                       _420,
                       0,
                       0,
                       mem[mem[64] + 288 len ceil32(_436) + 32],
                       _208,
                       mem[mem[64] + ceil32(_436) + 352 len ceil32(_208)]
            mem[mem[64] + _436 + 320] = 0
            mem[mem[64] + 96] = ceil32(_436) + 288
            mem[ceil32(_436) + mem[64] + 320] = _208
            mem[ceil32(_436) + mem[64] + 352 len ceil32(_208)] = mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)]
            if ceil32(_208) > _208:
                mem[ceil32(_436) + mem[64] + _208 + 352] = 0
            return 32, address(arg1), 
                   256,
                   ceil32(_436) + 288,
                   _404 << 248,
                   0,
                   _420,
                   0,
                   0,
                   mem[mem[64] + 288 len _436 + 32],
                   0,
                   mem[mem[64] + _436 + 352 len ceil32(_208) + ceil32(_436) - _436]
        mem[_204 + ceil32(return_data.size) + _208 + 32] = 0
        require ext_code.size(arg1)
        staticcall arg1.0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _402 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _406 = mem[_402]
        require mem[_402] == mem[_402 + 31 len 1]
        require ext_code.size(arg1)
        staticcall arg1.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _418 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _423 = mem[_418]
        _427 = mem[64]
        mem[64] = mem[64] + 256
        mem[_427] = arg1
        mem[_427 + 32] = ceil32(return_data.size) + 352
        mem[_427 + 64] = _204 + ceil32(return_data.size)
        mem[_427 + 96] = uint8(_406)
        mem[_427 + 128] = 0
        mem[_427 + 160] = _423
        mem[_427 + 192] = 0
        mem[_427 + 224] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = arg1
        mem[mem[64] + 64] = 256
        _442 = mem[ceil32(return_data.size) + 352]
        mem[mem[64] + 288] = mem[ceil32(return_data.size) + 352]
        mem[mem[64] + 320 len ceil32(_442)] = mem[ceil32(return_data.size) + 384 len ceil32(_442)]
        if ceil32(_442) <= _442:
            mem[mem[64] + 96] = ceil32(_442) + 288
            mem[ceil32(_442) + mem[64] + 320] = _208
            mem[ceil32(_442) + mem[64] + 352 len ceil32(_208)] = mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)]
            if ceil32(_208) > _208:
                mem[ceil32(_442) + mem[64] + _208 + 352] = 0
            return 32, address(arg1), 
                   256,
                   ceil32(_442) + 288,
                   _406 << 248,
                   0,
                   _423,
                   0,
                   0,
                   mem[mem[64] + 288 len ceil32(_442) + 32],
                   _208,
                   mem[mem[64] + ceil32(_442) + 352 len ceil32(_208)]
        mem[mem[64] + _442 + 320] = 0
        mem[mem[64] + 96] = ceil32(_442) + 288
        mem[ceil32(_442) + mem[64] + 320] = _208
        mem[ceil32(_442) + mem[64] + 352 len ceil32(_208)] = mem[_204 + ceil32(return_data.size) + 32 len ceil32(_208)]
        if ceil32(_208) > _208:
            mem[ceil32(_442) + mem[64] + _208 + 352] = 0
        return 32, address(arg1), 
               256,
               ceil32(_442) + 288,
               _406 << 248,
               0,
               _423,
               0,
               0,
               mem[mem[64] + 288 len _442 + 32],
               0,
               mem[mem[64] + _442 + 352 len ceil32(_208) + ceil32(_442) - _442]
    mem[ceil32(return_data.size) + _6 + 384] = 0
    mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
    require ext_code.size(arg1)
    staticcall arg1.0x95d89b41 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _205 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _207 = mem[_205]
    require mem[_205] <= test266151307()
    require _205 + return_data.size > _205 + mem[_205] + 31
    _209 = mem[_205 + mem[_205]]
    require mem[_205 + mem[_205]] <= test266151307()
    require ceil32(mem[_205 + mem[_205]]) + 32 >= 0 and _205 + ceil32(return_data.size) + ceil32(mem[_205 + mem[_205]]) + 32 <= test266151307()
    mem[64] = _205 + ceil32(return_data.size) + ceil32(mem[_205 + mem[_205]]) + 32
    mem[_205 + ceil32(return_data.size)] = _209
    require _207 + _209 + 32 <= return_data.size
    mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)] = mem[_205 + _207 + 32 len ceil32(_209)]
    if ceil32(_209) <= _209:
        require ext_code.size(arg1)
        staticcall arg1.0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _401 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _405 = mem[_401]
        require mem[_401] == mem[_401 + 31 len 1]
        require ext_code.size(arg1)
        staticcall arg1.0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _417 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _421 = mem[_417]
        _424 = mem[64]
        mem[64] = mem[64] + 256
        mem[_424] = arg1
        mem[_424 + 32] = ceil32(return_data.size) + 352
        mem[_424 + 64] = _205 + ceil32(return_data.size)
        mem[_424 + 96] = uint8(_405)
        mem[_424 + 128] = 0
        mem[_424 + 160] = _421
        mem[_424 + 192] = 0
        mem[_424 + 224] = 0
        mem[mem[64]] = 32
        mem[mem[64] + 32] = arg1
        mem[mem[64] + 64] = 256
        _439 = mem[ceil32(return_data.size) + 352]
        mem[mem[64] + 288] = mem[ceil32(return_data.size) + 352]
        mem[mem[64] + 320 len ceil32(_439)] = mem[ceil32(return_data.size) + 384 len ceil32(_439)]
        if ceil32(_439) <= _439:
            mem[mem[64] + 96] = ceil32(_439) + 288
            mem[ceil32(_439) + mem[64] + 320] = _209
            mem[ceil32(_439) + mem[64] + 352 len ceil32(_209)] = mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)]
            if ceil32(_209) > _209:
                mem[ceil32(_439) + mem[64] + _209 + 352] = 0
            return 32, address(arg1), 
                   256,
                   ceil32(_439) + 288,
                   _405 << 248,
                   0,
                   _421,
                   0,
                   0,
                   mem[mem[64] + 288 len ceil32(_439) + 32],
                   _209,
                   mem[mem[64] + ceil32(_439) + 352 len ceil32(_209)]
        mem[mem[64] + _439 + 320] = 0
        mem[mem[64] + 96] = ceil32(_439) + 288
        mem[ceil32(_439) + mem[64] + 320] = _209
        mem[ceil32(_439) + mem[64] + 352 len ceil32(_209)] = mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)]
        if ceil32(_209) > _209:
            mem[ceil32(_439) + mem[64] + _209 + 352] = 0
        return 32, address(arg1), 
               256,
               ceil32(_439) + 288,
               _405 << 248,
               0,
               _421,
               0,
               0,
               mem[mem[64] + 288 len _439 + 32],
               0,
               mem[mem[64] + _439 + 352 len ceil32(_209) + ceil32(_439) - _439]
    mem[_205 + ceil32(return_data.size) + _209 + 32] = 0
    require ext_code.size(arg1)
    staticcall arg1.0x313ce567 with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _403 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _407 = mem[_403]
    require mem[_403] == mem[_403 + 31 len 1]
    require ext_code.size(arg1)
    staticcall arg1.0x18160ddd with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _419 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _425 = mem[_419]
    _429 = mem[64]
    mem[64] = mem[64] + 256
    mem[_429] = arg1
    mem[_429 + 32] = ceil32(return_data.size) + 352
    mem[_429 + 64] = _205 + ceil32(return_data.size)
    mem[_429 + 96] = uint8(_407)
    mem[_429 + 128] = 0
    mem[_429 + 160] = _425
    mem[_429 + 192] = 0
    mem[_429 + 224] = 0
    mem[mem[64]] = 32
    mem[mem[64] + 32] = arg1
    mem[mem[64] + 64] = 256
    _443 = mem[ceil32(return_data.size) + 352]
    mem[mem[64] + 288] = mem[ceil32(return_data.size) + 352]
    mem[mem[64] + 320 len ceil32(_443)] = mem[ceil32(return_data.size) + 384 len ceil32(_443)]
    if ceil32(_443) <= _443:
        mem[mem[64] + 96] = ceil32(_443) + 288
        mem[ceil32(_443) + mem[64] + 320] = _209
        mem[ceil32(_443) + mem[64] + 352 len ceil32(_209)] = mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)]
        if ceil32(_209) > _209:
            mem[ceil32(_443) + mem[64] + _209 + 352] = 0
        return 32, address(arg1), 
               256,
               ceil32(_443) + 288,
               _407 << 248,
               0,
               _425,
               0,
               0,
               mem[mem[64] + 288 len ceil32(_443) + 32],
               _209,
               mem[mem[64] + ceil32(_443) + 352 len ceil32(_209)]
    mem[mem[64] + _443 + 320] = 0
    mem[mem[64] + 96] = ceil32(_443) + 288
    mem[ceil32(_443) + mem[64] + 320] = _209
    mem[ceil32(_443) + mem[64] + 352 len ceil32(_209)] = mem[_205 + ceil32(return_data.size) + 32 len ceil32(_209)]
    if ceil32(_209) > _209:
        mem[ceil32(_443) + mem[64] + _209 + 352] = 0
    return 32, address(arg1), 
           256,
           ceil32(_443) + 288,
           _407 << 248,
           0,
           _425,
           0,
           0,
           mem[mem[64] + 288 len _443 + 32],
           0,
           mem[mem[64] + _443 + 352 len ceil32(_209) + ceil32(_443) - _443]
}

function sub_bb17e444(?) payable {
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 >= 96 and (32 * ('cd', 4).length) + 128 <= test266151307()
    mem[96] = ('cd', 4).length
    require calldata.size >= cd[4] + (32 * ('cd', 4).length) + 36
    s = cd[4] + 36
    t = 128
    idx = 0
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        s = s + 32
        t = t + 32
        idx = idx + 1
        continue 
    require ('cd', 4).length <= test266151307()
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 4).length
    mem[64] = (64 * ('cd', 4).length) + 160
    if not ('cd', 4).length:
        idx = 0
        while idx < ('cd', 4).length:
            require idx < mem[96]
            _408 = mem[(32 * idx) + 128]
            _410 = mem[64]
            mem[64] = mem[64] + 256
            mem[_410] = 0
            mem[_410 + 32] = 96
            mem[_410 + 64] = 96
            mem[_410 + 96] = 0
            mem[_410 + 128] = 0
            mem[_410 + 160] = 0
            mem[_410 + 192] = 0
            mem[_410 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_408))
            staticcall address(_408).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _420 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _424 = mem[_420]
            require mem[_420] <= test266151307()
            require _420 + return_data.size > _420 + mem[_420] + 31
            _430 = mem[_420 + mem[_420]]
            require mem[_420 + mem[_420]] <= test266151307()
            require ceil32(mem[_420 + mem[_420]]) + 32 >= 0 and _420 + ceil32(return_data.size) + ceil32(mem[_420 + mem[_420]]) + 32 <= test266151307()
            mem[64] = _420 + ceil32(return_data.size) + ceil32(mem[_420 + mem[_420]]) + 32
            mem[_420 + ceil32(return_data.size)] = _430
            require _424 + _430 + 32 <= return_data.size
            s = 0
            while s < _430:
                mem[s + _420 + ceil32(return_data.size) + 32] = mem[s + _420 + _424 + 32]
                s = s + 32
                continue 
            if ceil32(_430) <= _430:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_408))
                staticcall address(_408).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _617 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _622 = mem[_617]
                require mem[_617] <= test266151307()
                require _617 + return_data.size > _617 + mem[_617] + 31
                _631 = mem[_617 + mem[_617]]
                require mem[_617 + mem[_617]] <= test266151307()
                require ceil32(mem[_617 + mem[_617]]) + 32 >= 0 and _617 + ceil32(return_data.size) + ceil32(mem[_617 + mem[_617]]) + 32 <= test266151307()
                mem[64] = _617 + ceil32(return_data.size) + ceil32(mem[_617 + mem[_617]]) + 32
                mem[_617 + ceil32(return_data.size)] = _631
                require _622 + _631 + 32 <= return_data.size
                s = 0
                while s < _631:
                    mem[s + _617 + ceil32(return_data.size) + 32] = mem[s + _617 + _622 + 32]
                    s = s + 32
                    continue 
                if ceil32(_631) <= _631:
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _814 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _824 = mem[_814]
                    require mem[_814] == mem[_814 + 31 len 1]
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _860 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _867 = mem[_860]
                    _871 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_871] = address(_408)
                    mem[_871 + 32] = _420 + ceil32(return_data.size)
                    mem[_871 + 64] = _617 + ceil32(return_data.size)
                    mem[_871 + 96] = uint8(_824)
                    mem[_871 + 128] = 0
                    mem[_871 + 160] = _867
                    mem[_871 + 192] = 0
                    mem[_871 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _871
                else:
                    mem[_617 + ceil32(return_data.size) + _631 + 32] = 0
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _819 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _827 = mem[_819]
                    require mem[_819] == mem[_819 + 31 len 1]
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _863 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _872 = mem[_863]
                    _876 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_876] = address(_408)
                    mem[_876 + 32] = _420 + ceil32(return_data.size)
                    mem[_876 + 64] = _617 + ceil32(return_data.size)
                    mem[_876 + 96] = uint8(_827)
                    mem[_876 + 128] = 0
                    mem[_876 + 160] = _872
                    mem[_876 + 192] = 0
                    mem[_876 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _876
            else:
                mem[_420 + ceil32(return_data.size) + _430 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_408))
                staticcall address(_408).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _620 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _625 = mem[_620]
                require mem[_620] <= test266151307()
                require _620 + return_data.size > _620 + mem[_620] + 31
                _636 = mem[_620 + mem[_620]]
                require mem[_620 + mem[_620]] <= test266151307()
                require ceil32(mem[_620 + mem[_620]]) + 32 >= 0 and _620 + ceil32(return_data.size) + ceil32(mem[_620 + mem[_620]]) + 32 <= test266151307()
                mem[64] = _620 + ceil32(return_data.size) + ceil32(mem[_620 + mem[_620]]) + 32
                mem[_620 + ceil32(return_data.size)] = _636
                require _625 + _636 + 32 <= return_data.size
                s = 0
                while s < _636:
                    mem[s + _620 + ceil32(return_data.size) + 32] = mem[s + _620 + _625 + 32]
                    s = s + 32
                    continue 
                if ceil32(_636) <= _636:
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _815 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _825 = mem[_815]
                    require mem[_815] == mem[_815 + 31 len 1]
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _861 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _868 = mem[_861]
                    _873 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_873] = address(_408)
                    mem[_873 + 32] = _420 + ceil32(return_data.size)
                    mem[_873 + 64] = _620 + ceil32(return_data.size)
                    mem[_873 + 96] = uint8(_825)
                    mem[_873 + 128] = 0
                    mem[_873 + 160] = _868
                    mem[_873 + 192] = 0
                    mem[_873 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _873
                else:
                    mem[_620 + ceil32(return_data.size) + _636 + 32] = 0
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _820 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _828 = mem[_820]
                    require mem[_820] == mem[_820 + 31 len 1]
                    require ext_code.size(address(_408))
                    staticcall address(_408).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _864 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _874 = mem[_864]
                    _878 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_878] = address(_408)
                    mem[_878 + 32] = _420 + ceil32(return_data.size)
                    mem[_878 + 64] = _620 + ceil32(return_data.size)
                    mem[_878 + 96] = uint8(_828)
                    mem[_878 + 128] = 0
                    mem[_878 + 160] = _874
                    mem[_878 + 192] = 0
                    mem[_878 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _878
            idx = idx + 1
            continue 
        _407 = mem[64]
        mem[mem[64]] = 32
        _409 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + 32] = mem[(32 * ('cd', 4).length) + 128]
        idx = 0
        s = (32 * ('cd', 4).length) + 160
        t = mem[64] + 64
        u = mem[64] + (32 * _409) + 64
        while idx < _409:
            mem[t] = u + -_407 - 64
            _604 = mem[s]
            mem[u] = mem[mem[s] + 12 len 20]
            _608 = mem[_604 + 32]
            mem[u + 32] = 256
            _609 = mem[_608]
            mem[u + 256] = mem[_608]
            v = 0
            while v < _609:
                mem[v + u + 288] = mem[v + _608 + 32]
                v = v + 32
                continue 
            if ceil32(_609) <= _609:
                _798 = mem[_604 + 64]
                mem[u + 64] = ceil32(_609) + 288
                _804 = mem[_798]
                mem[ceil32(_609) + u + 288] = mem[_798]
                v = 0
                while v < _804:
                    mem[v + ceil32(_609) + u + 320] = mem[v + _798 + 32]
                    v = v + 32
                    continue 
                if ceil32(_804) > _804:
                    mem[ceil32(_609) + u + _804 + 320] = 0
                mem[u + 96] = mem[_604 + 96]
                mem[u + 128] = mem[_604 + 128]
                mem[u + 160] = mem[_604 + 160]
                mem[u + 192] = mem[_604 + 192]
                mem[u + 224] = mem[_604 + 224]
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_804) + ceil32(_609) + u + 320
                continue 
            mem[u + _609 + 288] = 0
            _805 = mem[_604 + 64]
            mem[u + 64] = ceil32(_609) + 288
            _813 = mem[_805]
            mem[ceil32(_609) + u + 288] = mem[_805]
            v = 0
            while v < _813:
                mem[v + ceil32(_609) + u + 320] = mem[v + _805 + 32]
                v = v + 32
                continue 
            if ceil32(_813) > _813:
                mem[ceil32(_609) + u + _813 + 320] = 0
            mem[u + 96] = mem[_604 + 96]
            mem[u + 128] = mem[_604 + 128]
            mem[u + 160] = mem[_604 + 160]
            mem[u + 192] = mem[_604 + 192]
            mem[u + 224] = mem[_604 + 224]
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_813) + ceil32(_609) + u + 320
            continue 
    else:
        mem[64] = (64 * ('cd', 4).length) + 416
        mem[(64 * ('cd', 4).length) + 160] = 0
        mem[(64 * ('cd', 4).length) + 192] = 96
        mem[(64 * ('cd', 4).length) + 224] = 96
        mem[(64 * ('cd', 4).length) + 256] = 0
        mem[(64 * ('cd', 4).length) + 288] = 0
        mem[(64 * ('cd', 4).length) + 320] = 0
        mem[(64 * ('cd', 4).length) + 352] = 0
        mem[(64 * ('cd', 4).length) + 384] = 0
        mem[var23001] = (64 * ('cd', 4).length) + 160
        s = var23001
        idx = var23002
        while idx - 1:
            mem[64] = mem[64] + 256
            mem[(64 * ('cd', 4).length) + 160] = 0
            mem[(64 * ('cd', 4).length) + 192] = 96
            mem[(64 * ('cd', 4).length) + 224] = 96
            mem[(64 * ('cd', 4).length) + 256] = 0
            mem[(64 * ('cd', 4).length) + 288] = 0
            mem[(64 * ('cd', 4).length) + 320] = 0
            mem[(64 * ('cd', 4).length) + 352] = 0
            mem[(64 * ('cd', 4).length) + 384] = 0
            mem[s + 32] = (64 * ('cd', 4).length) + 160
            s = s + 32
            idx = idx - 1
            continue 
        _790 = mem[96]
        idx = 0
        while idx < _790:
            require idx < mem[96]
            _796 = mem[(32 * idx) + 128]
            _803 = mem[64]
            mem[64] = mem[64] + 256
            mem[_803] = 0
            mem[_803 + 32] = 96
            mem[_803 + 64] = 96
            mem[_803 + 96] = 0
            mem[_803 + 128] = 0
            mem[_803 + 160] = 0
            mem[_803 + 192] = 0
            mem[_803 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_796))
            staticcall address(_796).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _822 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _829 = mem[_822]
            require mem[_822] <= test266151307()
            require _822 + return_data.size > _822 + mem[_822] + 31
            _840 = mem[_822 + mem[_822]]
            require mem[_822 + mem[_822]] <= test266151307()
            require ceil32(mem[_822 + mem[_822]]) + 32 >= 0 and _822 + ceil32(return_data.size) + ceil32(mem[_822 + mem[_822]]) + 32 <= test266151307()
            mem[64] = _822 + ceil32(return_data.size) + ceil32(mem[_822 + mem[_822]]) + 32
            mem[_822 + ceil32(return_data.size)] = _840
            require _829 + _840 + 32 <= return_data.size
            s = 0
            while s < _840:
                mem[s + _822 + ceil32(return_data.size) + 32] = mem[s + _822 + _829 + 32]
                _790 = mem[96]
                s = s + 32
                continue 
            if ceil32(_840) <= _840:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_796))
                staticcall address(_796).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _991 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _993 = mem[_991]
                require mem[_991] <= test266151307()
                require _991 + return_data.size > _991 + mem[_991] + 31
                _998 = mem[_991 + mem[_991]]
                require mem[_991 + mem[_991]] <= test266151307()
                require ceil32(mem[_991 + mem[_991]]) + 32 >= 0 and _991 + ceil32(return_data.size) + ceil32(mem[_991 + mem[_991]]) + 32 <= test266151307()
                mem[64] = _991 + ceil32(return_data.size) + ceil32(mem[_991 + mem[_991]]) + 32
                mem[_991 + ceil32(return_data.size)] = _998
                require _993 + _998 + 32 <= return_data.size
                s = 0
                while s < _998:
                    mem[s + _991 + ceil32(return_data.size) + 32] = mem[s + _991 + _993 + 32]
                    _790 = mem[96]
                    s = s + 32
                    continue 
                if ceil32(_998) <= _998:
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1082 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1087 = mem[_1082]
                    require mem[_1082] == mem[_1082 + 31 len 1]
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1120 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1124 = mem[_1120]
                    _1126 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_1126] = address(_796)
                    mem[_1126 + 32] = _822 + ceil32(return_data.size)
                    mem[_1126 + 64] = _991 + ceil32(return_data.size)
                    mem[_1126 + 96] = uint8(_1087)
                    mem[_1126 + 128] = 0
                    mem[_1126 + 160] = _1124
                    mem[_1126 + 192] = 0
                    mem[_1126 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _1126
                else:
                    mem[_991 + ceil32(return_data.size) + _998 + 32] = 0
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1084 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1090 = mem[_1084]
                    require mem[_1084] == mem[_1084 + 31 len 1]
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1122 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1127 = mem[_1122]
                    _1131 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_1131] = address(_796)
                    mem[_1131 + 32] = _822 + ceil32(return_data.size)
                    mem[_1131 + 64] = _991 + ceil32(return_data.size)
                    mem[_1131 + 96] = uint8(_1090)
                    mem[_1131 + 128] = 0
                    mem[_1131 + 160] = _1127
                    mem[_1131 + 192] = 0
                    mem[_1131 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _1131
            else:
                mem[_822 + ceil32(return_data.size) + _840 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_796))
                staticcall address(_796).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _992 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _995 = mem[_992]
                require mem[_992] <= test266151307()
                require _992 + return_data.size > _992 + mem[_992] + 31
                _1000 = mem[_992 + mem[_992]]
                require mem[_992 + mem[_992]] <= test266151307()
                require ceil32(mem[_992 + mem[_992]]) + 32 >= 0 and _992 + ceil32(return_data.size) + ceil32(mem[_992 + mem[_992]]) + 32 <= test266151307()
                mem[64] = _992 + ceil32(return_data.size) + ceil32(mem[_992 + mem[_992]]) + 32
                mem[_992 + ceil32(return_data.size)] = _1000
                require _995 + _1000 + 32 <= return_data.size
                s = 0
                while s < _1000:
                    mem[s + _992 + ceil32(return_data.size) + 32] = mem[s + _992 + _995 + 32]
                    _790 = mem[96]
                    s = s + 32
                    continue 
                if ceil32(_1000) <= _1000:
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1083 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1088 = mem[_1083]
                    require mem[_1083] == mem[_1083 + 31 len 1]
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1121 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1125 = mem[_1121]
                    _1128 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_1128] = address(_796)
                    mem[_1128 + 32] = _822 + ceil32(return_data.size)
                    mem[_1128 + 64] = _992 + ceil32(return_data.size)
                    mem[_1128 + 96] = uint8(_1088)
                    mem[_1128 + 128] = 0
                    mem[_1128 + 160] = _1125
                    mem[_1128 + 192] = 0
                    mem[_1128 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _1128
                else:
                    mem[_992 + ceil32(return_data.size) + _1000 + 32] = 0
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1085 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1091 = mem[_1085]
                    require mem[_1085] == mem[_1085 + 31 len 1]
                    require ext_code.size(address(_796))
                    staticcall address(_796).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1123 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1129 = mem[_1123]
                    _1133 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_1133] = address(_796)
                    mem[_1133 + 32] = _822 + ceil32(return_data.size)
                    mem[_1133 + 64] = _992 + ceil32(return_data.size)
                    mem[_1133 + 96] = uint8(_1091)
                    mem[_1133 + 128] = 0
                    mem[_1133 + 160] = _1129
                    mem[_1133 + 192] = 0
                    mem[_1133 + 224] = 0
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    mem[(32 * idx) + (32 * ('cd', 4).length) + 160] = _1133
            _790 = mem[96]
            idx = idx + 1
            continue 
        _795 = mem[64]
        mem[mem[64]] = 32
        _797 = mem[(32 * ('cd', 4).length) + 128]
        mem[mem[64] + 32] = mem[(32 * ('cd', 4).length) + 128]
        idx = 0
        s = (32 * ('cd', 4).length) + 160
        t = mem[64] + 64
        u = mem[64] + (32 * _797) + 64
        while idx < _797:
            mem[t] = u + -_795 - 64
            _960 = mem[s]
            mem[u] = mem[mem[s] + 12 len 20]
            _964 = mem[_960 + 32]
            mem[u + 32] = 256
            _965 = mem[_964]
            mem[u + 256] = mem[_964]
            v = 0
            while v < _965:
                mem[v + u + 288] = mem[v + _964 + 32]
                v = v + 32
                continue 
            if ceil32(_965) <= _965:
                _1070 = mem[_960 + 64]
                mem[u + 64] = ceil32(_965) + 288
                _1075 = mem[_1070]
                mem[ceil32(_965) + u + 288] = mem[_1070]
                v = 0
                while v < _1075:
                    mem[v + ceil32(_965) + u + 320] = mem[v + _1070 + 32]
                    v = v + 32
                    continue 
                if ceil32(_1075) > _1075:
                    mem[ceil32(_965) + u + _1075 + 320] = 0
                mem[u + 96] = mem[_960 + 96]
                mem[u + 128] = mem[_960 + 128]
                mem[u + 160] = mem[_960 + 160]
                mem[u + 192] = mem[_960 + 192]
                mem[u + 224] = mem[_960 + 224]
                idx = idx + 1
                s = s + 32
                t = t + 32
                u = ceil32(_1075) + ceil32(_965) + u + 320
                continue 
            mem[u + _965 + 288] = 0
            _1076 = mem[_960 + 64]
            mem[u + 64] = ceil32(_965) + 288
            _1081 = mem[_1076]
            mem[ceil32(_965) + u + 288] = mem[_1076]
            v = 0
            while v < _1081:
                mem[v + ceil32(_965) + u + 320] = mem[v + _1076 + 32]
                v = v + 32
                continue 
            if ceil32(_1081) > _1081:
                mem[ceil32(_965) + u + _1081 + 320] = 0
            mem[u + 96] = mem[_960 + 96]
            mem[u + 128] = mem[_960 + 128]
            mem[u + 160] = mem[_960 + 160]
            mem[u + 192] = mem[_960 + 192]
            mem[u + 224] = mem[_960 + 224]
            idx = idx + 1
            s = s + 32
            t = t + 32
            u = ceil32(_1081) + ceil32(_965) + u + 320
            continue 
    return memory
      from mem[64]
       len u - mem[64]
}

function getPairTokenInfo(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[96] = 0
    mem[128] = 96
    mem[160] = 96
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[352] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 352] = 0
    mem[ceil32(return_data.size) + 384] = 96
    mem[ceil32(return_data.size) + 416] = 96
    mem[ceil32(return_data.size) + 448] = 0
    mem[ceil32(return_data.size) + 480] = 0
    mem[ceil32(return_data.size) + 512] = 0
    mem[ceil32(return_data.size) + 544] = 0
    mem[ceil32(return_data.size) + 576] = 0
    mem[ceil32(return_data.size) + 608] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).name() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 608 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _10 = mem[ceil32(return_data.size) + 608]
    require mem[ceil32(return_data.size) + 608] <= test266151307()
    require ceil32(return_data.size) + return_data.size + 608 > ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 639
    _11 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]
    require mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608] <= test266151307()
    require ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 32 >= 0 and (2 * ceil32(return_data.size)) + ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 640 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 640
    mem[(2 * ceil32(return_data.size)) + 608] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]
    require _10 + _11 + 32 <= return_data.size
    mem[(2 * ceil32(return_data.size)) + 640 len ceil32(_11)] = mem[ceil32(return_data.size) + _10 + 640 len ceil32(_11)]
    if ceil32(_11) <= _11:
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _609 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _611 = mem[_609]
        require mem[_609] <= test266151307()
        require _609 + return_data.size > _609 + mem[_609] + 31
        _613 = mem[_609 + mem[_609]]
        require mem[_609 + mem[_609]] <= test266151307()
        require ceil32(mem[_609 + mem[_609]]) + 32 >= 0 and _609 + ceil32(return_data.size) + ceil32(mem[_609 + mem[_609]]) + 32 <= test266151307()
        mem[64] = _609 + ceil32(return_data.size) + ceil32(mem[_609 + mem[_609]]) + 32
        mem[_609 + ceil32(return_data.size)] = _613
        require _611 + _613 + 32 <= return_data.size
        mem[_609 + ceil32(return_data.size) + 32 len ceil32(_613)] = mem[_609 + _611 + 32 len ceil32(_613)]
        if ceil32(_613) <= _613:
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1205 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1209 = mem[_1205]
            require mem[_1205] == mem[_1205 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1221 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1225 = mem[_1221]
            _1227 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1227] = address(ext_call.return_data[0])
            mem[_1227 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1227 + 64] = _609 + ceil32(return_data.size)
            mem[_1227 + 96] = uint8(_1209)
            mem[_1227 + 128] = 0
            mem[_1227 + 160] = _1225
            mem[_1227 + 192] = 0
            mem[_1227 + 224] = 0
            _1233 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1233] = 0
            mem[_1233 + 32] = 96
            mem[_1233 + 64] = 96
            mem[_1233 + 96] = 0
            mem[_1233 + 128] = 0
            mem[_1233 + 160] = 0
            mem[_1233 + 192] = 0
            mem[_1233 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1245 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1249 = mem[_1245]
            require mem[_1245] == mem[_1245 + 12 len 20]
            _1253 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1253] = 0
            mem[_1253 + 32] = 96
            mem[_1253 + 64] = 96
            mem[_1253 + 96] = 0
            mem[_1253 + 128] = 0
            mem[_1253 + 160] = 0
            mem[_1253 + 192] = 0
            mem[_1253 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1249))
            staticcall address(_1249).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1265 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1269 = mem[_1265]
            require mem[_1265] <= test266151307()
            require _1265 + return_data.size > _1265 + mem[_1265] + 31
            _1273 = mem[_1265 + mem[_1265]]
            require mem[_1265 + mem[_1265]] <= test266151307()
            require ceil32(mem[_1265 + mem[_1265]]) + 32 >= 0 and _1265 + ceil32(return_data.size) + ceil32(mem[_1265 + mem[_1265]]) + 32 <= test266151307()
            mem[64] = _1265 + ceil32(return_data.size) + ceil32(mem[_1265 + mem[_1265]]) + 32
            mem[_1265 + ceil32(return_data.size)] = _1273
            require _1269 + _1273 + 32 <= return_data.size
            mem[_1265 + ceil32(return_data.size) + 32 len ceil32(_1273)] = mem[_1265 + _1269 + 32 len ceil32(_1273)]
            if ceil32(_1273) <= _1273:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1249))
                staticcall address(_1249).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1793 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1801 = mem[_1793]
                require mem[_1793] <= test266151307()
                require _1793 + return_data.size > _1793 + mem[_1793] + 31
                _1809 = mem[_1793 + mem[_1793]]
                require mem[_1793 + mem[_1793]] <= test266151307()
                require ceil32(mem[_1793 + mem[_1793]]) + 32 >= 0 and _1793 + ceil32(return_data.size) + ceil32(mem[_1793 + mem[_1793]]) + 32 <= test266151307()
                mem[64] = _1793 + ceil32(return_data.size) + ceil32(mem[_1793 + mem[_1793]]) + 32
                mem[_1793 + ceil32(return_data.size)] = _1809
                require _1801 + _1809 + 32 <= return_data.size
                mem[_1793 + ceil32(return_data.size) + 32 len ceil32(_1809)] = mem[_1793 + _1801 + 32 len ceil32(_1809)]
                if ceil32(_1809) <= _1809:
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2305 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2321 = mem[_2305]
                    require mem[_2305] == mem[_2305 + 31 len 1]
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2369 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2385 = mem[_2369]
                    _2393 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2393] = address(_1249)
                    mem[_2393 + 32] = _1265 + ceil32(return_data.size)
                    mem[_2393 + 64] = _1793 + ceil32(return_data.size)
                    mem[_2393 + 96] = uint8(_2321)
                    mem[_2393 + 128] = 0
                    mem[_2393 + 160] = _2385
                    mem[_2393 + 192] = 0
                    mem[_2393 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2449 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2465 = mem[_2449]
                    require mem[_2449] == mem[_2449 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2465))
                    staticcall address(_2465).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2513 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1227 + 128] = mem[_2513]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2577 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2593 = mem[_2577]
                    require mem[_2577] == mem[_2577 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2593))
                    staticcall address(_2593).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2641 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2393 + 128] = mem[_2641]
                    _2665 = mem[64]
                    mem[mem[64]] = 2
                    _3297 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3297] = 0
                    mem[_3297 + 32] = 96
                    mem[_3297 + 64] = 96
                    mem[_3297 + 96] = 0
                    mem[_3297 + 128] = 0
                    mem[_3297 + 160] = 0
                    mem[_3297 + 192] = 0
                    mem[_3297 + 224] = 0
                    mem[var179001] = _3297
                    s = var179001
                    idx = var179002
                    while idx - 1:
                        _3297 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3297] = 0
                        mem[_3297 + 32] = 96
                        mem[_3297 + 64] = 96
                        mem[_3297 + 96] = 0
                        mem[_3297 + 128] = 0
                        mem[_3297 + 160] = 0
                        mem[_3297 + 192] = 0
                        mem[_3297 + 224] = 0
                        mem[s + 32] = _3297
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2665]
                    mem[_2665 + 32] = _1227
                    require 1 < mem[_2665]
                    mem[_2665 + 64] = _2393
                    _3345 = mem[64]
                    mem[mem[64]] = 32
                    _3361 = mem[_2665]
                    mem[mem[64] + 32] = mem[_2665]
                    idx = 0
                    s = _2665 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3361) + 64
                    while idx < _3361:
                        mem[t] = u + -_3345 - 64
                        _3889 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3907 = mem[_3889 + 32]
                        mem[u + 32] = 256
                        _3953 = mem[_3907]
                        mem[u + 256] = mem[_3907]
                        v = 0
                        while v < _3953:
                            mem[v + u + 288] = mem[v + _3907 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3953) <= _3953:
                            _4417 = mem[_3889 + 64]
                            mem[u + 64] = ceil32(_3953) + 288
                            _4433 = mem[_4417]
                            mem[ceil32(_3953) + u + 288] = mem[_4417]
                            v = 0
                            while v < _4433:
                                mem[v + ceil32(_3953) + u + 320] = mem[v + _4417 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4433) > _4433:
                                mem[ceil32(_3953) + u + _4433 + 320] = 0
                            mem[u + 96] = mem[_3889 + 96]
                            mem[u + 128] = mem[_3889 + 128]
                            mem[u + 160] = mem[_3889 + 160]
                            mem[u + 192] = mem[_3889 + 192]
                            mem[u + 224] = mem[_3889 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4433) + ceil32(_3953) + u + 320
                            continue 
                        mem[u + _3953 + 288] = 0
                        _4434 = mem[_3889 + 64]
                        mem[u + 64] = ceil32(_3953) + 288
                        _4465 = mem[_4434]
                        mem[ceil32(_3953) + u + 288] = mem[_4434]
                        v = 0
                        while v < _4465:
                            mem[v + ceil32(_3953) + u + 320] = mem[v + _4434 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4465) > _4465:
                            mem[ceil32(_3953) + u + _4465 + 320] = 0
                        mem[u + 96] = mem[_3889 + 96]
                        mem[u + 128] = mem[_3889 + 128]
                        mem[u + 160] = mem[_3889 + 160]
                        mem[u + 192] = mem[_3889 + 192]
                        mem[u + 224] = mem[_3889 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4465) + ceil32(_3953) + u + 320
                        continue 
                else:
                    mem[_1793 + ceil32(return_data.size) + _1809 + 32] = 0
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2313 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2329 = mem[_2313]
                    require mem[_2313] == mem[_2313 + 31 len 1]
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2377 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2394 = mem[_2377]
                    _2411 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2411] = address(_1249)
                    mem[_2411 + 32] = _1265 + ceil32(return_data.size)
                    mem[_2411 + 64] = _1793 + ceil32(return_data.size)
                    mem[_2411 + 96] = uint8(_2329)
                    mem[_2411 + 128] = 0
                    mem[_2411 + 160] = _2394
                    mem[_2411 + 192] = 0
                    mem[_2411 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2457 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2473 = mem[_2457]
                    require mem[_2457] == mem[_2457 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2473))
                    staticcall address(_2473).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2521 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1227 + 128] = mem[_2521]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2585 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2601 = mem[_2585]
                    require mem[_2585] == mem[_2585 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2601))
                    staticcall address(_2601).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2649 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2411 + 128] = mem[_2649]
                    _2681 = mem[64]
                    mem[mem[64]] = 2
                    _3298 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3298] = 0
                    mem[_3298 + 32] = 96
                    mem[_3298 + 64] = 96
                    mem[_3298 + 96] = 0
                    mem[_3298 + 128] = 0
                    mem[_3298 + 160] = 0
                    mem[_3298 + 192] = 0
                    mem[_3298 + 224] = 0
                    mem[var180001] = _3298
                    s = var180001
                    idx = var180002
                    while idx - 1:
                        _3298 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3298] = 0
                        mem[_3298 + 32] = 96
                        mem[_3298 + 64] = 96
                        mem[_3298 + 96] = 0
                        mem[_3298 + 128] = 0
                        mem[_3298 + 160] = 0
                        mem[_3298 + 192] = 0
                        mem[_3298 + 224] = 0
                        mem[s + 32] = _3298
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2681]
                    mem[_2681 + 32] = _1227
                    require 1 < mem[_2681]
                    mem[_2681 + 64] = _2411
                    _3346 = mem[64]
                    mem[mem[64]] = 32
                    _3362 = mem[_2681]
                    mem[mem[64] + 32] = mem[_2681]
                    idx = 0
                    s = _2681 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3362) + 64
                    while idx < _3362:
                        mem[t] = u + -_3346 - 64
                        _3890 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3910 = mem[_3890 + 32]
                        mem[u + 32] = 256
                        _3954 = mem[_3910]
                        mem[u + 256] = mem[_3910]
                        v = 0
                        while v < _3954:
                            mem[v + u + 288] = mem[v + _3910 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3954) <= _3954:
                            _4418 = mem[_3890 + 64]
                            mem[u + 64] = ceil32(_3954) + 288
                            _4435 = mem[_4418]
                            mem[ceil32(_3954) + u + 288] = mem[_4418]
                            v = 0
                            while v < _4435:
                                mem[v + ceil32(_3954) + u + 320] = mem[v + _4418 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4435) > _4435:
                                mem[ceil32(_3954) + u + _4435 + 320] = 0
                            mem[u + 96] = mem[_3890 + 96]
                            mem[u + 128] = mem[_3890 + 128]
                            mem[u + 160] = mem[_3890 + 160]
                            mem[u + 192] = mem[_3890 + 192]
                            mem[u + 224] = mem[_3890 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4435) + ceil32(_3954) + u + 320
                            continue 
                        mem[u + _3954 + 288] = 0
                        _4436 = mem[_3890 + 64]
                        mem[u + 64] = ceil32(_3954) + 288
                        _4466 = mem[_4436]
                        mem[ceil32(_3954) + u + 288] = mem[_4436]
                        v = 0
                        while v < _4466:
                            mem[v + ceil32(_3954) + u + 320] = mem[v + _4436 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4466) > _4466:
                            mem[ceil32(_3954) + u + _4466 + 320] = 0
                        mem[u + 96] = mem[_3890 + 96]
                        mem[u + 128] = mem[_3890 + 128]
                        mem[u + 160] = mem[_3890 + 160]
                        mem[u + 192] = mem[_3890 + 192]
                        mem[u + 224] = mem[_3890 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4466) + ceil32(_3954) + u + 320
                        continue 
            else:
                mem[_1265 + ceil32(return_data.size) + _1273 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1249))
                staticcall address(_1249).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1797 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1805 = mem[_1797]
                require mem[_1797] <= test266151307()
                require _1797 + return_data.size > _1797 + mem[_1797] + 31
                _1813 = mem[_1797 + mem[_1797]]
                require mem[_1797 + mem[_1797]] <= test266151307()
                require ceil32(mem[_1797 + mem[_1797]]) + 32 >= 0 and _1797 + ceil32(return_data.size) + ceil32(mem[_1797 + mem[_1797]]) + 32 <= test266151307()
                mem[64] = _1797 + ceil32(return_data.size) + ceil32(mem[_1797 + mem[_1797]]) + 32
                mem[_1797 + ceil32(return_data.size)] = _1813
                require _1805 + _1813 + 32 <= return_data.size
                mem[_1797 + ceil32(return_data.size) + 32 len ceil32(_1813)] = mem[_1797 + _1805 + 32 len ceil32(_1813)]
                if ceil32(_1813) <= _1813:
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2306 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2322 = mem[_2306]
                    require mem[_2306] == mem[_2306 + 31 len 1]
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2370 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2386 = mem[_2370]
                    _2395 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2395] = address(_1249)
                    mem[_2395 + 32] = _1265 + ceil32(return_data.size)
                    mem[_2395 + 64] = _1797 + ceil32(return_data.size)
                    mem[_2395 + 96] = uint8(_2322)
                    mem[_2395 + 128] = 0
                    mem[_2395 + 160] = _2386
                    mem[_2395 + 192] = 0
                    mem[_2395 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2450 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2466 = mem[_2450]
                    require mem[_2450] == mem[_2450 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2466))
                    staticcall address(_2466).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2514 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1227 + 128] = mem[_2514]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2578 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2594 = mem[_2578]
                    require mem[_2578] == mem[_2578 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2594))
                    staticcall address(_2594).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2642 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2395 + 128] = mem[_2642]
                    _2667 = mem[64]
                    mem[mem[64]] = 2
                    _3299 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3299] = 0
                    mem[_3299 + 32] = 96
                    mem[_3299 + 64] = 96
                    mem[_3299 + 96] = 0
                    mem[_3299 + 128] = 0
                    mem[_3299 + 160] = 0
                    mem[_3299 + 192] = 0
                    mem[_3299 + 224] = 0
                    mem[var180001] = _3299
                    s = var180001
                    idx = var180002
                    while idx - 1:
                        _3299 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3299] = 0
                        mem[_3299 + 32] = 96
                        mem[_3299 + 64] = 96
                        mem[_3299 + 96] = 0
                        mem[_3299 + 128] = 0
                        mem[_3299 + 160] = 0
                        mem[_3299 + 192] = 0
                        mem[_3299 + 224] = 0
                        mem[s + 32] = _3299
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2667]
                    mem[_2667 + 32] = _1227
                    require 1 < mem[_2667]
                    mem[_2667 + 64] = _2395
                    _3347 = mem[64]
                    mem[mem[64]] = 32
                    _3363 = mem[_2667]
                    mem[mem[64] + 32] = mem[_2667]
                    idx = 0
                    s = _2667 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3363) + 64
                    while idx < _3363:
                        mem[t] = u + -_3347 - 64
                        _3891 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3913 = mem[_3891 + 32]
                        mem[u + 32] = 256
                        _3955 = mem[_3913]
                        mem[u + 256] = mem[_3913]
                        v = 0
                        while v < _3955:
                            mem[v + u + 288] = mem[v + _3913 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3955) <= _3955:
                            _4419 = mem[_3891 + 64]
                            mem[u + 64] = ceil32(_3955) + 288
                            _4437 = mem[_4419]
                            mem[ceil32(_3955) + u + 288] = mem[_4419]
                            v = 0
                            while v < _4437:
                                mem[v + ceil32(_3955) + u + 320] = mem[v + _4419 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4437) > _4437:
                                mem[ceil32(_3955) + u + _4437 + 320] = 0
                            mem[u + 96] = mem[_3891 + 96]
                            mem[u + 128] = mem[_3891 + 128]
                            mem[u + 160] = mem[_3891 + 160]
                            mem[u + 192] = mem[_3891 + 192]
                            mem[u + 224] = mem[_3891 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4437) + ceil32(_3955) + u + 320
                            continue 
                        mem[u + _3955 + 288] = 0
                        _4438 = mem[_3891 + 64]
                        mem[u + 64] = ceil32(_3955) + 288
                        _4467 = mem[_4438]
                        mem[ceil32(_3955) + u + 288] = mem[_4438]
                        v = 0
                        while v < _4467:
                            mem[v + ceil32(_3955) + u + 320] = mem[v + _4438 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4467) > _4467:
                            mem[ceil32(_3955) + u + _4467 + 320] = 0
                        mem[u + 96] = mem[_3891 + 96]
                        mem[u + 128] = mem[_3891 + 128]
                        mem[u + 160] = mem[_3891 + 160]
                        mem[u + 192] = mem[_3891 + 192]
                        mem[u + 224] = mem[_3891 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4467) + ceil32(_3955) + u + 320
                        continue 
                else:
                    mem[_1797 + ceil32(return_data.size) + _1813 + 32] = 0
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2314 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2330 = mem[_2314]
                    require mem[_2314] == mem[_2314 + 31 len 1]
                    require ext_code.size(address(_1249))
                    staticcall address(_1249).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2378 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2396 = mem[_2378]
                    _2414 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2414] = address(_1249)
                    mem[_2414 + 32] = _1265 + ceil32(return_data.size)
                    mem[_2414 + 64] = _1797 + ceil32(return_data.size)
                    mem[_2414 + 96] = uint8(_2330)
                    mem[_2414 + 128] = 0
                    mem[_2414 + 160] = _2396
                    mem[_2414 + 192] = 0
                    mem[_2414 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2458 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2474 = mem[_2458]
                    require mem[_2458] == mem[_2458 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2474))
                    staticcall address(_2474).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2522 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1227 + 128] = mem[_2522]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2586 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2602 = mem[_2586]
                    require mem[_2586] == mem[_2586 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2602))
                    staticcall address(_2602).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2650 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2414 + 128] = mem[_2650]
                    _2682 = mem[64]
                    mem[mem[64]] = 2
                    _3300 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3300] = 0
                    mem[_3300 + 32] = 96
                    mem[_3300 + 64] = 96
                    mem[_3300 + 96] = 0
                    mem[_3300 + 128] = 0
                    mem[_3300 + 160] = 0
                    mem[_3300 + 192] = 0
                    mem[_3300 + 224] = 0
                    mem[var181001] = _3300
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _3300 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3300] = 0
                        mem[_3300 + 32] = 96
                        mem[_3300 + 64] = 96
                        mem[_3300 + 96] = 0
                        mem[_3300 + 128] = 0
                        mem[_3300 + 160] = 0
                        mem[_3300 + 192] = 0
                        mem[_3300 + 224] = 0
                        mem[s + 32] = _3300
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2682]
                    mem[_2682 + 32] = _1227
                    require 1 < mem[_2682]
                    mem[_2682 + 64] = _2414
                    _3348 = mem[64]
                    mem[mem[64]] = 32
                    _3364 = mem[_2682]
                    mem[mem[64] + 32] = mem[_2682]
                    idx = 0
                    s = _2682 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3364) + 64
                    while idx < _3364:
                        mem[t] = u + -_3348 - 64
                        _3892 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3916 = mem[_3892 + 32]
                        mem[u + 32] = 256
                        _3956 = mem[_3916]
                        mem[u + 256] = mem[_3916]
                        v = 0
                        while v < _3956:
                            mem[v + u + 288] = mem[v + _3916 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3956) <= _3956:
                            _4420 = mem[_3892 + 64]
                            mem[u + 64] = ceil32(_3956) + 288
                            _4439 = mem[_4420]
                            mem[ceil32(_3956) + u + 288] = mem[_4420]
                            v = 0
                            while v < _4439:
                                mem[v + ceil32(_3956) + u + 320] = mem[v + _4420 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4439) > _4439:
                                mem[ceil32(_3956) + u + _4439 + 320] = 0
                            mem[u + 96] = mem[_3892 + 96]
                            mem[u + 128] = mem[_3892 + 128]
                            mem[u + 160] = mem[_3892 + 160]
                            mem[u + 192] = mem[_3892 + 192]
                            mem[u + 224] = mem[_3892 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4439) + ceil32(_3956) + u + 320
                            continue 
                        mem[u + _3956 + 288] = 0
                        _4440 = mem[_3892 + 64]
                        mem[u + 64] = ceil32(_3956) + 288
                        _4468 = mem[_4440]
                        mem[ceil32(_3956) + u + 288] = mem[_4440]
                        v = 0
                        while v < _4468:
                            mem[v + ceil32(_3956) + u + 320] = mem[v + _4440 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4468) > _4468:
                            mem[ceil32(_3956) + u + _4468 + 320] = 0
                        mem[u + 96] = mem[_3892 + 96]
                        mem[u + 128] = mem[_3892 + 128]
                        mem[u + 160] = mem[_3892 + 160]
                        mem[u + 192] = mem[_3892 + 192]
                        mem[u + 224] = mem[_3892 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4468) + ceil32(_3956) + u + 320
                        continue 
        else:
            mem[_609 + ceil32(return_data.size) + _613 + 32] = 0
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1207 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1211 = mem[_1207]
            require mem[_1207] == mem[_1207 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1223 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1228 = mem[_1223]
            _1231 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1231] = address(ext_call.return_data[0])
            mem[_1231 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1231 + 64] = _609 + ceil32(return_data.size)
            mem[_1231 + 96] = uint8(_1211)
            mem[_1231 + 128] = 0
            mem[_1231 + 160] = _1228
            mem[_1231 + 192] = 0
            mem[_1231 + 224] = 0
            _1237 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1237] = 0
            mem[_1237 + 32] = 96
            mem[_1237 + 64] = 96
            mem[_1237 + 96] = 0
            mem[_1237 + 128] = 0
            mem[_1237 + 160] = 0
            mem[_1237 + 192] = 0
            mem[_1237 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1247 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1251 = mem[_1247]
            require mem[_1247] == mem[_1247 + 12 len 20]
            _1257 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1257] = 0
            mem[_1257 + 32] = 96
            mem[_1257 + 64] = 96
            mem[_1257 + 96] = 0
            mem[_1257 + 128] = 0
            mem[_1257 + 160] = 0
            mem[_1257 + 192] = 0
            mem[_1257 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1251))
            staticcall address(_1251).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1267 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1271 = mem[_1267]
            require mem[_1267] <= test266151307()
            require _1267 + return_data.size > _1267 + mem[_1267] + 31
            _1275 = mem[_1267 + mem[_1267]]
            require mem[_1267 + mem[_1267]] <= test266151307()
            require ceil32(mem[_1267 + mem[_1267]]) + 32 >= 0 and _1267 + ceil32(return_data.size) + ceil32(mem[_1267 + mem[_1267]]) + 32 <= test266151307()
            mem[64] = _1267 + ceil32(return_data.size) + ceil32(mem[_1267 + mem[_1267]]) + 32
            mem[_1267 + ceil32(return_data.size)] = _1275
            require _1271 + _1275 + 32 <= return_data.size
            mem[_1267 + ceil32(return_data.size) + 32 len ceil32(_1275)] = mem[_1267 + _1271 + 32 len ceil32(_1275)]
            if ceil32(_1275) <= _1275:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1251))
                staticcall address(_1251).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1794 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1802 = mem[_1794]
                require mem[_1794] <= test266151307()
                require _1794 + return_data.size > _1794 + mem[_1794] + 31
                _1810 = mem[_1794 + mem[_1794]]
                require mem[_1794 + mem[_1794]] <= test266151307()
                require ceil32(mem[_1794 + mem[_1794]]) + 32 >= 0 and _1794 + ceil32(return_data.size) + ceil32(mem[_1794 + mem[_1794]]) + 32 <= test266151307()
                mem[64] = _1794 + ceil32(return_data.size) + ceil32(mem[_1794 + mem[_1794]]) + 32
                mem[_1794 + ceil32(return_data.size)] = _1810
                require _1802 + _1810 + 32 <= return_data.size
                mem[_1794 + ceil32(return_data.size) + 32 len ceil32(_1810)] = mem[_1794 + _1802 + 32 len ceil32(_1810)]
                if ceil32(_1810) <= _1810:
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2307 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2323 = mem[_2307]
                    require mem[_2307] == mem[_2307 + 31 len 1]
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2371 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2387 = mem[_2371]
                    _2397 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2397] = address(_1251)
                    mem[_2397 + 32] = _1267 + ceil32(return_data.size)
                    mem[_2397 + 64] = _1794 + ceil32(return_data.size)
                    mem[_2397 + 96] = uint8(_2323)
                    mem[_2397 + 128] = 0
                    mem[_2397 + 160] = _2387
                    mem[_2397 + 192] = 0
                    mem[_2397 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2451 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2467 = mem[_2451]
                    require mem[_2451] == mem[_2451 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2467))
                    staticcall address(_2467).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2515 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1231 + 128] = mem[_2515]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2579 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2595 = mem[_2579]
                    require mem[_2579] == mem[_2579 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2595))
                    staticcall address(_2595).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2643 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2397 + 128] = mem[_2643]
                    _2669 = mem[64]
                    mem[mem[64]] = 2
                    _3301 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3301] = 0
                    mem[_3301 + 32] = 96
                    mem[_3301 + 64] = 96
                    mem[_3301 + 96] = 0
                    mem[_3301 + 128] = 0
                    mem[_3301 + 160] = 0
                    mem[_3301 + 192] = 0
                    mem[_3301 + 224] = 0
                    mem[var180001] = _3301
                    s = var180001
                    idx = var180002
                    while idx - 1:
                        _3301 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3301] = 0
                        mem[_3301 + 32] = 96
                        mem[_3301 + 64] = 96
                        mem[_3301 + 96] = 0
                        mem[_3301 + 128] = 0
                        mem[_3301 + 160] = 0
                        mem[_3301 + 192] = 0
                        mem[_3301 + 224] = 0
                        mem[s + 32] = _3301
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2669]
                    mem[_2669 + 32] = _1231
                    require 1 < mem[_2669]
                    mem[_2669 + 64] = _2397
                    _3349 = mem[64]
                    mem[mem[64]] = 32
                    _3365 = mem[_2669]
                    mem[mem[64] + 32] = mem[_2669]
                    idx = 0
                    s = _2669 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3365) + 64
                    while idx < _3365:
                        mem[t] = u + -_3349 - 64
                        _3893 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3919 = mem[_3893 + 32]
                        mem[u + 32] = 256
                        _3957 = mem[_3919]
                        mem[u + 256] = mem[_3919]
                        v = 0
                        while v < _3957:
                            mem[v + u + 288] = mem[v + _3919 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3957) <= _3957:
                            _4421 = mem[_3893 + 64]
                            mem[u + 64] = ceil32(_3957) + 288
                            _4441 = mem[_4421]
                            mem[ceil32(_3957) + u + 288] = mem[_4421]
                            v = 0
                            while v < _4441:
                                mem[v + ceil32(_3957) + u + 320] = mem[v + _4421 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4441) > _4441:
                                mem[ceil32(_3957) + u + _4441 + 320] = 0
                            mem[u + 96] = mem[_3893 + 96]
                            mem[u + 128] = mem[_3893 + 128]
                            mem[u + 160] = mem[_3893 + 160]
                            mem[u + 192] = mem[_3893 + 192]
                            mem[u + 224] = mem[_3893 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4441) + ceil32(_3957) + u + 320
                            continue 
                        mem[u + _3957 + 288] = 0
                        _4442 = mem[_3893 + 64]
                        mem[u + 64] = ceil32(_3957) + 288
                        _4469 = mem[_4442]
                        mem[ceil32(_3957) + u + 288] = mem[_4442]
                        v = 0
                        while v < _4469:
                            mem[v + ceil32(_3957) + u + 320] = mem[v + _4442 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4469) > _4469:
                            mem[ceil32(_3957) + u + _4469 + 320] = 0
                        mem[u + 96] = mem[_3893 + 96]
                        mem[u + 128] = mem[_3893 + 128]
                        mem[u + 160] = mem[_3893 + 160]
                        mem[u + 192] = mem[_3893 + 192]
                        mem[u + 224] = mem[_3893 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4469) + ceil32(_3957) + u + 320
                        continue 
                else:
                    mem[_1794 + ceil32(return_data.size) + _1810 + 32] = 0
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2315 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2331 = mem[_2315]
                    require mem[_2315] == mem[_2315 + 31 len 1]
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2379 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2398 = mem[_2379]
                    _2417 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2417] = address(_1251)
                    mem[_2417 + 32] = _1267 + ceil32(return_data.size)
                    mem[_2417 + 64] = _1794 + ceil32(return_data.size)
                    mem[_2417 + 96] = uint8(_2331)
                    mem[_2417 + 128] = 0
                    mem[_2417 + 160] = _2398
                    mem[_2417 + 192] = 0
                    mem[_2417 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2459 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2475 = mem[_2459]
                    require mem[_2459] == mem[_2459 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2475))
                    staticcall address(_2475).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2523 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1231 + 128] = mem[_2523]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2587 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2603 = mem[_2587]
                    require mem[_2587] == mem[_2587 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2603))
                    staticcall address(_2603).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2651 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2417 + 128] = mem[_2651]
                    _2683 = mem[64]
                    mem[mem[64]] = 2
                    _3302 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3302] = 0
                    mem[_3302 + 32] = 96
                    mem[_3302 + 64] = 96
                    mem[_3302 + 96] = 0
                    mem[_3302 + 128] = 0
                    mem[_3302 + 160] = 0
                    mem[_3302 + 192] = 0
                    mem[_3302 + 224] = 0
                    mem[var181001] = _3302
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _3302 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3302] = 0
                        mem[_3302 + 32] = 96
                        mem[_3302 + 64] = 96
                        mem[_3302 + 96] = 0
                        mem[_3302 + 128] = 0
                        mem[_3302 + 160] = 0
                        mem[_3302 + 192] = 0
                        mem[_3302 + 224] = 0
                        mem[s + 32] = _3302
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2683]
                    mem[_2683 + 32] = _1231
                    require 1 < mem[_2683]
                    mem[_2683 + 64] = _2417
                    _3350 = mem[64]
                    mem[mem[64]] = 32
                    _3366 = mem[_2683]
                    mem[mem[64] + 32] = mem[_2683]
                    idx = 0
                    s = _2683 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3366) + 64
                    while idx < _3366:
                        mem[t] = u + -_3350 - 64
                        _3894 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3922 = mem[_3894 + 32]
                        mem[u + 32] = 256
                        _3958 = mem[_3922]
                        mem[u + 256] = mem[_3922]
                        v = 0
                        while v < _3958:
                            mem[v + u + 288] = mem[v + _3922 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3958) <= _3958:
                            _4422 = mem[_3894 + 64]
                            mem[u + 64] = ceil32(_3958) + 288
                            _4443 = mem[_4422]
                            mem[ceil32(_3958) + u + 288] = mem[_4422]
                            v = 0
                            while v < _4443:
                                mem[v + ceil32(_3958) + u + 320] = mem[v + _4422 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4443) > _4443:
                                mem[ceil32(_3958) + u + _4443 + 320] = 0
                            mem[u + 96] = mem[_3894 + 96]
                            mem[u + 128] = mem[_3894 + 128]
                            mem[u + 160] = mem[_3894 + 160]
                            mem[u + 192] = mem[_3894 + 192]
                            mem[u + 224] = mem[_3894 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4443) + ceil32(_3958) + u + 320
                            continue 
                        mem[u + _3958 + 288] = 0
                        _4444 = mem[_3894 + 64]
                        mem[u + 64] = ceil32(_3958) + 288
                        _4470 = mem[_4444]
                        mem[ceil32(_3958) + u + 288] = mem[_4444]
                        v = 0
                        while v < _4470:
                            mem[v + ceil32(_3958) + u + 320] = mem[v + _4444 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4470) > _4470:
                            mem[ceil32(_3958) + u + _4470 + 320] = 0
                        mem[u + 96] = mem[_3894 + 96]
                        mem[u + 128] = mem[_3894 + 128]
                        mem[u + 160] = mem[_3894 + 160]
                        mem[u + 192] = mem[_3894 + 192]
                        mem[u + 224] = mem[_3894 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4470) + ceil32(_3958) + u + 320
                        continue 
            else:
                mem[_1267 + ceil32(return_data.size) + _1275 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1251))
                staticcall address(_1251).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1798 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1806 = mem[_1798]
                require mem[_1798] <= test266151307()
                require _1798 + return_data.size > _1798 + mem[_1798] + 31
                _1814 = mem[_1798 + mem[_1798]]
                require mem[_1798 + mem[_1798]] <= test266151307()
                require ceil32(mem[_1798 + mem[_1798]]) + 32 >= 0 and _1798 + ceil32(return_data.size) + ceil32(mem[_1798 + mem[_1798]]) + 32 <= test266151307()
                mem[64] = _1798 + ceil32(return_data.size) + ceil32(mem[_1798 + mem[_1798]]) + 32
                mem[_1798 + ceil32(return_data.size)] = _1814
                require _1806 + _1814 + 32 <= return_data.size
                mem[_1798 + ceil32(return_data.size) + 32 len ceil32(_1814)] = mem[_1798 + _1806 + 32 len ceil32(_1814)]
                if ceil32(_1814) <= _1814:
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2308 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2324 = mem[_2308]
                    require mem[_2308] == mem[_2308 + 31 len 1]
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2372 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2388 = mem[_2372]
                    _2399 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2399] = address(_1251)
                    mem[_2399 + 32] = _1267 + ceil32(return_data.size)
                    mem[_2399 + 64] = _1798 + ceil32(return_data.size)
                    mem[_2399 + 96] = uint8(_2324)
                    mem[_2399 + 128] = 0
                    mem[_2399 + 160] = _2388
                    mem[_2399 + 192] = 0
                    mem[_2399 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2452 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2468 = mem[_2452]
                    require mem[_2452] == mem[_2452 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2468))
                    staticcall address(_2468).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2516 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1231 + 128] = mem[_2516]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2580 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2596 = mem[_2580]
                    require mem[_2580] == mem[_2580 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2596))
                    staticcall address(_2596).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2644 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2399 + 128] = mem[_2644]
                    _2671 = mem[64]
                    mem[mem[64]] = 2
                    _3303 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3303] = 0
                    mem[_3303 + 32] = 96
                    mem[_3303 + 64] = 96
                    mem[_3303 + 96] = 0
                    mem[_3303 + 128] = 0
                    mem[_3303 + 160] = 0
                    mem[_3303 + 192] = 0
                    mem[_3303 + 224] = 0
                    mem[var181001] = _3303
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _3303 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3303] = 0
                        mem[_3303 + 32] = 96
                        mem[_3303 + 64] = 96
                        mem[_3303 + 96] = 0
                        mem[_3303 + 128] = 0
                        mem[_3303 + 160] = 0
                        mem[_3303 + 192] = 0
                        mem[_3303 + 224] = 0
                        mem[s + 32] = _3303
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2671]
                    mem[_2671 + 32] = _1231
                    require 1 < mem[_2671]
                    mem[_2671 + 64] = _2399
                    _3351 = mem[64]
                    mem[mem[64]] = 32
                    _3367 = mem[_2671]
                    mem[mem[64] + 32] = mem[_2671]
                    idx = 0
                    s = _2671 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3367) + 64
                    while idx < _3367:
                        mem[t] = u + -_3351 - 64
                        _3895 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3925 = mem[_3895 + 32]
                        mem[u + 32] = 256
                        _3959 = mem[_3925]
                        mem[u + 256] = mem[_3925]
                        v = 0
                        while v < _3959:
                            mem[v + u + 288] = mem[v + _3925 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3959) <= _3959:
                            _4423 = mem[_3895 + 64]
                            mem[u + 64] = ceil32(_3959) + 288
                            _4445 = mem[_4423]
                            mem[ceil32(_3959) + u + 288] = mem[_4423]
                            v = 0
                            while v < _4445:
                                mem[v + ceil32(_3959) + u + 320] = mem[v + _4423 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4445) > _4445:
                                mem[ceil32(_3959) + u + _4445 + 320] = 0
                            mem[u + 96] = mem[_3895 + 96]
                            mem[u + 128] = mem[_3895 + 128]
                            mem[u + 160] = mem[_3895 + 160]
                            mem[u + 192] = mem[_3895 + 192]
                            mem[u + 224] = mem[_3895 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4445) + ceil32(_3959) + u + 320
                            continue 
                        mem[u + _3959 + 288] = 0
                        _4446 = mem[_3895 + 64]
                        mem[u + 64] = ceil32(_3959) + 288
                        _4471 = mem[_4446]
                        mem[ceil32(_3959) + u + 288] = mem[_4446]
                        v = 0
                        while v < _4471:
                            mem[v + ceil32(_3959) + u + 320] = mem[v + _4446 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4471) > _4471:
                            mem[ceil32(_3959) + u + _4471 + 320] = 0
                        mem[u + 96] = mem[_3895 + 96]
                        mem[u + 128] = mem[_3895 + 128]
                        mem[u + 160] = mem[_3895 + 160]
                        mem[u + 192] = mem[_3895 + 192]
                        mem[u + 224] = mem[_3895 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4471) + ceil32(_3959) + u + 320
                        continue 
                else:
                    mem[_1798 + ceil32(return_data.size) + _1814 + 32] = 0
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2316 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2332 = mem[_2316]
                    require mem[_2316] == mem[_2316 + 31 len 1]
                    require ext_code.size(address(_1251))
                    staticcall address(_1251).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2380 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2400 = mem[_2380]
                    _2420 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2420] = address(_1251)
                    mem[_2420 + 32] = _1267 + ceil32(return_data.size)
                    mem[_2420 + 64] = _1798 + ceil32(return_data.size)
                    mem[_2420 + 96] = uint8(_2332)
                    mem[_2420 + 128] = 0
                    mem[_2420 + 160] = _2400
                    mem[_2420 + 192] = 0
                    mem[_2420 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2460 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2476 = mem[_2460]
                    require mem[_2460] == mem[_2460 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2476))
                    staticcall address(_2476).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2524 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1231 + 128] = mem[_2524]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2588 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2604 = mem[_2588]
                    require mem[_2588] == mem[_2588 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2604))
                    staticcall address(_2604).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2652 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2420 + 128] = mem[_2652]
                    _2684 = mem[64]
                    mem[mem[64]] = 2
                    _3304 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3304] = 0
                    mem[_3304 + 32] = 96
                    mem[_3304 + 64] = 96
                    mem[_3304 + 96] = 0
                    mem[_3304 + 128] = 0
                    mem[_3304 + 160] = 0
                    mem[_3304 + 192] = 0
                    mem[_3304 + 224] = 0
                    mem[var182001] = _3304
                    s = var182001
                    idx = var182002
                    while idx - 1:
                        _3304 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3304] = 0
                        mem[_3304 + 32] = 96
                        mem[_3304 + 64] = 96
                        mem[_3304 + 96] = 0
                        mem[_3304 + 128] = 0
                        mem[_3304 + 160] = 0
                        mem[_3304 + 192] = 0
                        mem[_3304 + 224] = 0
                        mem[s + 32] = _3304
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2684]
                    mem[_2684 + 32] = _1231
                    require 1 < mem[_2684]
                    mem[_2684 + 64] = _2420
                    _3352 = mem[64]
                    mem[mem[64]] = 32
                    _3368 = mem[_2684]
                    mem[mem[64] + 32] = mem[_2684]
                    idx = 0
                    s = _2684 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3368) + 64
                    while idx < _3368:
                        mem[t] = u + -_3352 - 64
                        _3896 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3928 = mem[_3896 + 32]
                        mem[u + 32] = 256
                        _3960 = mem[_3928]
                        mem[u + 256] = mem[_3928]
                        v = 0
                        while v < _3960:
                            mem[v + u + 288] = mem[v + _3928 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3960) <= _3960:
                            _4424 = mem[_3896 + 64]
                            mem[u + 64] = ceil32(_3960) + 288
                            _4447 = mem[_4424]
                            mem[ceil32(_3960) + u + 288] = mem[_4424]
                            v = 0
                            while v < _4447:
                                mem[v + ceil32(_3960) + u + 320] = mem[v + _4424 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4447) > _4447:
                                mem[ceil32(_3960) + u + _4447 + 320] = 0
                            mem[u + 96] = mem[_3896 + 96]
                            mem[u + 128] = mem[_3896 + 128]
                            mem[u + 160] = mem[_3896 + 160]
                            mem[u + 192] = mem[_3896 + 192]
                            mem[u + 224] = mem[_3896 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4447) + ceil32(_3960) + u + 320
                            continue 
                        mem[u + _3960 + 288] = 0
                        _4448 = mem[_3896 + 64]
                        mem[u + 64] = ceil32(_3960) + 288
                        _4472 = mem[_4448]
                        mem[ceil32(_3960) + u + 288] = mem[_4448]
                        v = 0
                        while v < _4472:
                            mem[v + ceil32(_3960) + u + 320] = mem[v + _4448 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4472) > _4472:
                            mem[ceil32(_3960) + u + _4472 + 320] = 0
                        mem[u + 96] = mem[_3896 + 96]
                        mem[u + 128] = mem[_3896 + 128]
                        mem[u + 160] = mem[_3896 + 160]
                        mem[u + 192] = mem[_3896 + 192]
                        mem[u + 224] = mem[_3896 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4472) + ceil32(_3960) + u + 320
                        continue 
    else:
        mem[(2 * ceil32(return_data.size)) + _11 + 640] = 0
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _610 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _612 = mem[_610]
        require mem[_610] <= test266151307()
        require _610 + return_data.size > _610 + mem[_610] + 31
        _614 = mem[_610 + mem[_610]]
        require mem[_610 + mem[_610]] <= test266151307()
        require ceil32(mem[_610 + mem[_610]]) + 32 >= 0 and _610 + ceil32(return_data.size) + ceil32(mem[_610 + mem[_610]]) + 32 <= test266151307()
        mem[64] = _610 + ceil32(return_data.size) + ceil32(mem[_610 + mem[_610]]) + 32
        mem[_610 + ceil32(return_data.size)] = _614
        require _612 + _614 + 32 <= return_data.size
        mem[_610 + ceil32(return_data.size) + 32 len ceil32(_614)] = mem[_610 + _612 + 32 len ceil32(_614)]
        if ceil32(_614) <= _614:
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1206 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1210 = mem[_1206]
            require mem[_1206] == mem[_1206 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1222 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1226 = mem[_1222]
            _1229 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1229] = address(ext_call.return_data[0])
            mem[_1229 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1229 + 64] = _610 + ceil32(return_data.size)
            mem[_1229 + 96] = uint8(_1210)
            mem[_1229 + 128] = 0
            mem[_1229 + 160] = _1226
            mem[_1229 + 192] = 0
            mem[_1229 + 224] = 0
            _1234 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1234] = 0
            mem[_1234 + 32] = 96
            mem[_1234 + 64] = 96
            mem[_1234 + 96] = 0
            mem[_1234 + 128] = 0
            mem[_1234 + 160] = 0
            mem[_1234 + 192] = 0
            mem[_1234 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1246 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1250 = mem[_1246]
            require mem[_1246] == mem[_1246 + 12 len 20]
            _1254 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1254] = 0
            mem[_1254 + 32] = 96
            mem[_1254 + 64] = 96
            mem[_1254 + 96] = 0
            mem[_1254 + 128] = 0
            mem[_1254 + 160] = 0
            mem[_1254 + 192] = 0
            mem[_1254 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1250))
            staticcall address(_1250).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1266 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1270 = mem[_1266]
            require mem[_1266] <= test266151307()
            require _1266 + return_data.size > _1266 + mem[_1266] + 31
            _1274 = mem[_1266 + mem[_1266]]
            require mem[_1266 + mem[_1266]] <= test266151307()
            require ceil32(mem[_1266 + mem[_1266]]) + 32 >= 0 and _1266 + ceil32(return_data.size) + ceil32(mem[_1266 + mem[_1266]]) + 32 <= test266151307()
            mem[64] = _1266 + ceil32(return_data.size) + ceil32(mem[_1266 + mem[_1266]]) + 32
            mem[_1266 + ceil32(return_data.size)] = _1274
            require _1270 + _1274 + 32 <= return_data.size
            mem[_1266 + ceil32(return_data.size) + 32 len ceil32(_1274)] = mem[_1266 + _1270 + 32 len ceil32(_1274)]
            if ceil32(_1274) <= _1274:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1250))
                staticcall address(_1250).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1795 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1803 = mem[_1795]
                require mem[_1795] <= test266151307()
                require _1795 + return_data.size > _1795 + mem[_1795] + 31
                _1811 = mem[_1795 + mem[_1795]]
                require mem[_1795 + mem[_1795]] <= test266151307()
                require ceil32(mem[_1795 + mem[_1795]]) + 32 >= 0 and _1795 + ceil32(return_data.size) + ceil32(mem[_1795 + mem[_1795]]) + 32 <= test266151307()
                mem[64] = _1795 + ceil32(return_data.size) + ceil32(mem[_1795 + mem[_1795]]) + 32
                mem[_1795 + ceil32(return_data.size)] = _1811
                require _1803 + _1811 + 32 <= return_data.size
                mem[_1795 + ceil32(return_data.size) + 32 len ceil32(_1811)] = mem[_1795 + _1803 + 32 len ceil32(_1811)]
                if ceil32(_1811) <= _1811:
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2309 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2325 = mem[_2309]
                    require mem[_2309] == mem[_2309 + 31 len 1]
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2373 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2389 = mem[_2373]
                    _2401 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2401] = address(_1250)
                    mem[_2401 + 32] = _1266 + ceil32(return_data.size)
                    mem[_2401 + 64] = _1795 + ceil32(return_data.size)
                    mem[_2401 + 96] = uint8(_2325)
                    mem[_2401 + 128] = 0
                    mem[_2401 + 160] = _2389
                    mem[_2401 + 192] = 0
                    mem[_2401 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2453 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2469 = mem[_2453]
                    require mem[_2453] == mem[_2453 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2469))
                    staticcall address(_2469).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2517 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1229 + 128] = mem[_2517]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2581 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2597 = mem[_2581]
                    require mem[_2581] == mem[_2581 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2597))
                    staticcall address(_2597).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2645 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2401 + 128] = mem[_2645]
                    _2673 = mem[64]
                    mem[mem[64]] = 2
                    _3305 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3305] = 0
                    mem[_3305 + 32] = 96
                    mem[_3305 + 64] = 96
                    mem[_3305 + 96] = 0
                    mem[_3305 + 128] = 0
                    mem[_3305 + 160] = 0
                    mem[_3305 + 192] = 0
                    mem[_3305 + 224] = 0
                    mem[var180001] = _3305
                    s = var180001
                    idx = var180002
                    while idx - 1:
                        _3305 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3305] = 0
                        mem[_3305 + 32] = 96
                        mem[_3305 + 64] = 96
                        mem[_3305 + 96] = 0
                        mem[_3305 + 128] = 0
                        mem[_3305 + 160] = 0
                        mem[_3305 + 192] = 0
                        mem[_3305 + 224] = 0
                        mem[s + 32] = _3305
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2673]
                    mem[_2673 + 32] = _1229
                    require 1 < mem[_2673]
                    mem[_2673 + 64] = _2401
                    _3353 = mem[64]
                    mem[mem[64]] = 32
                    _3369 = mem[_2673]
                    mem[mem[64] + 32] = mem[_2673]
                    idx = 0
                    s = _2673 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3369) + 64
                    while idx < _3369:
                        mem[t] = u + -_3353 - 64
                        _3897 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3931 = mem[_3897 + 32]
                        mem[u + 32] = 256
                        _3961 = mem[_3931]
                        mem[u + 256] = mem[_3931]
                        v = 0
                        while v < _3961:
                            mem[v + u + 288] = mem[v + _3931 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3961) <= _3961:
                            _4425 = mem[_3897 + 64]
                            mem[u + 64] = ceil32(_3961) + 288
                            _4449 = mem[_4425]
                            mem[ceil32(_3961) + u + 288] = mem[_4425]
                            v = 0
                            while v < _4449:
                                mem[v + ceil32(_3961) + u + 320] = mem[v + _4425 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4449) > _4449:
                                mem[ceil32(_3961) + u + _4449 + 320] = 0
                            mem[u + 96] = mem[_3897 + 96]
                            mem[u + 128] = mem[_3897 + 128]
                            mem[u + 160] = mem[_3897 + 160]
                            mem[u + 192] = mem[_3897 + 192]
                            mem[u + 224] = mem[_3897 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4449) + ceil32(_3961) + u + 320
                            continue 
                        mem[u + _3961 + 288] = 0
                        _4450 = mem[_3897 + 64]
                        mem[u + 64] = ceil32(_3961) + 288
                        _4473 = mem[_4450]
                        mem[ceil32(_3961) + u + 288] = mem[_4450]
                        v = 0
                        while v < _4473:
                            mem[v + ceil32(_3961) + u + 320] = mem[v + _4450 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4473) > _4473:
                            mem[ceil32(_3961) + u + _4473 + 320] = 0
                        mem[u + 96] = mem[_3897 + 96]
                        mem[u + 128] = mem[_3897 + 128]
                        mem[u + 160] = mem[_3897 + 160]
                        mem[u + 192] = mem[_3897 + 192]
                        mem[u + 224] = mem[_3897 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4473) + ceil32(_3961) + u + 320
                        continue 
                else:
                    mem[_1795 + ceil32(return_data.size) + _1811 + 32] = 0
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2317 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2333 = mem[_2317]
                    require mem[_2317] == mem[_2317 + 31 len 1]
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2381 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2402 = mem[_2381]
                    _2423 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2423] = address(_1250)
                    mem[_2423 + 32] = _1266 + ceil32(return_data.size)
                    mem[_2423 + 64] = _1795 + ceil32(return_data.size)
                    mem[_2423 + 96] = uint8(_2333)
                    mem[_2423 + 128] = 0
                    mem[_2423 + 160] = _2402
                    mem[_2423 + 192] = 0
                    mem[_2423 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2461 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2477 = mem[_2461]
                    require mem[_2461] == mem[_2461 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2477))
                    staticcall address(_2477).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2525 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1229 + 128] = mem[_2525]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2589 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2605 = mem[_2589]
                    require mem[_2589] == mem[_2589 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2605))
                    staticcall address(_2605).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2653 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2423 + 128] = mem[_2653]
                    _2685 = mem[64]
                    mem[mem[64]] = 2
                    _3306 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3306] = 0
                    mem[_3306 + 32] = 96
                    mem[_3306 + 64] = 96
                    mem[_3306 + 96] = 0
                    mem[_3306 + 128] = 0
                    mem[_3306 + 160] = 0
                    mem[_3306 + 192] = 0
                    mem[_3306 + 224] = 0
                    mem[var181001] = _3306
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _3306 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3306] = 0
                        mem[_3306 + 32] = 96
                        mem[_3306 + 64] = 96
                        mem[_3306 + 96] = 0
                        mem[_3306 + 128] = 0
                        mem[_3306 + 160] = 0
                        mem[_3306 + 192] = 0
                        mem[_3306 + 224] = 0
                        mem[s + 32] = _3306
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2685]
                    mem[_2685 + 32] = _1229
                    require 1 < mem[_2685]
                    mem[_2685 + 64] = _2423
                    _3354 = mem[64]
                    mem[mem[64]] = 32
                    _3370 = mem[_2685]
                    mem[mem[64] + 32] = mem[_2685]
                    idx = 0
                    s = _2685 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3370) + 64
                    while idx < _3370:
                        mem[t] = u + -_3354 - 64
                        _3898 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3934 = mem[_3898 + 32]
                        mem[u + 32] = 256
                        _3962 = mem[_3934]
                        mem[u + 256] = mem[_3934]
                        v = 0
                        while v < _3962:
                            mem[v + u + 288] = mem[v + _3934 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3962) <= _3962:
                            _4426 = mem[_3898 + 64]
                            mem[u + 64] = ceil32(_3962) + 288
                            _4451 = mem[_4426]
                            mem[ceil32(_3962) + u + 288] = mem[_4426]
                            v = 0
                            while v < _4451:
                                mem[v + ceil32(_3962) + u + 320] = mem[v + _4426 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4451) > _4451:
                                mem[ceil32(_3962) + u + _4451 + 320] = 0
                            mem[u + 96] = mem[_3898 + 96]
                            mem[u + 128] = mem[_3898 + 128]
                            mem[u + 160] = mem[_3898 + 160]
                            mem[u + 192] = mem[_3898 + 192]
                            mem[u + 224] = mem[_3898 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4451) + ceil32(_3962) + u + 320
                            continue 
                        mem[u + _3962 + 288] = 0
                        _4452 = mem[_3898 + 64]
                        mem[u + 64] = ceil32(_3962) + 288
                        _4474 = mem[_4452]
                        mem[ceil32(_3962) + u + 288] = mem[_4452]
                        v = 0
                        while v < _4474:
                            mem[v + ceil32(_3962) + u + 320] = mem[v + _4452 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4474) > _4474:
                            mem[ceil32(_3962) + u + _4474 + 320] = 0
                        mem[u + 96] = mem[_3898 + 96]
                        mem[u + 128] = mem[_3898 + 128]
                        mem[u + 160] = mem[_3898 + 160]
                        mem[u + 192] = mem[_3898 + 192]
                        mem[u + 224] = mem[_3898 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4474) + ceil32(_3962) + u + 320
                        continue 
            else:
                mem[_1266 + ceil32(return_data.size) + _1274 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1250))
                staticcall address(_1250).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1799 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1807 = mem[_1799]
                require mem[_1799] <= test266151307()
                require _1799 + return_data.size > _1799 + mem[_1799] + 31
                _1815 = mem[_1799 + mem[_1799]]
                require mem[_1799 + mem[_1799]] <= test266151307()
                require ceil32(mem[_1799 + mem[_1799]]) + 32 >= 0 and _1799 + ceil32(return_data.size) + ceil32(mem[_1799 + mem[_1799]]) + 32 <= test266151307()
                mem[64] = _1799 + ceil32(return_data.size) + ceil32(mem[_1799 + mem[_1799]]) + 32
                mem[_1799 + ceil32(return_data.size)] = _1815
                require _1807 + _1815 + 32 <= return_data.size
                mem[_1799 + ceil32(return_data.size) + 32 len ceil32(_1815)] = mem[_1799 + _1807 + 32 len ceil32(_1815)]
                if ceil32(_1815) <= _1815:
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2310 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2326 = mem[_2310]
                    require mem[_2310] == mem[_2310 + 31 len 1]
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2374 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2390 = mem[_2374]
                    _2403 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2403] = address(_1250)
                    mem[_2403 + 32] = _1266 + ceil32(return_data.size)
                    mem[_2403 + 64] = _1799 + ceil32(return_data.size)
                    mem[_2403 + 96] = uint8(_2326)
                    mem[_2403 + 128] = 0
                    mem[_2403 + 160] = _2390
                    mem[_2403 + 192] = 0
                    mem[_2403 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2454 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2470 = mem[_2454]
                    require mem[_2454] == mem[_2454 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2470))
                    staticcall address(_2470).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2518 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1229 + 128] = mem[_2518]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2582 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2598 = mem[_2582]
                    require mem[_2582] == mem[_2582 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2598))
                    staticcall address(_2598).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2646 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2403 + 128] = mem[_2646]
                    _2675 = mem[64]
                    mem[mem[64]] = 2
                    _3307 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3307] = 0
                    mem[_3307 + 32] = 96
                    mem[_3307 + 64] = 96
                    mem[_3307 + 96] = 0
                    mem[_3307 + 128] = 0
                    mem[_3307 + 160] = 0
                    mem[_3307 + 192] = 0
                    mem[_3307 + 224] = 0
                    mem[var181001] = _3307
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _3307 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3307] = 0
                        mem[_3307 + 32] = 96
                        mem[_3307 + 64] = 96
                        mem[_3307 + 96] = 0
                        mem[_3307 + 128] = 0
                        mem[_3307 + 160] = 0
                        mem[_3307 + 192] = 0
                        mem[_3307 + 224] = 0
                        mem[s + 32] = _3307
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2675]
                    mem[_2675 + 32] = _1229
                    require 1 < mem[_2675]
                    mem[_2675 + 64] = _2403
                    _3355 = mem[64]
                    mem[mem[64]] = 32
                    _3371 = mem[_2675]
                    mem[mem[64] + 32] = mem[_2675]
                    idx = 0
                    s = _2675 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3371) + 64
                    while idx < _3371:
                        mem[t] = u + -_3355 - 64
                        _3899 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3937 = mem[_3899 + 32]
                        mem[u + 32] = 256
                        _3963 = mem[_3937]
                        mem[u + 256] = mem[_3937]
                        v = 0
                        while v < _3963:
                            mem[v + u + 288] = mem[v + _3937 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3963) <= _3963:
                            _4427 = mem[_3899 + 64]
                            mem[u + 64] = ceil32(_3963) + 288
                            _4453 = mem[_4427]
                            mem[ceil32(_3963) + u + 288] = mem[_4427]
                            v = 0
                            while v < _4453:
                                mem[v + ceil32(_3963) + u + 320] = mem[v + _4427 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4453) > _4453:
                                mem[ceil32(_3963) + u + _4453 + 320] = 0
                            mem[u + 96] = mem[_3899 + 96]
                            mem[u + 128] = mem[_3899 + 128]
                            mem[u + 160] = mem[_3899 + 160]
                            mem[u + 192] = mem[_3899 + 192]
                            mem[u + 224] = mem[_3899 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4453) + ceil32(_3963) + u + 320
                            continue 
                        mem[u + _3963 + 288] = 0
                        _4454 = mem[_3899 + 64]
                        mem[u + 64] = ceil32(_3963) + 288
                        _4475 = mem[_4454]
                        mem[ceil32(_3963) + u + 288] = mem[_4454]
                        v = 0
                        while v < _4475:
                            mem[v + ceil32(_3963) + u + 320] = mem[v + _4454 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4475) > _4475:
                            mem[ceil32(_3963) + u + _4475 + 320] = 0
                        mem[u + 96] = mem[_3899 + 96]
                        mem[u + 128] = mem[_3899 + 128]
                        mem[u + 160] = mem[_3899 + 160]
                        mem[u + 192] = mem[_3899 + 192]
                        mem[u + 224] = mem[_3899 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4475) + ceil32(_3963) + u + 320
                        continue 
                else:
                    mem[_1799 + ceil32(return_data.size) + _1815 + 32] = 0
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2318 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2334 = mem[_2318]
                    require mem[_2318] == mem[_2318 + 31 len 1]
                    require ext_code.size(address(_1250))
                    staticcall address(_1250).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2382 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2404 = mem[_2382]
                    _2426 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2426] = address(_1250)
                    mem[_2426 + 32] = _1266 + ceil32(return_data.size)
                    mem[_2426 + 64] = _1799 + ceil32(return_data.size)
                    mem[_2426 + 96] = uint8(_2334)
                    mem[_2426 + 128] = 0
                    mem[_2426 + 160] = _2404
                    mem[_2426 + 192] = 0
                    mem[_2426 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2462 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2478 = mem[_2462]
                    require mem[_2462] == mem[_2462 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2478))
                    staticcall address(_2478).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2526 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1229 + 128] = mem[_2526]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2590 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2606 = mem[_2590]
                    require mem[_2590] == mem[_2590 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2606))
                    staticcall address(_2606).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2654 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2426 + 128] = mem[_2654]
                    _2686 = mem[64]
                    mem[mem[64]] = 2
                    _3308 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3308] = 0
                    mem[_3308 + 32] = 96
                    mem[_3308 + 64] = 96
                    mem[_3308 + 96] = 0
                    mem[_3308 + 128] = 0
                    mem[_3308 + 160] = 0
                    mem[_3308 + 192] = 0
                    mem[_3308 + 224] = 0
                    mem[var182001] = _3308
                    s = var182001
                    idx = var182002
                    while idx - 1:
                        _3308 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3308] = 0
                        mem[_3308 + 32] = 96
                        mem[_3308 + 64] = 96
                        mem[_3308 + 96] = 0
                        mem[_3308 + 128] = 0
                        mem[_3308 + 160] = 0
                        mem[_3308 + 192] = 0
                        mem[_3308 + 224] = 0
                        mem[s + 32] = _3308
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2686]
                    mem[_2686 + 32] = _1229
                    require 1 < mem[_2686]
                    mem[_2686 + 64] = _2426
                    _3356 = mem[64]
                    mem[mem[64]] = 32
                    _3372 = mem[_2686]
                    mem[mem[64] + 32] = mem[_2686]
                    idx = 0
                    s = _2686 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3372) + 64
                    while idx < _3372:
                        mem[t] = u + -_3356 - 64
                        _3900 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3940 = mem[_3900 + 32]
                        mem[u + 32] = 256
                        _3964 = mem[_3940]
                        mem[u + 256] = mem[_3940]
                        v = 0
                        while v < _3964:
                            mem[v + u + 288] = mem[v + _3940 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3964) <= _3964:
                            _4428 = mem[_3900 + 64]
                            mem[u + 64] = ceil32(_3964) + 288
                            _4455 = mem[_4428]
                            mem[ceil32(_3964) + u + 288] = mem[_4428]
                            v = 0
                            while v < _4455:
                                mem[v + ceil32(_3964) + u + 320] = mem[v + _4428 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4455) > _4455:
                                mem[ceil32(_3964) + u + _4455 + 320] = 0
                            mem[u + 96] = mem[_3900 + 96]
                            mem[u + 128] = mem[_3900 + 128]
                            mem[u + 160] = mem[_3900 + 160]
                            mem[u + 192] = mem[_3900 + 192]
                            mem[u + 224] = mem[_3900 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4455) + ceil32(_3964) + u + 320
                            continue 
                        mem[u + _3964 + 288] = 0
                        _4456 = mem[_3900 + 64]
                        mem[u + 64] = ceil32(_3964) + 288
                        _4476 = mem[_4456]
                        mem[ceil32(_3964) + u + 288] = mem[_4456]
                        v = 0
                        while v < _4476:
                            mem[v + ceil32(_3964) + u + 320] = mem[v + _4456 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4476) > _4476:
                            mem[ceil32(_3964) + u + _4476 + 320] = 0
                        mem[u + 96] = mem[_3900 + 96]
                        mem[u + 128] = mem[_3900 + 128]
                        mem[u + 160] = mem[_3900 + 160]
                        mem[u + 192] = mem[_3900 + 192]
                        mem[u + 224] = mem[_3900 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4476) + ceil32(_3964) + u + 320
                        continue 
        else:
            mem[_610 + ceil32(return_data.size) + _614 + 32] = 0
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1208 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1212 = mem[_1208]
            require mem[_1208] == mem[_1208 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1224 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1230 = mem[_1224]
            _1232 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1232] = address(ext_call.return_data[0])
            mem[_1232 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1232 + 64] = _610 + ceil32(return_data.size)
            mem[_1232 + 96] = uint8(_1212)
            mem[_1232 + 128] = 0
            mem[_1232 + 160] = _1230
            mem[_1232 + 192] = 0
            mem[_1232 + 224] = 0
            _1240 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1240] = 0
            mem[_1240 + 32] = 96
            mem[_1240 + 64] = 96
            mem[_1240 + 96] = 0
            mem[_1240 + 128] = 0
            mem[_1240 + 160] = 0
            mem[_1240 + 192] = 0
            mem[_1240 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1252 = mem[_1248]
            require mem[_1248] == mem[_1248 + 12 len 20]
            _1260 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1260] = 0
            mem[_1260 + 32] = 96
            mem[_1260 + 64] = 96
            mem[_1260 + 96] = 0
            mem[_1260 + 128] = 0
            mem[_1260 + 160] = 0
            mem[_1260 + 192] = 0
            mem[_1260 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1252))
            staticcall address(_1252).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1268 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1272 = mem[_1268]
            require mem[_1268] <= test266151307()
            require _1268 + return_data.size > _1268 + mem[_1268] + 31
            _1276 = mem[_1268 + mem[_1268]]
            require mem[_1268 + mem[_1268]] <= test266151307()
            require ceil32(mem[_1268 + mem[_1268]]) + 32 >= 0 and _1268 + ceil32(return_data.size) + ceil32(mem[_1268 + mem[_1268]]) + 32 <= test266151307()
            mem[64] = _1268 + ceil32(return_data.size) + ceil32(mem[_1268 + mem[_1268]]) + 32
            mem[_1268 + ceil32(return_data.size)] = _1276
            require _1272 + _1276 + 32 <= return_data.size
            mem[_1268 + ceil32(return_data.size) + 32 len ceil32(_1276)] = mem[_1268 + _1272 + 32 len ceil32(_1276)]
            if ceil32(_1276) <= _1276:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1252))
                staticcall address(_1252).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1796 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1804 = mem[_1796]
                require mem[_1796] <= test266151307()
                require _1796 + return_data.size > _1796 + mem[_1796] + 31
                _1812 = mem[_1796 + mem[_1796]]
                require mem[_1796 + mem[_1796]] <= test266151307()
                require ceil32(mem[_1796 + mem[_1796]]) + 32 >= 0 and _1796 + ceil32(return_data.size) + ceil32(mem[_1796 + mem[_1796]]) + 32 <= test266151307()
                mem[64] = _1796 + ceil32(return_data.size) + ceil32(mem[_1796 + mem[_1796]]) + 32
                mem[_1796 + ceil32(return_data.size)] = _1812
                require _1804 + _1812 + 32 <= return_data.size
                mem[_1796 + ceil32(return_data.size) + 32 len ceil32(_1812)] = mem[_1796 + _1804 + 32 len ceil32(_1812)]
                if ceil32(_1812) <= _1812:
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2311 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2327 = mem[_2311]
                    require mem[_2311] == mem[_2311 + 31 len 1]
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2375 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2391 = mem[_2375]
                    _2405 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2405] = address(_1252)
                    mem[_2405 + 32] = _1268 + ceil32(return_data.size)
                    mem[_2405 + 64] = _1796 + ceil32(return_data.size)
                    mem[_2405 + 96] = uint8(_2327)
                    mem[_2405 + 128] = 0
                    mem[_2405 + 160] = _2391
                    mem[_2405 + 192] = 0
                    mem[_2405 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2455 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2471 = mem[_2455]
                    require mem[_2455] == mem[_2455 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2471))
                    staticcall address(_2471).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2519 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1232 + 128] = mem[_2519]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2583 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2599 = mem[_2583]
                    require mem[_2583] == mem[_2583 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2599))
                    staticcall address(_2599).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2647 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2405 + 128] = mem[_2647]
                    _2677 = mem[64]
                    mem[mem[64]] = 2
                    _3309 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3309] = 0
                    mem[_3309 + 32] = 96
                    mem[_3309 + 64] = 96
                    mem[_3309 + 96] = 0
                    mem[_3309 + 128] = 0
                    mem[_3309 + 160] = 0
                    mem[_3309 + 192] = 0
                    mem[_3309 + 224] = 0
                    mem[var181001] = _3309
                    s = var181001
                    idx = var181002
                    while idx - 1:
                        _3309 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3309] = 0
                        mem[_3309 + 32] = 96
                        mem[_3309 + 64] = 96
                        mem[_3309 + 96] = 0
                        mem[_3309 + 128] = 0
                        mem[_3309 + 160] = 0
                        mem[_3309 + 192] = 0
                        mem[_3309 + 224] = 0
                        mem[s + 32] = _3309
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2677]
                    mem[_2677 + 32] = _1232
                    require 1 < mem[_2677]
                    mem[_2677 + 64] = _2405
                    _3357 = mem[64]
                    mem[mem[64]] = 32
                    _3373 = mem[_2677]
                    mem[mem[64] + 32] = mem[_2677]
                    idx = 0
                    s = _2677 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3373) + 64
                    while idx < _3373:
                        mem[t] = u + -_3357 - 64
                        _3901 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3943 = mem[_3901 + 32]
                        mem[u + 32] = 256
                        _3965 = mem[_3943]
                        mem[u + 256] = mem[_3943]
                        v = 0
                        while v < _3965:
                            mem[v + u + 288] = mem[v + _3943 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3965) <= _3965:
                            _4429 = mem[_3901 + 64]
                            mem[u + 64] = ceil32(_3965) + 288
                            _4457 = mem[_4429]
                            mem[ceil32(_3965) + u + 288] = mem[_4429]
                            v = 0
                            while v < _4457:
                                mem[v + ceil32(_3965) + u + 320] = mem[v + _4429 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4457) > _4457:
                                mem[ceil32(_3965) + u + _4457 + 320] = 0
                            mem[u + 96] = mem[_3901 + 96]
                            mem[u + 128] = mem[_3901 + 128]
                            mem[u + 160] = mem[_3901 + 160]
                            mem[u + 192] = mem[_3901 + 192]
                            mem[u + 224] = mem[_3901 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4457) + ceil32(_3965) + u + 320
                            continue 
                        mem[u + _3965 + 288] = 0
                        _4458 = mem[_3901 + 64]
                        mem[u + 64] = ceil32(_3965) + 288
                        _4477 = mem[_4458]
                        mem[ceil32(_3965) + u + 288] = mem[_4458]
                        v = 0
                        while v < _4477:
                            mem[v + ceil32(_3965) + u + 320] = mem[v + _4458 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4477) > _4477:
                            mem[ceil32(_3965) + u + _4477 + 320] = 0
                        mem[u + 96] = mem[_3901 + 96]
                        mem[u + 128] = mem[_3901 + 128]
                        mem[u + 160] = mem[_3901 + 160]
                        mem[u + 192] = mem[_3901 + 192]
                        mem[u + 224] = mem[_3901 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4477) + ceil32(_3965) + u + 320
                        continue 
                else:
                    mem[_1796 + ceil32(return_data.size) + _1812 + 32] = 0
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2319 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2335 = mem[_2319]
                    require mem[_2319] == mem[_2319 + 31 len 1]
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2383 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2406 = mem[_2383]
                    _2429 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2429] = address(_1252)
                    mem[_2429 + 32] = _1268 + ceil32(return_data.size)
                    mem[_2429 + 64] = _1796 + ceil32(return_data.size)
                    mem[_2429 + 96] = uint8(_2335)
                    mem[_2429 + 128] = 0
                    mem[_2429 + 160] = _2406
                    mem[_2429 + 192] = 0
                    mem[_2429 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2463 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2479 = mem[_2463]
                    require mem[_2463] == mem[_2463 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2479))
                    staticcall address(_2479).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2527 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1232 + 128] = mem[_2527]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2591 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2607 = mem[_2591]
                    require mem[_2591] == mem[_2591 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2607))
                    staticcall address(_2607).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2655 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2429 + 128] = mem[_2655]
                    _2687 = mem[64]
                    mem[mem[64]] = 2
                    _3310 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3310] = 0
                    mem[_3310 + 32] = 96
                    mem[_3310 + 64] = 96
                    mem[_3310 + 96] = 0
                    mem[_3310 + 128] = 0
                    mem[_3310 + 160] = 0
                    mem[_3310 + 192] = 0
                    mem[_3310 + 224] = 0
                    mem[var182001] = _3310
                    s = var182001
                    idx = var182002
                    while idx - 1:
                        _3310 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3310] = 0
                        mem[_3310 + 32] = 96
                        mem[_3310 + 64] = 96
                        mem[_3310 + 96] = 0
                        mem[_3310 + 128] = 0
                        mem[_3310 + 160] = 0
                        mem[_3310 + 192] = 0
                        mem[_3310 + 224] = 0
                        mem[s + 32] = _3310
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2687]
                    mem[_2687 + 32] = _1232
                    require 1 < mem[_2687]
                    mem[_2687 + 64] = _2429
                    _3358 = mem[64]
                    mem[mem[64]] = 32
                    _3374 = mem[_2687]
                    mem[mem[64] + 32] = mem[_2687]
                    idx = 0
                    s = _2687 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3374) + 64
                    while idx < _3374:
                        mem[t] = u + -_3358 - 64
                        _3902 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3946 = mem[_3902 + 32]
                        mem[u + 32] = 256
                        _3966 = mem[_3946]
                        mem[u + 256] = mem[_3946]
                        v = 0
                        while v < _3966:
                            mem[v + u + 288] = mem[v + _3946 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3966) <= _3966:
                            _4430 = mem[_3902 + 64]
                            mem[u + 64] = ceil32(_3966) + 288
                            _4459 = mem[_4430]
                            mem[ceil32(_3966) + u + 288] = mem[_4430]
                            v = 0
                            while v < _4459:
                                mem[v + ceil32(_3966) + u + 320] = mem[v + _4430 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4459) > _4459:
                                mem[ceil32(_3966) + u + _4459 + 320] = 0
                            mem[u + 96] = mem[_3902 + 96]
                            mem[u + 128] = mem[_3902 + 128]
                            mem[u + 160] = mem[_3902 + 160]
                            mem[u + 192] = mem[_3902 + 192]
                            mem[u + 224] = mem[_3902 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4459) + ceil32(_3966) + u + 320
                            continue 
                        mem[u + _3966 + 288] = 0
                        _4460 = mem[_3902 + 64]
                        mem[u + 64] = ceil32(_3966) + 288
                        _4478 = mem[_4460]
                        mem[ceil32(_3966) + u + 288] = mem[_4460]
                        v = 0
                        while v < _4478:
                            mem[v + ceil32(_3966) + u + 320] = mem[v + _4460 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4478) > _4478:
                            mem[ceil32(_3966) + u + _4478 + 320] = 0
                        mem[u + 96] = mem[_3902 + 96]
                        mem[u + 128] = mem[_3902 + 128]
                        mem[u + 160] = mem[_3902 + 160]
                        mem[u + 192] = mem[_3902 + 192]
                        mem[u + 224] = mem[_3902 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4478) + ceil32(_3966) + u + 320
                        continue 
            else:
                mem[_1268 + ceil32(return_data.size) + _1276 + 32] = 0
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1252))
                staticcall address(_1252).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1800 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1808 = mem[_1800]
                require mem[_1800] <= test266151307()
                require _1800 + return_data.size > _1800 + mem[_1800] + 31
                _1816 = mem[_1800 + mem[_1800]]
                require mem[_1800 + mem[_1800]] <= test266151307()
                require ceil32(mem[_1800 + mem[_1800]]) + 32 >= 0 and _1800 + ceil32(return_data.size) + ceil32(mem[_1800 + mem[_1800]]) + 32 <= test266151307()
                mem[64] = _1800 + ceil32(return_data.size) + ceil32(mem[_1800 + mem[_1800]]) + 32
                mem[_1800 + ceil32(return_data.size)] = _1816
                require _1808 + _1816 + 32 <= return_data.size
                mem[_1800 + ceil32(return_data.size) + 32 len ceil32(_1816)] = mem[_1800 + _1808 + 32 len ceil32(_1816)]
                if ceil32(_1816) <= _1816:
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2312 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2328 = mem[_2312]
                    require mem[_2312] == mem[_2312 + 31 len 1]
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2376 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2392 = mem[_2376]
                    _2407 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2407] = address(_1252)
                    mem[_2407 + 32] = _1268 + ceil32(return_data.size)
                    mem[_2407 + 64] = _1800 + ceil32(return_data.size)
                    mem[_2407 + 96] = uint8(_2328)
                    mem[_2407 + 128] = 0
                    mem[_2407 + 160] = _2392
                    mem[_2407 + 192] = 0
                    mem[_2407 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2456 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2472 = mem[_2456]
                    require mem[_2456] == mem[_2456 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2472))
                    staticcall address(_2472).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2520 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1232 + 128] = mem[_2520]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2584 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2600 = mem[_2584]
                    require mem[_2584] == mem[_2584 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2600))
                    staticcall address(_2600).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2648 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2407 + 128] = mem[_2648]
                    _2679 = mem[64]
                    mem[mem[64]] = 2
                    _3311 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3311] = 0
                    mem[_3311 + 32] = 96
                    mem[_3311 + 64] = 96
                    mem[_3311 + 96] = 0
                    mem[_3311 + 128] = 0
                    mem[_3311 + 160] = 0
                    mem[_3311 + 192] = 0
                    mem[_3311 + 224] = 0
                    mem[var182001] = _3311
                    s = var182001
                    idx = var182002
                    while idx - 1:
                        _3311 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3311] = 0
                        mem[_3311 + 32] = 96
                        mem[_3311 + 64] = 96
                        mem[_3311 + 96] = 0
                        mem[_3311 + 128] = 0
                        mem[_3311 + 160] = 0
                        mem[_3311 + 192] = 0
                        mem[_3311 + 224] = 0
                        mem[s + 32] = _3311
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2679]
                    mem[_2679 + 32] = _1232
                    require 1 < mem[_2679]
                    mem[_2679 + 64] = _2407
                    _3359 = mem[64]
                    mem[mem[64]] = 32
                    _3375 = mem[_2679]
                    mem[mem[64] + 32] = mem[_2679]
                    idx = 0
                    s = _2679 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3375) + 64
                    while idx < _3375:
                        mem[t] = u + -_3359 - 64
                        _3903 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3949 = mem[_3903 + 32]
                        mem[u + 32] = 256
                        _3967 = mem[_3949]
                        mem[u + 256] = mem[_3949]
                        v = 0
                        while v < _3967:
                            mem[v + u + 288] = mem[v + _3949 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3967) <= _3967:
                            _4431 = mem[_3903 + 64]
                            mem[u + 64] = ceil32(_3967) + 288
                            _4461 = mem[_4431]
                            mem[ceil32(_3967) + u + 288] = mem[_4431]
                            v = 0
                            while v < _4461:
                                mem[v + ceil32(_3967) + u + 320] = mem[v + _4431 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4461) > _4461:
                                mem[ceil32(_3967) + u + _4461 + 320] = 0
                            mem[u + 96] = mem[_3903 + 96]
                            mem[u + 128] = mem[_3903 + 128]
                            mem[u + 160] = mem[_3903 + 160]
                            mem[u + 192] = mem[_3903 + 192]
                            mem[u + 224] = mem[_3903 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4461) + ceil32(_3967) + u + 320
                            continue 
                        mem[u + _3967 + 288] = 0
                        _4462 = mem[_3903 + 64]
                        mem[u + 64] = ceil32(_3967) + 288
                        _4479 = mem[_4462]
                        mem[ceil32(_3967) + u + 288] = mem[_4462]
                        v = 0
                        while v < _4479:
                            mem[v + ceil32(_3967) + u + 320] = mem[v + _4462 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4479) > _4479:
                            mem[ceil32(_3967) + u + _4479 + 320] = 0
                        mem[u + 96] = mem[_3903 + 96]
                        mem[u + 128] = mem[_3903 + 128]
                        mem[u + 160] = mem[_3903 + 160]
                        mem[u + 192] = mem[_3903 + 192]
                        mem[u + 224] = mem[_3903 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4479) + ceil32(_3967) + u + 320
                        continue 
                else:
                    mem[_1800 + ceil32(return_data.size) + _1816 + 32] = 0
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2320 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2336 = mem[_2320]
                    require mem[_2320] == mem[_2320 + 31 len 1]
                    require ext_code.size(address(_1252))
                    staticcall address(_1252).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2384 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2408 = mem[_2384]
                    _2432 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_2432] = address(_1252)
                    mem[_2432 + 32] = _1268 + ceil32(return_data.size)
                    mem[_2432 + 64] = _1800 + ceil32(return_data.size)
                    mem[_2432 + 96] = uint8(_2336)
                    mem[_2432 + 128] = 0
                    mem[_2432 + 160] = _2408
                    mem[_2432 + 192] = 0
                    mem[_2432 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2464 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2480 = mem[_2464]
                    require mem[_2464] == mem[_2464 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2480))
                    staticcall address(_2480).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2528 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1232 + 128] = mem[_2528]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2592 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2608 = mem[_2592]
                    require mem[_2592] == mem[_2592 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_2608))
                    staticcall address(_2608).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2656 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_2432 + 128] = mem[_2656]
                    _2688 = mem[64]
                    mem[mem[64]] = 2
                    _3312 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_3312] = 0
                    mem[_3312 + 32] = 96
                    mem[_3312 + 64] = 96
                    mem[_3312 + 96] = 0
                    mem[_3312 + 128] = 0
                    mem[_3312 + 160] = 0
                    mem[_3312 + 192] = 0
                    mem[_3312 + 224] = 0
                    mem[var183001] = _3312
                    s = var183001
                    idx = var183002
                    while idx - 1:
                        _3312 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_3312] = 0
                        mem[_3312 + 32] = 96
                        mem[_3312 + 64] = 96
                        mem[_3312 + 96] = 0
                        mem[_3312 + 128] = 0
                        mem[_3312 + 160] = 0
                        mem[_3312 + 192] = 0
                        mem[_3312 + 224] = 0
                        mem[s + 32] = _3312
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_2688]
                    mem[_2688 + 32] = _1232
                    require 1 < mem[_2688]
                    mem[_2688 + 64] = _2432
                    _3360 = mem[64]
                    mem[mem[64]] = 32
                    _3376 = mem[_2688]
                    mem[mem[64] + 32] = mem[_2688]
                    idx = 0
                    s = _2688 + 32
                    t = mem[64] + 64
                    u = mem[64] + (32 * _3376) + 64
                    while idx < _3376:
                        mem[t] = u + -_3360 - 64
                        _3904 = mem[s]
                        mem[u] = mem[mem[s] + 12 len 20]
                        _3952 = mem[_3904 + 32]
                        mem[u + 32] = 256
                        _3968 = mem[_3952]
                        mem[u + 256] = mem[_3952]
                        v = 0
                        while v < _3968:
                            mem[v + u + 288] = mem[v + _3952 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_3968) <= _3968:
                            _4432 = mem[_3904 + 64]
                            mem[u + 64] = ceil32(_3968) + 288
                            _4463 = mem[_4432]
                            mem[ceil32(_3968) + u + 288] = mem[_4432]
                            v = 0
                            while v < _4463:
                                mem[v + ceil32(_3968) + u + 320] = mem[v + _4432 + 32]
                                v = v + 32
                                continue 
                            if ceil32(_4463) > _4463:
                                mem[ceil32(_3968) + u + _4463 + 320] = 0
                            mem[u + 96] = mem[_3904 + 96]
                            mem[u + 128] = mem[_3904 + 128]
                            mem[u + 160] = mem[_3904 + 160]
                            mem[u + 192] = mem[_3904 + 192]
                            mem[u + 224] = mem[_3904 + 224]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            u = ceil32(_4463) + ceil32(_3968) + u + 320
                            continue 
                        mem[u + _3968 + 288] = 0
                        _4464 = mem[_3904 + 64]
                        mem[u + 64] = ceil32(_3968) + 288
                        _4480 = mem[_4464]
                        mem[ceil32(_3968) + u + 288] = mem[_4464]
                        v = 0
                        while v < _4480:
                            mem[v + ceil32(_3968) + u + 320] = mem[v + _4464 + 32]
                            v = v + 32
                            continue 
                        if ceil32(_4480) > _4480:
                            mem[ceil32(_3968) + u + _4480 + 320] = 0
                        mem[u + 96] = mem[_3904 + 96]
                        mem[u + 128] = mem[_3904 + 128]
                        mem[u + 160] = mem[_3904 + 160]
                        mem[u + 192] = mem[_3904 + 192]
                        mem[u + 224] = mem[_3904 + 224]
                        idx = idx + 1
                        s = s + 32
                        t = t + 32
                        u = ceil32(_4480) + ceil32(_3968) + u + 320
                        continue 
    return memory
      from mem[64]
       len u - mem[64]
}

function getBnbPrice(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[96] = 0
    mem[128] = 96
    mem[160] = 96
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[352] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 352] = 0
    mem[ceil32(return_data.size) + 384] = 96
    mem[ceil32(return_data.size) + 416] = 96
    mem[ceil32(return_data.size) + 448] = 0
    mem[ceil32(return_data.size) + 480] = 0
    mem[ceil32(return_data.size) + 512] = 0
    mem[ceil32(return_data.size) + 544] = 0
    mem[ceil32(return_data.size) + 576] = 0
    mem[ceil32(return_data.size) + 608] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).name() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[ceil32(return_data.size) + 608 len return_data.size] = ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    _10 = mem[ceil32(return_data.size) + 608]
    require mem[ceil32(return_data.size) + 608] <= test266151307()
    require ceil32(return_data.size) + return_data.size + 608 > ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 639
    _11 = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]
    require mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608] <= test266151307()
    require ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 32 >= 0 and (2 * ceil32(return_data.size)) + ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 640 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + ceil32(mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]) + 640
    mem[(2 * ceil32(return_data.size)) + 608] = mem[ceil32(return_data.size) + mem[ceil32(return_data.size) + 608] + 608]
    require _10 + _11 + 32 <= return_data.size
    mem[(2 * ceil32(return_data.size)) + 640 len ceil32(_11)] = mem[ceil32(return_data.size) + _10 + 640 len ceil32(_11)]
    if ceil32(_11) <= _11:
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _869 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _871 = mem[_869]
        require mem[_869] <= test266151307()
        require _869 + return_data.size > _869 + mem[_869] + 31
        _873 = mem[_869 + mem[_869]]
        require mem[_869 + mem[_869]] <= test266151307()
        require ceil32(mem[_869 + mem[_869]]) + 32 >= 0 and _869 + ceil32(return_data.size) + ceil32(mem[_869 + mem[_869]]) + 32 <= test266151307()
        mem[64] = _869 + ceil32(return_data.size) + ceil32(mem[_869 + mem[_869]]) + 32
        mem[_869 + ceil32(return_data.size)] = _873
        require _871 + _873 + 32 <= return_data.size
        mem[_869 + ceil32(return_data.size) + 32 len ceil32(_873)] = mem[_869 + _871 + 32 len ceil32(_873)]
        if ceil32(_873) <= _873:
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1753 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1757 = mem[_1753]
            require mem[_1753] == mem[_1753 + 31 len 1]
            require ext_code.size(address(ext_call.return_data[0]))
            staticcall address(ext_call.return_data[0]).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1769 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1773 = mem[_1769]
            _1775 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1775] = address(ext_call.return_data[0])
            mem[_1775 + 32] = (2 * ceil32(return_data.size)) + 608
            mem[_1775 + 64] = _869 + ceil32(return_data.size)
            mem[_1775 + 96] = uint8(_1757)
            mem[_1775 + 128] = 0
            mem[_1775 + 160] = _1773
            mem[_1775 + 192] = 0
            mem[_1775 + 224] = 0
            _1781 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1781] = 0
            mem[_1781 + 32] = 96
            mem[_1781 + 64] = 96
            mem[_1781 + 96] = 0
            mem[_1781 + 128] = 0
            mem[_1781 + 160] = 0
            mem[_1781 + 192] = 0
            mem[_1781 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1793 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1797 = mem[_1793]
            require mem[_1793] == mem[_1793 + 12 len 20]
            _1801 = mem[64]
            mem[64] = mem[64] + 256
            mem[_1801] = 0
            mem[_1801 + 32] = 96
            mem[_1801 + 64] = 96
            mem[_1801 + 96] = 0
            mem[_1801 + 128] = 0
            mem[_1801 + 160] = 0
            mem[_1801 + 192] = 0
            mem[_1801 + 224] = 0
            mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1797))
            staticcall address(_1797).name() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1813 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1817 = mem[_1813]
            require mem[_1813] <= test266151307()
            require _1813 + return_data.size > _1813 + mem[_1813] + 31
            _1821 = mem[_1813 + mem[_1813]]
            require mem[_1813 + mem[_1813]] <= test266151307()
            require ceil32(mem[_1813 + mem[_1813]]) + 32 >= 0 and _1813 + ceil32(return_data.size) + ceil32(mem[_1813 + mem[_1813]]) + 32 <= test266151307()
            mem[64] = _1813 + ceil32(return_data.size) + ceil32(mem[_1813 + mem[_1813]]) + 32
            mem[_1813 + ceil32(return_data.size)] = _1821
            require _1817 + _1821 + 32 <= return_data.size
            mem[_1813 + ceil32(return_data.size) + 32 len ceil32(_1821)] = mem[_1813 + _1817 + 32 len ceil32(_1821)]
            if ceil32(_1821) <= _1821:
                mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
                require ext_code.size(address(_1797))
                staticcall address(_1797).0x95d89b41 with:
                        gas gas_remaining wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2629 = mem[64]
                mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2637 = mem[_2629]
                require mem[_2629] <= test266151307()
                require _2629 + return_data.size > _2629 + mem[_2629] + 31
                _2645 = mem[_2629 + mem[_2629]]
                require mem[_2629 + mem[_2629]] <= test266151307()
                require ceil32(mem[_2629 + mem[_2629]]) + 32 >= 0 and _2629 + ceil32(return_data.size) + ceil32(mem[_2629 + mem[_2629]]) + 32 <= test266151307()
                mem[64] = _2629 + ceil32(return_data.size) + ceil32(mem[_2629 + mem[_2629]]) + 32
                mem[_2629 + ceil32(return_data.size)] = _2645
                require _2637 + _2645 + 32 <= return_data.size
                mem[_2629 + ceil32(return_data.size) + 32 len ceil32(_2645)] = mem[_2629 + _2637 + 32 len ceil32(_2645)]
                if ceil32(_2645) <= _2645:
                    require ext_code.size(address(_1797))
                    staticcall address(_1797).0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3429 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3445 = mem[_3429]
                    require mem[_3429] == mem[_3429 + 31 len 1]
                    require ext_code.size(address(_1797))
                    staticcall address(_1797).0x18160ddd with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3493 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3509 = mem[_3493]
                    _3517 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_3517] = address(_1797)
                    mem[_3517 + 32] = _1813 + ceil32(return_data.size)
                    mem[_3517 + 64] = _2629 + ceil32(return_data.size)
                    mem[_3517 + 96] = uint8(_3445)
                    mem[_3517 + 128] = 0
                    mem[_3517 + 160] = _3509
                    mem[_3517 + 192] = 0
                    mem[_3517 + 224] = 0
                    require ext_code.size(arg1)
                    staticcall arg1.token0() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3573 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3589 = mem[_3573]
                    require mem[_3573] == mem[_3573 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_3589))
                    staticcall address(_3589).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3637 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_1775 + 128] = mem[_3637]
                    require ext_code.size(arg1)
                    staticcall arg1.token1() with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3701 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3717 = mem[_3701]
                    require mem[_3701] == mem[_3701 + 12 len 20]
                    mem[mem[64] + 4] = arg1
                    require ext_code.size(address(_3717))
                    staticcall address(_3717).0x70a08231 with:
                            gas gas_remaining wei
                           args address(arg1)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3765 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[_3517 + 128] = mem[_3765]
                    _3797 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_3797] = 0
                    mem[_3797 + 32] = 96
                    mem[_3797 + 64] = 96
                    mem[_3797 + 96] = 0
                    mem[_3797 + 128] = 0
                    mem[_3797 + 160] = 0
                    mem[_3797 + 192] = 0
                    mem[_3797 + 224] = 0
                    _3813 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_3813] = 0
                    mem[_3813 + 32] = 96
                    mem[_3813 + 64] = 96
                    mem[_3813 + 96] = 0
                    mem[_3813 + 128] = 0
                    mem[_3813 + 160] = 0
                    mem[_3813 + 192] = 0
                    mem[_3813 + 224] = 0
                    if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                        _3853 = mem[64]
                        mem[mem[64]] = 2
                        _4904 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_4904] = 0
                        mem[_4904 + 32] = 96
                        mem[_4904 + 64] = 96
                        mem[_4904 + 96] = 0
                        mem[_4904 + 128] = 0
                        mem[_4904 + 160] = 0
                        mem[_4904 + 192] = 0
                        mem[_4904 + 224] = 0
                        mem[var189001] = _4904
                        s = var189001
                        idx = var189002
                        while idx - 1:
                            _4904 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_4904] = 0
                            mem[_4904 + 32] = 96
                            mem[_4904 + 64] = 96
                            mem[_4904 + 96] = 0
                            mem[_4904 + 128] = 0
                            mem[_4904 + 160] = 0
                            mem[_4904 + 192] = 0
                            mem[_4904 + 224] = 0
                            mem[s + 32] = _4904
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_3853]
                        mem[_3853 + 32] = _3517
                        require 1 < mem[_3853]
                        mem[_3853 + 64] = _1775
                        _5192 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5192] = 0
                        mem[_5192 + 32] = 96
                        mem[_5192 + 64] = 96
                        mem[_5192 + 96] = 0
                        mem[_5192 + 128] = 0
                        mem[_5192 + 160] = 0
                        mem[_5192 + 192] = 0
                        mem[_5192 + 224] = 0
                        require 0 < mem[_3853]
                        _5450 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5450] = 0
                        mem[_5450 + 32] = 96
                        mem[_5450 + 64] = 96
                        mem[_5450 + 96] = 0
                        mem[_5450 + 128] = 0
                        mem[_5450 + 160] = 0
                        mem[_5450 + 192] = 0
                        mem[_5450 + 224] = 0
                        require 1 < mem[_3853]
                        if mem[_3517 + 96] <= mem[_1775 + 96]:
                            idx = 12
                            s = mem[_3517 + 96]
                            while idx >= 4:
                                if not mem[_3517 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_3517 + 96] - idx
                                continue 
                            _6003 = mem[_3517 + 96]
                            _6004 = mem[_3517 + 128]
                            mem[mem[64]] = 26
                            mem[mem[64] + 32] = 'SafeMath: division by zero'
                            if not 10^(_6003 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^(mem[_1775 + 96] - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                                if not _6004 / 10^(_6003 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not 0 / _6004 / 10^(_6003 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (1000000 * 10^18 / 0 / _6004 / 10^(_6003 - s))
                            if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not _6004 / 10^(_6003 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6004 / 10^(_6003 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6004 / 10^(_6003 - s))
                        idx = 12
                        s = mem[_1775 + 96]
                        while idx >= 4:
                            if not mem[_1775 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1775 + 96] - idx
                            continue 
                        _6005 = mem[_3517 + 96]
                        _6006 = mem[_3517 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6005 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _6006 / 10^(_6005 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6006 / 10^(_6005 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6006 / 10^(_6005 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6006 / 10^(_6005 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6006 / 10^(_6005 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6006 / 10^(_6005 - s))
                    if wbnbAddress == address(_1797):
                        _3901 = mem[64]
                        mem[mem[64]] = 2
                        _4903 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_4903] = 0
                        mem[_4903 + 32] = 96
                        mem[_4903 + 64] = 96
                        mem[_4903 + 96] = 0
                        mem[_4903 + 128] = 0
                        mem[_4903 + 160] = 0
                        mem[_4903 + 192] = 0
                        mem[_4903 + 224] = 0
                        mem[var193001] = _4903
                        s = var193001
                        idx = var193002
                        while idx - 1:
                            _4903 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_4903] = 0
                            mem[_4903 + 32] = 96
                            mem[_4903 + 64] = 96
                            mem[_4903 + 96] = 0
                            mem[_4903 + 128] = 0
                            mem[_4903 + 160] = 0
                            mem[_4903 + 192] = 0
                            mem[_4903 + 224] = 0
                            mem[s + 32] = _4903
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_3901]
                        mem[_3901 + 32] = _1775
                        require 1 < mem[_3901]
                        mem[_3901 + 64] = _3517
                        _5191 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5191] = 0
                        mem[_5191 + 32] = 96
                        mem[_5191 + 64] = 96
                        mem[_5191 + 96] = 0
                        mem[_5191 + 128] = 0
                        mem[_5191 + 160] = 0
                        mem[_5191 + 192] = 0
                        mem[_5191 + 224] = 0
                        require 0 < mem[_3901]
                        _5449 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5449] = 0
                        mem[_5449 + 32] = 96
                        mem[_5449 + 64] = 96
                        mem[_5449 + 96] = 0
                        mem[_5449 + 128] = 0
                        mem[_5449 + 160] = 0
                        mem[_5449 + 192] = 0
                        mem[_5449 + 224] = 0
                        require 1 < mem[_3901]
                        if mem[_1775 + 96] <= mem[_3517 + 96]:
                            idx = 12
                            s = mem[_1775 + 96]
                            while idx >= 4:
                                if not mem[_1775 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_1775 + 96] - idx
                                continue 
                            _5999 = mem[_1775 + 96]
                            _6000 = mem[_1775 + 128]
                            mem[mem[64]] = 26
                            mem[mem[64] + 32] = 'SafeMath: division by zero'
                            if not 10^(_5999 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^(mem[_3517 + 96] - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not mem[_3517 + 128] / 10^(mem[_3517 + 96] - s):
                                if not _6000 / 10^(_5999 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not 0 / _6000 / 10^(_5999 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (1000000 * 10^18 / 0 / _6000 / 10^(_5999 - s))
                            if 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not _6000 / 10^(_5999 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / _6000 / 10^(_5999 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / _6000 / 10^(_5999 - s))
                        idx = 12
                        s = mem[_3517 + 96]
                        while idx >= 4:
                            if not mem[_3517 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3517 + 96] - idx
                            continue 
                        _6001 = mem[_1775 + 96]
                        _6002 = mem[_1775 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6001 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3517 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3517 + 128] / 10^(mem[_3517 + 96] - s):
                            if not _6002 / 10^(_6001 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6002 / 10^(_6001 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6002 / 10^(_6001 - s))
                        if 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6002 / 10^(_6001 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / _6002 / 10^(_6001 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / _6002 / 10^(_6001 - s))
                    if busdAddress == uint64(ext_call.return_data[0]) << 96:
                        _3941 = mem[64]
                        mem[mem[64]] = 2
                        _4902 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_4902] = 0
                        mem[_4902 + 32] = 96
                        mem[_4902 + 64] = 96
                        mem[_4902 + 96] = 0
                        mem[_4902 + 128] = 0
                        mem[_4902 + 160] = 0
                        mem[_4902 + 192] = 0
                        mem[_4902 + 224] = 0
                        mem[var196001] = _4902
                        s = var196001
                        idx = var196002
                        while idx - 1:
                            _4902 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_4902] = 0
                            mem[_4902 + 32] = 96
                            mem[_4902 + 64] = 96
                            mem[_4902 + 96] = 0
                            mem[_4902 + 128] = 0
                            mem[_4902 + 160] = 0
                            mem[_4902 + 192] = 0
                            mem[_4902 + 224] = 0
                            mem[s + 32] = _4902
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_3941]
                        mem[_3941 + 32] = _3517
                        require 1 < mem[_3941]
                        mem[_3941 + 64] = _1775
                        _5190 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5190] = 0
                        mem[_5190 + 32] = 96
                        mem[_5190 + 64] = 96
                        mem[_5190 + 96] = 0
                        mem[_5190 + 128] = 0
                        mem[_5190 + 160] = 0
                        mem[_5190 + 192] = 0
                        mem[_5190 + 224] = 0
                        require 0 < mem[_3941]
                        _5448 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5448] = 0
                        mem[_5448 + 32] = 96
                        mem[_5448 + 64] = 96
                        mem[_5448 + 96] = 0
                        mem[_5448 + 128] = 0
                        mem[_5448 + 160] = 0
                        mem[_5448 + 192] = 0
                        mem[_5448 + 224] = 0
                        require 1 < mem[_3941]
                        if mem[_3517 + 96] <= mem[_1775 + 96]:
                            idx = 12
                            s = mem[_3517 + 96]
                            while idx >= 4:
                                if not mem[_3517 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_3517 + 96] - idx
                                continue 
                            _5995 = mem[_3517 + 96]
                            _5996 = mem[_3517 + 128]
                            mem[mem[64]] = 26
                            mem[mem[64] + 32] = 'SafeMath: division by zero'
                            if not 10^(_5995 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^(mem[_1775 + 96] - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                                if not _5996 / 10^(_5995 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not 0 / _5996 / 10^(_5995 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (1000000 * 10^18 / 0 / _5996 / 10^(_5995 - s))
                            if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not _5996 / 10^(_5995 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _5996 / 10^(_5995 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _5996 / 10^(_5995 - s))
                        idx = 12
                        s = mem[_1775 + 96]
                        while idx >= 4:
                            if not mem[_1775 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1775 + 96] - idx
                            continue 
                        _5997 = mem[_3517 + 96]
                        _5998 = mem[_3517 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_5997 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _5998 / 10^(_5997 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _5998 / 10^(_5997 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _5998 / 10^(_5997 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _5998 / 10^(_5997 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _5998 / 10^(_5997 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _5998 / 10^(_5997 - s))
                    if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                        _3989 = mem[64]
                        mem[mem[64]] = 2
                        _4901 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_4901] = 0
                        mem[_4901 + 32] = 96
                        mem[_4901 + 64] = 96
                        mem[_4901 + 96] = 0
                        mem[_4901 + 128] = 0
                        mem[_4901 + 160] = 0
                        mem[_4901 + 192] = 0
                        mem[_4901 + 224] = 0
                        mem[var199001] = _4901
                        s = var199001
                        idx = var199002
                        while idx - 1:
                            _4901 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_4901] = 0
                            mem[_4901 + 32] = 96
                            mem[_4901 + 64] = 96
                            mem[_4901 + 96] = 0
                            mem[_4901 + 128] = 0
                            mem[_4901 + 160] = 0
                            mem[_4901 + 192] = 0
                            mem[_4901 + 224] = 0
                            mem[s + 32] = _4901
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_3989]
                        mem[_3989 + 32] = _3517
                        require 1 < mem[_3989]
                        mem[_3989 + 64] = _1775
                        _5189 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5189] = 0
                        mem[_5189 + 32] = 96
                        mem[_5189 + 64] = 96
                        mem[_5189 + 96] = 0
                        mem[_5189 + 128] = 0
                        mem[_5189 + 160] = 0
                        mem[_5189 + 192] = 0
                        mem[_5189 + 224] = 0
                        require 0 < mem[_3989]
                        _5447 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5447] = 0
                        mem[_5447 + 32] = 96
                        mem[_5447 + 64] = 96
                        mem[_5447 + 96] = 0
                        mem[_5447 + 128] = 0
                        mem[_5447 + 160] = 0
                        mem[_5447 + 192] = 0
                        mem[_5447 + 224] = 0
                        require 1 < mem[_3989]
                        if mem[_3517 + 96] <= mem[_1775 + 96]:
                            idx = 12
                            s = mem[_3517 + 96]
                            while idx >= 4:
                                if not mem[_3517 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_3517 + 96] - idx
                                continue 
                            _5991 = mem[_3517 + 96]
                            _5992 = mem[_3517 + 128]
                            mem[mem[64]] = 26
                            mem[mem[64] + 32] = 'SafeMath: division by zero'
                            if not 10^(_5991 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^(mem[_1775 + 96] - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                                if not _5992 / 10^(_5991 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not 0 / _5992 / 10^(_5991 - s):
                                    revert with 0, 'SafeMath: division by zero', 0
                                return (1000000 * 10^18 / 0 / _5992 / 10^(_5991 - s))
                            if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not _5992 / 10^(_5991 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _5992 / 10^(_5991 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _5992 / 10^(_5991 - s))
                        idx = 12
                        s = mem[_1775 + 96]
                        while idx >= 4:
                            if not mem[_1775 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1775 + 96] - idx
                            continue 
                        _5993 = mem[_3517 + 96]
                        _5994 = mem[_3517 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_5993 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _5994 / 10^(_5993 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _5994 / 10^(_5993 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _5994 / 10^(_5993 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _5994 / 10^(_5993 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _5994 / 10^(_5993 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _5994 / 10^(_5993 - s))
                    idx = 0
                    while idx < sub_27d312da.length:
                        mem[0] = 1
                        if sub_27d312da[idx] != address(ext_call.return_data[0]):
                            idx = idx + 1
                            continue 
                        _4357 = mem[64]
                        mem[mem[64]] = 2
                        _5958 = mem[64] + 96
                        mem[64] = mem[64] + 352
                        mem[_5958] = 0
                        mem[_5958 + 32] = 96
                        mem[_5958 + 64] = 96
                        mem[_5958 + 96] = 0
                        mem[_5958 + 128] = 0
                        mem[_5958 + 160] = 0
                        mem[_5958 + 192] = 0
                        mem[_5958 + 224] = 0
                        mem[var208001] = _5958
                        s = var208001
                        idx = var208002
                        while idx - 1:
                            _5958 = mem[64]
                            mem[64] = mem[64] + 256
                            mem[_5958] = 0
                            mem[_5958 + 32] = 96
                            mem[_5958 + 64] = 96
                            mem[_5958 + 96] = 0
                            mem[_5958 + 128] = 0
                            mem[_5958 + 160] = 0
                            mem[_5958 + 192] = 0
                            mem[_5958 + 224] = 0
                            mem[s + 32] = _5958
                            s = s + 32
                            idx = idx - 1
                            continue 
                        require 0 < mem[_4357]
                        mem[_4357 + 32] = _3517
                        require 1 < mem[_4357]
                        mem[_4357 + 64] = _1775
                        _6566 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_6566] = 0
                        mem[_6566 + 32] = 96
                        mem[_6566 + 64] = 96
                        mem[_6566 + 96] = 0
                        mem[_6566 + 128] = 0
                        mem[_6566 + 160] = 0
                        mem[_6566 + 192] = 0
                        mem[_6566 + 224] = 0
                        require 0 < mem[_4357]
                        _6790 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_6790] = 0
                        mem[_6790 + 32] = 96
                        mem[_6790 + 64] = 96
                        mem[_6790 + 96] = 0
                        mem[_6790 + 128] = 0
                        mem[_6790 + 160] = 0
                        mem[_6790 + 192] = 0
                        mem[_6790 + 224] = 0
                        require 1 < mem[_4357]
                        if mem[_3517 + 96] <= mem[_1775 + 96]:
                            idx = 12
                            s = mem[_3517 + 96]
                            while idx >= 4:
                                if not mem[_3517 + 96] - idx:
                                    idx = idx - 1
                                    s = s
                                    continue 
                                idx = idx - 1
                                s = mem[_3517 + 96] - idx
                                continue 
                            _12969 = mem[_3517 + 96]
                            _12970 = mem[_3517 + 128]
                            _13095 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13095] = 26
                            mem[_13095 + 32] = 'SafeMath: division by zero'
                            if not 10^(_12969 - s):
                                _13159 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _13159 + 68] = mem[idx + _13095 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13159 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _13159 + -mem[64] + 100
                            _14825 = mem[_1775 + 96]
                            _14826 = mem[_1775 + 128]
                            _14953 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14953] = 26
                            mem[_14953 + 32] = 'SafeMath: division by zero'
                            if not 10^(_14825 - s):
                                _15079 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15079 + 68] = mem[idx + _14953 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15079 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15079 + -mem[64] + 100
                            if not _14826 / 10^(_14825 - s):
                                _15463 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15463] = 26
                                mem[_15463 + 32] = 'SafeMath: division by zero'
                                if not _12970 / 10^(_12969 - s):
                                    _15660 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _15660 + 68] = mem[idx + _15463 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15660 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15660 + -mem[64] + 100
                                _16233 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16233] = 26
                                mem[_16233 + 32] = 'SafeMath: division by zero'
                                if 0 / _12970 / 10^(_12969 - s):
                                    return (1000000 * 10^18 / 0 / _12970 / 10^(_12969 - s))
                                _16429 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _16429 + 68] = mem[idx + _16233 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16429 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _16429 + -mem[64] + 100
                            if 10^12 * _14826 / 10^(_14825 - s) / _14826 / 10^(_14825 - s) != 10^12:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _15659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15659] = 26
                            mem[_15659 + 32] = 'SafeMath: division by zero'
                            if not _12970 / 10^(_12969 - s):
                                _15849 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15849 + 68] = mem[idx + _15659 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15849 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15849 + -mem[64] + 100
                            _16427 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16427] = 26
                            mem[_16427 + 32] = 'SafeMath: division by zero'
                            if 10^12 * _14826 / 10^(_14825 - s) / _12970 / 10^(_12969 - s):
                                return (1000000 * 10^18 / 10^12 * _14826 / 10^(_14825 - s) / _12970 / 10^(_12969 - s))
                            _16617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16617 + 68] = mem[idx + _16427 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16617 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16617 + -mem[64] + 100
                        idx = 12
                        s = mem[_1775 + 96]
                        while idx >= 4:
                            if not mem[_1775 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1775 + 96] - idx
                            continue 
                        _12971 = mem[_3517 + 96]
                        _12972 = mem[_3517 + 128]
                        _13096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13096] = 26
                        mem[_13096 + 32] = 'SafeMath: division by zero'
                        if not 10^(_12971 - s):
                            _13160 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13160 + 68] = mem[idx + _13096 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13160 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13160 + -mem[64] + 100
                        _14827 = mem[_1775 + 96]
                        _14828 = mem[_1775 + 128]
                        _14955 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14955] = 26
                        mem[_14955 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14827 - s):
                            _15080 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15080 + 68] = mem[idx + _14955 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15080 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15080 + -mem[64] + 100
                        if not _14828 / 10^(_14827 - s):
                            _15464 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15464] = 26
                            mem[_15464 + 32] = 'SafeMath: division by zero'
                            if not _12972 / 10^(_12971 - s):
                                _15663 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15663 + 68] = mem[idx + _15464 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15663 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15663 + -mem[64] + 100
                            _16235 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16235] = 26
                            mem[_16235 + 32] = 'SafeMath: division by zero'
                            if 0 / _12972 / 10^(_12971 - s):
                                return (1000000 * 10^18 / 0 / _12972 / 10^(_12971 - s))
                            _16432 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16432 + 68] = mem[idx + _16235 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16432 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16432 + -mem[64] + 100
                        if 10^12 * _14828 / 10^(_14827 - s) / _14828 / 10^(_14827 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15662 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15662] = 26
                        mem[_15662 + 32] = 'SafeMath: division by zero'
                        if not _12972 / 10^(_12971 - s):
                            _15851 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15851 + 68] = mem[idx + _15662 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15851 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15851 + -mem[64] + 100
                        _16430 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16430] = 26
                        mem[_16430 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14828 / 10^(_14827 - s) / _12972 / 10^(_12971 - s):
                            return (1000000 * 10^18 / 10^12 * _14828 / 10^(_14827 - s) / _12972 / 10^(_12971 - s))
                        _16619 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16619 + 68] = mem[idx + _16430 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16619 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16619 + -mem[64] + 100
                    _4197 = mem[64]
                    mem[mem[64]] = 2
                    _5957 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5957] = 0
                    mem[_5957 + 32] = 96
                    mem[_5957 + 64] = 96
                    mem[_5957 + 96] = 0
                    mem[_5957 + 128] = 0
                    mem[_5957 + 160] = 0
                    mem[_5957 + 192] = 0
                    mem[_5957 + 224] = 0
                    mem[var204001] = _5957
                    s = var204001
                    idx = var204002
                    while idx - 1:
                        _5957 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5957] = 0
                        mem[_5957 + 32] = 96
                        mem[_5957 + 64] = 96
                        mem[_5957 + 96] = 0
                        mem[_5957 + 128] = 0
                        mem[_5957 + 160] = 0
                        mem[_5957 + 192] = 0
                        mem[_5957 + 224] = 0
                        mem[s + 32] = _5957
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4197]
                    mem[_4197 + 32] = _1775
                    require 1 < mem[_4197]
                    mem[_4197 + 64] = _3517
                    _6565 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6565] = 0
                    mem[_6565 + 32] = 96
                    mem[_6565 + 64] = 96
                    mem[_6565 + 96] = 0
                    mem[_6565 + 128] = 0
                    mem[_6565 + 160] = 0
                    mem[_6565 + 192] = 0
                    mem[_6565 + 224] = 0
                    require 0 < mem[_4197]
                    _6789 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6789] = 0
                    mem[_6789 + 32] = 96
                    mem[_6789 + 64] = 96
                    mem[_6789 + 96] = 0
                    mem[_6789 + 128] = 0
                    mem[_6789 + 160] = 0
                    mem[_6789 + 192] = 0
                    mem[_6789 + 224] = 0
                    require 1 < mem[_4197]
                    if mem[_1775 + 96] <= mem[_3517 + 96]:
                        idx = 12
                        s = mem[_1775 + 96]
                        while idx >= 4:
                            if not mem[_1775 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1775 + 96] - idx
                            continue 
                        _12965 = mem[_1775 + 96]
                        _12966 = mem[_1775 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_12965 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3517 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3517 + 128] / 10^(mem[_3517 + 96] - s):
                            if not _12966 / 10^(_12965 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _12966 / 10^(_12965 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _12966 / 10^(_12965 - s))
                        if 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _12966 / 10^(_12965 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / _12966 / 10^(_12965 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / _12966 / 10^(_12965 - s))
                    idx = 12
                    s = mem[_3517 + 96]
                    while idx >= 4:
                        if not mem[_3517 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3517 + 96] - idx
                        continue 
                    _12967 = mem[_1775 + 96]
                    _12968 = mem[_1775 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_12967 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3517 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3517 + 128] / 10^(mem[_3517 + 96] - s):
                        if not _12968 / 10^(_12967 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _12968 / 10^(_12967 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _12968 / 10^(_12967 - s))
                    if 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _12968 / 10^(_12967 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / _12968 / 10^(_12967 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3517 + 128] / 10^(mem[_3517 + 96] - s) / _12968 / 10^(_12967 - s))
                mem[_2629 + ceil32(return_data.size) + _2645 + 32] = 0
                require ext_code.size(address(_1797))
                staticcall address(_1797).0x313ce567 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3437 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3453 = mem[_3437]
                require mem[_3437] == mem[_3437 + 31 len 1]
                require ext_code.size(address(_1797))
                staticcall address(_1797).0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3501 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3518 = mem[_3501]
                _3535 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3535] = address(_1797)
                mem[_3535 + 32] = _1813 + ceil32(return_data.size)
                mem[_3535 + 64] = _2629 + ceil32(return_data.size)
                mem[_3535 + 96] = uint8(_3453)
                mem[_3535 + 128] = 0
                mem[_3535 + 160] = _3518
                mem[_3535 + 192] = 0
                mem[_3535 + 224] = 0
                require ext_code.size(arg1)
                staticcall arg1.token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3581 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3597 = mem[_3581]
                require mem[_3581] == mem[_3581 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3597))
                staticcall address(_3597).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3645 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_1775 + 128] = mem[_3645]
                require ext_code.size(arg1)
                staticcall arg1.token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3709 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3725 = mem[_3709]
                require mem[_3709] == mem[_3709 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3725))
                staticcall address(_3725).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3773 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_3535 + 128] = mem[_3773]
                _3805 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3805] = 0
                mem[_3805 + 32] = 96
                mem[_3805 + 64] = 96
                mem[_3805 + 96] = 0
                mem[_3805 + 128] = 0
                mem[_3805 + 160] = 0
                mem[_3805 + 192] = 0
                mem[_3805 + 224] = 0
                _3822 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3822] = 0
                mem[_3822 + 32] = 96
                mem[_3822 + 64] = 96
                mem[_3822 + 96] = 0
                mem[_3822 + 128] = 0
                mem[_3822 + 160] = 0
                mem[_3822 + 192] = 0
                mem[_3822 + 224] = 0
                if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                    _3869 = mem[64]
                    mem[mem[64]] = 2
                    _4908 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4908] = 0
                    mem[_4908 + 32] = 96
                    mem[_4908 + 64] = 96
                    mem[_4908 + 96] = 0
                    mem[_4908 + 128] = 0
                    mem[_4908 + 160] = 0
                    mem[_4908 + 192] = 0
                    mem[_4908 + 224] = 0
                    mem[var190001] = _4908
                    s = var190001
                    idx = var190002
                    while idx - 1:
                        _4908 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4908] = 0
                        mem[_4908 + 32] = 96
                        mem[_4908 + 64] = 96
                        mem[_4908 + 96] = 0
                        mem[_4908 + 128] = 0
                        mem[_4908 + 160] = 0
                        mem[_4908 + 192] = 0
                        mem[_4908 + 224] = 0
                        mem[s + 32] = _4908
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3869]
                    mem[_3869 + 32] = _3535
                    require 1 < mem[_3869]
                    mem[_3869 + 64] = _1775
                    _5196 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5196] = 0
                    mem[_5196 + 32] = 96
                    mem[_5196 + 64] = 96
                    mem[_5196 + 96] = 0
                    mem[_5196 + 128] = 0
                    mem[_5196 + 160] = 0
                    mem[_5196 + 192] = 0
                    mem[_5196 + 224] = 0
                    require 0 < mem[_3869]
                    _5456 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5456] = 0
                    mem[_5456 + 32] = 96
                    mem[_5456 + 64] = 96
                    mem[_5456 + 96] = 0
                    mem[_5456 + 128] = 0
                    mem[_5456 + 160] = 0
                    mem[_5456 + 192] = 0
                    mem[_5456 + 224] = 0
                    require 1 < mem[_3869]
                    if mem[_3535 + 96] <= mem[_1775 + 96]:
                        idx = 12
                        s = mem[_3535 + 96]
                        while idx >= 4:
                            if not mem[_3535 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3535 + 96] - idx
                            continue 
                        _6021 = mem[_3535 + 96]
                        _6022 = mem[_3535 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6021 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _6022 / 10^(_6021 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6022 / 10^(_6021 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6022 / 10^(_6021 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6022 / 10^(_6021 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6022 / 10^(_6021 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6022 / 10^(_6021 - s))
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _6023 = mem[_3535 + 96]
                    _6024 = mem[_3535 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6023 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6024 / 10^(_6023 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6024 / 10^(_6023 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6024 / 10^(_6023 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6024 / 10^(_6023 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6024 / 10^(_6023 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6024 / 10^(_6023 - s))
                if wbnbAddress == address(_1797):
                    _3917 = mem[64]
                    mem[mem[64]] = 2
                    _4907 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4907] = 0
                    mem[_4907 + 32] = 96
                    mem[_4907 + 64] = 96
                    mem[_4907 + 96] = 0
                    mem[_4907 + 128] = 0
                    mem[_4907 + 160] = 0
                    mem[_4907 + 192] = 0
                    mem[_4907 + 224] = 0
                    mem[var194001] = _4907
                    s = var194001
                    idx = var194002
                    while idx - 1:
                        _4907 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4907] = 0
                        mem[_4907 + 32] = 96
                        mem[_4907 + 64] = 96
                        mem[_4907 + 96] = 0
                        mem[_4907 + 128] = 0
                        mem[_4907 + 160] = 0
                        mem[_4907 + 192] = 0
                        mem[_4907 + 224] = 0
                        mem[s + 32] = _4907
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3917]
                    mem[_3917 + 32] = _1775
                    require 1 < mem[_3917]
                    mem[_3917 + 64] = _3535
                    _5195 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5195] = 0
                    mem[_5195 + 32] = 96
                    mem[_5195 + 64] = 96
                    mem[_5195 + 96] = 0
                    mem[_5195 + 128] = 0
                    mem[_5195 + 160] = 0
                    mem[_5195 + 192] = 0
                    mem[_5195 + 224] = 0
                    require 0 < mem[_3917]
                    _5455 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5455] = 0
                    mem[_5455 + 32] = 96
                    mem[_5455 + 64] = 96
                    mem[_5455 + 96] = 0
                    mem[_5455 + 128] = 0
                    mem[_5455 + 160] = 0
                    mem[_5455 + 192] = 0
                    mem[_5455 + 224] = 0
                    require 1 < mem[_3917]
                    if mem[_1775 + 96] <= mem[_3535 + 96]:
                        idx = 12
                        s = mem[_1775 + 96]
                        while idx >= 4:
                            if not mem[_1775 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1775 + 96] - idx
                            continue 
                        _6017 = mem[_1775 + 96]
                        _6018 = mem[_1775 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6017 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3535 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3535 + 128] / 10^(mem[_3535 + 96] - s):
                            if not _6018 / 10^(_6017 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6018 / 10^(_6017 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6018 / 10^(_6017 - s))
                        if 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6018 / 10^(_6017 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / _6018 / 10^(_6017 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / _6018 / 10^(_6017 - s))
                    idx = 12
                    s = mem[_3535 + 96]
                    while idx >= 4:
                        if not mem[_3535 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3535 + 96] - idx
                        continue 
                    _6019 = mem[_1775 + 96]
                    _6020 = mem[_1775 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6019 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3535 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3535 + 128] / 10^(mem[_3535 + 96] - s):
                        if not _6020 / 10^(_6019 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6020 / 10^(_6019 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6020 / 10^(_6019 - s))
                    if 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6020 / 10^(_6019 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / _6020 / 10^(_6019 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / _6020 / 10^(_6019 - s))
                if busdAddress == uint64(ext_call.return_data[0]) << 96:
                    _3965 = mem[64]
                    mem[mem[64]] = 2
                    _4906 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4906] = 0
                    mem[_4906 + 32] = 96
                    mem[_4906 + 64] = 96
                    mem[_4906 + 96] = 0
                    mem[_4906 + 128] = 0
                    mem[_4906 + 160] = 0
                    mem[_4906 + 192] = 0
                    mem[_4906 + 224] = 0
                    mem[var197001] = _4906
                    s = var197001
                    idx = var197002
                    while idx - 1:
                        _4906 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4906] = 0
                        mem[_4906 + 32] = 96
                        mem[_4906 + 64] = 96
                        mem[_4906 + 96] = 0
                        mem[_4906 + 128] = 0
                        mem[_4906 + 160] = 0
                        mem[_4906 + 192] = 0
                        mem[_4906 + 224] = 0
                        mem[s + 32] = _4906
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3965]
                    mem[_3965 + 32] = _3535
                    require 1 < mem[_3965]
                    mem[_3965 + 64] = _1775
                    _5194 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5194] = 0
                    mem[_5194 + 32] = 96
                    mem[_5194 + 64] = 96
                    mem[_5194 + 96] = 0
                    mem[_5194 + 128] = 0
                    mem[_5194 + 160] = 0
                    mem[_5194 + 192] = 0
                    mem[_5194 + 224] = 0
                    require 0 < mem[_3965]
                    _5454 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5454] = 0
                    mem[_5454 + 32] = 96
                    mem[_5454 + 64] = 96
                    mem[_5454 + 96] = 0
                    mem[_5454 + 128] = 0
                    mem[_5454 + 160] = 0
                    mem[_5454 + 192] = 0
                    mem[_5454 + 224] = 0
                    require 1 < mem[_3965]
                    if mem[_3535 + 96] <= mem[_1775 + 96]:
                        idx = 12
                        s = mem[_3535 + 96]
                        while idx >= 4:
                            if not mem[_3535 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3535 + 96] - idx
                            continue 
                        _6013 = mem[_3535 + 96]
                        _6014 = mem[_3535 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6013 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _6014 / 10^(_6013 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6014 / 10^(_6013 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6014 / 10^(_6013 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6014 / 10^(_6013 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6014 / 10^(_6013 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6014 / 10^(_6013 - s))
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _6015 = mem[_3535 + 96]
                    _6016 = mem[_3535 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6015 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6016 / 10^(_6015 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6016 / 10^(_6015 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6016 / 10^(_6015 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6016 / 10^(_6015 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6016 / 10^(_6015 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6016 / 10^(_6015 - s))
                if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                    _4013 = mem[64]
                    mem[mem[64]] = 2
                    _4905 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4905] = 0
                    mem[_4905 + 32] = 96
                    mem[_4905 + 64] = 96
                    mem[_4905 + 96] = 0
                    mem[_4905 + 128] = 0
                    mem[_4905 + 160] = 0
                    mem[_4905 + 192] = 0
                    mem[_4905 + 224] = 0
                    mem[var200001] = _4905
                    s = var200001
                    idx = var200002
                    while idx - 1:
                        _4905 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4905] = 0
                        mem[_4905 + 32] = 96
                        mem[_4905 + 64] = 96
                        mem[_4905 + 96] = 0
                        mem[_4905 + 128] = 0
                        mem[_4905 + 160] = 0
                        mem[_4905 + 192] = 0
                        mem[_4905 + 224] = 0
                        mem[s + 32] = _4905
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4013]
                    mem[_4013 + 32] = _3535
                    require 1 < mem[_4013]
                    mem[_4013 + 64] = _1775
                    _5193 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5193] = 0
                    mem[_5193 + 32] = 96
                    mem[_5193 + 64] = 96
                    mem[_5193 + 96] = 0
                    mem[_5193 + 128] = 0
                    mem[_5193 + 160] = 0
                    mem[_5193 + 192] = 0
                    mem[_5193 + 224] = 0
                    require 0 < mem[_4013]
                    _5453 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5453] = 0
                    mem[_5453 + 32] = 96
                    mem[_5453 + 64] = 96
                    mem[_5453 + 96] = 0
                    mem[_5453 + 128] = 0
                    mem[_5453 + 160] = 0
                    mem[_5453 + 192] = 0
                    mem[_5453 + 224] = 0
                    require 1 < mem[_4013]
                    if mem[_3535 + 96] <= mem[_1775 + 96]:
                        idx = 12
                        s = mem[_3535 + 96]
                        while idx >= 4:
                            if not mem[_3535 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3535 + 96] - idx
                            continue 
                        _6009 = mem[_3535 + 96]
                        _6010 = mem[_3535 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6009 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _6010 / 10^(_6009 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6010 / 10^(_6009 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6010 / 10^(_6009 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6010 / 10^(_6009 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6010 / 10^(_6009 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6010 / 10^(_6009 - s))
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _6011 = mem[_3535 + 96]
                    _6012 = mem[_3535 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6011 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6012 / 10^(_6011 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6012 / 10^(_6011 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6012 / 10^(_6011 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6012 / 10^(_6011 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6012 / 10^(_6011 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6012 / 10^(_6011 - s))
                idx = 0
                while idx < sub_27d312da.length:
                    mem[0] = 1
                    if sub_27d312da[idx] != address(ext_call.return_data[0]):
                        idx = idx + 1
                        continue 
                    _4362 = mem[64]
                    mem[mem[64]] = 2
                    _5960 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5960] = 0
                    mem[_5960 + 32] = 96
                    mem[_5960 + 64] = 96
                    mem[_5960 + 96] = 0
                    mem[_5960 + 128] = 0
                    mem[_5960 + 160] = 0
                    mem[_5960 + 192] = 0
                    mem[_5960 + 224] = 0
                    mem[var209001] = _5960
                    s = var209001
                    idx = var209002
                    while idx - 1:
                        _5960 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5960] = 0
                        mem[_5960 + 32] = 96
                        mem[_5960 + 64] = 96
                        mem[_5960 + 96] = 0
                        mem[_5960 + 128] = 0
                        mem[_5960 + 160] = 0
                        mem[_5960 + 192] = 0
                        mem[_5960 + 224] = 0
                        mem[s + 32] = _5960
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4362]
                    mem[_4362 + 32] = _3535
                    require 1 < mem[_4362]
                    mem[_4362 + 64] = _1775
                    _6568 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6568] = 0
                    mem[_6568 + 32] = 96
                    mem[_6568 + 64] = 96
                    mem[_6568 + 96] = 0
                    mem[_6568 + 128] = 0
                    mem[_6568 + 160] = 0
                    mem[_6568 + 192] = 0
                    mem[_6568 + 224] = 0
                    require 0 < mem[_4362]
                    _6808 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6808] = 0
                    mem[_6808 + 32] = 96
                    mem[_6808 + 64] = 96
                    mem[_6808 + 96] = 0
                    mem[_6808 + 128] = 0
                    mem[_6808 + 160] = 0
                    mem[_6808 + 192] = 0
                    mem[_6808 + 224] = 0
                    require 1 < mem[_4362]
                    if mem[_3535 + 96] <= mem[_1775 + 96]:
                        idx = 12
                        s = mem[_3535 + 96]
                        while idx >= 4:
                            if not mem[_3535 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3535 + 96] - idx
                            continue 
                        _12977 = mem[_3535 + 96]
                        _12978 = mem[_3535 + 128]
                        _13099 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13099] = 26
                        mem[_13099 + 32] = 'SafeMath: division by zero'
                        if not 10^(_12977 - s):
                            _13163 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13163 + 68] = mem[idx + _13099 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13163 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13163 + -mem[64] + 100
                        _14833 = mem[_1775 + 96]
                        _14834 = mem[_1775 + 128]
                        _14961 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14961] = 26
                        mem[_14961 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14833 - s):
                            _15083 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15083 + 68] = mem[idx + _14961 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15083 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15083 + -mem[64] + 100
                        if not _14834 / 10^(_14833 - s):
                            _15467 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15467] = 26
                            mem[_15467 + 32] = 'SafeMath: division by zero'
                            if not _12978 / 10^(_12977 - s):
                                _15672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15672 + 68] = mem[idx + _15467 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15672 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15672 + -mem[64] + 100
                            _16241 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16241] = 26
                            mem[_16241 + 32] = 'SafeMath: division by zero'
                            if 0 / _12978 / 10^(_12977 - s):
                                return (1000000 * 10^18 / 0 / _12978 / 10^(_12977 - s))
                            _16441 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16441 + 68] = mem[idx + _16241 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16441 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16441 + -mem[64] + 100
                        if 10^12 * _14834 / 10^(_14833 - s) / _14834 / 10^(_14833 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15671 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15671] = 26
                        mem[_15671 + 32] = 'SafeMath: division by zero'
                        if not _12978 / 10^(_12977 - s):
                            _15857 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15857 + 68] = mem[idx + _15671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15857 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15857 + -mem[64] + 100
                        _16439 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16439] = 26
                        mem[_16439 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14834 / 10^(_14833 - s) / _12978 / 10^(_12977 - s):
                            return (1000000 * 10^18 / 10^12 * _14834 / 10^(_14833 - s) / _12978 / 10^(_12977 - s))
                        _16625 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16625 + 68] = mem[idx + _16439 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16625 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16625 + -mem[64] + 100
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _12979 = mem[_3535 + 96]
                    _12980 = mem[_3535 + 128]
                    _13100 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13100] = 26
                    mem[_13100 + 32] = 'SafeMath: division by zero'
                    if not 10^(_12979 - s):
                        _13164 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13164 + 68] = mem[idx + _13100 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13164 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13164 + -mem[64] + 100
                    _14835 = mem[_1775 + 96]
                    _14836 = mem[_1775 + 128]
                    _14963 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14963] = 26
                    mem[_14963 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14835 - s):
                        _15084 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15084 + 68] = mem[idx + _14963 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15084 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15084 + -mem[64] + 100
                    if not _14836 / 10^(_14835 - s):
                        _15468 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15468] = 26
                        mem[_15468 + 32] = 'SafeMath: division by zero'
                        if not _12980 / 10^(_12979 - s):
                            _15675 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15675 + 68] = mem[idx + _15468 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15675 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15675 + -mem[64] + 100
                        _16243 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16243] = 26
                        mem[_16243 + 32] = 'SafeMath: division by zero'
                        if 0 / _12980 / 10^(_12979 - s):
                            return (1000000 * 10^18 / 0 / _12980 / 10^(_12979 - s))
                        _16444 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16444 + 68] = mem[idx + _16243 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16444 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16444 + -mem[64] + 100
                    if 10^12 * _14836 / 10^(_14835 - s) / _14836 / 10^(_14835 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15674 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15674] = 26
                    mem[_15674 + 32] = 'SafeMath: division by zero'
                    if not _12980 / 10^(_12979 - s):
                        _15859 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15859 + 68] = mem[idx + _15674 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15859 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15859 + -mem[64] + 100
                    _16442 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16442] = 26
                    mem[_16442 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14836 / 10^(_14835 - s) / _12980 / 10^(_12979 - s):
                        return (1000000 * 10^18 / 10^12 * _14836 / 10^(_14835 - s) / _12980 / 10^(_12979 - s))
                    _16627 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16627 + 68] = mem[idx + _16442 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16627 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16627 + -mem[64] + 100
                _4202 = mem[64]
                mem[mem[64]] = 2
                _5959 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5959] = 0
                mem[_5959 + 32] = 96
                mem[_5959 + 64] = 96
                mem[_5959 + 96] = 0
                mem[_5959 + 128] = 0
                mem[_5959 + 160] = 0
                mem[_5959 + 192] = 0
                mem[_5959 + 224] = 0
                mem[var205001] = _5959
                s = var205001
                idx = var205002
                while idx - 1:
                    _5959 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5959] = 0
                    mem[_5959 + 32] = 96
                    mem[_5959 + 64] = 96
                    mem[_5959 + 96] = 0
                    mem[_5959 + 128] = 0
                    mem[_5959 + 160] = 0
                    mem[_5959 + 192] = 0
                    mem[_5959 + 224] = 0
                    mem[s + 32] = _5959
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4202]
                mem[_4202 + 32] = _1775
                require 1 < mem[_4202]
                mem[_4202 + 64] = _3535
                _6567 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6567] = 0
                mem[_6567 + 32] = 96
                mem[_6567 + 64] = 96
                mem[_6567 + 96] = 0
                mem[_6567 + 128] = 0
                mem[_6567 + 160] = 0
                mem[_6567 + 192] = 0
                mem[_6567 + 224] = 0
                require 0 < mem[_4202]
                _6807 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6807] = 0
                mem[_6807 + 32] = 96
                mem[_6807 + 64] = 96
                mem[_6807 + 96] = 0
                mem[_6807 + 128] = 0
                mem[_6807 + 160] = 0
                mem[_6807 + 192] = 0
                mem[_6807 + 224] = 0
                require 1 < mem[_4202]
                if mem[_1775 + 96] <= mem[_3535 + 96]:
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _12973 = mem[_1775 + 96]
                    _12974 = mem[_1775 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_12973 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3535 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3535 + 128] / 10^(mem[_3535 + 96] - s):
                        if not _12974 / 10^(_12973 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _12974 / 10^(_12973 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _12974 / 10^(_12973 - s))
                    if 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _12974 / 10^(_12973 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / _12974 / 10^(_12973 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / _12974 / 10^(_12973 - s))
                idx = 12
                s = mem[_3535 + 96]
                while idx >= 4:
                    if not mem[_3535 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3535 + 96] - idx
                    continue 
                _12975 = mem[_1775 + 96]
                _12976 = mem[_1775 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_12975 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3535 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3535 + 128] / 10^(mem[_3535 + 96] - s):
                    if not _12976 / 10^(_12975 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _12976 / 10^(_12975 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _12976 / 10^(_12975 - s))
                if 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _12976 / 10^(_12975 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / _12976 / 10^(_12975 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3535 + 128] / 10^(mem[_3535 + 96] - s) / _12976 / 10^(_12975 - s))
            mem[_1813 + ceil32(return_data.size) + _1821 + 32] = 0
            mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1797))
            staticcall address(_1797).0x95d89b41 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2633 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2641 = mem[_2633]
            require mem[_2633] <= test266151307()
            require _2633 + return_data.size > _2633 + mem[_2633] + 31
            _2649 = mem[_2633 + mem[_2633]]
            require mem[_2633 + mem[_2633]] <= test266151307()
            require ceil32(mem[_2633 + mem[_2633]]) + 32 >= 0 and _2633 + ceil32(return_data.size) + ceil32(mem[_2633 + mem[_2633]]) + 32 <= test266151307()
            mem[64] = _2633 + ceil32(return_data.size) + ceil32(mem[_2633 + mem[_2633]]) + 32
            mem[_2633 + ceil32(return_data.size)] = _2649
            require _2641 + _2649 + 32 <= return_data.size
            mem[_2633 + ceil32(return_data.size) + 32 len ceil32(_2649)] = mem[_2633 + _2641 + 32 len ceil32(_2649)]
            if ceil32(_2649) <= _2649:
                require ext_code.size(address(_1797))
                staticcall address(_1797).0x313ce567 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3430 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3446 = mem[_3430]
                require mem[_3430] == mem[_3430 + 31 len 1]
                require ext_code.size(address(_1797))
                staticcall address(_1797).0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3494 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3510 = mem[_3494]
                _3519 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3519] = address(_1797)
                mem[_3519 + 32] = _1813 + ceil32(return_data.size)
                mem[_3519 + 64] = _2633 + ceil32(return_data.size)
                mem[_3519 + 96] = uint8(_3446)
                mem[_3519 + 128] = 0
                mem[_3519 + 160] = _3510
                mem[_3519 + 192] = 0
                mem[_3519 + 224] = 0
                require ext_code.size(arg1)
                staticcall arg1.token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3574 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3590 = mem[_3574]
                require mem[_3574] == mem[_3574 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3590))
                staticcall address(_3590).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3638 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_1775 + 128] = mem[_3638]
                require ext_code.size(arg1)
                staticcall arg1.token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3702 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3718 = mem[_3702]
                require mem[_3702] == mem[_3702 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3718))
                staticcall address(_3718).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3766 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_3519 + 128] = mem[_3766]
                _3798 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3798] = 0
                mem[_3798 + 32] = 96
                mem[_3798 + 64] = 96
                mem[_3798 + 96] = 0
                mem[_3798 + 128] = 0
                mem[_3798 + 160] = 0
                mem[_3798 + 192] = 0
                mem[_3798 + 224] = 0
                _3814 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3814] = 0
                mem[_3814 + 32] = 96
                mem[_3814 + 64] = 96
                mem[_3814 + 96] = 0
                mem[_3814 + 128] = 0
                mem[_3814 + 160] = 0
                mem[_3814 + 192] = 0
                mem[_3814 + 224] = 0
                if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                    _3855 = mem[64]
                    mem[mem[64]] = 2
                    _4912 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4912] = 0
                    mem[_4912 + 32] = 96
                    mem[_4912 + 64] = 96
                    mem[_4912 + 96] = 0
                    mem[_4912 + 128] = 0
                    mem[_4912 + 160] = 0
                    mem[_4912 + 192] = 0
                    mem[_4912 + 224] = 0
                    mem[var190001] = _4912
                    s = var190001
                    idx = var190002
                    while idx - 1:
                        _4912 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4912] = 0
                        mem[_4912 + 32] = 96
                        mem[_4912 + 64] = 96
                        mem[_4912 + 96] = 0
                        mem[_4912 + 128] = 0
                        mem[_4912 + 160] = 0
                        mem[_4912 + 192] = 0
                        mem[_4912 + 224] = 0
                        mem[s + 32] = _4912
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3855]
                    mem[_3855 + 32] = _3519
                    require 1 < mem[_3855]
                    mem[_3855 + 64] = _1775
                    _5200 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5200] = 0
                    mem[_5200 + 32] = 96
                    mem[_5200 + 64] = 96
                    mem[_5200 + 96] = 0
                    mem[_5200 + 128] = 0
                    mem[_5200 + 160] = 0
                    mem[_5200 + 192] = 0
                    mem[_5200 + 224] = 0
                    require 0 < mem[_3855]
                    _5462 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5462] = 0
                    mem[_5462 + 32] = 96
                    mem[_5462 + 64] = 96
                    mem[_5462 + 96] = 0
                    mem[_5462 + 128] = 0
                    mem[_5462 + 160] = 0
                    mem[_5462 + 192] = 0
                    mem[_5462 + 224] = 0
                    require 1 < mem[_3855]
                    if mem[_3519 + 96] <= mem[_1775 + 96]:
                        idx = 12
                        s = mem[_3519 + 96]
                        while idx >= 4:
                            if not mem[_3519 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3519 + 96] - idx
                            continue 
                        _6039 = mem[_3519 + 96]
                        _6040 = mem[_3519 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6039 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _6040 / 10^(_6039 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6040 / 10^(_6039 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6040 / 10^(_6039 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6040 / 10^(_6039 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6040 / 10^(_6039 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6040 / 10^(_6039 - s))
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _6041 = mem[_3519 + 96]
                    _6042 = mem[_3519 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6041 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6042 / 10^(_6041 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6042 / 10^(_6041 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6042 / 10^(_6041 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6042 / 10^(_6041 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6042 / 10^(_6041 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6042 / 10^(_6041 - s))
                if wbnbAddress == address(_1797):
                    _3903 = mem[64]
                    mem[mem[64]] = 2
                    _4911 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4911] = 0
                    mem[_4911 + 32] = 96
                    mem[_4911 + 64] = 96
                    mem[_4911 + 96] = 0
                    mem[_4911 + 128] = 0
                    mem[_4911 + 160] = 0
                    mem[_4911 + 192] = 0
                    mem[_4911 + 224] = 0
                    mem[var194001] = _4911
                    s = var194001
                    idx = var194002
                    while idx - 1:
                        _4911 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4911] = 0
                        mem[_4911 + 32] = 96
                        mem[_4911 + 64] = 96
                        mem[_4911 + 96] = 0
                        mem[_4911 + 128] = 0
                        mem[_4911 + 160] = 0
                        mem[_4911 + 192] = 0
                        mem[_4911 + 224] = 0
                        mem[s + 32] = _4911
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3903]
                    mem[_3903 + 32] = _1775
                    require 1 < mem[_3903]
                    mem[_3903 + 64] = _3519
                    _5199 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5199] = 0
                    mem[_5199 + 32] = 96
                    mem[_5199 + 64] = 96
                    mem[_5199 + 96] = 0
                    mem[_5199 + 128] = 0
                    mem[_5199 + 160] = 0
                    mem[_5199 + 192] = 0
                    mem[_5199 + 224] = 0
                    require 0 < mem[_3903]
                    _5461 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5461] = 0
                    mem[_5461 + 32] = 96
                    mem[_5461 + 64] = 96
                    mem[_5461 + 96] = 0
                    mem[_5461 + 128] = 0
                    mem[_5461 + 160] = 0
                    mem[_5461 + 192] = 0
                    mem[_5461 + 224] = 0
                    require 1 < mem[_3903]
                    if mem[_1775 + 96] <= mem[_3519 + 96]:
                        idx = 12
                        s = mem[_1775 + 96]
                        while idx >= 4:
                            if not mem[_1775 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1775 + 96] - idx
                            continue 
                        _6035 = mem[_1775 + 96]
                        _6036 = mem[_1775 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6035 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3519 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3519 + 128] / 10^(mem[_3519 + 96] - s):
                            if not _6036 / 10^(_6035 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6036 / 10^(_6035 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6036 / 10^(_6035 - s))
                        if 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6036 / 10^(_6035 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / _6036 / 10^(_6035 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / _6036 / 10^(_6035 - s))
                    idx = 12
                    s = mem[_3519 + 96]
                    while idx >= 4:
                        if not mem[_3519 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3519 + 96] - idx
                        continue 
                    _6037 = mem[_1775 + 96]
                    _6038 = mem[_1775 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6037 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3519 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3519 + 128] / 10^(mem[_3519 + 96] - s):
                        if not _6038 / 10^(_6037 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6038 / 10^(_6037 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6038 / 10^(_6037 - s))
                    if 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6038 / 10^(_6037 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / _6038 / 10^(_6037 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / _6038 / 10^(_6037 - s))
                if busdAddress == uint64(ext_call.return_data[0]) << 96:
                    _3944 = mem[64]
                    mem[mem[64]] = 2
                    _4910 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4910] = 0
                    mem[_4910 + 32] = 96
                    mem[_4910 + 64] = 96
                    mem[_4910 + 96] = 0
                    mem[_4910 + 128] = 0
                    mem[_4910 + 160] = 0
                    mem[_4910 + 192] = 0
                    mem[_4910 + 224] = 0
                    mem[var197001] = _4910
                    s = var197001
                    idx = var197002
                    while idx - 1:
                        _4910 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4910] = 0
                        mem[_4910 + 32] = 96
                        mem[_4910 + 64] = 96
                        mem[_4910 + 96] = 0
                        mem[_4910 + 128] = 0
                        mem[_4910 + 160] = 0
                        mem[_4910 + 192] = 0
                        mem[_4910 + 224] = 0
                        mem[s + 32] = _4910
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3944]
                    mem[_3944 + 32] = _3519
                    require 1 < mem[_3944]
                    mem[_3944 + 64] = _1775
                    _5198 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5198] = 0
                    mem[_5198 + 32] = 96
                    mem[_5198 + 64] = 96
                    mem[_5198 + 96] = 0
                    mem[_5198 + 128] = 0
                    mem[_5198 + 160] = 0
                    mem[_5198 + 192] = 0
                    mem[_5198 + 224] = 0
                    require 0 < mem[_3944]
                    _5460 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5460] = 0
                    mem[_5460 + 32] = 96
                    mem[_5460 + 64] = 96
                    mem[_5460 + 96] = 0
                    mem[_5460 + 128] = 0
                    mem[_5460 + 160] = 0
                    mem[_5460 + 192] = 0
                    mem[_5460 + 224] = 0
                    require 1 < mem[_3944]
                    if mem[_3519 + 96] <= mem[_1775 + 96]:
                        idx = 12
                        s = mem[_3519 + 96]
                        while idx >= 4:
                            if not mem[_3519 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3519 + 96] - idx
                            continue 
                        _6031 = mem[_3519 + 96]
                        _6032 = mem[_3519 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6031 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _6032 / 10^(_6031 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6032 / 10^(_6031 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6032 / 10^(_6031 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6032 / 10^(_6031 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6032 / 10^(_6031 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6032 / 10^(_6031 - s))
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _6033 = mem[_3519 + 96]
                    _6034 = mem[_3519 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6033 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6034 / 10^(_6033 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6034 / 10^(_6033 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6034 / 10^(_6033 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6034 / 10^(_6033 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6034 / 10^(_6033 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6034 / 10^(_6033 - s))
                if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                    _3992 = mem[64]
                    mem[mem[64]] = 2
                    _4909 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4909] = 0
                    mem[_4909 + 32] = 96
                    mem[_4909 + 64] = 96
                    mem[_4909 + 96] = 0
                    mem[_4909 + 128] = 0
                    mem[_4909 + 160] = 0
                    mem[_4909 + 192] = 0
                    mem[_4909 + 224] = 0
                    mem[var200001] = _4909
                    s = var200001
                    idx = var200002
                    while idx - 1:
                        _4909 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4909] = 0
                        mem[_4909 + 32] = 96
                        mem[_4909 + 64] = 96
                        mem[_4909 + 96] = 0
                        mem[_4909 + 128] = 0
                        mem[_4909 + 160] = 0
                        mem[_4909 + 192] = 0
                        mem[_4909 + 224] = 0
                        mem[s + 32] = _4909
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3992]
                    mem[_3992 + 32] = _3519
                    require 1 < mem[_3992]
                    mem[_3992 + 64] = _1775
                    _5197 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5197] = 0
                    mem[_5197 + 32] = 96
                    mem[_5197 + 64] = 96
                    mem[_5197 + 96] = 0
                    mem[_5197 + 128] = 0
                    mem[_5197 + 160] = 0
                    mem[_5197 + 192] = 0
                    mem[_5197 + 224] = 0
                    require 0 < mem[_3992]
                    _5459 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5459] = 0
                    mem[_5459 + 32] = 96
                    mem[_5459 + 64] = 96
                    mem[_5459 + 96] = 0
                    mem[_5459 + 128] = 0
                    mem[_5459 + 160] = 0
                    mem[_5459 + 192] = 0
                    mem[_5459 + 224] = 0
                    require 1 < mem[_3992]
                    if mem[_3519 + 96] <= mem[_1775 + 96]:
                        idx = 12
                        s = mem[_3519 + 96]
                        while idx >= 4:
                            if not mem[_3519 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3519 + 96] - idx
                            continue 
                        _6027 = mem[_3519 + 96]
                        _6028 = mem[_3519 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6027 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1775 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                            if not _6028 / 10^(_6027 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6028 / 10^(_6027 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6028 / 10^(_6027 - s))
                        if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6028 / 10^(_6027 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6028 / 10^(_6027 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6028 / 10^(_6027 - s))
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _6029 = mem[_3519 + 96]
                    _6030 = mem[_3519 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6029 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6030 / 10^(_6029 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6030 / 10^(_6029 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6030 / 10^(_6029 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6030 / 10^(_6029 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6030 / 10^(_6029 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6030 / 10^(_6029 - s))
                idx = 0
                while idx < sub_27d312da.length:
                    mem[0] = 1
                    if sub_27d312da[idx] != address(ext_call.return_data[0]):
                        idx = idx + 1
                        continue 
                    _4367 = mem[64]
                    mem[mem[64]] = 2
                    _5962 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5962] = 0
                    mem[_5962 + 32] = 96
                    mem[_5962 + 64] = 96
                    mem[_5962 + 96] = 0
                    mem[_5962 + 128] = 0
                    mem[_5962 + 160] = 0
                    mem[_5962 + 192] = 0
                    mem[_5962 + 224] = 0
                    mem[var209001] = _5962
                    s = var209001
                    idx = var209002
                    while idx - 1:
                        _5962 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5962] = 0
                        mem[_5962 + 32] = 96
                        mem[_5962 + 64] = 96
                        mem[_5962 + 96] = 0
                        mem[_5962 + 128] = 0
                        mem[_5962 + 160] = 0
                        mem[_5962 + 192] = 0
                        mem[_5962 + 224] = 0
                        mem[s + 32] = _5962
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4367]
                    mem[_4367 + 32] = _3519
                    require 1 < mem[_4367]
                    mem[_4367 + 64] = _1775
                    _6570 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6570] = 0
                    mem[_6570 + 32] = 96
                    mem[_6570 + 64] = 96
                    mem[_6570 + 96] = 0
                    mem[_6570 + 128] = 0
                    mem[_6570 + 160] = 0
                    mem[_6570 + 192] = 0
                    mem[_6570 + 224] = 0
                    require 0 < mem[_4367]
                    _6826 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6826] = 0
                    mem[_6826 + 32] = 96
                    mem[_6826 + 64] = 96
                    mem[_6826 + 96] = 0
                    mem[_6826 + 128] = 0
                    mem[_6826 + 160] = 0
                    mem[_6826 + 192] = 0
                    mem[_6826 + 224] = 0
                    require 1 < mem[_4367]
                    if mem[_3519 + 96] <= mem[_1775 + 96]:
                        idx = 12
                        s = mem[_3519 + 96]
                        while idx >= 4:
                            if not mem[_3519 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3519 + 96] - idx
                            continue 
                        _12985 = mem[_3519 + 96]
                        _12986 = mem[_3519 + 128]
                        _13103 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13103] = 26
                        mem[_13103 + 32] = 'SafeMath: division by zero'
                        if not 10^(_12985 - s):
                            _13167 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13167 + 68] = mem[idx + _13103 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13167 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13167 + -mem[64] + 100
                        _14841 = mem[_1775 + 96]
                        _14842 = mem[_1775 + 128]
                        _14969 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14969] = 26
                        mem[_14969 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14841 - s):
                            _15087 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15087 + 68] = mem[idx + _14969 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15087 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15087 + -mem[64] + 100
                        if not _14842 / 10^(_14841 - s):
                            _15471 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15471] = 26
                            mem[_15471 + 32] = 'SafeMath: division by zero'
                            if not _12986 / 10^(_12985 - s):
                                _15684 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15684 + 68] = mem[idx + _15471 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15684 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15684 + -mem[64] + 100
                            _16249 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16249] = 26
                            mem[_16249 + 32] = 'SafeMath: division by zero'
                            if 0 / _12986 / 10^(_12985 - s):
                                return (1000000 * 10^18 / 0 / _12986 / 10^(_12985 - s))
                            _16453 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16453 + 68] = mem[idx + _16249 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16453 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16453 + -mem[64] + 100
                        if 10^12 * _14842 / 10^(_14841 - s) / _14842 / 10^(_14841 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15683 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15683] = 26
                        mem[_15683 + 32] = 'SafeMath: division by zero'
                        if not _12986 / 10^(_12985 - s):
                            _15865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15865 + 68] = mem[idx + _15683 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15865 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15865 + -mem[64] + 100
                        _16451 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16451] = 26
                        mem[_16451 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14842 / 10^(_14841 - s) / _12986 / 10^(_12985 - s):
                            return (1000000 * 10^18 / 10^12 * _14842 / 10^(_14841 - s) / _12986 / 10^(_12985 - s))
                        _16633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16633 + 68] = mem[idx + _16451 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16633 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16633 + -mem[64] + 100
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _12987 = mem[_3519 + 96]
                    _12988 = mem[_3519 + 128]
                    _13104 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13104] = 26
                    mem[_13104 + 32] = 'SafeMath: division by zero'
                    if not 10^(_12987 - s):
                        _13168 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13168 + 68] = mem[idx + _13104 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13168 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13168 + -mem[64] + 100
                    _14843 = mem[_1775 + 96]
                    _14844 = mem[_1775 + 128]
                    _14971 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14971] = 26
                    mem[_14971 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14843 - s):
                        _15088 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15088 + 68] = mem[idx + _14971 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15088 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15088 + -mem[64] + 100
                    if not _14844 / 10^(_14843 - s):
                        _15472 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15472] = 26
                        mem[_15472 + 32] = 'SafeMath: division by zero'
                        if not _12988 / 10^(_12987 - s):
                            _15687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15687 + 68] = mem[idx + _15472 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15687 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15687 + -mem[64] + 100
                        _16251 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16251] = 26
                        mem[_16251 + 32] = 'SafeMath: division by zero'
                        if 0 / _12988 / 10^(_12987 - s):
                            return (1000000 * 10^18 / 0 / _12988 / 10^(_12987 - s))
                        _16456 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16456 + 68] = mem[idx + _16251 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16456 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16456 + -mem[64] + 100
                    if 10^12 * _14844 / 10^(_14843 - s) / _14844 / 10^(_14843 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15686 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15686] = 26
                    mem[_15686 + 32] = 'SafeMath: division by zero'
                    if not _12988 / 10^(_12987 - s):
                        _15867 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15867 + 68] = mem[idx + _15686 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15867 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15867 + -mem[64] + 100
                    _16454 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16454] = 26
                    mem[_16454 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14844 / 10^(_14843 - s) / _12988 / 10^(_12987 - s):
                        return (1000000 * 10^18 / 10^12 * _14844 / 10^(_14843 - s) / _12988 / 10^(_12987 - s))
                    _16635 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16635 + 68] = mem[idx + _16454 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16635 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16635 + -mem[64] + 100
                _4207 = mem[64]
                mem[mem[64]] = 2
                _5961 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5961] = 0
                mem[_5961 + 32] = 96
                mem[_5961 + 64] = 96
                mem[_5961 + 96] = 0
                mem[_5961 + 128] = 0
                mem[_5961 + 160] = 0
                mem[_5961 + 192] = 0
                mem[_5961 + 224] = 0
                mem[var205001] = _5961
                s = var205001
                idx = var205002
                while idx - 1:
                    _5961 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5961] = 0
                    mem[_5961 + 32] = 96
                    mem[_5961 + 64] = 96
                    mem[_5961 + 96] = 0
                    mem[_5961 + 128] = 0
                    mem[_5961 + 160] = 0
                    mem[_5961 + 192] = 0
                    mem[_5961 + 224] = 0
                    mem[s + 32] = _5961
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4207]
                mem[_4207 + 32] = _1775
                require 1 < mem[_4207]
                mem[_4207 + 64] = _3519
                _6569 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6569] = 0
                mem[_6569 + 32] = 96
                mem[_6569 + 64] = 96
                mem[_6569 + 96] = 0
                mem[_6569 + 128] = 0
                mem[_6569 + 160] = 0
                mem[_6569 + 192] = 0
                mem[_6569 + 224] = 0
                require 0 < mem[_4207]
                _6825 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6825] = 0
                mem[_6825 + 32] = 96
                mem[_6825 + 64] = 96
                mem[_6825 + 96] = 0
                mem[_6825 + 128] = 0
                mem[_6825 + 160] = 0
                mem[_6825 + 192] = 0
                mem[_6825 + 224] = 0
                require 1 < mem[_4207]
                if mem[_1775 + 96] <= mem[_3519 + 96]:
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _12981 = mem[_1775 + 96]
                    _12982 = mem[_1775 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_12981 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3519 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3519 + 128] / 10^(mem[_3519 + 96] - s):
                        if not _12982 / 10^(_12981 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _12982 / 10^(_12981 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _12982 / 10^(_12981 - s))
                    if 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _12982 / 10^(_12981 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / _12982 / 10^(_12981 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / _12982 / 10^(_12981 - s))
                idx = 12
                s = mem[_3519 + 96]
                while idx >= 4:
                    if not mem[_3519 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3519 + 96] - idx
                    continue 
                _12983 = mem[_1775 + 96]
                _12984 = mem[_1775 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_12983 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3519 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3519 + 128] / 10^(mem[_3519 + 96] - s):
                    if not _12984 / 10^(_12983 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _12984 / 10^(_12983 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _12984 / 10^(_12983 - s))
                if 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _12984 / 10^(_12983 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / _12984 / 10^(_12983 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3519 + 128] / 10^(mem[_3519 + 96] - s) / _12984 / 10^(_12983 - s))
            mem[_2633 + ceil32(return_data.size) + _2649 + 32] = 0
            require ext_code.size(address(_1797))
            staticcall address(_1797).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3438 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3454 = mem[_3438]
            require mem[_3438] == mem[_3438 + 31 len 1]
            require ext_code.size(address(_1797))
            staticcall address(_1797).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3502 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3520 = mem[_3502]
            _3538 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3538] = address(_1797)
            mem[_3538 + 32] = _1813 + ceil32(return_data.size)
            mem[_3538 + 64] = _2633 + ceil32(return_data.size)
            mem[_3538 + 96] = uint8(_3454)
            mem[_3538 + 128] = 0
            mem[_3538 + 160] = _3520
            mem[_3538 + 192] = 0
            mem[_3538 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3582 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3598 = mem[_3582]
            require mem[_3582] == mem[_3582 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3598))
            staticcall address(_3598).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3646 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1775 + 128] = mem[_3646]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3710 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3726 = mem[_3710]
            require mem[_3710] == mem[_3710 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3726))
            staticcall address(_3726).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3774 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3538 + 128] = mem[_3774]
            _3806 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3806] = 0
            mem[_3806 + 32] = 96
            mem[_3806 + 64] = 96
            mem[_3806 + 96] = 0
            mem[_3806 + 128] = 0
            mem[_3806 + 160] = 0
            mem[_3806 + 192] = 0
            mem[_3806 + 224] = 0
            _3824 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3824] = 0
            mem[_3824 + 32] = 96
            mem[_3824 + 64] = 96
            mem[_3824 + 96] = 0
            mem[_3824 + 128] = 0
            mem[_3824 + 160] = 0
            mem[_3824 + 192] = 0
            mem[_3824 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3870 = mem[64]
                mem[mem[64]] = 2
                _4916 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4916] = 0
                mem[_4916 + 32] = 96
                mem[_4916 + 64] = 96
                mem[_4916 + 96] = 0
                mem[_4916 + 128] = 0
                mem[_4916 + 160] = 0
                mem[_4916 + 192] = 0
                mem[_4916 + 224] = 0
                mem[var191001] = _4916
                s = var191001
                idx = var191002
                while idx - 1:
                    _4916 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4916] = 0
                    mem[_4916 + 32] = 96
                    mem[_4916 + 64] = 96
                    mem[_4916 + 96] = 0
                    mem[_4916 + 128] = 0
                    mem[_4916 + 160] = 0
                    mem[_4916 + 192] = 0
                    mem[_4916 + 224] = 0
                    mem[s + 32] = _4916
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3870]
                mem[_3870 + 32] = _3538
                require 1 < mem[_3870]
                mem[_3870 + 64] = _1775
                _5204 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5204] = 0
                mem[_5204 + 32] = 96
                mem[_5204 + 64] = 96
                mem[_5204 + 96] = 0
                mem[_5204 + 128] = 0
                mem[_5204 + 160] = 0
                mem[_5204 + 192] = 0
                mem[_5204 + 224] = 0
                require 0 < mem[_3870]
                _5468 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5468] = 0
                mem[_5468 + 32] = 96
                mem[_5468 + 64] = 96
                mem[_5468 + 96] = 0
                mem[_5468 + 128] = 0
                mem[_5468 + 160] = 0
                mem[_5468 + 192] = 0
                mem[_5468 + 224] = 0
                require 1 < mem[_3870]
                if mem[_3538 + 96] <= mem[_1775 + 96]:
                    idx = 12
                    s = mem[_3538 + 96]
                    while idx >= 4:
                        if not mem[_3538 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3538 + 96] - idx
                        continue 
                    _6057 = mem[_3538 + 96]
                    _6058 = mem[_3538 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6057 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6058 / 10^(_6057 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6058 / 10^(_6057 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6058 / 10^(_6057 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6058 / 10^(_6057 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6058 / 10^(_6057 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6058 / 10^(_6057 - s))
                idx = 12
                s = mem[_1775 + 96]
                while idx >= 4:
                    if not mem[_1775 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1775 + 96] - idx
                    continue 
                _6059 = mem[_3538 + 96]
                _6060 = mem[_3538 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6059 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1775 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                    if not _6060 / 10^(_6059 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6060 / 10^(_6059 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6060 / 10^(_6059 - s))
                if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6060 / 10^(_6059 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6060 / 10^(_6059 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6060 / 10^(_6059 - s))
            if wbnbAddress == address(_1797):
                _3918 = mem[64]
                mem[mem[64]] = 2
                _4915 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4915] = 0
                mem[_4915 + 32] = 96
                mem[_4915 + 64] = 96
                mem[_4915 + 96] = 0
                mem[_4915 + 128] = 0
                mem[_4915 + 160] = 0
                mem[_4915 + 192] = 0
                mem[_4915 + 224] = 0
                mem[var195001] = _4915
                s = var195001
                idx = var195002
                while idx - 1:
                    _4915 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4915] = 0
                    mem[_4915 + 32] = 96
                    mem[_4915 + 64] = 96
                    mem[_4915 + 96] = 0
                    mem[_4915 + 128] = 0
                    mem[_4915 + 160] = 0
                    mem[_4915 + 192] = 0
                    mem[_4915 + 224] = 0
                    mem[s + 32] = _4915
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3918]
                mem[_3918 + 32] = _1775
                require 1 < mem[_3918]
                mem[_3918 + 64] = _3538
                _5203 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5203] = 0
                mem[_5203 + 32] = 96
                mem[_5203 + 64] = 96
                mem[_5203 + 96] = 0
                mem[_5203 + 128] = 0
                mem[_5203 + 160] = 0
                mem[_5203 + 192] = 0
                mem[_5203 + 224] = 0
                require 0 < mem[_3918]
                _5467 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5467] = 0
                mem[_5467 + 32] = 96
                mem[_5467 + 64] = 96
                mem[_5467 + 96] = 0
                mem[_5467 + 128] = 0
                mem[_5467 + 160] = 0
                mem[_5467 + 192] = 0
                mem[_5467 + 224] = 0
                require 1 < mem[_3918]
                if mem[_1775 + 96] <= mem[_3538 + 96]:
                    idx = 12
                    s = mem[_1775 + 96]
                    while idx >= 4:
                        if not mem[_1775 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1775 + 96] - idx
                        continue 
                    _6053 = mem[_1775 + 96]
                    _6054 = mem[_1775 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6053 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3538 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3538 + 128] / 10^(mem[_3538 + 96] - s):
                        if not _6054 / 10^(_6053 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6054 / 10^(_6053 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6054 / 10^(_6053 - s))
                    if 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6054 / 10^(_6053 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / _6054 / 10^(_6053 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / _6054 / 10^(_6053 - s))
                idx = 12
                s = mem[_3538 + 96]
                while idx >= 4:
                    if not mem[_3538 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3538 + 96] - idx
                    continue 
                _6055 = mem[_1775 + 96]
                _6056 = mem[_1775 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6055 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3538 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3538 + 128] / 10^(mem[_3538 + 96] - s):
                    if not _6056 / 10^(_6055 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6056 / 10^(_6055 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6056 / 10^(_6055 - s))
                if 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6056 / 10^(_6055 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / _6056 / 10^(_6055 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / _6056 / 10^(_6055 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3966 = mem[64]
                mem[mem[64]] = 2
                _4914 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4914] = 0
                mem[_4914 + 32] = 96
                mem[_4914 + 64] = 96
                mem[_4914 + 96] = 0
                mem[_4914 + 128] = 0
                mem[_4914 + 160] = 0
                mem[_4914 + 192] = 0
                mem[_4914 + 224] = 0
                mem[var198001] = _4914
                s = var198001
                idx = var198002
                while idx - 1:
                    _4914 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4914] = 0
                    mem[_4914 + 32] = 96
                    mem[_4914 + 64] = 96
                    mem[_4914 + 96] = 0
                    mem[_4914 + 128] = 0
                    mem[_4914 + 160] = 0
                    mem[_4914 + 192] = 0
                    mem[_4914 + 224] = 0
                    mem[s + 32] = _4914
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3966]
                mem[_3966 + 32] = _3538
                require 1 < mem[_3966]
                mem[_3966 + 64] = _1775
                _5202 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5202] = 0
                mem[_5202 + 32] = 96
                mem[_5202 + 64] = 96
                mem[_5202 + 96] = 0
                mem[_5202 + 128] = 0
                mem[_5202 + 160] = 0
                mem[_5202 + 192] = 0
                mem[_5202 + 224] = 0
                require 0 < mem[_3966]
                _5466 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5466] = 0
                mem[_5466 + 32] = 96
                mem[_5466 + 64] = 96
                mem[_5466 + 96] = 0
                mem[_5466 + 128] = 0
                mem[_5466 + 160] = 0
                mem[_5466 + 192] = 0
                mem[_5466 + 224] = 0
                require 1 < mem[_3966]
                if mem[_3538 + 96] <= mem[_1775 + 96]:
                    idx = 12
                    s = mem[_3538 + 96]
                    while idx >= 4:
                        if not mem[_3538 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3538 + 96] - idx
                        continue 
                    _6049 = mem[_3538 + 96]
                    _6050 = mem[_3538 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6049 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6050 / 10^(_6049 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6050 / 10^(_6049 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6050 / 10^(_6049 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6050 / 10^(_6049 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6050 / 10^(_6049 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6050 / 10^(_6049 - s))
                idx = 12
                s = mem[_1775 + 96]
                while idx >= 4:
                    if not mem[_1775 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1775 + 96] - idx
                    continue 
                _6051 = mem[_3538 + 96]
                _6052 = mem[_3538 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6051 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1775 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                    if not _6052 / 10^(_6051 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6052 / 10^(_6051 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6052 / 10^(_6051 - s))
                if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6052 / 10^(_6051 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6052 / 10^(_6051 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6052 / 10^(_6051 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4014 = mem[64]
                mem[mem[64]] = 2
                _4913 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4913] = 0
                mem[_4913 + 32] = 96
                mem[_4913 + 64] = 96
                mem[_4913 + 96] = 0
                mem[_4913 + 128] = 0
                mem[_4913 + 160] = 0
                mem[_4913 + 192] = 0
                mem[_4913 + 224] = 0
                mem[var201001] = _4913
                s = var201001
                idx = var201002
                while idx - 1:
                    _4913 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4913] = 0
                    mem[_4913 + 32] = 96
                    mem[_4913 + 64] = 96
                    mem[_4913 + 96] = 0
                    mem[_4913 + 128] = 0
                    mem[_4913 + 160] = 0
                    mem[_4913 + 192] = 0
                    mem[_4913 + 224] = 0
                    mem[s + 32] = _4913
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4014]
                mem[_4014 + 32] = _3538
                require 1 < mem[_4014]
                mem[_4014 + 64] = _1775
                _5201 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5201] = 0
                mem[_5201 + 32] = 96
                mem[_5201 + 64] = 96
                mem[_5201 + 96] = 0
                mem[_5201 + 128] = 0
                mem[_5201 + 160] = 0
                mem[_5201 + 192] = 0
                mem[_5201 + 224] = 0
                require 0 < mem[_4014]
                _5465 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5465] = 0
                mem[_5465 + 32] = 96
                mem[_5465 + 64] = 96
                mem[_5465 + 96] = 0
                mem[_5465 + 128] = 0
                mem[_5465 + 160] = 0
                mem[_5465 + 192] = 0
                mem[_5465 + 224] = 0
                require 1 < mem[_4014]
                if mem[_3538 + 96] <= mem[_1775 + 96]:
                    idx = 12
                    s = mem[_3538 + 96]
                    while idx >= 4:
                        if not mem[_3538 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3538 + 96] - idx
                        continue 
                    _6045 = mem[_3538 + 96]
                    _6046 = mem[_3538 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6045 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1775 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                        if not _6046 / 10^(_6045 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6046 / 10^(_6045 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6046 / 10^(_6045 - s))
                    if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6046 / 10^(_6045 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6046 / 10^(_6045 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6046 / 10^(_6045 - s))
                idx = 12
                s = mem[_1775 + 96]
                while idx >= 4:
                    if not mem[_1775 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1775 + 96] - idx
                    continue 
                _6047 = mem[_3538 + 96]
                _6048 = mem[_3538 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6047 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1775 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1775 + 128] / 10^(mem[_1775 + 96] - s):
                    if not _6048 / 10^(_6047 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6048 / 10^(_6047 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6048 / 10^(_6047 - s))
                if 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6048 / 10^(_6047 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6048 / 10^(_6047 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1775 + 128] / 10^(mem[_1775 + 96] - s) / _6048 / 10^(_6047 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4372 = mem[64]
                mem[mem[64]] = 2
                _5964 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5964] = 0
                mem[_5964 + 32] = 96
                mem[_5964 + 64] = 96
                mem[_5964 + 96] = 0
                mem[_5964 + 128] = 0
                mem[_5964 + 160] = 0
                mem[_5964 + 192] = 0
                mem[_5964 + 224] = 0
                mem[var210001] = _5964
                s = var210001
                idx = var210002
                while idx - 1:
                    _5964 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5964] = 0
                    mem[_5964 + 32] = 96
                    mem[_5964 + 64] = 96
                    mem[_5964 + 96] = 0
                    mem[_5964 + 128] = 0
                    mem[_5964 + 160] = 0
                    mem[_5964 + 192] = 0
                    mem[_5964 + 224] = 0
                    mem[s + 32] = _5964
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4372]
                mem[_4372 + 32] = _3538
                require 1 < mem[_4372]
                mem[_4372 + 64] = _1775
                _6572 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6572] = 0
                mem[_6572 + 32] = 96
                mem[_6572 + 64] = 96
                mem[_6572 + 96] = 0
                mem[_6572 + 128] = 0
                mem[_6572 + 160] = 0
                mem[_6572 + 192] = 0
                mem[_6572 + 224] = 0
                require 0 < mem[_4372]
                _6844 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6844] = 0
                mem[_6844 + 32] = 96
                mem[_6844 + 64] = 96
                mem[_6844 + 96] = 0
                mem[_6844 + 128] = 0
                mem[_6844 + 160] = 0
                mem[_6844 + 192] = 0
                mem[_6844 + 224] = 0
                require 1 < mem[_4372]
                if mem[_3538 + 96] <= mem[_1775 + 96]:
                    idx = 12
                    s = mem[_3538 + 96]
                    while idx >= 4:
                        if not mem[_3538 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3538 + 96] - idx
                        continue 
                    _12993 = mem[_3538 + 96]
                    _12994 = mem[_3538 + 128]
                    _13107 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13107] = 26
                    mem[_13107 + 32] = 'SafeMath: division by zero'
                    if not 10^(_12993 - s):
                        _13171 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13171 + 68] = mem[idx + _13107 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13171 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13171 + -mem[64] + 100
                    _14849 = mem[_1775 + 96]
                    _14850 = mem[_1775 + 128]
                    _14977 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14977] = 26
                    mem[_14977 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14849 - s):
                        _15091 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15091 + 68] = mem[idx + _14977 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15091 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15091 + -mem[64] + 100
                    if not _14850 / 10^(_14849 - s):
                        _15475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15475] = 26
                        mem[_15475 + 32] = 'SafeMath: division by zero'
                        if not _12994 / 10^(_12993 - s):
                            _15696 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15696 + 68] = mem[idx + _15475 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15696 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15696 + -mem[64] + 100
                        _16257 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16257] = 26
                        mem[_16257 + 32] = 'SafeMath: division by zero'
                        if 0 / _12994 / 10^(_12993 - s):
                            return (1000000 * 10^18 / 0 / _12994 / 10^(_12993 - s))
                        _16465 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16465 + 68] = mem[idx + _16257 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16465 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16465 + -mem[64] + 100
                    if 10^12 * _14850 / 10^(_14849 - s) / _14850 / 10^(_14849 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15695 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15695] = 26
                    mem[_15695 + 32] = 'SafeMath: division by zero'
                    if not _12994 / 10^(_12993 - s):
                        _15873 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15873 + 68] = mem[idx + _15695 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15873 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15873 + -mem[64] + 100
                    _16463 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16463] = 26
                    mem[_16463 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14850 / 10^(_14849 - s) / _12994 / 10^(_12993 - s):
                        return (1000000 * 10^18 / 10^12 * _14850 / 10^(_14849 - s) / _12994 / 10^(_12993 - s))
                    _16641 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16641 + 68] = mem[idx + _16463 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16641 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16641 + -mem[64] + 100
                idx = 12
                s = mem[_1775 + 96]
                while idx >= 4:
                    if not mem[_1775 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1775 + 96] - idx
                    continue 
                _12995 = mem[_3538 + 96]
                _12996 = mem[_3538 + 128]
                _13108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13108] = 26
                mem[_13108 + 32] = 'SafeMath: division by zero'
                if not 10^(_12995 - s):
                    _13172 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13172 + 68] = mem[idx + _13108 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13172 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13172 + -mem[64] + 100
                _14851 = mem[_1775 + 96]
                _14852 = mem[_1775 + 128]
                _14979 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14979] = 26
                mem[_14979 + 32] = 'SafeMath: division by zero'
                if not 10^(_14851 - s):
                    _15092 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15092 + 68] = mem[idx + _14979 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15092 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15092 + -mem[64] + 100
                if not _14852 / 10^(_14851 - s):
                    _15476 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15476] = 26
                    mem[_15476 + 32] = 'SafeMath: division by zero'
                    if not _12996 / 10^(_12995 - s):
                        _15699 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15699 + 68] = mem[idx + _15476 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15699 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15699 + -mem[64] + 100
                    _16259 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16259] = 26
                    mem[_16259 + 32] = 'SafeMath: division by zero'
                    if 0 / _12996 / 10^(_12995 - s):
                        return (1000000 * 10^18 / 0 / _12996 / 10^(_12995 - s))
                    _16468 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16468 + 68] = mem[idx + _16259 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16468 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16468 + -mem[64] + 100
                if 10^12 * _14852 / 10^(_14851 - s) / _14852 / 10^(_14851 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15698 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15698] = 26
                mem[_15698 + 32] = 'SafeMath: division by zero'
                if not _12996 / 10^(_12995 - s):
                    _15875 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15875 + 68] = mem[idx + _15698 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15875 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15875 + -mem[64] + 100
                _16466 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16466] = 26
                mem[_16466 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14852 / 10^(_14851 - s) / _12996 / 10^(_12995 - s):
                    return (1000000 * 10^18 / 10^12 * _14852 / 10^(_14851 - s) / _12996 / 10^(_12995 - s))
                _16643 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16643 + 68] = mem[idx + _16466 + 32]
                    idx = idx + 32
                    continue 
                mem[_16643 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16643 + -mem[64] + 100
            _4212 = mem[64]
            mem[mem[64]] = 2
            _5963 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5963] = 0
            mem[_5963 + 32] = 96
            mem[_5963 + 64] = 96
            mem[_5963 + 96] = 0
            mem[_5963 + 128] = 0
            mem[_5963 + 160] = 0
            mem[_5963 + 192] = 0
            mem[_5963 + 224] = 0
            mem[var206001] = _5963
            s = var206001
            idx = var206002
            while idx - 1:
                _5963 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5963] = 0
                mem[_5963 + 32] = 96
                mem[_5963 + 64] = 96
                mem[_5963 + 96] = 0
                mem[_5963 + 128] = 0
                mem[_5963 + 160] = 0
                mem[_5963 + 192] = 0
                mem[_5963 + 224] = 0
                mem[s + 32] = _5963
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4212]
            mem[_4212 + 32] = _1775
            require 1 < mem[_4212]
            mem[_4212 + 64] = _3538
            _6571 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6571] = 0
            mem[_6571 + 32] = 96
            mem[_6571 + 64] = 96
            mem[_6571 + 96] = 0
            mem[_6571 + 128] = 0
            mem[_6571 + 160] = 0
            mem[_6571 + 192] = 0
            mem[_6571 + 224] = 0
            require 0 < mem[_4212]
            _6843 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6843] = 0
            mem[_6843 + 32] = 96
            mem[_6843 + 64] = 96
            mem[_6843 + 96] = 0
            mem[_6843 + 128] = 0
            mem[_6843 + 160] = 0
            mem[_6843 + 192] = 0
            mem[_6843 + 224] = 0
            require 1 < mem[_4212]
            if mem[_1775 + 96] <= mem[_3538 + 96]:
                idx = 12
                s = mem[_1775 + 96]
                while idx >= 4:
                    if not mem[_1775 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1775 + 96] - idx
                    continue 
                _12989 = mem[_1775 + 96]
                _12990 = mem[_1775 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_12989 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3538 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3538 + 128] / 10^(mem[_3538 + 96] - s):
                    if not _12990 / 10^(_12989 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _12990 / 10^(_12989 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _12990 / 10^(_12989 - s))
                if 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _12990 / 10^(_12989 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / _12990 / 10^(_12989 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / _12990 / 10^(_12989 - s))
            idx = 12
            s = mem[_3538 + 96]
            while idx >= 4:
                if not mem[_3538 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3538 + 96] - idx
                continue 
            _12991 = mem[_1775 + 96]
            _12992 = mem[_1775 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_12991 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3538 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3538 + 128] / 10^(mem[_3538 + 96] - s):
                if not _12992 / 10^(_12991 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _12992 / 10^(_12991 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _12992 / 10^(_12991 - s))
            if 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _12992 / 10^(_12991 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / _12992 / 10^(_12991 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3538 + 128] / 10^(mem[_3538 + 96] - s) / _12992 / 10^(_12991 - s))
        mem[_869 + ceil32(return_data.size) + _873 + 32] = 0
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1755 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1759 = mem[_1755]
        require mem[_1755] == mem[_1755 + 31 len 1]
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1771 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1776 = mem[_1771]
        _1779 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1779] = address(ext_call.return_data[0])
        mem[_1779 + 32] = (2 * ceil32(return_data.size)) + 608
        mem[_1779 + 64] = _869 + ceil32(return_data.size)
        mem[_1779 + 96] = uint8(_1759)
        mem[_1779 + 128] = 0
        mem[_1779 + 160] = _1776
        mem[_1779 + 192] = 0
        mem[_1779 + 224] = 0
        _1785 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1785] = 0
        mem[_1785 + 32] = 96
        mem[_1785 + 64] = 96
        mem[_1785 + 96] = 0
        mem[_1785 + 128] = 0
        mem[_1785 + 160] = 0
        mem[_1785 + 192] = 0
        mem[_1785 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1795 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1799 = mem[_1795]
        require mem[_1795] == mem[_1795 + 12 len 20]
        _1805 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1805] = 0
        mem[_1805 + 32] = 96
        mem[_1805 + 64] = 96
        mem[_1805 + 96] = 0
        mem[_1805 + 128] = 0
        mem[_1805 + 160] = 0
        mem[_1805 + 192] = 0
        mem[_1805 + 224] = 0
        mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1799))
        staticcall address(_1799).name() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1815 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1819 = mem[_1815]
        require mem[_1815] <= test266151307()
        require _1815 + return_data.size > _1815 + mem[_1815] + 31
        _1823 = mem[_1815 + mem[_1815]]
        require mem[_1815 + mem[_1815]] <= test266151307()
        require ceil32(mem[_1815 + mem[_1815]]) + 32 >= 0 and _1815 + ceil32(return_data.size) + ceil32(mem[_1815 + mem[_1815]]) + 32 <= test266151307()
        mem[64] = _1815 + ceil32(return_data.size) + ceil32(mem[_1815 + mem[_1815]]) + 32
        mem[_1815 + ceil32(return_data.size)] = _1823
        require _1819 + _1823 + 32 <= return_data.size
        mem[_1815 + ceil32(return_data.size) + 32 len ceil32(_1823)] = mem[_1815 + _1819 + 32 len ceil32(_1823)]
        if ceil32(_1823) <= _1823:
            mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1799))
            staticcall address(_1799).0x95d89b41 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2630 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2638 = mem[_2630]
            require mem[_2630] <= test266151307()
            require _2630 + return_data.size > _2630 + mem[_2630] + 31
            _2646 = mem[_2630 + mem[_2630]]
            require mem[_2630 + mem[_2630]] <= test266151307()
            require ceil32(mem[_2630 + mem[_2630]]) + 32 >= 0 and _2630 + ceil32(return_data.size) + ceil32(mem[_2630 + mem[_2630]]) + 32 <= test266151307()
            mem[64] = _2630 + ceil32(return_data.size) + ceil32(mem[_2630 + mem[_2630]]) + 32
            mem[_2630 + ceil32(return_data.size)] = _2646
            require _2638 + _2646 + 32 <= return_data.size
            mem[_2630 + ceil32(return_data.size) + 32 len ceil32(_2646)] = mem[_2630 + _2638 + 32 len ceil32(_2646)]
            if ceil32(_2646) <= _2646:
                require ext_code.size(address(_1799))
                staticcall address(_1799).0x313ce567 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3431 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3447 = mem[_3431]
                require mem[_3431] == mem[_3431 + 31 len 1]
                require ext_code.size(address(_1799))
                staticcall address(_1799).0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3495 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3511 = mem[_3495]
                _3521 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3521] = address(_1799)
                mem[_3521 + 32] = _1815 + ceil32(return_data.size)
                mem[_3521 + 64] = _2630 + ceil32(return_data.size)
                mem[_3521 + 96] = uint8(_3447)
                mem[_3521 + 128] = 0
                mem[_3521 + 160] = _3511
                mem[_3521 + 192] = 0
                mem[_3521 + 224] = 0
                require ext_code.size(arg1)
                staticcall arg1.token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3575 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3591 = mem[_3575]
                require mem[_3575] == mem[_3575 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3591))
                staticcall address(_3591).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3639 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_1779 + 128] = mem[_3639]
                require ext_code.size(arg1)
                staticcall arg1.token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3703 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3719 = mem[_3703]
                require mem[_3703] == mem[_3703 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3719))
                staticcall address(_3719).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3767 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_3521 + 128] = mem[_3767]
                _3799 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3799] = 0
                mem[_3799 + 32] = 96
                mem[_3799 + 64] = 96
                mem[_3799 + 96] = 0
                mem[_3799 + 128] = 0
                mem[_3799 + 160] = 0
                mem[_3799 + 192] = 0
                mem[_3799 + 224] = 0
                _3815 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3815] = 0
                mem[_3815 + 32] = 96
                mem[_3815 + 64] = 96
                mem[_3815 + 96] = 0
                mem[_3815 + 128] = 0
                mem[_3815 + 160] = 0
                mem[_3815 + 192] = 0
                mem[_3815 + 224] = 0
                if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                    _3857 = mem[64]
                    mem[mem[64]] = 2
                    _4920 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4920] = 0
                    mem[_4920 + 32] = 96
                    mem[_4920 + 64] = 96
                    mem[_4920 + 96] = 0
                    mem[_4920 + 128] = 0
                    mem[_4920 + 160] = 0
                    mem[_4920 + 192] = 0
                    mem[_4920 + 224] = 0
                    mem[var190001] = _4920
                    s = var190001
                    idx = var190002
                    while idx - 1:
                        _4920 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4920] = 0
                        mem[_4920 + 32] = 96
                        mem[_4920 + 64] = 96
                        mem[_4920 + 96] = 0
                        mem[_4920 + 128] = 0
                        mem[_4920 + 160] = 0
                        mem[_4920 + 192] = 0
                        mem[_4920 + 224] = 0
                        mem[s + 32] = _4920
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3857]
                    mem[_3857 + 32] = _3521
                    require 1 < mem[_3857]
                    mem[_3857 + 64] = _1779
                    _5208 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5208] = 0
                    mem[_5208 + 32] = 96
                    mem[_5208 + 64] = 96
                    mem[_5208 + 96] = 0
                    mem[_5208 + 128] = 0
                    mem[_5208 + 160] = 0
                    mem[_5208 + 192] = 0
                    mem[_5208 + 224] = 0
                    require 0 < mem[_3857]
                    _5474 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5474] = 0
                    mem[_5474 + 32] = 96
                    mem[_5474 + 64] = 96
                    mem[_5474 + 96] = 0
                    mem[_5474 + 128] = 0
                    mem[_5474 + 160] = 0
                    mem[_5474 + 192] = 0
                    mem[_5474 + 224] = 0
                    require 1 < mem[_3857]
                    if mem[_3521 + 96] <= mem[_1779 + 96]:
                        idx = 12
                        s = mem[_3521 + 96]
                        while idx >= 4:
                            if not mem[_3521 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3521 + 96] - idx
                            continue 
                        _6075 = mem[_3521 + 96]
                        _6076 = mem[_3521 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6075 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1779 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                            if not _6076 / 10^(_6075 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6076 / 10^(_6075 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6076 / 10^(_6075 - s))
                        if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6076 / 10^(_6075 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6076 / 10^(_6075 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6076 / 10^(_6075 - s))
                    idx = 12
                    s = mem[_1779 + 96]
                    while idx >= 4:
                        if not mem[_1779 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1779 + 96] - idx
                        continue 
                    _6077 = mem[_3521 + 96]
                    _6078 = mem[_3521 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6077 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6078 / 10^(_6077 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6078 / 10^(_6077 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6078 / 10^(_6077 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6078 / 10^(_6077 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6078 / 10^(_6077 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6078 / 10^(_6077 - s))
                if wbnbAddress == address(_1799):
                    _3905 = mem[64]
                    mem[mem[64]] = 2
                    _4919 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4919] = 0
                    mem[_4919 + 32] = 96
                    mem[_4919 + 64] = 96
                    mem[_4919 + 96] = 0
                    mem[_4919 + 128] = 0
                    mem[_4919 + 160] = 0
                    mem[_4919 + 192] = 0
                    mem[_4919 + 224] = 0
                    mem[var194001] = _4919
                    s = var194001
                    idx = var194002
                    while idx - 1:
                        _4919 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4919] = 0
                        mem[_4919 + 32] = 96
                        mem[_4919 + 64] = 96
                        mem[_4919 + 96] = 0
                        mem[_4919 + 128] = 0
                        mem[_4919 + 160] = 0
                        mem[_4919 + 192] = 0
                        mem[_4919 + 224] = 0
                        mem[s + 32] = _4919
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3905]
                    mem[_3905 + 32] = _1779
                    require 1 < mem[_3905]
                    mem[_3905 + 64] = _3521
                    _5207 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5207] = 0
                    mem[_5207 + 32] = 96
                    mem[_5207 + 64] = 96
                    mem[_5207 + 96] = 0
                    mem[_5207 + 128] = 0
                    mem[_5207 + 160] = 0
                    mem[_5207 + 192] = 0
                    mem[_5207 + 224] = 0
                    require 0 < mem[_3905]
                    _5473 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5473] = 0
                    mem[_5473 + 32] = 96
                    mem[_5473 + 64] = 96
                    mem[_5473 + 96] = 0
                    mem[_5473 + 128] = 0
                    mem[_5473 + 160] = 0
                    mem[_5473 + 192] = 0
                    mem[_5473 + 224] = 0
                    require 1 < mem[_3905]
                    if mem[_1779 + 96] <= mem[_3521 + 96]:
                        idx = 12
                        s = mem[_1779 + 96]
                        while idx >= 4:
                            if not mem[_1779 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1779 + 96] - idx
                            continue 
                        _6071 = mem[_1779 + 96]
                        _6072 = mem[_1779 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6071 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3521 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3521 + 128] / 10^(mem[_3521 + 96] - s):
                            if not _6072 / 10^(_6071 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6072 / 10^(_6071 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6072 / 10^(_6071 - s))
                        if 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6072 / 10^(_6071 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / _6072 / 10^(_6071 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / _6072 / 10^(_6071 - s))
                    idx = 12
                    s = mem[_3521 + 96]
                    while idx >= 4:
                        if not mem[_3521 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3521 + 96] - idx
                        continue 
                    _6073 = mem[_1779 + 96]
                    _6074 = mem[_1779 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6073 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3521 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3521 + 128] / 10^(mem[_3521 + 96] - s):
                        if not _6074 / 10^(_6073 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6074 / 10^(_6073 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6074 / 10^(_6073 - s))
                    if 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6074 / 10^(_6073 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / _6074 / 10^(_6073 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / _6074 / 10^(_6073 - s))
                if busdAddress == uint64(ext_call.return_data[0]) << 96:
                    _3947 = mem[64]
                    mem[mem[64]] = 2
                    _4918 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4918] = 0
                    mem[_4918 + 32] = 96
                    mem[_4918 + 64] = 96
                    mem[_4918 + 96] = 0
                    mem[_4918 + 128] = 0
                    mem[_4918 + 160] = 0
                    mem[_4918 + 192] = 0
                    mem[_4918 + 224] = 0
                    mem[var197001] = _4918
                    s = var197001
                    idx = var197002
                    while idx - 1:
                        _4918 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4918] = 0
                        mem[_4918 + 32] = 96
                        mem[_4918 + 64] = 96
                        mem[_4918 + 96] = 0
                        mem[_4918 + 128] = 0
                        mem[_4918 + 160] = 0
                        mem[_4918 + 192] = 0
                        mem[_4918 + 224] = 0
                        mem[s + 32] = _4918
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3947]
                    mem[_3947 + 32] = _3521
                    require 1 < mem[_3947]
                    mem[_3947 + 64] = _1779
                    _5206 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5206] = 0
                    mem[_5206 + 32] = 96
                    mem[_5206 + 64] = 96
                    mem[_5206 + 96] = 0
                    mem[_5206 + 128] = 0
                    mem[_5206 + 160] = 0
                    mem[_5206 + 192] = 0
                    mem[_5206 + 224] = 0
                    require 0 < mem[_3947]
                    _5472 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5472] = 0
                    mem[_5472 + 32] = 96
                    mem[_5472 + 64] = 96
                    mem[_5472 + 96] = 0
                    mem[_5472 + 128] = 0
                    mem[_5472 + 160] = 0
                    mem[_5472 + 192] = 0
                    mem[_5472 + 224] = 0
                    require 1 < mem[_3947]
                    if mem[_3521 + 96] <= mem[_1779 + 96]:
                        idx = 12
                        s = mem[_3521 + 96]
                        while idx >= 4:
                            if not mem[_3521 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3521 + 96] - idx
                            continue 
                        _6067 = mem[_3521 + 96]
                        _6068 = mem[_3521 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6067 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1779 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                            if not _6068 / 10^(_6067 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6068 / 10^(_6067 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6068 / 10^(_6067 - s))
                        if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6068 / 10^(_6067 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6068 / 10^(_6067 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6068 / 10^(_6067 - s))
                    idx = 12
                    s = mem[_1779 + 96]
                    while idx >= 4:
                        if not mem[_1779 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1779 + 96] - idx
                        continue 
                    _6069 = mem[_3521 + 96]
                    _6070 = mem[_3521 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6069 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6070 / 10^(_6069 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6070 / 10^(_6069 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6070 / 10^(_6069 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6070 / 10^(_6069 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6070 / 10^(_6069 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6070 / 10^(_6069 - s))
                if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                    _3995 = mem[64]
                    mem[mem[64]] = 2
                    _4917 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4917] = 0
                    mem[_4917 + 32] = 96
                    mem[_4917 + 64] = 96
                    mem[_4917 + 96] = 0
                    mem[_4917 + 128] = 0
                    mem[_4917 + 160] = 0
                    mem[_4917 + 192] = 0
                    mem[_4917 + 224] = 0
                    mem[var200001] = _4917
                    s = var200001
                    idx = var200002
                    while idx - 1:
                        _4917 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4917] = 0
                        mem[_4917 + 32] = 96
                        mem[_4917 + 64] = 96
                        mem[_4917 + 96] = 0
                        mem[_4917 + 128] = 0
                        mem[_4917 + 160] = 0
                        mem[_4917 + 192] = 0
                        mem[_4917 + 224] = 0
                        mem[s + 32] = _4917
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3995]
                    mem[_3995 + 32] = _3521
                    require 1 < mem[_3995]
                    mem[_3995 + 64] = _1779
                    _5205 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5205] = 0
                    mem[_5205 + 32] = 96
                    mem[_5205 + 64] = 96
                    mem[_5205 + 96] = 0
                    mem[_5205 + 128] = 0
                    mem[_5205 + 160] = 0
                    mem[_5205 + 192] = 0
                    mem[_5205 + 224] = 0
                    require 0 < mem[_3995]
                    _5471 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5471] = 0
                    mem[_5471 + 32] = 96
                    mem[_5471 + 64] = 96
                    mem[_5471 + 96] = 0
                    mem[_5471 + 128] = 0
                    mem[_5471 + 160] = 0
                    mem[_5471 + 192] = 0
                    mem[_5471 + 224] = 0
                    require 1 < mem[_3995]
                    if mem[_3521 + 96] <= mem[_1779 + 96]:
                        idx = 12
                        s = mem[_3521 + 96]
                        while idx >= 4:
                            if not mem[_3521 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3521 + 96] - idx
                            continue 
                        _6063 = mem[_3521 + 96]
                        _6064 = mem[_3521 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6063 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1779 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                            if not _6064 / 10^(_6063 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6064 / 10^(_6063 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6064 / 10^(_6063 - s))
                        if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6064 / 10^(_6063 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6064 / 10^(_6063 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6064 / 10^(_6063 - s))
                    idx = 12
                    s = mem[_1779 + 96]
                    while idx >= 4:
                        if not mem[_1779 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1779 + 96] - idx
                        continue 
                    _6065 = mem[_3521 + 96]
                    _6066 = mem[_3521 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6065 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6066 / 10^(_6065 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6066 / 10^(_6065 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6066 / 10^(_6065 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6066 / 10^(_6065 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6066 / 10^(_6065 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6066 / 10^(_6065 - s))
                idx = 0
                while idx < sub_27d312da.length:
                    mem[0] = 1
                    if sub_27d312da[idx] != address(ext_call.return_data[0]):
                        idx = idx + 1
                        continue 
                    _4377 = mem[64]
                    mem[mem[64]] = 2
                    _5966 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5966] = 0
                    mem[_5966 + 32] = 96
                    mem[_5966 + 64] = 96
                    mem[_5966 + 96] = 0
                    mem[_5966 + 128] = 0
                    mem[_5966 + 160] = 0
                    mem[_5966 + 192] = 0
                    mem[_5966 + 224] = 0
                    mem[var209001] = _5966
                    s = var209001
                    idx = var209002
                    while idx - 1:
                        _5966 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5966] = 0
                        mem[_5966 + 32] = 96
                        mem[_5966 + 64] = 96
                        mem[_5966 + 96] = 0
                        mem[_5966 + 128] = 0
                        mem[_5966 + 160] = 0
                        mem[_5966 + 192] = 0
                        mem[_5966 + 224] = 0
                        mem[s + 32] = _5966
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4377]
                    mem[_4377 + 32] = _3521
                    require 1 < mem[_4377]
                    mem[_4377 + 64] = _1779
                    _6574 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6574] = 0
                    mem[_6574 + 32] = 96
                    mem[_6574 + 64] = 96
                    mem[_6574 + 96] = 0
                    mem[_6574 + 128] = 0
                    mem[_6574 + 160] = 0
                    mem[_6574 + 192] = 0
                    mem[_6574 + 224] = 0
                    require 0 < mem[_4377]
                    _6862 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6862] = 0
                    mem[_6862 + 32] = 96
                    mem[_6862 + 64] = 96
                    mem[_6862 + 96] = 0
                    mem[_6862 + 128] = 0
                    mem[_6862 + 160] = 0
                    mem[_6862 + 192] = 0
                    mem[_6862 + 224] = 0
                    require 1 < mem[_4377]
                    if mem[_3521 + 96] <= mem[_1779 + 96]:
                        idx = 12
                        s = mem[_3521 + 96]
                        while idx >= 4:
                            if not mem[_3521 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3521 + 96] - idx
                            continue 
                        _13001 = mem[_3521 + 96]
                        _13002 = mem[_3521 + 128]
                        _13111 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13111] = 26
                        mem[_13111 + 32] = 'SafeMath: division by zero'
                        if not 10^(_13001 - s):
                            _13175 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13175 + 68] = mem[idx + _13111 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13175 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13175 + -mem[64] + 100
                        _14857 = mem[_1779 + 96]
                        _14858 = mem[_1779 + 128]
                        _14985 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14985] = 26
                        mem[_14985 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14857 - s):
                            _15095 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15095 + 68] = mem[idx + _14985 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15095 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15095 + -mem[64] + 100
                        if not _14858 / 10^(_14857 - s):
                            _15479 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15479] = 26
                            mem[_15479 + 32] = 'SafeMath: division by zero'
                            if not _13002 / 10^(_13001 - s):
                                _15708 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15708 + 68] = mem[idx + _15479 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15708 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15708 + -mem[64] + 100
                            _16265 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16265] = 26
                            mem[_16265 + 32] = 'SafeMath: division by zero'
                            if 0 / _13002 / 10^(_13001 - s):
                                return (1000000 * 10^18 / 0 / _13002 / 10^(_13001 - s))
                            _16477 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16477 + 68] = mem[idx + _16265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16477 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16477 + -mem[64] + 100
                        if 10^12 * _14858 / 10^(_14857 - s) / _14858 / 10^(_14857 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15707 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15707] = 26
                        mem[_15707 + 32] = 'SafeMath: division by zero'
                        if not _13002 / 10^(_13001 - s):
                            _15881 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15881 + 68] = mem[idx + _15707 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15881 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15881 + -mem[64] + 100
                        _16475 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16475] = 26
                        mem[_16475 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14858 / 10^(_14857 - s) / _13002 / 10^(_13001 - s):
                            return (1000000 * 10^18 / 10^12 * _14858 / 10^(_14857 - s) / _13002 / 10^(_13001 - s))
                        _16649 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16649 + 68] = mem[idx + _16475 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16649 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16649 + -mem[64] + 100
                    idx = 12
                    s = mem[_1779 + 96]
                    while idx >= 4:
                        if not mem[_1779 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1779 + 96] - idx
                        continue 
                    _13003 = mem[_3521 + 96]
                    _13004 = mem[_3521 + 128]
                    _13112 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13112] = 26
                    mem[_13112 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13003 - s):
                        _13176 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13176 + 68] = mem[idx + _13112 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13176 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13176 + -mem[64] + 100
                    _14859 = mem[_1779 + 96]
                    _14860 = mem[_1779 + 128]
                    _14987 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14987] = 26
                    mem[_14987 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14859 - s):
                        _15096 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15096 + 68] = mem[idx + _14987 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15096 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15096 + -mem[64] + 100
                    if not _14860 / 10^(_14859 - s):
                        _15480 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15480] = 26
                        mem[_15480 + 32] = 'SafeMath: division by zero'
                        if not _13004 / 10^(_13003 - s):
                            _15711 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15711 + 68] = mem[idx + _15480 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15711 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15711 + -mem[64] + 100
                        _16267 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16267] = 26
                        mem[_16267 + 32] = 'SafeMath: division by zero'
                        if 0 / _13004 / 10^(_13003 - s):
                            return (1000000 * 10^18 / 0 / _13004 / 10^(_13003 - s))
                        _16480 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16480 + 68] = mem[idx + _16267 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16480 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16480 + -mem[64] + 100
                    if 10^12 * _14860 / 10^(_14859 - s) / _14860 / 10^(_14859 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15710 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15710] = 26
                    mem[_15710 + 32] = 'SafeMath: division by zero'
                    if not _13004 / 10^(_13003 - s):
                        _15883 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15883 + 68] = mem[idx + _15710 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15883 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15883 + -mem[64] + 100
                    _16478 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16478] = 26
                    mem[_16478 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14860 / 10^(_14859 - s) / _13004 / 10^(_13003 - s):
                        return (1000000 * 10^18 / 10^12 * _14860 / 10^(_14859 - s) / _13004 / 10^(_13003 - s))
                    _16651 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16651 + 68] = mem[idx + _16478 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16651 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16651 + -mem[64] + 100
                _4217 = mem[64]
                mem[mem[64]] = 2
                _5965 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5965] = 0
                mem[_5965 + 32] = 96
                mem[_5965 + 64] = 96
                mem[_5965 + 96] = 0
                mem[_5965 + 128] = 0
                mem[_5965 + 160] = 0
                mem[_5965 + 192] = 0
                mem[_5965 + 224] = 0
                mem[var205001] = _5965
                s = var205001
                idx = var205002
                while idx - 1:
                    _5965 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5965] = 0
                    mem[_5965 + 32] = 96
                    mem[_5965 + 64] = 96
                    mem[_5965 + 96] = 0
                    mem[_5965 + 128] = 0
                    mem[_5965 + 160] = 0
                    mem[_5965 + 192] = 0
                    mem[_5965 + 224] = 0
                    mem[s + 32] = _5965
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4217]
                mem[_4217 + 32] = _1779
                require 1 < mem[_4217]
                mem[_4217 + 64] = _3521
                _6573 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6573] = 0
                mem[_6573 + 32] = 96
                mem[_6573 + 64] = 96
                mem[_6573 + 96] = 0
                mem[_6573 + 128] = 0
                mem[_6573 + 160] = 0
                mem[_6573 + 192] = 0
                mem[_6573 + 224] = 0
                require 0 < mem[_4217]
                _6861 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6861] = 0
                mem[_6861 + 32] = 96
                mem[_6861 + 64] = 96
                mem[_6861 + 96] = 0
                mem[_6861 + 128] = 0
                mem[_6861 + 160] = 0
                mem[_6861 + 192] = 0
                mem[_6861 + 224] = 0
                require 1 < mem[_4217]
                if mem[_1779 + 96] <= mem[_3521 + 96]:
                    idx = 12
                    s = mem[_1779 + 96]
                    while idx >= 4:
                        if not mem[_1779 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1779 + 96] - idx
                        continue 
                    _12997 = mem[_1779 + 96]
                    _12998 = mem[_1779 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_12997 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3521 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3521 + 128] / 10^(mem[_3521 + 96] - s):
                        if not _12998 / 10^(_12997 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _12998 / 10^(_12997 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _12998 / 10^(_12997 - s))
                    if 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _12998 / 10^(_12997 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / _12998 / 10^(_12997 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / _12998 / 10^(_12997 - s))
                idx = 12
                s = mem[_3521 + 96]
                while idx >= 4:
                    if not mem[_3521 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3521 + 96] - idx
                    continue 
                _12999 = mem[_1779 + 96]
                _13000 = mem[_1779 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_12999 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3521 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3521 + 128] / 10^(mem[_3521 + 96] - s):
                    if not _13000 / 10^(_12999 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13000 / 10^(_12999 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13000 / 10^(_12999 - s))
                if 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13000 / 10^(_12999 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / _13000 / 10^(_12999 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3521 + 128] / 10^(mem[_3521 + 96] - s) / _13000 / 10^(_12999 - s))
            mem[_2630 + ceil32(return_data.size) + _2646 + 32] = 0
            require ext_code.size(address(_1799))
            staticcall address(_1799).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3439 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3455 = mem[_3439]
            require mem[_3439] == mem[_3439 + 31 len 1]
            require ext_code.size(address(_1799))
            staticcall address(_1799).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3503 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3522 = mem[_3503]
            _3541 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3541] = address(_1799)
            mem[_3541 + 32] = _1815 + ceil32(return_data.size)
            mem[_3541 + 64] = _2630 + ceil32(return_data.size)
            mem[_3541 + 96] = uint8(_3455)
            mem[_3541 + 128] = 0
            mem[_3541 + 160] = _3522
            mem[_3541 + 192] = 0
            mem[_3541 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3583 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3599 = mem[_3583]
            require mem[_3583] == mem[_3583 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3599))
            staticcall address(_3599).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3647 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1779 + 128] = mem[_3647]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3711 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3727 = mem[_3711]
            require mem[_3711] == mem[_3711 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3727))
            staticcall address(_3727).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3775 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3541 + 128] = mem[_3775]
            _3807 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3807] = 0
            mem[_3807 + 32] = 96
            mem[_3807 + 64] = 96
            mem[_3807 + 96] = 0
            mem[_3807 + 128] = 0
            mem[_3807 + 160] = 0
            mem[_3807 + 192] = 0
            mem[_3807 + 224] = 0
            _3826 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3826] = 0
            mem[_3826 + 32] = 96
            mem[_3826 + 64] = 96
            mem[_3826 + 96] = 0
            mem[_3826 + 128] = 0
            mem[_3826 + 160] = 0
            mem[_3826 + 192] = 0
            mem[_3826 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3871 = mem[64]
                mem[mem[64]] = 2
                _4924 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4924] = 0
                mem[_4924 + 32] = 96
                mem[_4924 + 64] = 96
                mem[_4924 + 96] = 0
                mem[_4924 + 128] = 0
                mem[_4924 + 160] = 0
                mem[_4924 + 192] = 0
                mem[_4924 + 224] = 0
                mem[var191001] = _4924
                s = var191001
                idx = var191002
                while idx - 1:
                    _4924 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4924] = 0
                    mem[_4924 + 32] = 96
                    mem[_4924 + 64] = 96
                    mem[_4924 + 96] = 0
                    mem[_4924 + 128] = 0
                    mem[_4924 + 160] = 0
                    mem[_4924 + 192] = 0
                    mem[_4924 + 224] = 0
                    mem[s + 32] = _4924
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3871]
                mem[_3871 + 32] = _3541
                require 1 < mem[_3871]
                mem[_3871 + 64] = _1779
                _5212 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5212] = 0
                mem[_5212 + 32] = 96
                mem[_5212 + 64] = 96
                mem[_5212 + 96] = 0
                mem[_5212 + 128] = 0
                mem[_5212 + 160] = 0
                mem[_5212 + 192] = 0
                mem[_5212 + 224] = 0
                require 0 < mem[_3871]
                _5480 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5480] = 0
                mem[_5480 + 32] = 96
                mem[_5480 + 64] = 96
                mem[_5480 + 96] = 0
                mem[_5480 + 128] = 0
                mem[_5480 + 160] = 0
                mem[_5480 + 192] = 0
                mem[_5480 + 224] = 0
                require 1 < mem[_3871]
                if mem[_3541 + 96] <= mem[_1779 + 96]:
                    idx = 12
                    s = mem[_3541 + 96]
                    while idx >= 4:
                        if not mem[_3541 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3541 + 96] - idx
                        continue 
                    _6093 = mem[_3541 + 96]
                    _6094 = mem[_3541 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6093 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6094 / 10^(_6093 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6094 / 10^(_6093 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6094 / 10^(_6093 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6094 / 10^(_6093 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6094 / 10^(_6093 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6094 / 10^(_6093 - s))
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _6095 = mem[_3541 + 96]
                _6096 = mem[_3541 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6095 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6096 / 10^(_6095 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6096 / 10^(_6095 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6096 / 10^(_6095 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6096 / 10^(_6095 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6096 / 10^(_6095 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6096 / 10^(_6095 - s))
            if wbnbAddress == address(_1799):
                _3919 = mem[64]
                mem[mem[64]] = 2
                _4923 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4923] = 0
                mem[_4923 + 32] = 96
                mem[_4923 + 64] = 96
                mem[_4923 + 96] = 0
                mem[_4923 + 128] = 0
                mem[_4923 + 160] = 0
                mem[_4923 + 192] = 0
                mem[_4923 + 224] = 0
                mem[var195001] = _4923
                s = var195001
                idx = var195002
                while idx - 1:
                    _4923 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4923] = 0
                    mem[_4923 + 32] = 96
                    mem[_4923 + 64] = 96
                    mem[_4923 + 96] = 0
                    mem[_4923 + 128] = 0
                    mem[_4923 + 160] = 0
                    mem[_4923 + 192] = 0
                    mem[_4923 + 224] = 0
                    mem[s + 32] = _4923
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3919]
                mem[_3919 + 32] = _1779
                require 1 < mem[_3919]
                mem[_3919 + 64] = _3541
                _5211 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5211] = 0
                mem[_5211 + 32] = 96
                mem[_5211 + 64] = 96
                mem[_5211 + 96] = 0
                mem[_5211 + 128] = 0
                mem[_5211 + 160] = 0
                mem[_5211 + 192] = 0
                mem[_5211 + 224] = 0
                require 0 < mem[_3919]
                _5479 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5479] = 0
                mem[_5479 + 32] = 96
                mem[_5479 + 64] = 96
                mem[_5479 + 96] = 0
                mem[_5479 + 128] = 0
                mem[_5479 + 160] = 0
                mem[_5479 + 192] = 0
                mem[_5479 + 224] = 0
                require 1 < mem[_3919]
                if mem[_1779 + 96] <= mem[_3541 + 96]:
                    idx = 12
                    s = mem[_1779 + 96]
                    while idx >= 4:
                        if not mem[_1779 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1779 + 96] - idx
                        continue 
                    _6089 = mem[_1779 + 96]
                    _6090 = mem[_1779 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6089 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3541 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3541 + 128] / 10^(mem[_3541 + 96] - s):
                        if not _6090 / 10^(_6089 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6090 / 10^(_6089 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6090 / 10^(_6089 - s))
                    if 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6090 / 10^(_6089 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / _6090 / 10^(_6089 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / _6090 / 10^(_6089 - s))
                idx = 12
                s = mem[_3541 + 96]
                while idx >= 4:
                    if not mem[_3541 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3541 + 96] - idx
                    continue 
                _6091 = mem[_1779 + 96]
                _6092 = mem[_1779 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6091 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3541 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3541 + 128] / 10^(mem[_3541 + 96] - s):
                    if not _6092 / 10^(_6091 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6092 / 10^(_6091 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6092 / 10^(_6091 - s))
                if 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6092 / 10^(_6091 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / _6092 / 10^(_6091 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / _6092 / 10^(_6091 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3967 = mem[64]
                mem[mem[64]] = 2
                _4922 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4922] = 0
                mem[_4922 + 32] = 96
                mem[_4922 + 64] = 96
                mem[_4922 + 96] = 0
                mem[_4922 + 128] = 0
                mem[_4922 + 160] = 0
                mem[_4922 + 192] = 0
                mem[_4922 + 224] = 0
                mem[var198001] = _4922
                s = var198001
                idx = var198002
                while idx - 1:
                    _4922 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4922] = 0
                    mem[_4922 + 32] = 96
                    mem[_4922 + 64] = 96
                    mem[_4922 + 96] = 0
                    mem[_4922 + 128] = 0
                    mem[_4922 + 160] = 0
                    mem[_4922 + 192] = 0
                    mem[_4922 + 224] = 0
                    mem[s + 32] = _4922
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3967]
                mem[_3967 + 32] = _3541
                require 1 < mem[_3967]
                mem[_3967 + 64] = _1779
                _5210 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5210] = 0
                mem[_5210 + 32] = 96
                mem[_5210 + 64] = 96
                mem[_5210 + 96] = 0
                mem[_5210 + 128] = 0
                mem[_5210 + 160] = 0
                mem[_5210 + 192] = 0
                mem[_5210 + 224] = 0
                require 0 < mem[_3967]
                _5478 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5478] = 0
                mem[_5478 + 32] = 96
                mem[_5478 + 64] = 96
                mem[_5478 + 96] = 0
                mem[_5478 + 128] = 0
                mem[_5478 + 160] = 0
                mem[_5478 + 192] = 0
                mem[_5478 + 224] = 0
                require 1 < mem[_3967]
                if mem[_3541 + 96] <= mem[_1779 + 96]:
                    idx = 12
                    s = mem[_3541 + 96]
                    while idx >= 4:
                        if not mem[_3541 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3541 + 96] - idx
                        continue 
                    _6085 = mem[_3541 + 96]
                    _6086 = mem[_3541 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6085 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6086 / 10^(_6085 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6086 / 10^(_6085 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6086 / 10^(_6085 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6086 / 10^(_6085 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6086 / 10^(_6085 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6086 / 10^(_6085 - s))
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _6087 = mem[_3541 + 96]
                _6088 = mem[_3541 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6087 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6088 / 10^(_6087 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6088 / 10^(_6087 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6088 / 10^(_6087 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6088 / 10^(_6087 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6088 / 10^(_6087 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6088 / 10^(_6087 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4015 = mem[64]
                mem[mem[64]] = 2
                _4921 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4921] = 0
                mem[_4921 + 32] = 96
                mem[_4921 + 64] = 96
                mem[_4921 + 96] = 0
                mem[_4921 + 128] = 0
                mem[_4921 + 160] = 0
                mem[_4921 + 192] = 0
                mem[_4921 + 224] = 0
                mem[var201001] = _4921
                s = var201001
                idx = var201002
                while idx - 1:
                    _4921 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4921] = 0
                    mem[_4921 + 32] = 96
                    mem[_4921 + 64] = 96
                    mem[_4921 + 96] = 0
                    mem[_4921 + 128] = 0
                    mem[_4921 + 160] = 0
                    mem[_4921 + 192] = 0
                    mem[_4921 + 224] = 0
                    mem[s + 32] = _4921
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4015]
                mem[_4015 + 32] = _3541
                require 1 < mem[_4015]
                mem[_4015 + 64] = _1779
                _5209 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5209] = 0
                mem[_5209 + 32] = 96
                mem[_5209 + 64] = 96
                mem[_5209 + 96] = 0
                mem[_5209 + 128] = 0
                mem[_5209 + 160] = 0
                mem[_5209 + 192] = 0
                mem[_5209 + 224] = 0
                require 0 < mem[_4015]
                _5477 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5477] = 0
                mem[_5477 + 32] = 96
                mem[_5477 + 64] = 96
                mem[_5477 + 96] = 0
                mem[_5477 + 128] = 0
                mem[_5477 + 160] = 0
                mem[_5477 + 192] = 0
                mem[_5477 + 224] = 0
                require 1 < mem[_4015]
                if mem[_3541 + 96] <= mem[_1779 + 96]:
                    idx = 12
                    s = mem[_3541 + 96]
                    while idx >= 4:
                        if not mem[_3541 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3541 + 96] - idx
                        continue 
                    _6081 = mem[_3541 + 96]
                    _6082 = mem[_3541 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6081 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6082 / 10^(_6081 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6082 / 10^(_6081 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6082 / 10^(_6081 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6082 / 10^(_6081 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6082 / 10^(_6081 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6082 / 10^(_6081 - s))
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _6083 = mem[_3541 + 96]
                _6084 = mem[_3541 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6083 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6084 / 10^(_6083 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6084 / 10^(_6083 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6084 / 10^(_6083 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6084 / 10^(_6083 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6084 / 10^(_6083 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6084 / 10^(_6083 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4382 = mem[64]
                mem[mem[64]] = 2
                _5968 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5968] = 0
                mem[_5968 + 32] = 96
                mem[_5968 + 64] = 96
                mem[_5968 + 96] = 0
                mem[_5968 + 128] = 0
                mem[_5968 + 160] = 0
                mem[_5968 + 192] = 0
                mem[_5968 + 224] = 0
                mem[var210001] = _5968
                s = var210001
                idx = var210002
                while idx - 1:
                    _5968 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5968] = 0
                    mem[_5968 + 32] = 96
                    mem[_5968 + 64] = 96
                    mem[_5968 + 96] = 0
                    mem[_5968 + 128] = 0
                    mem[_5968 + 160] = 0
                    mem[_5968 + 192] = 0
                    mem[_5968 + 224] = 0
                    mem[s + 32] = _5968
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4382]
                mem[_4382 + 32] = _3541
                require 1 < mem[_4382]
                mem[_4382 + 64] = _1779
                _6576 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6576] = 0
                mem[_6576 + 32] = 96
                mem[_6576 + 64] = 96
                mem[_6576 + 96] = 0
                mem[_6576 + 128] = 0
                mem[_6576 + 160] = 0
                mem[_6576 + 192] = 0
                mem[_6576 + 224] = 0
                require 0 < mem[_4382]
                _6880 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6880] = 0
                mem[_6880 + 32] = 96
                mem[_6880 + 64] = 96
                mem[_6880 + 96] = 0
                mem[_6880 + 128] = 0
                mem[_6880 + 160] = 0
                mem[_6880 + 192] = 0
                mem[_6880 + 224] = 0
                require 1 < mem[_4382]
                if mem[_3541 + 96] <= mem[_1779 + 96]:
                    idx = 12
                    s = mem[_3541 + 96]
                    while idx >= 4:
                        if not mem[_3541 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3541 + 96] - idx
                        continue 
                    _13009 = mem[_3541 + 96]
                    _13010 = mem[_3541 + 128]
                    _13115 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13115] = 26
                    mem[_13115 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13009 - s):
                        _13179 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13179 + 68] = mem[idx + _13115 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13179 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13179 + -mem[64] + 100
                    _14865 = mem[_1779 + 96]
                    _14866 = mem[_1779 + 128]
                    _14993 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14993] = 26
                    mem[_14993 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14865 - s):
                        _15099 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15099 + 68] = mem[idx + _14993 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15099 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15099 + -mem[64] + 100
                    if not _14866 / 10^(_14865 - s):
                        _15483 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15483] = 26
                        mem[_15483 + 32] = 'SafeMath: division by zero'
                        if not _13010 / 10^(_13009 - s):
                            _15720 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15720 + 68] = mem[idx + _15483 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15720 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15720 + -mem[64] + 100
                        _16273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16273] = 26
                        mem[_16273 + 32] = 'SafeMath: division by zero'
                        if 0 / _13010 / 10^(_13009 - s):
                            return (1000000 * 10^18 / 0 / _13010 / 10^(_13009 - s))
                        _16489 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16489 + 68] = mem[idx + _16273 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16489 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16489 + -mem[64] + 100
                    if 10^12 * _14866 / 10^(_14865 - s) / _14866 / 10^(_14865 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15719 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15719] = 26
                    mem[_15719 + 32] = 'SafeMath: division by zero'
                    if not _13010 / 10^(_13009 - s):
                        _15889 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15889 + 68] = mem[idx + _15719 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15889 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15889 + -mem[64] + 100
                    _16487 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16487] = 26
                    mem[_16487 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14866 / 10^(_14865 - s) / _13010 / 10^(_13009 - s):
                        return (1000000 * 10^18 / 10^12 * _14866 / 10^(_14865 - s) / _13010 / 10^(_13009 - s))
                    _16657 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16657 + 68] = mem[idx + _16487 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16657 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16657 + -mem[64] + 100
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _13011 = mem[_3541 + 96]
                _13012 = mem[_3541 + 128]
                _13116 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13116] = 26
                mem[_13116 + 32] = 'SafeMath: division by zero'
                if not 10^(_13011 - s):
                    _13180 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13180 + 68] = mem[idx + _13116 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13180 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13180 + -mem[64] + 100
                _14867 = mem[_1779 + 96]
                _14868 = mem[_1779 + 128]
                _14995 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14995] = 26
                mem[_14995 + 32] = 'SafeMath: division by zero'
                if not 10^(_14867 - s):
                    _15100 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15100 + 68] = mem[idx + _14995 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15100 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15100 + -mem[64] + 100
                if not _14868 / 10^(_14867 - s):
                    _15484 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15484] = 26
                    mem[_15484 + 32] = 'SafeMath: division by zero'
                    if not _13012 / 10^(_13011 - s):
                        _15723 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15723 + 68] = mem[idx + _15484 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15723 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15723 + -mem[64] + 100
                    _16275 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16275] = 26
                    mem[_16275 + 32] = 'SafeMath: division by zero'
                    if 0 / _13012 / 10^(_13011 - s):
                        return (1000000 * 10^18 / 0 / _13012 / 10^(_13011 - s))
                    _16492 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16492 + 68] = mem[idx + _16275 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16492 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16492 + -mem[64] + 100
                if 10^12 * _14868 / 10^(_14867 - s) / _14868 / 10^(_14867 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15722 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15722] = 26
                mem[_15722 + 32] = 'SafeMath: division by zero'
                if not _13012 / 10^(_13011 - s):
                    _15891 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15891 + 68] = mem[idx + _15722 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15891 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15891 + -mem[64] + 100
                _16490 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16490] = 26
                mem[_16490 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14868 / 10^(_14867 - s) / _13012 / 10^(_13011 - s):
                    return (1000000 * 10^18 / 10^12 * _14868 / 10^(_14867 - s) / _13012 / 10^(_13011 - s))
                _16659 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16659 + 68] = mem[idx + _16490 + 32]
                    idx = idx + 32
                    continue 
                mem[_16659 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16659 + -mem[64] + 100
            _4222 = mem[64]
            mem[mem[64]] = 2
            _5967 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5967] = 0
            mem[_5967 + 32] = 96
            mem[_5967 + 64] = 96
            mem[_5967 + 96] = 0
            mem[_5967 + 128] = 0
            mem[_5967 + 160] = 0
            mem[_5967 + 192] = 0
            mem[_5967 + 224] = 0
            mem[var206001] = _5967
            s = var206001
            idx = var206002
            while idx - 1:
                _5967 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5967] = 0
                mem[_5967 + 32] = 96
                mem[_5967 + 64] = 96
                mem[_5967 + 96] = 0
                mem[_5967 + 128] = 0
                mem[_5967 + 160] = 0
                mem[_5967 + 192] = 0
                mem[_5967 + 224] = 0
                mem[s + 32] = _5967
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4222]
            mem[_4222 + 32] = _1779
            require 1 < mem[_4222]
            mem[_4222 + 64] = _3541
            _6575 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6575] = 0
            mem[_6575 + 32] = 96
            mem[_6575 + 64] = 96
            mem[_6575 + 96] = 0
            mem[_6575 + 128] = 0
            mem[_6575 + 160] = 0
            mem[_6575 + 192] = 0
            mem[_6575 + 224] = 0
            require 0 < mem[_4222]
            _6879 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6879] = 0
            mem[_6879 + 32] = 96
            mem[_6879 + 64] = 96
            mem[_6879 + 96] = 0
            mem[_6879 + 128] = 0
            mem[_6879 + 160] = 0
            mem[_6879 + 192] = 0
            mem[_6879 + 224] = 0
            require 1 < mem[_4222]
            if mem[_1779 + 96] <= mem[_3541 + 96]:
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _13005 = mem[_1779 + 96]
                _13006 = mem[_1779 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13005 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3541 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3541 + 128] / 10^(mem[_3541 + 96] - s):
                    if not _13006 / 10^(_13005 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13006 / 10^(_13005 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13006 / 10^(_13005 - s))
                if 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13006 / 10^(_13005 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / _13006 / 10^(_13005 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / _13006 / 10^(_13005 - s))
            idx = 12
            s = mem[_3541 + 96]
            while idx >= 4:
                if not mem[_3541 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3541 + 96] - idx
                continue 
            _13007 = mem[_1779 + 96]
            _13008 = mem[_1779 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13007 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3541 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3541 + 128] / 10^(mem[_3541 + 96] - s):
                if not _13008 / 10^(_13007 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13008 / 10^(_13007 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13008 / 10^(_13007 - s))
            if 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13008 / 10^(_13007 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / _13008 / 10^(_13007 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3541 + 128] / 10^(mem[_3541 + 96] - s) / _13008 / 10^(_13007 - s))
        mem[_1815 + ceil32(return_data.size) + _1823 + 32] = 0
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1799))
        staticcall address(_1799).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2634 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2642 = mem[_2634]
        require mem[_2634] <= test266151307()
        require _2634 + return_data.size > _2634 + mem[_2634] + 31
        _2650 = mem[_2634 + mem[_2634]]
        require mem[_2634 + mem[_2634]] <= test266151307()
        require ceil32(mem[_2634 + mem[_2634]]) + 32 >= 0 and _2634 + ceil32(return_data.size) + ceil32(mem[_2634 + mem[_2634]]) + 32 <= test266151307()
        mem[64] = _2634 + ceil32(return_data.size) + ceil32(mem[_2634 + mem[_2634]]) + 32
        mem[_2634 + ceil32(return_data.size)] = _2650
        require _2642 + _2650 + 32 <= return_data.size
        mem[_2634 + ceil32(return_data.size) + 32 len ceil32(_2650)] = mem[_2634 + _2642 + 32 len ceil32(_2650)]
        if ceil32(_2650) <= _2650:
            require ext_code.size(address(_1799))
            staticcall address(_1799).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3432 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3448 = mem[_3432]
            require mem[_3432] == mem[_3432 + 31 len 1]
            require ext_code.size(address(_1799))
            staticcall address(_1799).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3496 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3512 = mem[_3496]
            _3523 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3523] = address(_1799)
            mem[_3523 + 32] = _1815 + ceil32(return_data.size)
            mem[_3523 + 64] = _2634 + ceil32(return_data.size)
            mem[_3523 + 96] = uint8(_3448)
            mem[_3523 + 128] = 0
            mem[_3523 + 160] = _3512
            mem[_3523 + 192] = 0
            mem[_3523 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3576 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3592 = mem[_3576]
            require mem[_3576] == mem[_3576 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3592))
            staticcall address(_3592).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3640 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1779 + 128] = mem[_3640]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3704 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3720 = mem[_3704]
            require mem[_3704] == mem[_3704 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3720))
            staticcall address(_3720).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3768 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3523 + 128] = mem[_3768]
            _3800 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3800] = 0
            mem[_3800 + 32] = 96
            mem[_3800 + 64] = 96
            mem[_3800 + 96] = 0
            mem[_3800 + 128] = 0
            mem[_3800 + 160] = 0
            mem[_3800 + 192] = 0
            mem[_3800 + 224] = 0
            _3816 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3816] = 0
            mem[_3816 + 32] = 96
            mem[_3816 + 64] = 96
            mem[_3816 + 96] = 0
            mem[_3816 + 128] = 0
            mem[_3816 + 160] = 0
            mem[_3816 + 192] = 0
            mem[_3816 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3859 = mem[64]
                mem[mem[64]] = 2
                _4928 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4928] = 0
                mem[_4928 + 32] = 96
                mem[_4928 + 64] = 96
                mem[_4928 + 96] = 0
                mem[_4928 + 128] = 0
                mem[_4928 + 160] = 0
                mem[_4928 + 192] = 0
                mem[_4928 + 224] = 0
                mem[var191001] = _4928
                s = var191001
                idx = var191002
                while idx - 1:
                    _4928 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4928] = 0
                    mem[_4928 + 32] = 96
                    mem[_4928 + 64] = 96
                    mem[_4928 + 96] = 0
                    mem[_4928 + 128] = 0
                    mem[_4928 + 160] = 0
                    mem[_4928 + 192] = 0
                    mem[_4928 + 224] = 0
                    mem[s + 32] = _4928
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3859]
                mem[_3859 + 32] = _3523
                require 1 < mem[_3859]
                mem[_3859 + 64] = _1779
                _5216 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5216] = 0
                mem[_5216 + 32] = 96
                mem[_5216 + 64] = 96
                mem[_5216 + 96] = 0
                mem[_5216 + 128] = 0
                mem[_5216 + 160] = 0
                mem[_5216 + 192] = 0
                mem[_5216 + 224] = 0
                require 0 < mem[_3859]
                _5486 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5486] = 0
                mem[_5486 + 32] = 96
                mem[_5486 + 64] = 96
                mem[_5486 + 96] = 0
                mem[_5486 + 128] = 0
                mem[_5486 + 160] = 0
                mem[_5486 + 192] = 0
                mem[_5486 + 224] = 0
                require 1 < mem[_3859]
                if mem[_3523 + 96] <= mem[_1779 + 96]:
                    idx = 12
                    s = mem[_3523 + 96]
                    while idx >= 4:
                        if not mem[_3523 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3523 + 96] - idx
                        continue 
                    _6111 = mem[_3523 + 96]
                    _6112 = mem[_3523 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6111 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6112 / 10^(_6111 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6112 / 10^(_6111 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6112 / 10^(_6111 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6112 / 10^(_6111 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6112 / 10^(_6111 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6112 / 10^(_6111 - s))
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _6113 = mem[_3523 + 96]
                _6114 = mem[_3523 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6113 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6114 / 10^(_6113 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6114 / 10^(_6113 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6114 / 10^(_6113 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6114 / 10^(_6113 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6114 / 10^(_6113 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6114 / 10^(_6113 - s))
            if wbnbAddress == address(_1799):
                _3907 = mem[64]
                mem[mem[64]] = 2
                _4927 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4927] = 0
                mem[_4927 + 32] = 96
                mem[_4927 + 64] = 96
                mem[_4927 + 96] = 0
                mem[_4927 + 128] = 0
                mem[_4927 + 160] = 0
                mem[_4927 + 192] = 0
                mem[_4927 + 224] = 0
                mem[var195001] = _4927
                s = var195001
                idx = var195002
                while idx - 1:
                    _4927 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4927] = 0
                    mem[_4927 + 32] = 96
                    mem[_4927 + 64] = 96
                    mem[_4927 + 96] = 0
                    mem[_4927 + 128] = 0
                    mem[_4927 + 160] = 0
                    mem[_4927 + 192] = 0
                    mem[_4927 + 224] = 0
                    mem[s + 32] = _4927
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3907]
                mem[_3907 + 32] = _1779
                require 1 < mem[_3907]
                mem[_3907 + 64] = _3523
                _5215 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5215] = 0
                mem[_5215 + 32] = 96
                mem[_5215 + 64] = 96
                mem[_5215 + 96] = 0
                mem[_5215 + 128] = 0
                mem[_5215 + 160] = 0
                mem[_5215 + 192] = 0
                mem[_5215 + 224] = 0
                require 0 < mem[_3907]
                _5485 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5485] = 0
                mem[_5485 + 32] = 96
                mem[_5485 + 64] = 96
                mem[_5485 + 96] = 0
                mem[_5485 + 128] = 0
                mem[_5485 + 160] = 0
                mem[_5485 + 192] = 0
                mem[_5485 + 224] = 0
                require 1 < mem[_3907]
                if mem[_1779 + 96] <= mem[_3523 + 96]:
                    idx = 12
                    s = mem[_1779 + 96]
                    while idx >= 4:
                        if not mem[_1779 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1779 + 96] - idx
                        continue 
                    _6107 = mem[_1779 + 96]
                    _6108 = mem[_1779 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6107 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3523 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3523 + 128] / 10^(mem[_3523 + 96] - s):
                        if not _6108 / 10^(_6107 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6108 / 10^(_6107 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6108 / 10^(_6107 - s))
                    if 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6108 / 10^(_6107 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / _6108 / 10^(_6107 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / _6108 / 10^(_6107 - s))
                idx = 12
                s = mem[_3523 + 96]
                while idx >= 4:
                    if not mem[_3523 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3523 + 96] - idx
                    continue 
                _6109 = mem[_1779 + 96]
                _6110 = mem[_1779 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6109 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3523 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3523 + 128] / 10^(mem[_3523 + 96] - s):
                    if not _6110 / 10^(_6109 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6110 / 10^(_6109 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6110 / 10^(_6109 - s))
                if 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6110 / 10^(_6109 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / _6110 / 10^(_6109 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / _6110 / 10^(_6109 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3950 = mem[64]
                mem[mem[64]] = 2
                _4926 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4926] = 0
                mem[_4926 + 32] = 96
                mem[_4926 + 64] = 96
                mem[_4926 + 96] = 0
                mem[_4926 + 128] = 0
                mem[_4926 + 160] = 0
                mem[_4926 + 192] = 0
                mem[_4926 + 224] = 0
                mem[var198001] = _4926
                s = var198001
                idx = var198002
                while idx - 1:
                    _4926 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4926] = 0
                    mem[_4926 + 32] = 96
                    mem[_4926 + 64] = 96
                    mem[_4926 + 96] = 0
                    mem[_4926 + 128] = 0
                    mem[_4926 + 160] = 0
                    mem[_4926 + 192] = 0
                    mem[_4926 + 224] = 0
                    mem[s + 32] = _4926
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3950]
                mem[_3950 + 32] = _3523
                require 1 < mem[_3950]
                mem[_3950 + 64] = _1779
                _5214 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5214] = 0
                mem[_5214 + 32] = 96
                mem[_5214 + 64] = 96
                mem[_5214 + 96] = 0
                mem[_5214 + 128] = 0
                mem[_5214 + 160] = 0
                mem[_5214 + 192] = 0
                mem[_5214 + 224] = 0
                require 0 < mem[_3950]
                _5484 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5484] = 0
                mem[_5484 + 32] = 96
                mem[_5484 + 64] = 96
                mem[_5484 + 96] = 0
                mem[_5484 + 128] = 0
                mem[_5484 + 160] = 0
                mem[_5484 + 192] = 0
                mem[_5484 + 224] = 0
                require 1 < mem[_3950]
                if mem[_3523 + 96] <= mem[_1779 + 96]:
                    idx = 12
                    s = mem[_3523 + 96]
                    while idx >= 4:
                        if not mem[_3523 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3523 + 96] - idx
                        continue 
                    _6103 = mem[_3523 + 96]
                    _6104 = mem[_3523 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6103 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6104 / 10^(_6103 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6104 / 10^(_6103 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6104 / 10^(_6103 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6104 / 10^(_6103 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6104 / 10^(_6103 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6104 / 10^(_6103 - s))
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _6105 = mem[_3523 + 96]
                _6106 = mem[_3523 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6105 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6106 / 10^(_6105 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6106 / 10^(_6105 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6106 / 10^(_6105 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6106 / 10^(_6105 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6106 / 10^(_6105 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6106 / 10^(_6105 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _3998 = mem[64]
                mem[mem[64]] = 2
                _4925 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4925] = 0
                mem[_4925 + 32] = 96
                mem[_4925 + 64] = 96
                mem[_4925 + 96] = 0
                mem[_4925 + 128] = 0
                mem[_4925 + 160] = 0
                mem[_4925 + 192] = 0
                mem[_4925 + 224] = 0
                mem[var201001] = _4925
                s = var201001
                idx = var201002
                while idx - 1:
                    _4925 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4925] = 0
                    mem[_4925 + 32] = 96
                    mem[_4925 + 64] = 96
                    mem[_4925 + 96] = 0
                    mem[_4925 + 128] = 0
                    mem[_4925 + 160] = 0
                    mem[_4925 + 192] = 0
                    mem[_4925 + 224] = 0
                    mem[s + 32] = _4925
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3998]
                mem[_3998 + 32] = _3523
                require 1 < mem[_3998]
                mem[_3998 + 64] = _1779
                _5213 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5213] = 0
                mem[_5213 + 32] = 96
                mem[_5213 + 64] = 96
                mem[_5213 + 96] = 0
                mem[_5213 + 128] = 0
                mem[_5213 + 160] = 0
                mem[_5213 + 192] = 0
                mem[_5213 + 224] = 0
                require 0 < mem[_3998]
                _5483 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5483] = 0
                mem[_5483 + 32] = 96
                mem[_5483 + 64] = 96
                mem[_5483 + 96] = 0
                mem[_5483 + 128] = 0
                mem[_5483 + 160] = 0
                mem[_5483 + 192] = 0
                mem[_5483 + 224] = 0
                require 1 < mem[_3998]
                if mem[_3523 + 96] <= mem[_1779 + 96]:
                    idx = 12
                    s = mem[_3523 + 96]
                    while idx >= 4:
                        if not mem[_3523 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3523 + 96] - idx
                        continue 
                    _6099 = mem[_3523 + 96]
                    _6100 = mem[_3523 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6099 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1779 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                        if not _6100 / 10^(_6099 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6100 / 10^(_6099 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6100 / 10^(_6099 - s))
                    if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6100 / 10^(_6099 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6100 / 10^(_6099 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6100 / 10^(_6099 - s))
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _6101 = mem[_3523 + 96]
                _6102 = mem[_3523 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6101 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6102 / 10^(_6101 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6102 / 10^(_6101 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6102 / 10^(_6101 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6102 / 10^(_6101 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6102 / 10^(_6101 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6102 / 10^(_6101 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4387 = mem[64]
                mem[mem[64]] = 2
                _5970 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5970] = 0
                mem[_5970 + 32] = 96
                mem[_5970 + 64] = 96
                mem[_5970 + 96] = 0
                mem[_5970 + 128] = 0
                mem[_5970 + 160] = 0
                mem[_5970 + 192] = 0
                mem[_5970 + 224] = 0
                mem[var210001] = _5970
                s = var210001
                idx = var210002
                while idx - 1:
                    _5970 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5970] = 0
                    mem[_5970 + 32] = 96
                    mem[_5970 + 64] = 96
                    mem[_5970 + 96] = 0
                    mem[_5970 + 128] = 0
                    mem[_5970 + 160] = 0
                    mem[_5970 + 192] = 0
                    mem[_5970 + 224] = 0
                    mem[s + 32] = _5970
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4387]
                mem[_4387 + 32] = _3523
                require 1 < mem[_4387]
                mem[_4387 + 64] = _1779
                _6578 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6578] = 0
                mem[_6578 + 32] = 96
                mem[_6578 + 64] = 96
                mem[_6578 + 96] = 0
                mem[_6578 + 128] = 0
                mem[_6578 + 160] = 0
                mem[_6578 + 192] = 0
                mem[_6578 + 224] = 0
                require 0 < mem[_4387]
                _6898 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6898] = 0
                mem[_6898 + 32] = 96
                mem[_6898 + 64] = 96
                mem[_6898 + 96] = 0
                mem[_6898 + 128] = 0
                mem[_6898 + 160] = 0
                mem[_6898 + 192] = 0
                mem[_6898 + 224] = 0
                require 1 < mem[_4387]
                if mem[_3523 + 96] <= mem[_1779 + 96]:
                    idx = 12
                    s = mem[_3523 + 96]
                    while idx >= 4:
                        if not mem[_3523 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3523 + 96] - idx
                        continue 
                    _13017 = mem[_3523 + 96]
                    _13018 = mem[_3523 + 128]
                    _13119 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13119] = 26
                    mem[_13119 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13017 - s):
                        _13183 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13183 + 68] = mem[idx + _13119 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13183 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13183 + -mem[64] + 100
                    _14873 = mem[_1779 + 96]
                    _14874 = mem[_1779 + 128]
                    _15001 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15001] = 26
                    mem[_15001 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14873 - s):
                        _15103 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15103 + 68] = mem[idx + _15001 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15103 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15103 + -mem[64] + 100
                    if not _14874 / 10^(_14873 - s):
                        _15487 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15487] = 26
                        mem[_15487 + 32] = 'SafeMath: division by zero'
                        if not _13018 / 10^(_13017 - s):
                            _15732 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15732 + 68] = mem[idx + _15487 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15732 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15732 + -mem[64] + 100
                        _16281 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16281] = 26
                        mem[_16281 + 32] = 'SafeMath: division by zero'
                        if 0 / _13018 / 10^(_13017 - s):
                            return (1000000 * 10^18 / 0 / _13018 / 10^(_13017 - s))
                        _16501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16501 + 68] = mem[idx + _16281 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16501 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16501 + -mem[64] + 100
                    if 10^12 * _14874 / 10^(_14873 - s) / _14874 / 10^(_14873 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15731 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15731] = 26
                    mem[_15731 + 32] = 'SafeMath: division by zero'
                    if not _13018 / 10^(_13017 - s):
                        _15897 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15897 + 68] = mem[idx + _15731 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15897 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15897 + -mem[64] + 100
                    _16499 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16499] = 26
                    mem[_16499 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14874 / 10^(_14873 - s) / _13018 / 10^(_13017 - s):
                        return (1000000 * 10^18 / 10^12 * _14874 / 10^(_14873 - s) / _13018 / 10^(_13017 - s))
                    _16665 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16665 + 68] = mem[idx + _16499 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16665 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16665 + -mem[64] + 100
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _13019 = mem[_3523 + 96]
                _13020 = mem[_3523 + 128]
                _13120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13120] = 26
                mem[_13120 + 32] = 'SafeMath: division by zero'
                if not 10^(_13019 - s):
                    _13184 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13184 + 68] = mem[idx + _13120 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13184 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13184 + -mem[64] + 100
                _14875 = mem[_1779 + 96]
                _14876 = mem[_1779 + 128]
                _15003 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15003] = 26
                mem[_15003 + 32] = 'SafeMath: division by zero'
                if not 10^(_14875 - s):
                    _15104 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15104 + 68] = mem[idx + _15003 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15104 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15104 + -mem[64] + 100
                if not _14876 / 10^(_14875 - s):
                    _15488 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15488] = 26
                    mem[_15488 + 32] = 'SafeMath: division by zero'
                    if not _13020 / 10^(_13019 - s):
                        _15735 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15735 + 68] = mem[idx + _15488 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15735 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15735 + -mem[64] + 100
                    _16283 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16283] = 26
                    mem[_16283 + 32] = 'SafeMath: division by zero'
                    if 0 / _13020 / 10^(_13019 - s):
                        return (1000000 * 10^18 / 0 / _13020 / 10^(_13019 - s))
                    _16504 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16504 + 68] = mem[idx + _16283 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16504 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16504 + -mem[64] + 100
                if 10^12 * _14876 / 10^(_14875 - s) / _14876 / 10^(_14875 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15734 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15734] = 26
                mem[_15734 + 32] = 'SafeMath: division by zero'
                if not _13020 / 10^(_13019 - s):
                    _15899 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15899 + 68] = mem[idx + _15734 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15899 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15899 + -mem[64] + 100
                _16502 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16502] = 26
                mem[_16502 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14876 / 10^(_14875 - s) / _13020 / 10^(_13019 - s):
                    return (1000000 * 10^18 / 10^12 * _14876 / 10^(_14875 - s) / _13020 / 10^(_13019 - s))
                _16667 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16667 + 68] = mem[idx + _16502 + 32]
                    idx = idx + 32
                    continue 
                mem[_16667 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16667 + -mem[64] + 100
            _4227 = mem[64]
            mem[mem[64]] = 2
            _5969 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5969] = 0
            mem[_5969 + 32] = 96
            mem[_5969 + 64] = 96
            mem[_5969 + 96] = 0
            mem[_5969 + 128] = 0
            mem[_5969 + 160] = 0
            mem[_5969 + 192] = 0
            mem[_5969 + 224] = 0
            mem[var206001] = _5969
            s = var206001
            idx = var206002
            while idx - 1:
                _5969 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5969] = 0
                mem[_5969 + 32] = 96
                mem[_5969 + 64] = 96
                mem[_5969 + 96] = 0
                mem[_5969 + 128] = 0
                mem[_5969 + 160] = 0
                mem[_5969 + 192] = 0
                mem[_5969 + 224] = 0
                mem[s + 32] = _5969
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4227]
            mem[_4227 + 32] = _1779
            require 1 < mem[_4227]
            mem[_4227 + 64] = _3523
            _6577 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6577] = 0
            mem[_6577 + 32] = 96
            mem[_6577 + 64] = 96
            mem[_6577 + 96] = 0
            mem[_6577 + 128] = 0
            mem[_6577 + 160] = 0
            mem[_6577 + 192] = 0
            mem[_6577 + 224] = 0
            require 0 < mem[_4227]
            _6897 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6897] = 0
            mem[_6897 + 32] = 96
            mem[_6897 + 64] = 96
            mem[_6897 + 96] = 0
            mem[_6897 + 128] = 0
            mem[_6897 + 160] = 0
            mem[_6897 + 192] = 0
            mem[_6897 + 224] = 0
            require 1 < mem[_4227]
            if mem[_1779 + 96] <= mem[_3523 + 96]:
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _13013 = mem[_1779 + 96]
                _13014 = mem[_1779 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13013 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3523 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3523 + 128] / 10^(mem[_3523 + 96] - s):
                    if not _13014 / 10^(_13013 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13014 / 10^(_13013 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13014 / 10^(_13013 - s))
                if 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13014 / 10^(_13013 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / _13014 / 10^(_13013 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / _13014 / 10^(_13013 - s))
            idx = 12
            s = mem[_3523 + 96]
            while idx >= 4:
                if not mem[_3523 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3523 + 96] - idx
                continue 
            _13015 = mem[_1779 + 96]
            _13016 = mem[_1779 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13015 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3523 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3523 + 128] / 10^(mem[_3523 + 96] - s):
                if not _13016 / 10^(_13015 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13016 / 10^(_13015 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13016 / 10^(_13015 - s))
            if 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13016 / 10^(_13015 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / _13016 / 10^(_13015 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3523 + 128] / 10^(mem[_3523 + 96] - s) / _13016 / 10^(_13015 - s))
        mem[_2634 + ceil32(return_data.size) + _2650 + 32] = 0
        require ext_code.size(address(_1799))
        staticcall address(_1799).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3440 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3456 = mem[_3440]
        require mem[_3440] == mem[_3440 + 31 len 1]
        require ext_code.size(address(_1799))
        staticcall address(_1799).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3504 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3524 = mem[_3504]
        _3544 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3544] = address(_1799)
        mem[_3544 + 32] = _1815 + ceil32(return_data.size)
        mem[_3544 + 64] = _2634 + ceil32(return_data.size)
        mem[_3544 + 96] = uint8(_3456)
        mem[_3544 + 128] = 0
        mem[_3544 + 160] = _3524
        mem[_3544 + 192] = 0
        mem[_3544 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3584 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3600 = mem[_3584]
        require mem[_3584] == mem[_3584 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3600))
        staticcall address(_3600).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3648 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_1779 + 128] = mem[_3648]
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3712 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3728 = mem[_3712]
        require mem[_3712] == mem[_3712 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3728))
        staticcall address(_3728).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3776 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_3544 + 128] = mem[_3776]
        _3808 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3808] = 0
        mem[_3808 + 32] = 96
        mem[_3808 + 64] = 96
        mem[_3808 + 96] = 0
        mem[_3808 + 128] = 0
        mem[_3808 + 160] = 0
        mem[_3808 + 192] = 0
        mem[_3808 + 224] = 0
        _3828 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3828] = 0
        mem[_3828 + 32] = 96
        mem[_3828 + 64] = 96
        mem[_3828 + 96] = 0
        mem[_3828 + 128] = 0
        mem[_3828 + 160] = 0
        mem[_3828 + 192] = 0
        mem[_3828 + 224] = 0
        if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
            _3872 = mem[64]
            mem[mem[64]] = 2
            _4932 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4932] = 0
            mem[_4932 + 32] = 96
            mem[_4932 + 64] = 96
            mem[_4932 + 96] = 0
            mem[_4932 + 128] = 0
            mem[_4932 + 160] = 0
            mem[_4932 + 192] = 0
            mem[_4932 + 224] = 0
            mem[var192001] = _4932
            s = var192001
            idx = var192002
            while idx - 1:
                _4932 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4932] = 0
                mem[_4932 + 32] = 96
                mem[_4932 + 64] = 96
                mem[_4932 + 96] = 0
                mem[_4932 + 128] = 0
                mem[_4932 + 160] = 0
                mem[_4932 + 192] = 0
                mem[_4932 + 224] = 0
                mem[s + 32] = _4932
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3872]
            mem[_3872 + 32] = _3544
            require 1 < mem[_3872]
            mem[_3872 + 64] = _1779
            _5220 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5220] = 0
            mem[_5220 + 32] = 96
            mem[_5220 + 64] = 96
            mem[_5220 + 96] = 0
            mem[_5220 + 128] = 0
            mem[_5220 + 160] = 0
            mem[_5220 + 192] = 0
            mem[_5220 + 224] = 0
            require 0 < mem[_3872]
            _5492 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5492] = 0
            mem[_5492 + 32] = 96
            mem[_5492 + 64] = 96
            mem[_5492 + 96] = 0
            mem[_5492 + 128] = 0
            mem[_5492 + 160] = 0
            mem[_5492 + 192] = 0
            mem[_5492 + 224] = 0
            require 1 < mem[_3872]
            if mem[_3544 + 96] <= mem[_1779 + 96]:
                idx = 12
                s = mem[_3544 + 96]
                while idx >= 4:
                    if not mem[_3544 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3544 + 96] - idx
                    continue 
                _6129 = mem[_3544 + 96]
                _6130 = mem[_3544 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6129 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6130 / 10^(_6129 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6130 / 10^(_6129 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6130 / 10^(_6129 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6130 / 10^(_6129 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6130 / 10^(_6129 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6130 / 10^(_6129 - s))
            idx = 12
            s = mem[_1779 + 96]
            while idx >= 4:
                if not mem[_1779 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1779 + 96] - idx
                continue 
            _6131 = mem[_3544 + 96]
            _6132 = mem[_3544 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6131 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1779 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                if not _6132 / 10^(_6131 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6132 / 10^(_6131 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6132 / 10^(_6131 - s))
            if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6132 / 10^(_6131 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6132 / 10^(_6131 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6132 / 10^(_6131 - s))
        if wbnbAddress == address(_1799):
            _3920 = mem[64]
            mem[mem[64]] = 2
            _4931 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4931] = 0
            mem[_4931 + 32] = 96
            mem[_4931 + 64] = 96
            mem[_4931 + 96] = 0
            mem[_4931 + 128] = 0
            mem[_4931 + 160] = 0
            mem[_4931 + 192] = 0
            mem[_4931 + 224] = 0
            mem[var196001] = _4931
            s = var196001
            idx = var196002
            while idx - 1:
                _4931 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4931] = 0
                mem[_4931 + 32] = 96
                mem[_4931 + 64] = 96
                mem[_4931 + 96] = 0
                mem[_4931 + 128] = 0
                mem[_4931 + 160] = 0
                mem[_4931 + 192] = 0
                mem[_4931 + 224] = 0
                mem[s + 32] = _4931
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3920]
            mem[_3920 + 32] = _1779
            require 1 < mem[_3920]
            mem[_3920 + 64] = _3544
            _5219 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5219] = 0
            mem[_5219 + 32] = 96
            mem[_5219 + 64] = 96
            mem[_5219 + 96] = 0
            mem[_5219 + 128] = 0
            mem[_5219 + 160] = 0
            mem[_5219 + 192] = 0
            mem[_5219 + 224] = 0
            require 0 < mem[_3920]
            _5491 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5491] = 0
            mem[_5491 + 32] = 96
            mem[_5491 + 64] = 96
            mem[_5491 + 96] = 0
            mem[_5491 + 128] = 0
            mem[_5491 + 160] = 0
            mem[_5491 + 192] = 0
            mem[_5491 + 224] = 0
            require 1 < mem[_3920]
            if mem[_1779 + 96] <= mem[_3544 + 96]:
                idx = 12
                s = mem[_1779 + 96]
                while idx >= 4:
                    if not mem[_1779 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1779 + 96] - idx
                    continue 
                _6125 = mem[_1779 + 96]
                _6126 = mem[_1779 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6125 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3544 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3544 + 128] / 10^(mem[_3544 + 96] - s):
                    if not _6126 / 10^(_6125 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6126 / 10^(_6125 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6126 / 10^(_6125 - s))
                if 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6126 / 10^(_6125 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / _6126 / 10^(_6125 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / _6126 / 10^(_6125 - s))
            idx = 12
            s = mem[_3544 + 96]
            while idx >= 4:
                if not mem[_3544 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3544 + 96] - idx
                continue 
            _6127 = mem[_1779 + 96]
            _6128 = mem[_1779 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6127 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3544 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3544 + 128] / 10^(mem[_3544 + 96] - s):
                if not _6128 / 10^(_6127 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6128 / 10^(_6127 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6128 / 10^(_6127 - s))
            if 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6128 / 10^(_6127 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / _6128 / 10^(_6127 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / _6128 / 10^(_6127 - s))
        if busdAddress == uint64(ext_call.return_data[0]) << 96:
            _3968 = mem[64]
            mem[mem[64]] = 2
            _4930 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4930] = 0
            mem[_4930 + 32] = 96
            mem[_4930 + 64] = 96
            mem[_4930 + 96] = 0
            mem[_4930 + 128] = 0
            mem[_4930 + 160] = 0
            mem[_4930 + 192] = 0
            mem[_4930 + 224] = 0
            mem[var199001] = _4930
            s = var199001
            idx = var199002
            while idx - 1:
                _4930 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4930] = 0
                mem[_4930 + 32] = 96
                mem[_4930 + 64] = 96
                mem[_4930 + 96] = 0
                mem[_4930 + 128] = 0
                mem[_4930 + 160] = 0
                mem[_4930 + 192] = 0
                mem[_4930 + 224] = 0
                mem[s + 32] = _4930
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3968]
            mem[_3968 + 32] = _3544
            require 1 < mem[_3968]
            mem[_3968 + 64] = _1779
            _5218 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5218] = 0
            mem[_5218 + 32] = 96
            mem[_5218 + 64] = 96
            mem[_5218 + 96] = 0
            mem[_5218 + 128] = 0
            mem[_5218 + 160] = 0
            mem[_5218 + 192] = 0
            mem[_5218 + 224] = 0
            require 0 < mem[_3968]
            _5490 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5490] = 0
            mem[_5490 + 32] = 96
            mem[_5490 + 64] = 96
            mem[_5490 + 96] = 0
            mem[_5490 + 128] = 0
            mem[_5490 + 160] = 0
            mem[_5490 + 192] = 0
            mem[_5490 + 224] = 0
            require 1 < mem[_3968]
            if mem[_3544 + 96] <= mem[_1779 + 96]:
                idx = 12
                s = mem[_3544 + 96]
                while idx >= 4:
                    if not mem[_3544 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3544 + 96] - idx
                    continue 
                _6121 = mem[_3544 + 96]
                _6122 = mem[_3544 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6121 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6122 / 10^(_6121 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6122 / 10^(_6121 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6122 / 10^(_6121 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6122 / 10^(_6121 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6122 / 10^(_6121 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6122 / 10^(_6121 - s))
            idx = 12
            s = mem[_1779 + 96]
            while idx >= 4:
                if not mem[_1779 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1779 + 96] - idx
                continue 
            _6123 = mem[_3544 + 96]
            _6124 = mem[_3544 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6123 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1779 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                if not _6124 / 10^(_6123 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6124 / 10^(_6123 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6124 / 10^(_6123 - s))
            if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6124 / 10^(_6123 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6124 / 10^(_6123 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6124 / 10^(_6123 - s))
        if usdtAddress == uint64(ext_call.return_data[0]) << 96:
            _4016 = mem[64]
            mem[mem[64]] = 2
            _4929 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4929] = 0
            mem[_4929 + 32] = 96
            mem[_4929 + 64] = 96
            mem[_4929 + 96] = 0
            mem[_4929 + 128] = 0
            mem[_4929 + 160] = 0
            mem[_4929 + 192] = 0
            mem[_4929 + 224] = 0
            mem[var202001] = _4929
            s = var202001
            idx = var202002
            while idx - 1:
                _4929 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4929] = 0
                mem[_4929 + 32] = 96
                mem[_4929 + 64] = 96
                mem[_4929 + 96] = 0
                mem[_4929 + 128] = 0
                mem[_4929 + 160] = 0
                mem[_4929 + 192] = 0
                mem[_4929 + 224] = 0
                mem[s + 32] = _4929
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4016]
            mem[_4016 + 32] = _3544
            require 1 < mem[_4016]
            mem[_4016 + 64] = _1779
            _5217 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5217] = 0
            mem[_5217 + 32] = 96
            mem[_5217 + 64] = 96
            mem[_5217 + 96] = 0
            mem[_5217 + 128] = 0
            mem[_5217 + 160] = 0
            mem[_5217 + 192] = 0
            mem[_5217 + 224] = 0
            require 0 < mem[_4016]
            _5489 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5489] = 0
            mem[_5489 + 32] = 96
            mem[_5489 + 64] = 96
            mem[_5489 + 96] = 0
            mem[_5489 + 128] = 0
            mem[_5489 + 160] = 0
            mem[_5489 + 192] = 0
            mem[_5489 + 224] = 0
            require 1 < mem[_4016]
            if mem[_3544 + 96] <= mem[_1779 + 96]:
                idx = 12
                s = mem[_3544 + 96]
                while idx >= 4:
                    if not mem[_3544 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3544 + 96] - idx
                    continue 
                _6117 = mem[_3544 + 96]
                _6118 = mem[_3544 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6117 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1779 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                    if not _6118 / 10^(_6117 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6118 / 10^(_6117 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6118 / 10^(_6117 - s))
                if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6118 / 10^(_6117 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6118 / 10^(_6117 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6118 / 10^(_6117 - s))
            idx = 12
            s = mem[_1779 + 96]
            while idx >= 4:
                if not mem[_1779 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1779 + 96] - idx
                continue 
            _6119 = mem[_3544 + 96]
            _6120 = mem[_3544 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6119 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1779 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1779 + 128] / 10^(mem[_1779 + 96] - s):
                if not _6120 / 10^(_6119 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6120 / 10^(_6119 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6120 / 10^(_6119 - s))
            if 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6120 / 10^(_6119 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6120 / 10^(_6119 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1779 + 128] / 10^(mem[_1779 + 96] - s) / _6120 / 10^(_6119 - s))
        idx = 0
        while idx < sub_27d312da.length:
            mem[0] = 1
            if sub_27d312da[idx] != address(ext_call.return_data[0]):
                idx = idx + 1
                continue 
            _4392 = mem[64]
            mem[mem[64]] = 2
            _5972 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5972] = 0
            mem[_5972 + 32] = 96
            mem[_5972 + 64] = 96
            mem[_5972 + 96] = 0
            mem[_5972 + 128] = 0
            mem[_5972 + 160] = 0
            mem[_5972 + 192] = 0
            mem[_5972 + 224] = 0
            mem[var211001] = _5972
            s = var211001
            idx = var211002
            while idx - 1:
                _5972 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5972] = 0
                mem[_5972 + 32] = 96
                mem[_5972 + 64] = 96
                mem[_5972 + 96] = 0
                mem[_5972 + 128] = 0
                mem[_5972 + 160] = 0
                mem[_5972 + 192] = 0
                mem[_5972 + 224] = 0
                mem[s + 32] = _5972
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4392]
            mem[_4392 + 32] = _3544
            require 1 < mem[_4392]
            mem[_4392 + 64] = _1779
            _6580 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6580] = 0
            mem[_6580 + 32] = 96
            mem[_6580 + 64] = 96
            mem[_6580 + 96] = 0
            mem[_6580 + 128] = 0
            mem[_6580 + 160] = 0
            mem[_6580 + 192] = 0
            mem[_6580 + 224] = 0
            require 0 < mem[_4392]
            _6916 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6916] = 0
            mem[_6916 + 32] = 96
            mem[_6916 + 64] = 96
            mem[_6916 + 96] = 0
            mem[_6916 + 128] = 0
            mem[_6916 + 160] = 0
            mem[_6916 + 192] = 0
            mem[_6916 + 224] = 0
            require 1 < mem[_4392]
            if mem[_3544 + 96] <= mem[_1779 + 96]:
                idx = 12
                s = mem[_3544 + 96]
                while idx >= 4:
                    if not mem[_3544 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3544 + 96] - idx
                    continue 
                _13025 = mem[_3544 + 96]
                _13026 = mem[_3544 + 128]
                _13123 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13123] = 26
                mem[_13123 + 32] = 'SafeMath: division by zero'
                if not 10^(_13025 - s):
                    _13187 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13187 + 68] = mem[idx + _13123 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13187 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13187 + -mem[64] + 100
                _14881 = mem[_1779 + 96]
                _14882 = mem[_1779 + 128]
                _15009 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15009] = 26
                mem[_15009 + 32] = 'SafeMath: division by zero'
                if not 10^(_14881 - s):
                    _15107 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15107 + 68] = mem[idx + _15009 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15107 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15107 + -mem[64] + 100
                if not _14882 / 10^(_14881 - s):
                    _15491 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15491] = 26
                    mem[_15491 + 32] = 'SafeMath: division by zero'
                    if not _13026 / 10^(_13025 - s):
                        _15744 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15744 + 68] = mem[idx + _15491 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15744 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15744 + -mem[64] + 100
                    _16289 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16289] = 26
                    mem[_16289 + 32] = 'SafeMath: division by zero'
                    if 0 / _13026 / 10^(_13025 - s):
                        return (1000000 * 10^18 / 0 / _13026 / 10^(_13025 - s))
                    _16513 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16513 + 68] = mem[idx + _16289 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16513 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16513 + -mem[64] + 100
                if 10^12 * _14882 / 10^(_14881 - s) / _14882 / 10^(_14881 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15743 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15743] = 26
                mem[_15743 + 32] = 'SafeMath: division by zero'
                if not _13026 / 10^(_13025 - s):
                    _15905 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15905 + 68] = mem[idx + _15743 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15905 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15905 + -mem[64] + 100
                _16511 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16511] = 26
                mem[_16511 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14882 / 10^(_14881 - s) / _13026 / 10^(_13025 - s):
                    return (1000000 * 10^18 / 10^12 * _14882 / 10^(_14881 - s) / _13026 / 10^(_13025 - s))
                _16673 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16673 + 68] = mem[idx + _16511 + 32]
                    idx = idx + 32
                    continue 
                mem[_16673 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16673 + -mem[64] + 100
            idx = 12
            s = mem[_1779 + 96]
            while idx >= 4:
                if not mem[_1779 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1779 + 96] - idx
                continue 
            _13027 = mem[_3544 + 96]
            _13028 = mem[_3544 + 128]
            _13124 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13124] = 26
            mem[_13124 + 32] = 'SafeMath: division by zero'
            if not 10^(_13027 - s):
                _13188 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13188 + 68] = mem[idx + _13124 + 32]
                    idx = idx + 32
                    continue 
                mem[_13188 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13188 + -mem[64] + 100
            _14883 = mem[_1779 + 96]
            _14884 = mem[_1779 + 128]
            _15011 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15011] = 26
            mem[_15011 + 32] = 'SafeMath: division by zero'
            if not 10^(_14883 - s):
                _15108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15108 + 68] = mem[idx + _15011 + 32]
                    idx = idx + 32
                    continue 
                mem[_15108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15108 + -mem[64] + 100
            if not _14884 / 10^(_14883 - s):
                _15492 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15492] = 26
                mem[_15492 + 32] = 'SafeMath: division by zero'
                if not _13028 / 10^(_13027 - s):
                    _15747 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15747 + 68] = mem[idx + _15492 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15747 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15747 + -mem[64] + 100
                _16291 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16291] = 26
                mem[_16291 + 32] = 'SafeMath: division by zero'
                if 0 / _13028 / 10^(_13027 - s):
                    return (1000000 * 10^18 / 0 / _13028 / 10^(_13027 - s))
                _16516 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16516 + 68] = mem[idx + _16291 + 32]
                    idx = idx + 32
                    continue 
                mem[_16516 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16516 + -mem[64] + 100
            if 10^12 * _14884 / 10^(_14883 - s) / _14884 / 10^(_14883 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15746 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15746] = 26
            mem[_15746 + 32] = 'SafeMath: division by zero'
            if not _13028 / 10^(_13027 - s):
                _15907 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15907 + 68] = mem[idx + _15746 + 32]
                    idx = idx + 32
                    continue 
                mem[_15907 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15907 + -mem[64] + 100
            _16514 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16514] = 26
            mem[_16514 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14884 / 10^(_14883 - s) / _13028 / 10^(_13027 - s):
                return (1000000 * 10^18 / 10^12 * _14884 / 10^(_14883 - s) / _13028 / 10^(_13027 - s))
            _16675 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16675 + 68] = mem[idx + _16514 + 32]
                idx = idx + 32
                continue 
            mem[_16675 + 94] = 0
            revert with memory
              from mem[64]
               len _16675 + -mem[64] + 100
        _4232 = mem[64]
        mem[mem[64]] = 2
        _5971 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_5971] = 0
        mem[_5971 + 32] = 96
        mem[_5971 + 64] = 96
        mem[_5971 + 96] = 0
        mem[_5971 + 128] = 0
        mem[_5971 + 160] = 0
        mem[_5971 + 192] = 0
        mem[_5971 + 224] = 0
        mem[var207001] = _5971
        s = var207001
        idx = var207002
        while idx - 1:
            _5971 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5971] = 0
            mem[_5971 + 32] = 96
            mem[_5971 + 64] = 96
            mem[_5971 + 96] = 0
            mem[_5971 + 128] = 0
            mem[_5971 + 160] = 0
            mem[_5971 + 192] = 0
            mem[_5971 + 224] = 0
            mem[s + 32] = _5971
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4232]
        mem[_4232 + 32] = _1779
        require 1 < mem[_4232]
        mem[_4232 + 64] = _3544
        _6579 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6579] = 0
        mem[_6579 + 32] = 96
        mem[_6579 + 64] = 96
        mem[_6579 + 96] = 0
        mem[_6579 + 128] = 0
        mem[_6579 + 160] = 0
        mem[_6579 + 192] = 0
        mem[_6579 + 224] = 0
        require 0 < mem[_4232]
        _6915 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6915] = 0
        mem[_6915 + 32] = 96
        mem[_6915 + 64] = 96
        mem[_6915 + 96] = 0
        mem[_6915 + 128] = 0
        mem[_6915 + 160] = 0
        mem[_6915 + 192] = 0
        mem[_6915 + 224] = 0
        require 1 < mem[_4232]
        if mem[_1779 + 96] <= mem[_3544 + 96]:
            idx = 12
            s = mem[_1779 + 96]
            while idx >= 4:
                if not mem[_1779 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1779 + 96] - idx
                continue 
            _13021 = mem[_1779 + 96]
            _13022 = mem[_1779 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13021 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3544 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3544 + 128] / 10^(mem[_3544 + 96] - s):
                if not _13022 / 10^(_13021 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13022 / 10^(_13021 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13022 / 10^(_13021 - s))
            if 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13022 / 10^(_13021 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / _13022 / 10^(_13021 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / _13022 / 10^(_13021 - s))
        idx = 12
        s = mem[_3544 + 96]
        while idx >= 4:
            if not mem[_3544 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3544 + 96] - idx
            continue 
        _13023 = mem[_1779 + 96]
        _13024 = mem[_1779 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13023 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3544 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3544 + 128] / 10^(mem[_3544 + 96] - s):
            if not _13024 / 10^(_13023 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13024 / 10^(_13023 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13024 / 10^(_13023 - s))
        if 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13024 / 10^(_13023 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / _13024 / 10^(_13023 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3544 + 128] / 10^(mem[_3544 + 96] - s) / _13024 / 10^(_13023 - s))
    mem[(2 * ceil32(return_data.size)) + _11 + 640] = 0
    mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x95d89b41 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _870 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _872 = mem[_870]
    require mem[_870] <= test266151307()
    require _870 + return_data.size > _870 + mem[_870] + 31
    _874 = mem[_870 + mem[_870]]
    require mem[_870 + mem[_870]] <= test266151307()
    require ceil32(mem[_870 + mem[_870]]) + 32 >= 0 and _870 + ceil32(return_data.size) + ceil32(mem[_870 + mem[_870]]) + 32 <= test266151307()
    mem[64] = _870 + ceil32(return_data.size) + ceil32(mem[_870 + mem[_870]]) + 32
    mem[_870 + ceil32(return_data.size)] = _874
    require _872 + _874 + 32 <= return_data.size
    mem[_870 + ceil32(return_data.size) + 32 len ceil32(_874)] = mem[_870 + _872 + 32 len ceil32(_874)]
    if ceil32(_874) <= _874:
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1754 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1758 = mem[_1754]
        require mem[_1754] == mem[_1754 + 31 len 1]
        require ext_code.size(address(ext_call.return_data[0]))
        staticcall address(ext_call.return_data[0]).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1770 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1774 = mem[_1770]
        _1777 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1777] = address(ext_call.return_data[0])
        mem[_1777 + 32] = (2 * ceil32(return_data.size)) + 608
        mem[_1777 + 64] = _870 + ceil32(return_data.size)
        mem[_1777 + 96] = uint8(_1758)
        mem[_1777 + 128] = 0
        mem[_1777 + 160] = _1774
        mem[_1777 + 192] = 0
        mem[_1777 + 224] = 0
        _1782 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1782] = 0
        mem[_1782 + 32] = 96
        mem[_1782 + 64] = 96
        mem[_1782 + 96] = 0
        mem[_1782 + 128] = 0
        mem[_1782 + 160] = 0
        mem[_1782 + 192] = 0
        mem[_1782 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1794 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1798 = mem[_1794]
        require mem[_1794] == mem[_1794 + 12 len 20]
        _1802 = mem[64]
        mem[64] = mem[64] + 256
        mem[_1802] = 0
        mem[_1802 + 32] = 96
        mem[_1802 + 64] = 96
        mem[_1802 + 96] = 0
        mem[_1802 + 128] = 0
        mem[_1802 + 160] = 0
        mem[_1802 + 192] = 0
        mem[_1802 + 224] = 0
        mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1798))
        staticcall address(_1798).name() with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1814 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1818 = mem[_1814]
        require mem[_1814] <= test266151307()
        require _1814 + return_data.size > _1814 + mem[_1814] + 31
        _1822 = mem[_1814 + mem[_1814]]
        require mem[_1814 + mem[_1814]] <= test266151307()
        require ceil32(mem[_1814 + mem[_1814]]) + 32 >= 0 and _1814 + ceil32(return_data.size) + ceil32(mem[_1814 + mem[_1814]]) + 32 <= test266151307()
        mem[64] = _1814 + ceil32(return_data.size) + ceil32(mem[_1814 + mem[_1814]]) + 32
        mem[_1814 + ceil32(return_data.size)] = _1822
        require _1818 + _1822 + 32 <= return_data.size
        mem[_1814 + ceil32(return_data.size) + 32 len ceil32(_1822)] = mem[_1814 + _1818 + 32 len ceil32(_1822)]
        if ceil32(_1822) <= _1822:
            mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
            require ext_code.size(address(_1798))
            staticcall address(_1798).0x95d89b41 with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2631 = mem[64]
            mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2639 = mem[_2631]
            require mem[_2631] <= test266151307()
            require _2631 + return_data.size > _2631 + mem[_2631] + 31
            _2647 = mem[_2631 + mem[_2631]]
            require mem[_2631 + mem[_2631]] <= test266151307()
            require ceil32(mem[_2631 + mem[_2631]]) + 32 >= 0 and _2631 + ceil32(return_data.size) + ceil32(mem[_2631 + mem[_2631]]) + 32 <= test266151307()
            mem[64] = _2631 + ceil32(return_data.size) + ceil32(mem[_2631 + mem[_2631]]) + 32
            mem[_2631 + ceil32(return_data.size)] = _2647
            require _2639 + _2647 + 32 <= return_data.size
            mem[_2631 + ceil32(return_data.size) + 32 len ceil32(_2647)] = mem[_2631 + _2639 + 32 len ceil32(_2647)]
            if ceil32(_2647) <= _2647:
                require ext_code.size(address(_1798))
                staticcall address(_1798).0x313ce567 with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3433 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3449 = mem[_3433]
                require mem[_3433] == mem[_3433 + 31 len 1]
                require ext_code.size(address(_1798))
                staticcall address(_1798).0x18160ddd with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3497 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3513 = mem[_3497]
                _3525 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3525] = address(_1798)
                mem[_3525 + 32] = _1814 + ceil32(return_data.size)
                mem[_3525 + 64] = _2631 + ceil32(return_data.size)
                mem[_3525 + 96] = uint8(_3449)
                mem[_3525 + 128] = 0
                mem[_3525 + 160] = _3513
                mem[_3525 + 192] = 0
                mem[_3525 + 224] = 0
                require ext_code.size(arg1)
                staticcall arg1.token0() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3577 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3593 = mem[_3577]
                require mem[_3577] == mem[_3577 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3593))
                staticcall address(_3593).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3641 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_1777 + 128] = mem[_3641]
                require ext_code.size(arg1)
                staticcall arg1.token1() with:
                        gas gas_remaining wei
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3705 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3721 = mem[_3705]
                require mem[_3705] == mem[_3705 + 12 len 20]
                mem[mem[64] + 4] = arg1
                require ext_code.size(address(_3721))
                staticcall address(_3721).0x70a08231 with:
                        gas gas_remaining wei
                       args address(arg1)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3769 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[_3525 + 128] = mem[_3769]
                _3801 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3801] = 0
                mem[_3801 + 32] = 96
                mem[_3801 + 64] = 96
                mem[_3801 + 96] = 0
                mem[_3801 + 128] = 0
                mem[_3801 + 160] = 0
                mem[_3801 + 192] = 0
                mem[_3801 + 224] = 0
                _3817 = mem[64]
                mem[64] = mem[64] + 256
                mem[_3817] = 0
                mem[_3817 + 32] = 96
                mem[_3817 + 64] = 96
                mem[_3817 + 96] = 0
                mem[_3817 + 128] = 0
                mem[_3817 + 160] = 0
                mem[_3817 + 192] = 0
                mem[_3817 + 224] = 0
                if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                    _3861 = mem[64]
                    mem[mem[64]] = 2
                    _4936 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4936] = 0
                    mem[_4936 + 32] = 96
                    mem[_4936 + 64] = 96
                    mem[_4936 + 96] = 0
                    mem[_4936 + 128] = 0
                    mem[_4936 + 160] = 0
                    mem[_4936 + 192] = 0
                    mem[_4936 + 224] = 0
                    mem[var190001] = _4936
                    s = var190001
                    idx = var190002
                    while idx - 1:
                        _4936 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4936] = 0
                        mem[_4936 + 32] = 96
                        mem[_4936 + 64] = 96
                        mem[_4936 + 96] = 0
                        mem[_4936 + 128] = 0
                        mem[_4936 + 160] = 0
                        mem[_4936 + 192] = 0
                        mem[_4936 + 224] = 0
                        mem[s + 32] = _4936
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3861]
                    mem[_3861 + 32] = _3525
                    require 1 < mem[_3861]
                    mem[_3861 + 64] = _1777
                    _5224 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5224] = 0
                    mem[_5224 + 32] = 96
                    mem[_5224 + 64] = 96
                    mem[_5224 + 96] = 0
                    mem[_5224 + 128] = 0
                    mem[_5224 + 160] = 0
                    mem[_5224 + 192] = 0
                    mem[_5224 + 224] = 0
                    require 0 < mem[_3861]
                    _5498 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5498] = 0
                    mem[_5498 + 32] = 96
                    mem[_5498 + 64] = 96
                    mem[_5498 + 96] = 0
                    mem[_5498 + 128] = 0
                    mem[_5498 + 160] = 0
                    mem[_5498 + 192] = 0
                    mem[_5498 + 224] = 0
                    require 1 < mem[_3861]
                    if mem[_3525 + 96] <= mem[_1777 + 96]:
                        idx = 12
                        s = mem[_3525 + 96]
                        while idx >= 4:
                            if not mem[_3525 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3525 + 96] - idx
                            continue 
                        _6147 = mem[_3525 + 96]
                        _6148 = mem[_3525 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6147 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1777 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                            if not _6148 / 10^(_6147 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6148 / 10^(_6147 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6148 / 10^(_6147 - s))
                        if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6148 / 10^(_6147 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6148 / 10^(_6147 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6148 / 10^(_6147 - s))
                    idx = 12
                    s = mem[_1777 + 96]
                    while idx >= 4:
                        if not mem[_1777 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1777 + 96] - idx
                        continue 
                    _6149 = mem[_3525 + 96]
                    _6150 = mem[_3525 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6149 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6150 / 10^(_6149 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6150 / 10^(_6149 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6150 / 10^(_6149 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6150 / 10^(_6149 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6150 / 10^(_6149 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6150 / 10^(_6149 - s))
                if wbnbAddress == address(_1798):
                    _3909 = mem[64]
                    mem[mem[64]] = 2
                    _4935 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4935] = 0
                    mem[_4935 + 32] = 96
                    mem[_4935 + 64] = 96
                    mem[_4935 + 96] = 0
                    mem[_4935 + 128] = 0
                    mem[_4935 + 160] = 0
                    mem[_4935 + 192] = 0
                    mem[_4935 + 224] = 0
                    mem[var194001] = _4935
                    s = var194001
                    idx = var194002
                    while idx - 1:
                        _4935 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4935] = 0
                        mem[_4935 + 32] = 96
                        mem[_4935 + 64] = 96
                        mem[_4935 + 96] = 0
                        mem[_4935 + 128] = 0
                        mem[_4935 + 160] = 0
                        mem[_4935 + 192] = 0
                        mem[_4935 + 224] = 0
                        mem[s + 32] = _4935
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3909]
                    mem[_3909 + 32] = _1777
                    require 1 < mem[_3909]
                    mem[_3909 + 64] = _3525
                    _5223 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5223] = 0
                    mem[_5223 + 32] = 96
                    mem[_5223 + 64] = 96
                    mem[_5223 + 96] = 0
                    mem[_5223 + 128] = 0
                    mem[_5223 + 160] = 0
                    mem[_5223 + 192] = 0
                    mem[_5223 + 224] = 0
                    require 0 < mem[_3909]
                    _5497 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5497] = 0
                    mem[_5497 + 32] = 96
                    mem[_5497 + 64] = 96
                    mem[_5497 + 96] = 0
                    mem[_5497 + 128] = 0
                    mem[_5497 + 160] = 0
                    mem[_5497 + 192] = 0
                    mem[_5497 + 224] = 0
                    require 1 < mem[_3909]
                    if mem[_1777 + 96] <= mem[_3525 + 96]:
                        idx = 12
                        s = mem[_1777 + 96]
                        while idx >= 4:
                            if not mem[_1777 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_1777 + 96] - idx
                            continue 
                        _6143 = mem[_1777 + 96]
                        _6144 = mem[_1777 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6143 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_3525 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_3525 + 128] / 10^(mem[_3525 + 96] - s):
                            if not _6144 / 10^(_6143 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6144 / 10^(_6143 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6144 / 10^(_6143 - s))
                        if 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6144 / 10^(_6143 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / _6144 / 10^(_6143 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / _6144 / 10^(_6143 - s))
                    idx = 12
                    s = mem[_3525 + 96]
                    while idx >= 4:
                        if not mem[_3525 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3525 + 96] - idx
                        continue 
                    _6145 = mem[_1777 + 96]
                    _6146 = mem[_1777 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6145 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3525 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3525 + 128] / 10^(mem[_3525 + 96] - s):
                        if not _6146 / 10^(_6145 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6146 / 10^(_6145 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6146 / 10^(_6145 - s))
                    if 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6146 / 10^(_6145 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / _6146 / 10^(_6145 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / _6146 / 10^(_6145 - s))
                if busdAddress == uint64(ext_call.return_data[0]) << 96:
                    _3953 = mem[64]
                    mem[mem[64]] = 2
                    _4934 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4934] = 0
                    mem[_4934 + 32] = 96
                    mem[_4934 + 64] = 96
                    mem[_4934 + 96] = 0
                    mem[_4934 + 128] = 0
                    mem[_4934 + 160] = 0
                    mem[_4934 + 192] = 0
                    mem[_4934 + 224] = 0
                    mem[var197001] = _4934
                    s = var197001
                    idx = var197002
                    while idx - 1:
                        _4934 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4934] = 0
                        mem[_4934 + 32] = 96
                        mem[_4934 + 64] = 96
                        mem[_4934 + 96] = 0
                        mem[_4934 + 128] = 0
                        mem[_4934 + 160] = 0
                        mem[_4934 + 192] = 0
                        mem[_4934 + 224] = 0
                        mem[s + 32] = _4934
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_3953]
                    mem[_3953 + 32] = _3525
                    require 1 < mem[_3953]
                    mem[_3953 + 64] = _1777
                    _5222 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5222] = 0
                    mem[_5222 + 32] = 96
                    mem[_5222 + 64] = 96
                    mem[_5222 + 96] = 0
                    mem[_5222 + 128] = 0
                    mem[_5222 + 160] = 0
                    mem[_5222 + 192] = 0
                    mem[_5222 + 224] = 0
                    require 0 < mem[_3953]
                    _5496 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5496] = 0
                    mem[_5496 + 32] = 96
                    mem[_5496 + 64] = 96
                    mem[_5496 + 96] = 0
                    mem[_5496 + 128] = 0
                    mem[_5496 + 160] = 0
                    mem[_5496 + 192] = 0
                    mem[_5496 + 224] = 0
                    require 1 < mem[_3953]
                    if mem[_3525 + 96] <= mem[_1777 + 96]:
                        idx = 12
                        s = mem[_3525 + 96]
                        while idx >= 4:
                            if not mem[_3525 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3525 + 96] - idx
                            continue 
                        _6139 = mem[_3525 + 96]
                        _6140 = mem[_3525 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6139 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1777 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                            if not _6140 / 10^(_6139 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6140 / 10^(_6139 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6140 / 10^(_6139 - s))
                        if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6140 / 10^(_6139 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6140 / 10^(_6139 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6140 / 10^(_6139 - s))
                    idx = 12
                    s = mem[_1777 + 96]
                    while idx >= 4:
                        if not mem[_1777 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1777 + 96] - idx
                        continue 
                    _6141 = mem[_3525 + 96]
                    _6142 = mem[_3525 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6141 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6142 / 10^(_6141 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6142 / 10^(_6141 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6142 / 10^(_6141 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6142 / 10^(_6141 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6142 / 10^(_6141 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6142 / 10^(_6141 - s))
                if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                    _4001 = mem[64]
                    mem[mem[64]] = 2
                    _4933 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_4933] = 0
                    mem[_4933 + 32] = 96
                    mem[_4933 + 64] = 96
                    mem[_4933 + 96] = 0
                    mem[_4933 + 128] = 0
                    mem[_4933 + 160] = 0
                    mem[_4933 + 192] = 0
                    mem[_4933 + 224] = 0
                    mem[var200001] = _4933
                    s = var200001
                    idx = var200002
                    while idx - 1:
                        _4933 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_4933] = 0
                        mem[_4933 + 32] = 96
                        mem[_4933 + 64] = 96
                        mem[_4933 + 96] = 0
                        mem[_4933 + 128] = 0
                        mem[_4933 + 160] = 0
                        mem[_4933 + 192] = 0
                        mem[_4933 + 224] = 0
                        mem[s + 32] = _4933
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4001]
                    mem[_4001 + 32] = _3525
                    require 1 < mem[_4001]
                    mem[_4001 + 64] = _1777
                    _5221 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5221] = 0
                    mem[_5221 + 32] = 96
                    mem[_5221 + 64] = 96
                    mem[_5221 + 96] = 0
                    mem[_5221 + 128] = 0
                    mem[_5221 + 160] = 0
                    mem[_5221 + 192] = 0
                    mem[_5221 + 224] = 0
                    require 0 < mem[_4001]
                    _5495 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5495] = 0
                    mem[_5495 + 32] = 96
                    mem[_5495 + 64] = 96
                    mem[_5495 + 96] = 0
                    mem[_5495 + 128] = 0
                    mem[_5495 + 160] = 0
                    mem[_5495 + 192] = 0
                    mem[_5495 + 224] = 0
                    require 1 < mem[_4001]
                    if mem[_3525 + 96] <= mem[_1777 + 96]:
                        idx = 12
                        s = mem[_3525 + 96]
                        while idx >= 4:
                            if not mem[_3525 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3525 + 96] - idx
                            continue 
                        _6135 = mem[_3525 + 96]
                        _6136 = mem[_3525 + 128]
                        mem[mem[64]] = 26
                        mem[mem[64] + 32] = 'SafeMath: division by zero'
                        if not 10^(_6135 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^(mem[_1777 + 96] - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                            if not _6136 / 10^(_6135 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            if not 0 / _6136 / 10^(_6135 - s):
                                revert with 0, 'SafeMath: division by zero', 0
                            return (1000000 * 10^18 / 0 / _6136 / 10^(_6135 - s))
                        if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not _6136 / 10^(_6135 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6136 / 10^(_6135 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6136 / 10^(_6135 - s))
                    idx = 12
                    s = mem[_1777 + 96]
                    while idx >= 4:
                        if not mem[_1777 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1777 + 96] - idx
                        continue 
                    _6137 = mem[_3525 + 96]
                    _6138 = mem[_3525 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6137 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6138 / 10^(_6137 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6138 / 10^(_6137 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6138 / 10^(_6137 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6138 / 10^(_6137 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6138 / 10^(_6137 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6138 / 10^(_6137 - s))
                idx = 0
                while idx < sub_27d312da.length:
                    mem[0] = 1
                    if sub_27d312da[idx] != address(ext_call.return_data[0]):
                        idx = idx + 1
                        continue 
                    _4397 = mem[64]
                    mem[mem[64]] = 2
                    _5974 = mem[64] + 96
                    mem[64] = mem[64] + 352
                    mem[_5974] = 0
                    mem[_5974 + 32] = 96
                    mem[_5974 + 64] = 96
                    mem[_5974 + 96] = 0
                    mem[_5974 + 128] = 0
                    mem[_5974 + 160] = 0
                    mem[_5974 + 192] = 0
                    mem[_5974 + 224] = 0
                    mem[var209001] = _5974
                    s = var209001
                    idx = var209002
                    while idx - 1:
                        _5974 = mem[64]
                        mem[64] = mem[64] + 256
                        mem[_5974] = 0
                        mem[_5974 + 32] = 96
                        mem[_5974 + 64] = 96
                        mem[_5974 + 96] = 0
                        mem[_5974 + 128] = 0
                        mem[_5974 + 160] = 0
                        mem[_5974 + 192] = 0
                        mem[_5974 + 224] = 0
                        mem[s + 32] = _5974
                        s = s + 32
                        idx = idx - 1
                        continue 
                    require 0 < mem[_4397]
                    mem[_4397 + 32] = _3525
                    require 1 < mem[_4397]
                    mem[_4397 + 64] = _1777
                    _6582 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6582] = 0
                    mem[_6582 + 32] = 96
                    mem[_6582 + 64] = 96
                    mem[_6582 + 96] = 0
                    mem[_6582 + 128] = 0
                    mem[_6582 + 160] = 0
                    mem[_6582 + 192] = 0
                    mem[_6582 + 224] = 0
                    require 0 < mem[_4397]
                    _6934 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_6934] = 0
                    mem[_6934 + 32] = 96
                    mem[_6934 + 64] = 96
                    mem[_6934 + 96] = 0
                    mem[_6934 + 128] = 0
                    mem[_6934 + 160] = 0
                    mem[_6934 + 192] = 0
                    mem[_6934 + 224] = 0
                    require 1 < mem[_4397]
                    if mem[_3525 + 96] <= mem[_1777 + 96]:
                        idx = 12
                        s = mem[_3525 + 96]
                        while idx >= 4:
                            if not mem[_3525 + 96] - idx:
                                idx = idx - 1
                                s = s
                                continue 
                            idx = idx - 1
                            s = mem[_3525 + 96] - idx
                            continue 
                        _13033 = mem[_3525 + 96]
                        _13034 = mem[_3525 + 128]
                        _13127 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13127] = 26
                        mem[_13127 + 32] = 'SafeMath: division by zero'
                        if not 10^(_13033 - s):
                            _13191 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13191 + 68] = mem[idx + _13127 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13191 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13191 + -mem[64] + 100
                        _14889 = mem[_1777 + 96]
                        _14890 = mem[_1777 + 128]
                        _15017 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15017] = 26
                        mem[_15017 + 32] = 'SafeMath: division by zero'
                        if not 10^(_14889 - s):
                            _15111 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15111 + 68] = mem[idx + _15017 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15111 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15111 + -mem[64] + 100
                        if not _14890 / 10^(_14889 - s):
                            _15495 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15495] = 26
                            mem[_15495 + 32] = 'SafeMath: division by zero'
                            if not _13034 / 10^(_13033 - s):
                                _15756 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15756 + 68] = mem[idx + _15495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15756 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15756 + -mem[64] + 100
                            _16297 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16297] = 26
                            mem[_16297 + 32] = 'SafeMath: division by zero'
                            if 0 / _13034 / 10^(_13033 - s):
                                return (1000000 * 10^18 / 0 / _13034 / 10^(_13033 - s))
                            _16525 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _16525 + 68] = mem[idx + _16297 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16525 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _16525 + -mem[64] + 100
                        if 10^12 * _14890 / 10^(_14889 - s) / _14890 / 10^(_14889 - s) != 10^12:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15755 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15755] = 26
                        mem[_15755 + 32] = 'SafeMath: division by zero'
                        if not _13034 / 10^(_13033 - s):
                            _15913 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15913 + 68] = mem[idx + _15755 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15913 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15913 + -mem[64] + 100
                        _16523 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16523] = 26
                        mem[_16523 + 32] = 'SafeMath: division by zero'
                        if 10^12 * _14890 / 10^(_14889 - s) / _13034 / 10^(_13033 - s):
                            return (1000000 * 10^18 / 10^12 * _14890 / 10^(_14889 - s) / _13034 / 10^(_13033 - s))
                        _16681 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16681 + 68] = mem[idx + _16523 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16681 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16681 + -mem[64] + 100
                    idx = 12
                    s = mem[_1777 + 96]
                    while idx >= 4:
                        if not mem[_1777 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1777 + 96] - idx
                        continue 
                    _13035 = mem[_3525 + 96]
                    _13036 = mem[_3525 + 128]
                    _13128 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13128] = 26
                    mem[_13128 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13035 - s):
                        _13192 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13192 + 68] = mem[idx + _13128 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13192 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13192 + -mem[64] + 100
                    _14891 = mem[_1777 + 96]
                    _14892 = mem[_1777 + 128]
                    _15019 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15019] = 26
                    mem[_15019 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14891 - s):
                        _15112 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15112 + 68] = mem[idx + _15019 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15112 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15112 + -mem[64] + 100
                    if not _14892 / 10^(_14891 - s):
                        _15496 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15496] = 26
                        mem[_15496 + 32] = 'SafeMath: division by zero'
                        if not _13036 / 10^(_13035 - s):
                            _15759 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15759 + 68] = mem[idx + _15496 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15759 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15759 + -mem[64] + 100
                        _16299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16299] = 26
                        mem[_16299 + 32] = 'SafeMath: division by zero'
                        if 0 / _13036 / 10^(_13035 - s):
                            return (1000000 * 10^18 / 0 / _13036 / 10^(_13035 - s))
                        _16528 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16528 + 68] = mem[idx + _16299 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16528 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16528 + -mem[64] + 100
                    if 10^12 * _14892 / 10^(_14891 - s) / _14892 / 10^(_14891 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15758 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15758] = 26
                    mem[_15758 + 32] = 'SafeMath: division by zero'
                    if not _13036 / 10^(_13035 - s):
                        _15915 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15915 + 68] = mem[idx + _15758 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15915 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15915 + -mem[64] + 100
                    _16526 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16526] = 26
                    mem[_16526 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14892 / 10^(_14891 - s) / _13036 / 10^(_13035 - s):
                        return (1000000 * 10^18 / 10^12 * _14892 / 10^(_14891 - s) / _13036 / 10^(_13035 - s))
                    _16683 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16683 + 68] = mem[idx + _16526 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16683 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16683 + -mem[64] + 100
                _4237 = mem[64]
                mem[mem[64]] = 2
                _5973 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5973] = 0
                mem[_5973 + 32] = 96
                mem[_5973 + 64] = 96
                mem[_5973 + 96] = 0
                mem[_5973 + 128] = 0
                mem[_5973 + 160] = 0
                mem[_5973 + 192] = 0
                mem[_5973 + 224] = 0
                mem[var205001] = _5973
                s = var205001
                idx = var205002
                while idx - 1:
                    _5973 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5973] = 0
                    mem[_5973 + 32] = 96
                    mem[_5973 + 64] = 96
                    mem[_5973 + 96] = 0
                    mem[_5973 + 128] = 0
                    mem[_5973 + 160] = 0
                    mem[_5973 + 192] = 0
                    mem[_5973 + 224] = 0
                    mem[s + 32] = _5973
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4237]
                mem[_4237 + 32] = _1777
                require 1 < mem[_4237]
                mem[_4237 + 64] = _3525
                _6581 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6581] = 0
                mem[_6581 + 32] = 96
                mem[_6581 + 64] = 96
                mem[_6581 + 96] = 0
                mem[_6581 + 128] = 0
                mem[_6581 + 160] = 0
                mem[_6581 + 192] = 0
                mem[_6581 + 224] = 0
                require 0 < mem[_4237]
                _6933 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6933] = 0
                mem[_6933 + 32] = 96
                mem[_6933 + 64] = 96
                mem[_6933 + 96] = 0
                mem[_6933 + 128] = 0
                mem[_6933 + 160] = 0
                mem[_6933 + 192] = 0
                mem[_6933 + 224] = 0
                require 1 < mem[_4237]
                if mem[_1777 + 96] <= mem[_3525 + 96]:
                    idx = 12
                    s = mem[_1777 + 96]
                    while idx >= 4:
                        if not mem[_1777 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1777 + 96] - idx
                        continue 
                    _13029 = mem[_1777 + 96]
                    _13030 = mem[_1777 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_13029 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3525 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3525 + 128] / 10^(mem[_3525 + 96] - s):
                        if not _13030 / 10^(_13029 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _13030 / 10^(_13029 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _13030 / 10^(_13029 - s))
                    if 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _13030 / 10^(_13029 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / _13030 / 10^(_13029 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / _13030 / 10^(_13029 - s))
                idx = 12
                s = mem[_3525 + 96]
                while idx >= 4:
                    if not mem[_3525 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3525 + 96] - idx
                    continue 
                _13031 = mem[_1777 + 96]
                _13032 = mem[_1777 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13031 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3525 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3525 + 128] / 10^(mem[_3525 + 96] - s):
                    if not _13032 / 10^(_13031 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13032 / 10^(_13031 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13032 / 10^(_13031 - s))
                if 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13032 / 10^(_13031 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / _13032 / 10^(_13031 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3525 + 128] / 10^(mem[_3525 + 96] - s) / _13032 / 10^(_13031 - s))
            mem[_2631 + ceil32(return_data.size) + _2647 + 32] = 0
            require ext_code.size(address(_1798))
            staticcall address(_1798).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3441 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3457 = mem[_3441]
            require mem[_3441] == mem[_3441 + 31 len 1]
            require ext_code.size(address(_1798))
            staticcall address(_1798).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3505 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3526 = mem[_3505]
            _3547 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3547] = address(_1798)
            mem[_3547 + 32] = _1814 + ceil32(return_data.size)
            mem[_3547 + 64] = _2631 + ceil32(return_data.size)
            mem[_3547 + 96] = uint8(_3457)
            mem[_3547 + 128] = 0
            mem[_3547 + 160] = _3526
            mem[_3547 + 192] = 0
            mem[_3547 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3585 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3601 = mem[_3585]
            require mem[_3585] == mem[_3585 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3601))
            staticcall address(_3601).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3649 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1777 + 128] = mem[_3649]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3713 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3729 = mem[_3713]
            require mem[_3713] == mem[_3713 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3729))
            staticcall address(_3729).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3777 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3547 + 128] = mem[_3777]
            _3809 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3809] = 0
            mem[_3809 + 32] = 96
            mem[_3809 + 64] = 96
            mem[_3809 + 96] = 0
            mem[_3809 + 128] = 0
            mem[_3809 + 160] = 0
            mem[_3809 + 192] = 0
            mem[_3809 + 224] = 0
            _3830 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3830] = 0
            mem[_3830 + 32] = 96
            mem[_3830 + 64] = 96
            mem[_3830 + 96] = 0
            mem[_3830 + 128] = 0
            mem[_3830 + 160] = 0
            mem[_3830 + 192] = 0
            mem[_3830 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3873 = mem[64]
                mem[mem[64]] = 2
                _4940 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4940] = 0
                mem[_4940 + 32] = 96
                mem[_4940 + 64] = 96
                mem[_4940 + 96] = 0
                mem[_4940 + 128] = 0
                mem[_4940 + 160] = 0
                mem[_4940 + 192] = 0
                mem[_4940 + 224] = 0
                mem[var191001] = _4940
                s = var191001
                idx = var191002
                while idx - 1:
                    _4940 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4940] = 0
                    mem[_4940 + 32] = 96
                    mem[_4940 + 64] = 96
                    mem[_4940 + 96] = 0
                    mem[_4940 + 128] = 0
                    mem[_4940 + 160] = 0
                    mem[_4940 + 192] = 0
                    mem[_4940 + 224] = 0
                    mem[s + 32] = _4940
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3873]
                mem[_3873 + 32] = _3547
                require 1 < mem[_3873]
                mem[_3873 + 64] = _1777
                _5228 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5228] = 0
                mem[_5228 + 32] = 96
                mem[_5228 + 64] = 96
                mem[_5228 + 96] = 0
                mem[_5228 + 128] = 0
                mem[_5228 + 160] = 0
                mem[_5228 + 192] = 0
                mem[_5228 + 224] = 0
                require 0 < mem[_3873]
                _5504 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5504] = 0
                mem[_5504 + 32] = 96
                mem[_5504 + 64] = 96
                mem[_5504 + 96] = 0
                mem[_5504 + 128] = 0
                mem[_5504 + 160] = 0
                mem[_5504 + 192] = 0
                mem[_5504 + 224] = 0
                require 1 < mem[_3873]
                if mem[_3547 + 96] <= mem[_1777 + 96]:
                    idx = 12
                    s = mem[_3547 + 96]
                    while idx >= 4:
                        if not mem[_3547 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3547 + 96] - idx
                        continue 
                    _6165 = mem[_3547 + 96]
                    _6166 = mem[_3547 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6165 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6166 / 10^(_6165 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6166 / 10^(_6165 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6166 / 10^(_6165 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6166 / 10^(_6165 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6166 / 10^(_6165 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6166 / 10^(_6165 - s))
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _6167 = mem[_3547 + 96]
                _6168 = mem[_3547 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6167 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6168 / 10^(_6167 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6168 / 10^(_6167 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6168 / 10^(_6167 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6168 / 10^(_6167 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6168 / 10^(_6167 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6168 / 10^(_6167 - s))
            if wbnbAddress == address(_1798):
                _3921 = mem[64]
                mem[mem[64]] = 2
                _4939 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4939] = 0
                mem[_4939 + 32] = 96
                mem[_4939 + 64] = 96
                mem[_4939 + 96] = 0
                mem[_4939 + 128] = 0
                mem[_4939 + 160] = 0
                mem[_4939 + 192] = 0
                mem[_4939 + 224] = 0
                mem[var195001] = _4939
                s = var195001
                idx = var195002
                while idx - 1:
                    _4939 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4939] = 0
                    mem[_4939 + 32] = 96
                    mem[_4939 + 64] = 96
                    mem[_4939 + 96] = 0
                    mem[_4939 + 128] = 0
                    mem[_4939 + 160] = 0
                    mem[_4939 + 192] = 0
                    mem[_4939 + 224] = 0
                    mem[s + 32] = _4939
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3921]
                mem[_3921 + 32] = _1777
                require 1 < mem[_3921]
                mem[_3921 + 64] = _3547
                _5227 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5227] = 0
                mem[_5227 + 32] = 96
                mem[_5227 + 64] = 96
                mem[_5227 + 96] = 0
                mem[_5227 + 128] = 0
                mem[_5227 + 160] = 0
                mem[_5227 + 192] = 0
                mem[_5227 + 224] = 0
                require 0 < mem[_3921]
                _5503 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5503] = 0
                mem[_5503 + 32] = 96
                mem[_5503 + 64] = 96
                mem[_5503 + 96] = 0
                mem[_5503 + 128] = 0
                mem[_5503 + 160] = 0
                mem[_5503 + 192] = 0
                mem[_5503 + 224] = 0
                require 1 < mem[_3921]
                if mem[_1777 + 96] <= mem[_3547 + 96]:
                    idx = 12
                    s = mem[_1777 + 96]
                    while idx >= 4:
                        if not mem[_1777 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1777 + 96] - idx
                        continue 
                    _6161 = mem[_1777 + 96]
                    _6162 = mem[_1777 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6161 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3547 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3547 + 128] / 10^(mem[_3547 + 96] - s):
                        if not _6162 / 10^(_6161 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6162 / 10^(_6161 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6162 / 10^(_6161 - s))
                    if 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6162 / 10^(_6161 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _6162 / 10^(_6161 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _6162 / 10^(_6161 - s))
                idx = 12
                s = mem[_3547 + 96]
                while idx >= 4:
                    if not mem[_3547 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3547 + 96] - idx
                    continue 
                _6163 = mem[_1777 + 96]
                _6164 = mem[_1777 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6163 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3547 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3547 + 128] / 10^(mem[_3547 + 96] - s):
                    if not _6164 / 10^(_6163 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6164 / 10^(_6163 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6164 / 10^(_6163 - s))
                if 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6164 / 10^(_6163 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _6164 / 10^(_6163 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _6164 / 10^(_6163 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3969 = mem[64]
                mem[mem[64]] = 2
                _4938 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4938] = 0
                mem[_4938 + 32] = 96
                mem[_4938 + 64] = 96
                mem[_4938 + 96] = 0
                mem[_4938 + 128] = 0
                mem[_4938 + 160] = 0
                mem[_4938 + 192] = 0
                mem[_4938 + 224] = 0
                mem[var198001] = _4938
                s = var198001
                idx = var198002
                while idx - 1:
                    _4938 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4938] = 0
                    mem[_4938 + 32] = 96
                    mem[_4938 + 64] = 96
                    mem[_4938 + 96] = 0
                    mem[_4938 + 128] = 0
                    mem[_4938 + 160] = 0
                    mem[_4938 + 192] = 0
                    mem[_4938 + 224] = 0
                    mem[s + 32] = _4938
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3969]
                mem[_3969 + 32] = _3547
                require 1 < mem[_3969]
                mem[_3969 + 64] = _1777
                _5226 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5226] = 0
                mem[_5226 + 32] = 96
                mem[_5226 + 64] = 96
                mem[_5226 + 96] = 0
                mem[_5226 + 128] = 0
                mem[_5226 + 160] = 0
                mem[_5226 + 192] = 0
                mem[_5226 + 224] = 0
                require 0 < mem[_3969]
                _5502 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5502] = 0
                mem[_5502 + 32] = 96
                mem[_5502 + 64] = 96
                mem[_5502 + 96] = 0
                mem[_5502 + 128] = 0
                mem[_5502 + 160] = 0
                mem[_5502 + 192] = 0
                mem[_5502 + 224] = 0
                require 1 < mem[_3969]
                if mem[_3547 + 96] <= mem[_1777 + 96]:
                    idx = 12
                    s = mem[_3547 + 96]
                    while idx >= 4:
                        if not mem[_3547 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3547 + 96] - idx
                        continue 
                    _6157 = mem[_3547 + 96]
                    _6158 = mem[_3547 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6157 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6158 / 10^(_6157 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6158 / 10^(_6157 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6158 / 10^(_6157 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6158 / 10^(_6157 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6158 / 10^(_6157 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6158 / 10^(_6157 - s))
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _6159 = mem[_3547 + 96]
                _6160 = mem[_3547 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6159 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6160 / 10^(_6159 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6160 / 10^(_6159 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6160 / 10^(_6159 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6160 / 10^(_6159 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6160 / 10^(_6159 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6160 / 10^(_6159 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4017 = mem[64]
                mem[mem[64]] = 2
                _4937 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4937] = 0
                mem[_4937 + 32] = 96
                mem[_4937 + 64] = 96
                mem[_4937 + 96] = 0
                mem[_4937 + 128] = 0
                mem[_4937 + 160] = 0
                mem[_4937 + 192] = 0
                mem[_4937 + 224] = 0
                mem[var201001] = _4937
                s = var201001
                idx = var201002
                while idx - 1:
                    _4937 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4937] = 0
                    mem[_4937 + 32] = 96
                    mem[_4937 + 64] = 96
                    mem[_4937 + 96] = 0
                    mem[_4937 + 128] = 0
                    mem[_4937 + 160] = 0
                    mem[_4937 + 192] = 0
                    mem[_4937 + 224] = 0
                    mem[s + 32] = _4937
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4017]
                mem[_4017 + 32] = _3547
                require 1 < mem[_4017]
                mem[_4017 + 64] = _1777
                _5225 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5225] = 0
                mem[_5225 + 32] = 96
                mem[_5225 + 64] = 96
                mem[_5225 + 96] = 0
                mem[_5225 + 128] = 0
                mem[_5225 + 160] = 0
                mem[_5225 + 192] = 0
                mem[_5225 + 224] = 0
                require 0 < mem[_4017]
                _5501 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5501] = 0
                mem[_5501 + 32] = 96
                mem[_5501 + 64] = 96
                mem[_5501 + 96] = 0
                mem[_5501 + 128] = 0
                mem[_5501 + 160] = 0
                mem[_5501 + 192] = 0
                mem[_5501 + 224] = 0
                require 1 < mem[_4017]
                if mem[_3547 + 96] <= mem[_1777 + 96]:
                    idx = 12
                    s = mem[_3547 + 96]
                    while idx >= 4:
                        if not mem[_3547 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3547 + 96] - idx
                        continue 
                    _6153 = mem[_3547 + 96]
                    _6154 = mem[_3547 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6153 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6154 / 10^(_6153 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6154 / 10^(_6153 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6154 / 10^(_6153 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6154 / 10^(_6153 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6154 / 10^(_6153 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6154 / 10^(_6153 - s))
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _6155 = mem[_3547 + 96]
                _6156 = mem[_3547 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6155 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6156 / 10^(_6155 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6156 / 10^(_6155 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6156 / 10^(_6155 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6156 / 10^(_6155 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6156 / 10^(_6155 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6156 / 10^(_6155 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4402 = mem[64]
                mem[mem[64]] = 2
                _5976 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5976] = 0
                mem[_5976 + 32] = 96
                mem[_5976 + 64] = 96
                mem[_5976 + 96] = 0
                mem[_5976 + 128] = 0
                mem[_5976 + 160] = 0
                mem[_5976 + 192] = 0
                mem[_5976 + 224] = 0
                mem[var210001] = _5976
                s = var210001
                idx = var210002
                while idx - 1:
                    _5976 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5976] = 0
                    mem[_5976 + 32] = 96
                    mem[_5976 + 64] = 96
                    mem[_5976 + 96] = 0
                    mem[_5976 + 128] = 0
                    mem[_5976 + 160] = 0
                    mem[_5976 + 192] = 0
                    mem[_5976 + 224] = 0
                    mem[s + 32] = _5976
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4402]
                mem[_4402 + 32] = _3547
                require 1 < mem[_4402]
                mem[_4402 + 64] = _1777
                _6584 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6584] = 0
                mem[_6584 + 32] = 96
                mem[_6584 + 64] = 96
                mem[_6584 + 96] = 0
                mem[_6584 + 128] = 0
                mem[_6584 + 160] = 0
                mem[_6584 + 192] = 0
                mem[_6584 + 224] = 0
                require 0 < mem[_4402]
                _6952 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6952] = 0
                mem[_6952 + 32] = 96
                mem[_6952 + 64] = 96
                mem[_6952 + 96] = 0
                mem[_6952 + 128] = 0
                mem[_6952 + 160] = 0
                mem[_6952 + 192] = 0
                mem[_6952 + 224] = 0
                require 1 < mem[_4402]
                if mem[_3547 + 96] <= mem[_1777 + 96]:
                    idx = 12
                    s = mem[_3547 + 96]
                    while idx >= 4:
                        if not mem[_3547 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3547 + 96] - idx
                        continue 
                    _13041 = mem[_3547 + 96]
                    _13042 = mem[_3547 + 128]
                    _13131 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13131] = 26
                    mem[_13131 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13041 - s):
                        _13195 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13195 + 68] = mem[idx + _13131 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13195 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13195 + -mem[64] + 100
                    _14897 = mem[_1777 + 96]
                    _14898 = mem[_1777 + 128]
                    _15025 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15025] = 26
                    mem[_15025 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14897 - s):
                        _15115 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15115 + 68] = mem[idx + _15025 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15115 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15115 + -mem[64] + 100
                    if not _14898 / 10^(_14897 - s):
                        _15499 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15499] = 26
                        mem[_15499 + 32] = 'SafeMath: division by zero'
                        if not _13042 / 10^(_13041 - s):
                            _15768 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15768 + 68] = mem[idx + _15499 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15768 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15768 + -mem[64] + 100
                        _16305 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16305] = 26
                        mem[_16305 + 32] = 'SafeMath: division by zero'
                        if 0 / _13042 / 10^(_13041 - s):
                            return (1000000 * 10^18 / 0 / _13042 / 10^(_13041 - s))
                        _16537 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16537 + 68] = mem[idx + _16305 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16537 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16537 + -mem[64] + 100
                    if 10^12 * _14898 / 10^(_14897 - s) / _14898 / 10^(_14897 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15767 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15767] = 26
                    mem[_15767 + 32] = 'SafeMath: division by zero'
                    if not _13042 / 10^(_13041 - s):
                        _15921 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15921 + 68] = mem[idx + _15767 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15921 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15921 + -mem[64] + 100
                    _16535 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16535] = 26
                    mem[_16535 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14898 / 10^(_14897 - s) / _13042 / 10^(_13041 - s):
                        return (1000000 * 10^18 / 10^12 * _14898 / 10^(_14897 - s) / _13042 / 10^(_13041 - s))
                    _16689 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16689 + 68] = mem[idx + _16535 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16689 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16689 + -mem[64] + 100
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _13043 = mem[_3547 + 96]
                _13044 = mem[_3547 + 128]
                _13132 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13132] = 26
                mem[_13132 + 32] = 'SafeMath: division by zero'
                if not 10^(_13043 - s):
                    _13196 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13196 + 68] = mem[idx + _13132 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13196 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13196 + -mem[64] + 100
                _14899 = mem[_1777 + 96]
                _14900 = mem[_1777 + 128]
                _15027 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15027] = 26
                mem[_15027 + 32] = 'SafeMath: division by zero'
                if not 10^(_14899 - s):
                    _15116 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15116 + 68] = mem[idx + _15027 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15116 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15116 + -mem[64] + 100
                if not _14900 / 10^(_14899 - s):
                    _15500 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15500] = 26
                    mem[_15500 + 32] = 'SafeMath: division by zero'
                    if not _13044 / 10^(_13043 - s):
                        _15771 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15771 + 68] = mem[idx + _15500 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15771 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15771 + -mem[64] + 100
                    _16307 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16307] = 26
                    mem[_16307 + 32] = 'SafeMath: division by zero'
                    if 0 / _13044 / 10^(_13043 - s):
                        return (1000000 * 10^18 / 0 / _13044 / 10^(_13043 - s))
                    _16540 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16540 + 68] = mem[idx + _16307 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16540 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16540 + -mem[64] + 100
                if 10^12 * _14900 / 10^(_14899 - s) / _14900 / 10^(_14899 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15770 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15770] = 26
                mem[_15770 + 32] = 'SafeMath: division by zero'
                if not _13044 / 10^(_13043 - s):
                    _15923 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15923 + 68] = mem[idx + _15770 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15923 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15923 + -mem[64] + 100
                _16538 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16538] = 26
                mem[_16538 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14900 / 10^(_14899 - s) / _13044 / 10^(_13043 - s):
                    return (1000000 * 10^18 / 10^12 * _14900 / 10^(_14899 - s) / _13044 / 10^(_13043 - s))
                _16691 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16691 + 68] = mem[idx + _16538 + 32]
                    idx = idx + 32
                    continue 
                mem[_16691 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16691 + -mem[64] + 100
            _4242 = mem[64]
            mem[mem[64]] = 2
            _5975 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5975] = 0
            mem[_5975 + 32] = 96
            mem[_5975 + 64] = 96
            mem[_5975 + 96] = 0
            mem[_5975 + 128] = 0
            mem[_5975 + 160] = 0
            mem[_5975 + 192] = 0
            mem[_5975 + 224] = 0
            mem[var206001] = _5975
            s = var206001
            idx = var206002
            while idx - 1:
                _5975 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5975] = 0
                mem[_5975 + 32] = 96
                mem[_5975 + 64] = 96
                mem[_5975 + 96] = 0
                mem[_5975 + 128] = 0
                mem[_5975 + 160] = 0
                mem[_5975 + 192] = 0
                mem[_5975 + 224] = 0
                mem[s + 32] = _5975
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4242]
            mem[_4242 + 32] = _1777
            require 1 < mem[_4242]
            mem[_4242 + 64] = _3547
            _6583 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6583] = 0
            mem[_6583 + 32] = 96
            mem[_6583 + 64] = 96
            mem[_6583 + 96] = 0
            mem[_6583 + 128] = 0
            mem[_6583 + 160] = 0
            mem[_6583 + 192] = 0
            mem[_6583 + 224] = 0
            require 0 < mem[_4242]
            _6951 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6951] = 0
            mem[_6951 + 32] = 96
            mem[_6951 + 64] = 96
            mem[_6951 + 96] = 0
            mem[_6951 + 128] = 0
            mem[_6951 + 160] = 0
            mem[_6951 + 192] = 0
            mem[_6951 + 224] = 0
            require 1 < mem[_4242]
            if mem[_1777 + 96] <= mem[_3547 + 96]:
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _13037 = mem[_1777 + 96]
                _13038 = mem[_1777 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13037 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3547 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3547 + 128] / 10^(mem[_3547 + 96] - s):
                    if not _13038 / 10^(_13037 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13038 / 10^(_13037 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13038 / 10^(_13037 - s))
                if 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13038 / 10^(_13037 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _13038 / 10^(_13037 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _13038 / 10^(_13037 - s))
            idx = 12
            s = mem[_3547 + 96]
            while idx >= 4:
                if not mem[_3547 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3547 + 96] - idx
                continue 
            _13039 = mem[_1777 + 96]
            _13040 = mem[_1777 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13039 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3547 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3547 + 128] / 10^(mem[_3547 + 96] - s):
                if not _13040 / 10^(_13039 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13040 / 10^(_13039 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13040 / 10^(_13039 - s))
            if 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13040 / 10^(_13039 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _13040 / 10^(_13039 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3547 + 128] / 10^(mem[_3547 + 96] - s) / _13040 / 10^(_13039 - s))
        mem[_1814 + ceil32(return_data.size) + _1822 + 32] = 0
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1798))
        staticcall address(_1798).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2635 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2643 = mem[_2635]
        require mem[_2635] <= test266151307()
        require _2635 + return_data.size > _2635 + mem[_2635] + 31
        _2651 = mem[_2635 + mem[_2635]]
        require mem[_2635 + mem[_2635]] <= test266151307()
        require ceil32(mem[_2635 + mem[_2635]]) + 32 >= 0 and _2635 + ceil32(return_data.size) + ceil32(mem[_2635 + mem[_2635]]) + 32 <= test266151307()
        mem[64] = _2635 + ceil32(return_data.size) + ceil32(mem[_2635 + mem[_2635]]) + 32
        mem[_2635 + ceil32(return_data.size)] = _2651
        require _2643 + _2651 + 32 <= return_data.size
        mem[_2635 + ceil32(return_data.size) + 32 len ceil32(_2651)] = mem[_2635 + _2643 + 32 len ceil32(_2651)]
        if ceil32(_2651) <= _2651:
            require ext_code.size(address(_1798))
            staticcall address(_1798).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3434 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3450 = mem[_3434]
            require mem[_3434] == mem[_3434 + 31 len 1]
            require ext_code.size(address(_1798))
            staticcall address(_1798).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3498 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3514 = mem[_3498]
            _3527 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3527] = address(_1798)
            mem[_3527 + 32] = _1814 + ceil32(return_data.size)
            mem[_3527 + 64] = _2635 + ceil32(return_data.size)
            mem[_3527 + 96] = uint8(_3450)
            mem[_3527 + 128] = 0
            mem[_3527 + 160] = _3514
            mem[_3527 + 192] = 0
            mem[_3527 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3578 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3594 = mem[_3578]
            require mem[_3578] == mem[_3578 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3594))
            staticcall address(_3594).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3642 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1777 + 128] = mem[_3642]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3706 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3722 = mem[_3706]
            require mem[_3706] == mem[_3706 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3722))
            staticcall address(_3722).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3770 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3527 + 128] = mem[_3770]
            _3802 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3802] = 0
            mem[_3802 + 32] = 96
            mem[_3802 + 64] = 96
            mem[_3802 + 96] = 0
            mem[_3802 + 128] = 0
            mem[_3802 + 160] = 0
            mem[_3802 + 192] = 0
            mem[_3802 + 224] = 0
            _3818 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3818] = 0
            mem[_3818 + 32] = 96
            mem[_3818 + 64] = 96
            mem[_3818 + 96] = 0
            mem[_3818 + 128] = 0
            mem[_3818 + 160] = 0
            mem[_3818 + 192] = 0
            mem[_3818 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3863 = mem[64]
                mem[mem[64]] = 2
                _4944 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4944] = 0
                mem[_4944 + 32] = 96
                mem[_4944 + 64] = 96
                mem[_4944 + 96] = 0
                mem[_4944 + 128] = 0
                mem[_4944 + 160] = 0
                mem[_4944 + 192] = 0
                mem[_4944 + 224] = 0
                mem[var191001] = _4944
                s = var191001
                idx = var191002
                while idx - 1:
                    _4944 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4944] = 0
                    mem[_4944 + 32] = 96
                    mem[_4944 + 64] = 96
                    mem[_4944 + 96] = 0
                    mem[_4944 + 128] = 0
                    mem[_4944 + 160] = 0
                    mem[_4944 + 192] = 0
                    mem[_4944 + 224] = 0
                    mem[s + 32] = _4944
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3863]
                mem[_3863 + 32] = _3527
                require 1 < mem[_3863]
                mem[_3863 + 64] = _1777
                _5232 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5232] = 0
                mem[_5232 + 32] = 96
                mem[_5232 + 64] = 96
                mem[_5232 + 96] = 0
                mem[_5232 + 128] = 0
                mem[_5232 + 160] = 0
                mem[_5232 + 192] = 0
                mem[_5232 + 224] = 0
                require 0 < mem[_3863]
                _5510 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5510] = 0
                mem[_5510 + 32] = 96
                mem[_5510 + 64] = 96
                mem[_5510 + 96] = 0
                mem[_5510 + 128] = 0
                mem[_5510 + 160] = 0
                mem[_5510 + 192] = 0
                mem[_5510 + 224] = 0
                require 1 < mem[_3863]
                if mem[_3527 + 96] <= mem[_1777 + 96]:
                    idx = 12
                    s = mem[_3527 + 96]
                    while idx >= 4:
                        if not mem[_3527 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3527 + 96] - idx
                        continue 
                    _6183 = mem[_3527 + 96]
                    _6184 = mem[_3527 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6183 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6184 / 10^(_6183 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6184 / 10^(_6183 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6184 / 10^(_6183 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6184 / 10^(_6183 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6184 / 10^(_6183 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6184 / 10^(_6183 - s))
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _6185 = mem[_3527 + 96]
                _6186 = mem[_3527 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6185 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6186 / 10^(_6185 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6186 / 10^(_6185 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6186 / 10^(_6185 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6186 / 10^(_6185 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6186 / 10^(_6185 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6186 / 10^(_6185 - s))
            if wbnbAddress == address(_1798):
                _3911 = mem[64]
                mem[mem[64]] = 2
                _4943 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4943] = 0
                mem[_4943 + 32] = 96
                mem[_4943 + 64] = 96
                mem[_4943 + 96] = 0
                mem[_4943 + 128] = 0
                mem[_4943 + 160] = 0
                mem[_4943 + 192] = 0
                mem[_4943 + 224] = 0
                mem[var195001] = _4943
                s = var195001
                idx = var195002
                while idx - 1:
                    _4943 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4943] = 0
                    mem[_4943 + 32] = 96
                    mem[_4943 + 64] = 96
                    mem[_4943 + 96] = 0
                    mem[_4943 + 128] = 0
                    mem[_4943 + 160] = 0
                    mem[_4943 + 192] = 0
                    mem[_4943 + 224] = 0
                    mem[s + 32] = _4943
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3911]
                mem[_3911 + 32] = _1777
                require 1 < mem[_3911]
                mem[_3911 + 64] = _3527
                _5231 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5231] = 0
                mem[_5231 + 32] = 96
                mem[_5231 + 64] = 96
                mem[_5231 + 96] = 0
                mem[_5231 + 128] = 0
                mem[_5231 + 160] = 0
                mem[_5231 + 192] = 0
                mem[_5231 + 224] = 0
                require 0 < mem[_3911]
                _5509 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5509] = 0
                mem[_5509 + 32] = 96
                mem[_5509 + 64] = 96
                mem[_5509 + 96] = 0
                mem[_5509 + 128] = 0
                mem[_5509 + 160] = 0
                mem[_5509 + 192] = 0
                mem[_5509 + 224] = 0
                require 1 < mem[_3911]
                if mem[_1777 + 96] <= mem[_3527 + 96]:
                    idx = 12
                    s = mem[_1777 + 96]
                    while idx >= 4:
                        if not mem[_1777 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1777 + 96] - idx
                        continue 
                    _6179 = mem[_1777 + 96]
                    _6180 = mem[_1777 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6179 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3527 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3527 + 128] / 10^(mem[_3527 + 96] - s):
                        if not _6180 / 10^(_6179 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6180 / 10^(_6179 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6180 / 10^(_6179 - s))
                    if 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6180 / 10^(_6179 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / _6180 / 10^(_6179 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / _6180 / 10^(_6179 - s))
                idx = 12
                s = mem[_3527 + 96]
                while idx >= 4:
                    if not mem[_3527 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3527 + 96] - idx
                    continue 
                _6181 = mem[_1777 + 96]
                _6182 = mem[_1777 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6181 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3527 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3527 + 128] / 10^(mem[_3527 + 96] - s):
                    if not _6182 / 10^(_6181 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6182 / 10^(_6181 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6182 / 10^(_6181 - s))
                if 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6182 / 10^(_6181 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / _6182 / 10^(_6181 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / _6182 / 10^(_6181 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3956 = mem[64]
                mem[mem[64]] = 2
                _4942 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4942] = 0
                mem[_4942 + 32] = 96
                mem[_4942 + 64] = 96
                mem[_4942 + 96] = 0
                mem[_4942 + 128] = 0
                mem[_4942 + 160] = 0
                mem[_4942 + 192] = 0
                mem[_4942 + 224] = 0
                mem[var198001] = _4942
                s = var198001
                idx = var198002
                while idx - 1:
                    _4942 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4942] = 0
                    mem[_4942 + 32] = 96
                    mem[_4942 + 64] = 96
                    mem[_4942 + 96] = 0
                    mem[_4942 + 128] = 0
                    mem[_4942 + 160] = 0
                    mem[_4942 + 192] = 0
                    mem[_4942 + 224] = 0
                    mem[s + 32] = _4942
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3956]
                mem[_3956 + 32] = _3527
                require 1 < mem[_3956]
                mem[_3956 + 64] = _1777
                _5230 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5230] = 0
                mem[_5230 + 32] = 96
                mem[_5230 + 64] = 96
                mem[_5230 + 96] = 0
                mem[_5230 + 128] = 0
                mem[_5230 + 160] = 0
                mem[_5230 + 192] = 0
                mem[_5230 + 224] = 0
                require 0 < mem[_3956]
                _5508 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5508] = 0
                mem[_5508 + 32] = 96
                mem[_5508 + 64] = 96
                mem[_5508 + 96] = 0
                mem[_5508 + 128] = 0
                mem[_5508 + 160] = 0
                mem[_5508 + 192] = 0
                mem[_5508 + 224] = 0
                require 1 < mem[_3956]
                if mem[_3527 + 96] <= mem[_1777 + 96]:
                    idx = 12
                    s = mem[_3527 + 96]
                    while idx >= 4:
                        if not mem[_3527 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3527 + 96] - idx
                        continue 
                    _6175 = mem[_3527 + 96]
                    _6176 = mem[_3527 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6175 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6176 / 10^(_6175 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6176 / 10^(_6175 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6176 / 10^(_6175 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6176 / 10^(_6175 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6176 / 10^(_6175 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6176 / 10^(_6175 - s))
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _6177 = mem[_3527 + 96]
                _6178 = mem[_3527 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6177 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6178 / 10^(_6177 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6178 / 10^(_6177 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6178 / 10^(_6177 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6178 / 10^(_6177 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6178 / 10^(_6177 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6178 / 10^(_6177 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4004 = mem[64]
                mem[mem[64]] = 2
                _4941 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4941] = 0
                mem[_4941 + 32] = 96
                mem[_4941 + 64] = 96
                mem[_4941 + 96] = 0
                mem[_4941 + 128] = 0
                mem[_4941 + 160] = 0
                mem[_4941 + 192] = 0
                mem[_4941 + 224] = 0
                mem[var201001] = _4941
                s = var201001
                idx = var201002
                while idx - 1:
                    _4941 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4941] = 0
                    mem[_4941 + 32] = 96
                    mem[_4941 + 64] = 96
                    mem[_4941 + 96] = 0
                    mem[_4941 + 128] = 0
                    mem[_4941 + 160] = 0
                    mem[_4941 + 192] = 0
                    mem[_4941 + 224] = 0
                    mem[s + 32] = _4941
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4004]
                mem[_4004 + 32] = _3527
                require 1 < mem[_4004]
                mem[_4004 + 64] = _1777
                _5229 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5229] = 0
                mem[_5229 + 32] = 96
                mem[_5229 + 64] = 96
                mem[_5229 + 96] = 0
                mem[_5229 + 128] = 0
                mem[_5229 + 160] = 0
                mem[_5229 + 192] = 0
                mem[_5229 + 224] = 0
                require 0 < mem[_4004]
                _5507 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5507] = 0
                mem[_5507 + 32] = 96
                mem[_5507 + 64] = 96
                mem[_5507 + 96] = 0
                mem[_5507 + 128] = 0
                mem[_5507 + 160] = 0
                mem[_5507 + 192] = 0
                mem[_5507 + 224] = 0
                require 1 < mem[_4004]
                if mem[_3527 + 96] <= mem[_1777 + 96]:
                    idx = 12
                    s = mem[_3527 + 96]
                    while idx >= 4:
                        if not mem[_3527 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3527 + 96] - idx
                        continue 
                    _6171 = mem[_3527 + 96]
                    _6172 = mem[_3527 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6171 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1777 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                        if not _6172 / 10^(_6171 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6172 / 10^(_6171 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6172 / 10^(_6171 - s))
                    if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6172 / 10^(_6171 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6172 / 10^(_6171 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6172 / 10^(_6171 - s))
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _6173 = mem[_3527 + 96]
                _6174 = mem[_3527 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6173 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6174 / 10^(_6173 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6174 / 10^(_6173 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6174 / 10^(_6173 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6174 / 10^(_6173 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6174 / 10^(_6173 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6174 / 10^(_6173 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4407 = mem[64]
                mem[mem[64]] = 2
                _5978 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5978] = 0
                mem[_5978 + 32] = 96
                mem[_5978 + 64] = 96
                mem[_5978 + 96] = 0
                mem[_5978 + 128] = 0
                mem[_5978 + 160] = 0
                mem[_5978 + 192] = 0
                mem[_5978 + 224] = 0
                mem[var210001] = _5978
                s = var210001
                idx = var210002
                while idx - 1:
                    _5978 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5978] = 0
                    mem[_5978 + 32] = 96
                    mem[_5978 + 64] = 96
                    mem[_5978 + 96] = 0
                    mem[_5978 + 128] = 0
                    mem[_5978 + 160] = 0
                    mem[_5978 + 192] = 0
                    mem[_5978 + 224] = 0
                    mem[s + 32] = _5978
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4407]
                mem[_4407 + 32] = _3527
                require 1 < mem[_4407]
                mem[_4407 + 64] = _1777
                _6586 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6586] = 0
                mem[_6586 + 32] = 96
                mem[_6586 + 64] = 96
                mem[_6586 + 96] = 0
                mem[_6586 + 128] = 0
                mem[_6586 + 160] = 0
                mem[_6586 + 192] = 0
                mem[_6586 + 224] = 0
                require 0 < mem[_4407]
                _6970 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6970] = 0
                mem[_6970 + 32] = 96
                mem[_6970 + 64] = 96
                mem[_6970 + 96] = 0
                mem[_6970 + 128] = 0
                mem[_6970 + 160] = 0
                mem[_6970 + 192] = 0
                mem[_6970 + 224] = 0
                require 1 < mem[_4407]
                if mem[_3527 + 96] <= mem[_1777 + 96]:
                    idx = 12
                    s = mem[_3527 + 96]
                    while idx >= 4:
                        if not mem[_3527 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3527 + 96] - idx
                        continue 
                    _13049 = mem[_3527 + 96]
                    _13050 = mem[_3527 + 128]
                    _13135 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13135] = 26
                    mem[_13135 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13049 - s):
                        _13199 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13199 + 68] = mem[idx + _13135 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13199 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13199 + -mem[64] + 100
                    _14905 = mem[_1777 + 96]
                    _14906 = mem[_1777 + 128]
                    _15033 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15033] = 26
                    mem[_15033 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14905 - s):
                        _15119 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15119 + 68] = mem[idx + _15033 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15119 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15119 + -mem[64] + 100
                    if not _14906 / 10^(_14905 - s):
                        _15503 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15503] = 26
                        mem[_15503 + 32] = 'SafeMath: division by zero'
                        if not _13050 / 10^(_13049 - s):
                            _15780 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15780 + 68] = mem[idx + _15503 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15780 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15780 + -mem[64] + 100
                        _16313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16313] = 26
                        mem[_16313 + 32] = 'SafeMath: division by zero'
                        if 0 / _13050 / 10^(_13049 - s):
                            return (1000000 * 10^18 / 0 / _13050 / 10^(_13049 - s))
                        _16549 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16549 + 68] = mem[idx + _16313 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16549 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16549 + -mem[64] + 100
                    if 10^12 * _14906 / 10^(_14905 - s) / _14906 / 10^(_14905 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15779 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15779] = 26
                    mem[_15779 + 32] = 'SafeMath: division by zero'
                    if not _13050 / 10^(_13049 - s):
                        _15929 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15929 + 68] = mem[idx + _15779 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15929 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15929 + -mem[64] + 100
                    _16547 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16547] = 26
                    mem[_16547 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14906 / 10^(_14905 - s) / _13050 / 10^(_13049 - s):
                        return (1000000 * 10^18 / 10^12 * _14906 / 10^(_14905 - s) / _13050 / 10^(_13049 - s))
                    _16697 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16697 + 68] = mem[idx + _16547 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16697 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16697 + -mem[64] + 100
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _13051 = mem[_3527 + 96]
                _13052 = mem[_3527 + 128]
                _13136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13136] = 26
                mem[_13136 + 32] = 'SafeMath: division by zero'
                if not 10^(_13051 - s):
                    _13200 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13200 + 68] = mem[idx + _13136 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13200 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13200 + -mem[64] + 100
                _14907 = mem[_1777 + 96]
                _14908 = mem[_1777 + 128]
                _15035 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15035] = 26
                mem[_15035 + 32] = 'SafeMath: division by zero'
                if not 10^(_14907 - s):
                    _15120 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15120 + 68] = mem[idx + _15035 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15120 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15120 + -mem[64] + 100
                if not _14908 / 10^(_14907 - s):
                    _15504 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15504] = 26
                    mem[_15504 + 32] = 'SafeMath: division by zero'
                    if not _13052 / 10^(_13051 - s):
                        _15783 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15783 + 68] = mem[idx + _15504 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15783 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15783 + -mem[64] + 100
                    _16315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16315] = 26
                    mem[_16315 + 32] = 'SafeMath: division by zero'
                    if 0 / _13052 / 10^(_13051 - s):
                        return (1000000 * 10^18 / 0 / _13052 / 10^(_13051 - s))
                    _16552 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16552 + 68] = mem[idx + _16315 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16552 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16552 + -mem[64] + 100
                if 10^12 * _14908 / 10^(_14907 - s) / _14908 / 10^(_14907 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15782 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15782] = 26
                mem[_15782 + 32] = 'SafeMath: division by zero'
                if not _13052 / 10^(_13051 - s):
                    _15931 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15931 + 68] = mem[idx + _15782 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15931 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15931 + -mem[64] + 100
                _16550 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16550] = 26
                mem[_16550 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14908 / 10^(_14907 - s) / _13052 / 10^(_13051 - s):
                    return (1000000 * 10^18 / 10^12 * _14908 / 10^(_14907 - s) / _13052 / 10^(_13051 - s))
                _16699 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16699 + 68] = mem[idx + _16550 + 32]
                    idx = idx + 32
                    continue 
                mem[_16699 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16699 + -mem[64] + 100
            _4247 = mem[64]
            mem[mem[64]] = 2
            _5977 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5977] = 0
            mem[_5977 + 32] = 96
            mem[_5977 + 64] = 96
            mem[_5977 + 96] = 0
            mem[_5977 + 128] = 0
            mem[_5977 + 160] = 0
            mem[_5977 + 192] = 0
            mem[_5977 + 224] = 0
            mem[var206001] = _5977
            s = var206001
            idx = var206002
            while idx - 1:
                _5977 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5977] = 0
                mem[_5977 + 32] = 96
                mem[_5977 + 64] = 96
                mem[_5977 + 96] = 0
                mem[_5977 + 128] = 0
                mem[_5977 + 160] = 0
                mem[_5977 + 192] = 0
                mem[_5977 + 224] = 0
                mem[s + 32] = _5977
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4247]
            mem[_4247 + 32] = _1777
            require 1 < mem[_4247]
            mem[_4247 + 64] = _3527
            _6585 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6585] = 0
            mem[_6585 + 32] = 96
            mem[_6585 + 64] = 96
            mem[_6585 + 96] = 0
            mem[_6585 + 128] = 0
            mem[_6585 + 160] = 0
            mem[_6585 + 192] = 0
            mem[_6585 + 224] = 0
            require 0 < mem[_4247]
            _6969 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6969] = 0
            mem[_6969 + 32] = 96
            mem[_6969 + 64] = 96
            mem[_6969 + 96] = 0
            mem[_6969 + 128] = 0
            mem[_6969 + 160] = 0
            mem[_6969 + 192] = 0
            mem[_6969 + 224] = 0
            require 1 < mem[_4247]
            if mem[_1777 + 96] <= mem[_3527 + 96]:
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _13045 = mem[_1777 + 96]
                _13046 = mem[_1777 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13045 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3527 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3527 + 128] / 10^(mem[_3527 + 96] - s):
                    if not _13046 / 10^(_13045 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13046 / 10^(_13045 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13046 / 10^(_13045 - s))
                if 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13046 / 10^(_13045 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / _13046 / 10^(_13045 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / _13046 / 10^(_13045 - s))
            idx = 12
            s = mem[_3527 + 96]
            while idx >= 4:
                if not mem[_3527 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3527 + 96] - idx
                continue 
            _13047 = mem[_1777 + 96]
            _13048 = mem[_1777 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13047 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3527 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3527 + 128] / 10^(mem[_3527 + 96] - s):
                if not _13048 / 10^(_13047 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13048 / 10^(_13047 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13048 / 10^(_13047 - s))
            if 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13048 / 10^(_13047 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / _13048 / 10^(_13047 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3527 + 128] / 10^(mem[_3527 + 96] - s) / _13048 / 10^(_13047 - s))
        mem[_2635 + ceil32(return_data.size) + _2651 + 32] = 0
        require ext_code.size(address(_1798))
        staticcall address(_1798).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3442 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3458 = mem[_3442]
        require mem[_3442] == mem[_3442 + 31 len 1]
        require ext_code.size(address(_1798))
        staticcall address(_1798).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3506 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3528 = mem[_3506]
        _3550 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3550] = address(_1798)
        mem[_3550 + 32] = _1814 + ceil32(return_data.size)
        mem[_3550 + 64] = _2635 + ceil32(return_data.size)
        mem[_3550 + 96] = uint8(_3458)
        mem[_3550 + 128] = 0
        mem[_3550 + 160] = _3528
        mem[_3550 + 192] = 0
        mem[_3550 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3586 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3602 = mem[_3586]
        require mem[_3586] == mem[_3586 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3602))
        staticcall address(_3602).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3650 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_1777 + 128] = mem[_3650]
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3714 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3730 = mem[_3714]
        require mem[_3714] == mem[_3714 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3730))
        staticcall address(_3730).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3778 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_3550 + 128] = mem[_3778]
        _3810 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3810] = 0
        mem[_3810 + 32] = 96
        mem[_3810 + 64] = 96
        mem[_3810 + 96] = 0
        mem[_3810 + 128] = 0
        mem[_3810 + 160] = 0
        mem[_3810 + 192] = 0
        mem[_3810 + 224] = 0
        _3832 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3832] = 0
        mem[_3832 + 32] = 96
        mem[_3832 + 64] = 96
        mem[_3832 + 96] = 0
        mem[_3832 + 128] = 0
        mem[_3832 + 160] = 0
        mem[_3832 + 192] = 0
        mem[_3832 + 224] = 0
        if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
            _3874 = mem[64]
            mem[mem[64]] = 2
            _4948 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4948] = 0
            mem[_4948 + 32] = 96
            mem[_4948 + 64] = 96
            mem[_4948 + 96] = 0
            mem[_4948 + 128] = 0
            mem[_4948 + 160] = 0
            mem[_4948 + 192] = 0
            mem[_4948 + 224] = 0
            mem[var192001] = _4948
            s = var192001
            idx = var192002
            while idx - 1:
                _4948 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4948] = 0
                mem[_4948 + 32] = 96
                mem[_4948 + 64] = 96
                mem[_4948 + 96] = 0
                mem[_4948 + 128] = 0
                mem[_4948 + 160] = 0
                mem[_4948 + 192] = 0
                mem[_4948 + 224] = 0
                mem[s + 32] = _4948
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3874]
            mem[_3874 + 32] = _3550
            require 1 < mem[_3874]
            mem[_3874 + 64] = _1777
            _5236 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5236] = 0
            mem[_5236 + 32] = 96
            mem[_5236 + 64] = 96
            mem[_5236 + 96] = 0
            mem[_5236 + 128] = 0
            mem[_5236 + 160] = 0
            mem[_5236 + 192] = 0
            mem[_5236 + 224] = 0
            require 0 < mem[_3874]
            _5516 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5516] = 0
            mem[_5516 + 32] = 96
            mem[_5516 + 64] = 96
            mem[_5516 + 96] = 0
            mem[_5516 + 128] = 0
            mem[_5516 + 160] = 0
            mem[_5516 + 192] = 0
            mem[_5516 + 224] = 0
            require 1 < mem[_3874]
            if mem[_3550 + 96] <= mem[_1777 + 96]:
                idx = 12
                s = mem[_3550 + 96]
                while idx >= 4:
                    if not mem[_3550 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3550 + 96] - idx
                    continue 
                _6201 = mem[_3550 + 96]
                _6202 = mem[_3550 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6201 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6202 / 10^(_6201 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6202 / 10^(_6201 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6202 / 10^(_6201 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6202 / 10^(_6201 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6202 / 10^(_6201 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6202 / 10^(_6201 - s))
            idx = 12
            s = mem[_1777 + 96]
            while idx >= 4:
                if not mem[_1777 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1777 + 96] - idx
                continue 
            _6203 = mem[_3550 + 96]
            _6204 = mem[_3550 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6203 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1777 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                if not _6204 / 10^(_6203 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6204 / 10^(_6203 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6204 / 10^(_6203 - s))
            if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6204 / 10^(_6203 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6204 / 10^(_6203 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6204 / 10^(_6203 - s))
        if wbnbAddress == address(_1798):
            _3922 = mem[64]
            mem[mem[64]] = 2
            _4947 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4947] = 0
            mem[_4947 + 32] = 96
            mem[_4947 + 64] = 96
            mem[_4947 + 96] = 0
            mem[_4947 + 128] = 0
            mem[_4947 + 160] = 0
            mem[_4947 + 192] = 0
            mem[_4947 + 224] = 0
            mem[var196001] = _4947
            s = var196001
            idx = var196002
            while idx - 1:
                _4947 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4947] = 0
                mem[_4947 + 32] = 96
                mem[_4947 + 64] = 96
                mem[_4947 + 96] = 0
                mem[_4947 + 128] = 0
                mem[_4947 + 160] = 0
                mem[_4947 + 192] = 0
                mem[_4947 + 224] = 0
                mem[s + 32] = _4947
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3922]
            mem[_3922 + 32] = _1777
            require 1 < mem[_3922]
            mem[_3922 + 64] = _3550
            _5235 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5235] = 0
            mem[_5235 + 32] = 96
            mem[_5235 + 64] = 96
            mem[_5235 + 96] = 0
            mem[_5235 + 128] = 0
            mem[_5235 + 160] = 0
            mem[_5235 + 192] = 0
            mem[_5235 + 224] = 0
            require 0 < mem[_3922]
            _5515 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5515] = 0
            mem[_5515 + 32] = 96
            mem[_5515 + 64] = 96
            mem[_5515 + 96] = 0
            mem[_5515 + 128] = 0
            mem[_5515 + 160] = 0
            mem[_5515 + 192] = 0
            mem[_5515 + 224] = 0
            require 1 < mem[_3922]
            if mem[_1777 + 96] <= mem[_3550 + 96]:
                idx = 12
                s = mem[_1777 + 96]
                while idx >= 4:
                    if not mem[_1777 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1777 + 96] - idx
                    continue 
                _6197 = mem[_1777 + 96]
                _6198 = mem[_1777 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6197 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3550 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3550 + 128] / 10^(mem[_3550 + 96] - s):
                    if not _6198 / 10^(_6197 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6198 / 10^(_6197 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6198 / 10^(_6197 - s))
                if 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6198 / 10^(_6197 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / _6198 / 10^(_6197 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / _6198 / 10^(_6197 - s))
            idx = 12
            s = mem[_3550 + 96]
            while idx >= 4:
                if not mem[_3550 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3550 + 96] - idx
                continue 
            _6199 = mem[_1777 + 96]
            _6200 = mem[_1777 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6199 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3550 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3550 + 128] / 10^(mem[_3550 + 96] - s):
                if not _6200 / 10^(_6199 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6200 / 10^(_6199 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6200 / 10^(_6199 - s))
            if 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6200 / 10^(_6199 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / _6200 / 10^(_6199 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / _6200 / 10^(_6199 - s))
        if busdAddress == uint64(ext_call.return_data[0]) << 96:
            _3970 = mem[64]
            mem[mem[64]] = 2
            _4946 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4946] = 0
            mem[_4946 + 32] = 96
            mem[_4946 + 64] = 96
            mem[_4946 + 96] = 0
            mem[_4946 + 128] = 0
            mem[_4946 + 160] = 0
            mem[_4946 + 192] = 0
            mem[_4946 + 224] = 0
            mem[var199001] = _4946
            s = var199001
            idx = var199002
            while idx - 1:
                _4946 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4946] = 0
                mem[_4946 + 32] = 96
                mem[_4946 + 64] = 96
                mem[_4946 + 96] = 0
                mem[_4946 + 128] = 0
                mem[_4946 + 160] = 0
                mem[_4946 + 192] = 0
                mem[_4946 + 224] = 0
                mem[s + 32] = _4946
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3970]
            mem[_3970 + 32] = _3550
            require 1 < mem[_3970]
            mem[_3970 + 64] = _1777
            _5234 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5234] = 0
            mem[_5234 + 32] = 96
            mem[_5234 + 64] = 96
            mem[_5234 + 96] = 0
            mem[_5234 + 128] = 0
            mem[_5234 + 160] = 0
            mem[_5234 + 192] = 0
            mem[_5234 + 224] = 0
            require 0 < mem[_3970]
            _5514 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5514] = 0
            mem[_5514 + 32] = 96
            mem[_5514 + 64] = 96
            mem[_5514 + 96] = 0
            mem[_5514 + 128] = 0
            mem[_5514 + 160] = 0
            mem[_5514 + 192] = 0
            mem[_5514 + 224] = 0
            require 1 < mem[_3970]
            if mem[_3550 + 96] <= mem[_1777 + 96]:
                idx = 12
                s = mem[_3550 + 96]
                while idx >= 4:
                    if not mem[_3550 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3550 + 96] - idx
                    continue 
                _6193 = mem[_3550 + 96]
                _6194 = mem[_3550 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6193 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6194 / 10^(_6193 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6194 / 10^(_6193 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6194 / 10^(_6193 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6194 / 10^(_6193 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6194 / 10^(_6193 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6194 / 10^(_6193 - s))
            idx = 12
            s = mem[_1777 + 96]
            while idx >= 4:
                if not mem[_1777 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1777 + 96] - idx
                continue 
            _6195 = mem[_3550 + 96]
            _6196 = mem[_3550 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6195 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1777 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                if not _6196 / 10^(_6195 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6196 / 10^(_6195 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6196 / 10^(_6195 - s))
            if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6196 / 10^(_6195 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6196 / 10^(_6195 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6196 / 10^(_6195 - s))
        if usdtAddress == uint64(ext_call.return_data[0]) << 96:
            _4018 = mem[64]
            mem[mem[64]] = 2
            _4945 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4945] = 0
            mem[_4945 + 32] = 96
            mem[_4945 + 64] = 96
            mem[_4945 + 96] = 0
            mem[_4945 + 128] = 0
            mem[_4945 + 160] = 0
            mem[_4945 + 192] = 0
            mem[_4945 + 224] = 0
            mem[var202001] = _4945
            s = var202001
            idx = var202002
            while idx - 1:
                _4945 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4945] = 0
                mem[_4945 + 32] = 96
                mem[_4945 + 64] = 96
                mem[_4945 + 96] = 0
                mem[_4945 + 128] = 0
                mem[_4945 + 160] = 0
                mem[_4945 + 192] = 0
                mem[_4945 + 224] = 0
                mem[s + 32] = _4945
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4018]
            mem[_4018 + 32] = _3550
            require 1 < mem[_4018]
            mem[_4018 + 64] = _1777
            _5233 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5233] = 0
            mem[_5233 + 32] = 96
            mem[_5233 + 64] = 96
            mem[_5233 + 96] = 0
            mem[_5233 + 128] = 0
            mem[_5233 + 160] = 0
            mem[_5233 + 192] = 0
            mem[_5233 + 224] = 0
            require 0 < mem[_4018]
            _5513 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5513] = 0
            mem[_5513 + 32] = 96
            mem[_5513 + 64] = 96
            mem[_5513 + 96] = 0
            mem[_5513 + 128] = 0
            mem[_5513 + 160] = 0
            mem[_5513 + 192] = 0
            mem[_5513 + 224] = 0
            require 1 < mem[_4018]
            if mem[_3550 + 96] <= mem[_1777 + 96]:
                idx = 12
                s = mem[_3550 + 96]
                while idx >= 4:
                    if not mem[_3550 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3550 + 96] - idx
                    continue 
                _6189 = mem[_3550 + 96]
                _6190 = mem[_3550 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6189 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1777 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                    if not _6190 / 10^(_6189 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6190 / 10^(_6189 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6190 / 10^(_6189 - s))
                if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6190 / 10^(_6189 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6190 / 10^(_6189 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6190 / 10^(_6189 - s))
            idx = 12
            s = mem[_1777 + 96]
            while idx >= 4:
                if not mem[_1777 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1777 + 96] - idx
                continue 
            _6191 = mem[_3550 + 96]
            _6192 = mem[_3550 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6191 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1777 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1777 + 128] / 10^(mem[_1777 + 96] - s):
                if not _6192 / 10^(_6191 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6192 / 10^(_6191 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6192 / 10^(_6191 - s))
            if 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6192 / 10^(_6191 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6192 / 10^(_6191 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1777 + 128] / 10^(mem[_1777 + 96] - s) / _6192 / 10^(_6191 - s))
        idx = 0
        while idx < sub_27d312da.length:
            mem[0] = 1
            if sub_27d312da[idx] != address(ext_call.return_data[0]):
                idx = idx + 1
                continue 
            _4412 = mem[64]
            mem[mem[64]] = 2
            _5980 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5980] = 0
            mem[_5980 + 32] = 96
            mem[_5980 + 64] = 96
            mem[_5980 + 96] = 0
            mem[_5980 + 128] = 0
            mem[_5980 + 160] = 0
            mem[_5980 + 192] = 0
            mem[_5980 + 224] = 0
            mem[var211001] = _5980
            s = var211001
            idx = var211002
            while idx - 1:
                _5980 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5980] = 0
                mem[_5980 + 32] = 96
                mem[_5980 + 64] = 96
                mem[_5980 + 96] = 0
                mem[_5980 + 128] = 0
                mem[_5980 + 160] = 0
                mem[_5980 + 192] = 0
                mem[_5980 + 224] = 0
                mem[s + 32] = _5980
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4412]
            mem[_4412 + 32] = _3550
            require 1 < mem[_4412]
            mem[_4412 + 64] = _1777
            _6588 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6588] = 0
            mem[_6588 + 32] = 96
            mem[_6588 + 64] = 96
            mem[_6588 + 96] = 0
            mem[_6588 + 128] = 0
            mem[_6588 + 160] = 0
            mem[_6588 + 192] = 0
            mem[_6588 + 224] = 0
            require 0 < mem[_4412]
            _6988 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6988] = 0
            mem[_6988 + 32] = 96
            mem[_6988 + 64] = 96
            mem[_6988 + 96] = 0
            mem[_6988 + 128] = 0
            mem[_6988 + 160] = 0
            mem[_6988 + 192] = 0
            mem[_6988 + 224] = 0
            require 1 < mem[_4412]
            if mem[_3550 + 96] <= mem[_1777 + 96]:
                idx = 12
                s = mem[_3550 + 96]
                while idx >= 4:
                    if not mem[_3550 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3550 + 96] - idx
                    continue 
                _13057 = mem[_3550 + 96]
                _13058 = mem[_3550 + 128]
                _13139 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13139] = 26
                mem[_13139 + 32] = 'SafeMath: division by zero'
                if not 10^(_13057 - s):
                    _13203 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13203 + 68] = mem[idx + _13139 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13203 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13203 + -mem[64] + 100
                _14913 = mem[_1777 + 96]
                _14914 = mem[_1777 + 128]
                _15041 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15041] = 26
                mem[_15041 + 32] = 'SafeMath: division by zero'
                if not 10^(_14913 - s):
                    _15123 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15123 + 68] = mem[idx + _15041 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15123 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15123 + -mem[64] + 100
                if not _14914 / 10^(_14913 - s):
                    _15507 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15507] = 26
                    mem[_15507 + 32] = 'SafeMath: division by zero'
                    if not _13058 / 10^(_13057 - s):
                        _15792 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15792 + 68] = mem[idx + _15507 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15792 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15792 + -mem[64] + 100
                    _16321 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16321] = 26
                    mem[_16321 + 32] = 'SafeMath: division by zero'
                    if 0 / _13058 / 10^(_13057 - s):
                        return (1000000 * 10^18 / 0 / _13058 / 10^(_13057 - s))
                    _16561 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16561 + 68] = mem[idx + _16321 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16561 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16561 + -mem[64] + 100
                if 10^12 * _14914 / 10^(_14913 - s) / _14914 / 10^(_14913 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15791 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15791] = 26
                mem[_15791 + 32] = 'SafeMath: division by zero'
                if not _13058 / 10^(_13057 - s):
                    _15937 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15937 + 68] = mem[idx + _15791 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15937 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15937 + -mem[64] + 100
                _16559 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16559] = 26
                mem[_16559 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14914 / 10^(_14913 - s) / _13058 / 10^(_13057 - s):
                    return (1000000 * 10^18 / 10^12 * _14914 / 10^(_14913 - s) / _13058 / 10^(_13057 - s))
                _16705 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16705 + 68] = mem[idx + _16559 + 32]
                    idx = idx + 32
                    continue 
                mem[_16705 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16705 + -mem[64] + 100
            idx = 12
            s = mem[_1777 + 96]
            while idx >= 4:
                if not mem[_1777 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1777 + 96] - idx
                continue 
            _13059 = mem[_3550 + 96]
            _13060 = mem[_3550 + 128]
            _13140 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13140] = 26
            mem[_13140 + 32] = 'SafeMath: division by zero'
            if not 10^(_13059 - s):
                _13204 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13204 + 68] = mem[idx + _13140 + 32]
                    idx = idx + 32
                    continue 
                mem[_13204 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13204 + -mem[64] + 100
            _14915 = mem[_1777 + 96]
            _14916 = mem[_1777 + 128]
            _15043 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15043] = 26
            mem[_15043 + 32] = 'SafeMath: division by zero'
            if not 10^(_14915 - s):
                _15124 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15124 + 68] = mem[idx + _15043 + 32]
                    idx = idx + 32
                    continue 
                mem[_15124 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15124 + -mem[64] + 100
            if not _14916 / 10^(_14915 - s):
                _15508 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15508] = 26
                mem[_15508 + 32] = 'SafeMath: division by zero'
                if not _13060 / 10^(_13059 - s):
                    _15795 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15795 + 68] = mem[idx + _15508 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15795 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15795 + -mem[64] + 100
                _16323 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16323] = 26
                mem[_16323 + 32] = 'SafeMath: division by zero'
                if 0 / _13060 / 10^(_13059 - s):
                    return (1000000 * 10^18 / 0 / _13060 / 10^(_13059 - s))
                _16564 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16564 + 68] = mem[idx + _16323 + 32]
                    idx = idx + 32
                    continue 
                mem[_16564 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16564 + -mem[64] + 100
            if 10^12 * _14916 / 10^(_14915 - s) / _14916 / 10^(_14915 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15794 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15794] = 26
            mem[_15794 + 32] = 'SafeMath: division by zero'
            if not _13060 / 10^(_13059 - s):
                _15939 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15939 + 68] = mem[idx + _15794 + 32]
                    idx = idx + 32
                    continue 
                mem[_15939 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15939 + -mem[64] + 100
            _16562 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16562] = 26
            mem[_16562 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14916 / 10^(_14915 - s) / _13060 / 10^(_13059 - s):
                return (1000000 * 10^18 / 10^12 * _14916 / 10^(_14915 - s) / _13060 / 10^(_13059 - s))
            _16707 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16707 + 68] = mem[idx + _16562 + 32]
                idx = idx + 32
                continue 
            mem[_16707 + 94] = 0
            revert with memory
              from mem[64]
               len _16707 + -mem[64] + 100
        _4252 = mem[64]
        mem[mem[64]] = 2
        _5979 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_5979] = 0
        mem[_5979 + 32] = 96
        mem[_5979 + 64] = 96
        mem[_5979 + 96] = 0
        mem[_5979 + 128] = 0
        mem[_5979 + 160] = 0
        mem[_5979 + 192] = 0
        mem[_5979 + 224] = 0
        mem[var207001] = _5979
        s = var207001
        idx = var207002
        while idx - 1:
            _5979 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5979] = 0
            mem[_5979 + 32] = 96
            mem[_5979 + 64] = 96
            mem[_5979 + 96] = 0
            mem[_5979 + 128] = 0
            mem[_5979 + 160] = 0
            mem[_5979 + 192] = 0
            mem[_5979 + 224] = 0
            mem[s + 32] = _5979
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4252]
        mem[_4252 + 32] = _1777
        require 1 < mem[_4252]
        mem[_4252 + 64] = _3550
        _6587 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6587] = 0
        mem[_6587 + 32] = 96
        mem[_6587 + 64] = 96
        mem[_6587 + 96] = 0
        mem[_6587 + 128] = 0
        mem[_6587 + 160] = 0
        mem[_6587 + 192] = 0
        mem[_6587 + 224] = 0
        require 0 < mem[_4252]
        _6987 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6987] = 0
        mem[_6987 + 32] = 96
        mem[_6987 + 64] = 96
        mem[_6987 + 96] = 0
        mem[_6987 + 128] = 0
        mem[_6987 + 160] = 0
        mem[_6987 + 192] = 0
        mem[_6987 + 224] = 0
        require 1 < mem[_4252]
        if mem[_1777 + 96] <= mem[_3550 + 96]:
            idx = 12
            s = mem[_1777 + 96]
            while idx >= 4:
                if not mem[_1777 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1777 + 96] - idx
                continue 
            _13053 = mem[_1777 + 96]
            _13054 = mem[_1777 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13053 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3550 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3550 + 128] / 10^(mem[_3550 + 96] - s):
                if not _13054 / 10^(_13053 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13054 / 10^(_13053 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13054 / 10^(_13053 - s))
            if 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13054 / 10^(_13053 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / _13054 / 10^(_13053 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / _13054 / 10^(_13053 - s))
        idx = 12
        s = mem[_3550 + 96]
        while idx >= 4:
            if not mem[_3550 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3550 + 96] - idx
            continue 
        _13055 = mem[_1777 + 96]
        _13056 = mem[_1777 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13055 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3550 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3550 + 128] / 10^(mem[_3550 + 96] - s):
            if not _13056 / 10^(_13055 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13056 / 10^(_13055 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13056 / 10^(_13055 - s))
        if 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13056 / 10^(_13055 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / _13056 / 10^(_13055 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3550 + 128] / 10^(mem[_3550 + 96] - s) / _13056 / 10^(_13055 - s))
    mem[_870 + ceil32(return_data.size) + _874 + 32] = 0
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x313ce567 with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1756 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1760 = mem[_1756]
    require mem[_1756] == mem[_1756 + 31 len 1]
    require ext_code.size(address(ext_call.return_data[0]))
    staticcall address(ext_call.return_data[0]).0x18160ddd with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1772 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1778 = mem[_1772]
    _1780 = mem[64]
    mem[64] = mem[64] + 256
    mem[_1780] = address(ext_call.return_data[0])
    mem[_1780 + 32] = (2 * ceil32(return_data.size)) + 608
    mem[_1780 + 64] = _870 + ceil32(return_data.size)
    mem[_1780 + 96] = uint8(_1760)
    mem[_1780 + 128] = 0
    mem[_1780 + 160] = _1778
    mem[_1780 + 192] = 0
    mem[_1780 + 224] = 0
    _1788 = mem[64]
    mem[64] = mem[64] + 256
    mem[_1788] = 0
    mem[_1788 + 32] = 96
    mem[_1788 + 64] = 96
    mem[_1788 + 96] = 0
    mem[_1788 + 128] = 0
    mem[_1788 + 160] = 0
    mem[_1788 + 192] = 0
    mem[_1788 + 224] = 0
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1796 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1800 = mem[_1796]
    require mem[_1796] == mem[_1796 + 12 len 20]
    _1808 = mem[64]
    mem[64] = mem[64] + 256
    mem[_1808] = 0
    mem[_1808 + 32] = 96
    mem[_1808 + 64] = 96
    mem[_1808 + 96] = 0
    mem[_1808 + 128] = 0
    mem[_1808 + 160] = 0
    mem[_1808 + 192] = 0
    mem[_1808 + 224] = 0
    mem[mem[64]] = 0x6fdde0300000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(_1800))
    staticcall address(_1800).name() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1816 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _1820 = mem[_1816]
    require mem[_1816] <= test266151307()
    require _1816 + return_data.size > _1816 + mem[_1816] + 31
    _1824 = mem[_1816 + mem[_1816]]
    require mem[_1816 + mem[_1816]] <= test266151307()
    require ceil32(mem[_1816 + mem[_1816]]) + 32 >= 0 and _1816 + ceil32(return_data.size) + ceil32(mem[_1816 + mem[_1816]]) + 32 <= test266151307()
    mem[64] = _1816 + ceil32(return_data.size) + ceil32(mem[_1816 + mem[_1816]]) + 32
    mem[_1816 + ceil32(return_data.size)] = _1824
    require _1820 + _1824 + 32 <= return_data.size
    mem[_1816 + ceil32(return_data.size) + 32 len ceil32(_1824)] = mem[_1816 + _1820 + 32 len ceil32(_1824)]
    if ceil32(_1824) <= _1824:
        mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
        require ext_code.size(address(_1800))
        staticcall address(_1800).0x95d89b41 with:
                gas gas_remaining wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2632 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2640 = mem[_2632]
        require mem[_2632] <= test266151307()
        require _2632 + return_data.size > _2632 + mem[_2632] + 31
        _2648 = mem[_2632 + mem[_2632]]
        require mem[_2632 + mem[_2632]] <= test266151307()
        require ceil32(mem[_2632 + mem[_2632]]) + 32 >= 0 and _2632 + ceil32(return_data.size) + ceil32(mem[_2632 + mem[_2632]]) + 32 <= test266151307()
        mem[64] = _2632 + ceil32(return_data.size) + ceil32(mem[_2632 + mem[_2632]]) + 32
        mem[_2632 + ceil32(return_data.size)] = _2648
        require _2640 + _2648 + 32 <= return_data.size
        mem[_2632 + ceil32(return_data.size) + 32 len ceil32(_2648)] = mem[_2632 + _2640 + 32 len ceil32(_2648)]
        if ceil32(_2648) <= _2648:
            require ext_code.size(address(_1800))
            staticcall address(_1800).0x313ce567 with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3435 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3451 = mem[_3435]
            require mem[_3435] == mem[_3435 + 31 len 1]
            require ext_code.size(address(_1800))
            staticcall address(_1800).0x18160ddd with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3499 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3515 = mem[_3499]
            _3529 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3529] = address(_1800)
            mem[_3529 + 32] = _1816 + ceil32(return_data.size)
            mem[_3529 + 64] = _2632 + ceil32(return_data.size)
            mem[_3529 + 96] = uint8(_3451)
            mem[_3529 + 128] = 0
            mem[_3529 + 160] = _3515
            mem[_3529 + 192] = 0
            mem[_3529 + 224] = 0
            require ext_code.size(arg1)
            staticcall arg1.token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3579 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3595 = mem[_3579]
            require mem[_3579] == mem[_3579 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3595))
            staticcall address(_3595).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3643 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_1780 + 128] = mem[_3643]
            require ext_code.size(arg1)
            staticcall arg1.token1() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3707 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3723 = mem[_3707]
            require mem[_3707] == mem[_3707 + 12 len 20]
            mem[mem[64] + 4] = arg1
            require ext_code.size(address(_3723))
            staticcall address(_3723).0x70a08231 with:
                    gas gas_remaining wei
                   args address(arg1)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3771 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[_3529 + 128] = mem[_3771]
            _3803 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3803] = 0
            mem[_3803 + 32] = 96
            mem[_3803 + 64] = 96
            mem[_3803 + 96] = 0
            mem[_3803 + 128] = 0
            mem[_3803 + 160] = 0
            mem[_3803 + 192] = 0
            mem[_3803 + 224] = 0
            _3819 = mem[64]
            mem[64] = mem[64] + 256
            mem[_3819] = 0
            mem[_3819 + 32] = 96
            mem[_3819 + 64] = 96
            mem[_3819 + 96] = 0
            mem[_3819 + 128] = 0
            mem[_3819 + 160] = 0
            mem[_3819 + 192] = 0
            mem[_3819 + 224] = 0
            if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
                _3865 = mem[64]
                mem[mem[64]] = 2
                _4952 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4952] = 0
                mem[_4952 + 32] = 96
                mem[_4952 + 64] = 96
                mem[_4952 + 96] = 0
                mem[_4952 + 128] = 0
                mem[_4952 + 160] = 0
                mem[_4952 + 192] = 0
                mem[_4952 + 224] = 0
                mem[var191001] = _4952
                s = var191001
                idx = var191002
                while idx - 1:
                    _4952 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4952] = 0
                    mem[_4952 + 32] = 96
                    mem[_4952 + 64] = 96
                    mem[_4952 + 96] = 0
                    mem[_4952 + 128] = 0
                    mem[_4952 + 160] = 0
                    mem[_4952 + 192] = 0
                    mem[_4952 + 224] = 0
                    mem[s + 32] = _4952
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3865]
                mem[_3865 + 32] = _3529
                require 1 < mem[_3865]
                mem[_3865 + 64] = _1780
                _5240 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5240] = 0
                mem[_5240 + 32] = 96
                mem[_5240 + 64] = 96
                mem[_5240 + 96] = 0
                mem[_5240 + 128] = 0
                mem[_5240 + 160] = 0
                mem[_5240 + 192] = 0
                mem[_5240 + 224] = 0
                require 0 < mem[_3865]
                _5522 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5522] = 0
                mem[_5522 + 32] = 96
                mem[_5522 + 64] = 96
                mem[_5522 + 96] = 0
                mem[_5522 + 128] = 0
                mem[_5522 + 160] = 0
                mem[_5522 + 192] = 0
                mem[_5522 + 224] = 0
                require 1 < mem[_3865]
                if mem[_3529 + 96] <= mem[_1780 + 96]:
                    idx = 12
                    s = mem[_3529 + 96]
                    while idx >= 4:
                        if not mem[_3529 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3529 + 96] - idx
                        continue 
                    _6219 = mem[_3529 + 96]
                    _6220 = mem[_3529 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6219 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1780 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                        if not _6220 / 10^(_6219 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6220 / 10^(_6219 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6220 / 10^(_6219 - s))
                    if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6220 / 10^(_6219 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6220 / 10^(_6219 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6220 / 10^(_6219 - s))
                idx = 12
                s = mem[_1780 + 96]
                while idx >= 4:
                    if not mem[_1780 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1780 + 96] - idx
                    continue 
                _6221 = mem[_3529 + 96]
                _6222 = mem[_3529 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6221 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6222 / 10^(_6221 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6222 / 10^(_6221 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6222 / 10^(_6221 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6222 / 10^(_6221 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6222 / 10^(_6221 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6222 / 10^(_6221 - s))
            if wbnbAddress == address(_1800):
                _3913 = mem[64]
                mem[mem[64]] = 2
                _4951 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4951] = 0
                mem[_4951 + 32] = 96
                mem[_4951 + 64] = 96
                mem[_4951 + 96] = 0
                mem[_4951 + 128] = 0
                mem[_4951 + 160] = 0
                mem[_4951 + 192] = 0
                mem[_4951 + 224] = 0
                mem[var195001] = _4951
                s = var195001
                idx = var195002
                while idx - 1:
                    _4951 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4951] = 0
                    mem[_4951 + 32] = 96
                    mem[_4951 + 64] = 96
                    mem[_4951 + 96] = 0
                    mem[_4951 + 128] = 0
                    mem[_4951 + 160] = 0
                    mem[_4951 + 192] = 0
                    mem[_4951 + 224] = 0
                    mem[s + 32] = _4951
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3913]
                mem[_3913 + 32] = _1780
                require 1 < mem[_3913]
                mem[_3913 + 64] = _3529
                _5239 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5239] = 0
                mem[_5239 + 32] = 96
                mem[_5239 + 64] = 96
                mem[_5239 + 96] = 0
                mem[_5239 + 128] = 0
                mem[_5239 + 160] = 0
                mem[_5239 + 192] = 0
                mem[_5239 + 224] = 0
                require 0 < mem[_3913]
                _5521 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5521] = 0
                mem[_5521 + 32] = 96
                mem[_5521 + 64] = 96
                mem[_5521 + 96] = 0
                mem[_5521 + 128] = 0
                mem[_5521 + 160] = 0
                mem[_5521 + 192] = 0
                mem[_5521 + 224] = 0
                require 1 < mem[_3913]
                if mem[_1780 + 96] <= mem[_3529 + 96]:
                    idx = 12
                    s = mem[_1780 + 96]
                    while idx >= 4:
                        if not mem[_1780 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_1780 + 96] - idx
                        continue 
                    _6215 = mem[_1780 + 96]
                    _6216 = mem[_1780 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6215 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_3529 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_3529 + 128] / 10^(mem[_3529 + 96] - s):
                        if not _6216 / 10^(_6215 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6216 / 10^(_6215 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6216 / 10^(_6215 - s))
                    if 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6216 / 10^(_6215 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / _6216 / 10^(_6215 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / _6216 / 10^(_6215 - s))
                idx = 12
                s = mem[_3529 + 96]
                while idx >= 4:
                    if not mem[_3529 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3529 + 96] - idx
                    continue 
                _6217 = mem[_1780 + 96]
                _6218 = mem[_1780 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6217 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3529 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3529 + 128] / 10^(mem[_3529 + 96] - s):
                    if not _6218 / 10^(_6217 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6218 / 10^(_6217 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6218 / 10^(_6217 - s))
                if 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6218 / 10^(_6217 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / _6218 / 10^(_6217 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / _6218 / 10^(_6217 - s))
            if busdAddress == uint64(ext_call.return_data[0]) << 96:
                _3959 = mem[64]
                mem[mem[64]] = 2
                _4950 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4950] = 0
                mem[_4950 + 32] = 96
                mem[_4950 + 64] = 96
                mem[_4950 + 96] = 0
                mem[_4950 + 128] = 0
                mem[_4950 + 160] = 0
                mem[_4950 + 192] = 0
                mem[_4950 + 224] = 0
                mem[var198001] = _4950
                s = var198001
                idx = var198002
                while idx - 1:
                    _4950 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4950] = 0
                    mem[_4950 + 32] = 96
                    mem[_4950 + 64] = 96
                    mem[_4950 + 96] = 0
                    mem[_4950 + 128] = 0
                    mem[_4950 + 160] = 0
                    mem[_4950 + 192] = 0
                    mem[_4950 + 224] = 0
                    mem[s + 32] = _4950
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_3959]
                mem[_3959 + 32] = _3529
                require 1 < mem[_3959]
                mem[_3959 + 64] = _1780
                _5238 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5238] = 0
                mem[_5238 + 32] = 96
                mem[_5238 + 64] = 96
                mem[_5238 + 96] = 0
                mem[_5238 + 128] = 0
                mem[_5238 + 160] = 0
                mem[_5238 + 192] = 0
                mem[_5238 + 224] = 0
                require 0 < mem[_3959]
                _5520 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5520] = 0
                mem[_5520 + 32] = 96
                mem[_5520 + 64] = 96
                mem[_5520 + 96] = 0
                mem[_5520 + 128] = 0
                mem[_5520 + 160] = 0
                mem[_5520 + 192] = 0
                mem[_5520 + 224] = 0
                require 1 < mem[_3959]
                if mem[_3529 + 96] <= mem[_1780 + 96]:
                    idx = 12
                    s = mem[_3529 + 96]
                    while idx >= 4:
                        if not mem[_3529 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3529 + 96] - idx
                        continue 
                    _6211 = mem[_3529 + 96]
                    _6212 = mem[_3529 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6211 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1780 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                        if not _6212 / 10^(_6211 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6212 / 10^(_6211 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6212 / 10^(_6211 - s))
                    if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6212 / 10^(_6211 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6212 / 10^(_6211 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6212 / 10^(_6211 - s))
                idx = 12
                s = mem[_1780 + 96]
                while idx >= 4:
                    if not mem[_1780 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1780 + 96] - idx
                    continue 
                _6213 = mem[_3529 + 96]
                _6214 = mem[_3529 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6213 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6214 / 10^(_6213 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6214 / 10^(_6213 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6214 / 10^(_6213 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6214 / 10^(_6213 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6214 / 10^(_6213 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6214 / 10^(_6213 - s))
            if usdtAddress == uint64(ext_call.return_data[0]) << 96:
                _4007 = mem[64]
                mem[mem[64]] = 2
                _4949 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_4949] = 0
                mem[_4949 + 32] = 96
                mem[_4949 + 64] = 96
                mem[_4949 + 96] = 0
                mem[_4949 + 128] = 0
                mem[_4949 + 160] = 0
                mem[_4949 + 192] = 0
                mem[_4949 + 224] = 0
                mem[var201001] = _4949
                s = var201001
                idx = var201002
                while idx - 1:
                    _4949 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_4949] = 0
                    mem[_4949 + 32] = 96
                    mem[_4949 + 64] = 96
                    mem[_4949 + 96] = 0
                    mem[_4949 + 128] = 0
                    mem[_4949 + 160] = 0
                    mem[_4949 + 192] = 0
                    mem[_4949 + 224] = 0
                    mem[s + 32] = _4949
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4007]
                mem[_4007 + 32] = _3529
                require 1 < mem[_4007]
                mem[_4007 + 64] = _1780
                _5237 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5237] = 0
                mem[_5237 + 32] = 96
                mem[_5237 + 64] = 96
                mem[_5237 + 96] = 0
                mem[_5237 + 128] = 0
                mem[_5237 + 160] = 0
                mem[_5237 + 192] = 0
                mem[_5237 + 224] = 0
                require 0 < mem[_4007]
                _5519 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5519] = 0
                mem[_5519 + 32] = 96
                mem[_5519 + 64] = 96
                mem[_5519 + 96] = 0
                mem[_5519 + 128] = 0
                mem[_5519 + 160] = 0
                mem[_5519 + 192] = 0
                mem[_5519 + 224] = 0
                require 1 < mem[_4007]
                if mem[_3529 + 96] <= mem[_1780 + 96]:
                    idx = 12
                    s = mem[_3529 + 96]
                    while idx >= 4:
                        if not mem[_3529 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3529 + 96] - idx
                        continue 
                    _6207 = mem[_3529 + 96]
                    _6208 = mem[_3529 + 128]
                    mem[mem[64]] = 26
                    mem[mem[64] + 32] = 'SafeMath: division by zero'
                    if not 10^(_6207 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^(mem[_1780 + 96] - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                        if not _6208 / 10^(_6207 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        if not 0 / _6208 / 10^(_6207 - s):
                            revert with 0, 'SafeMath: division by zero', 0
                        return (1000000 * 10^18 / 0 / _6208 / 10^(_6207 - s))
                    if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not _6208 / 10^(_6207 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6208 / 10^(_6207 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6208 / 10^(_6207 - s))
                idx = 12
                s = mem[_1780 + 96]
                while idx >= 4:
                    if not mem[_1780 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1780 + 96] - idx
                    continue 
                _6209 = mem[_3529 + 96]
                _6210 = mem[_3529 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6209 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6210 / 10^(_6209 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6210 / 10^(_6209 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6210 / 10^(_6209 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6210 / 10^(_6209 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6210 / 10^(_6209 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6210 / 10^(_6209 - s))
            idx = 0
            while idx < sub_27d312da.length:
                mem[0] = 1
                if sub_27d312da[idx] != address(ext_call.return_data[0]):
                    idx = idx + 1
                    continue 
                _4417 = mem[64]
                mem[mem[64]] = 2
                _5982 = mem[64] + 96
                mem[64] = mem[64] + 352
                mem[_5982] = 0
                mem[_5982 + 32] = 96
                mem[_5982 + 64] = 96
                mem[_5982 + 96] = 0
                mem[_5982 + 128] = 0
                mem[_5982 + 160] = 0
                mem[_5982 + 192] = 0
                mem[_5982 + 224] = 0
                mem[var210001] = _5982
                s = var210001
                idx = var210002
                while idx - 1:
                    _5982 = mem[64]
                    mem[64] = mem[64] + 256
                    mem[_5982] = 0
                    mem[_5982 + 32] = 96
                    mem[_5982 + 64] = 96
                    mem[_5982 + 96] = 0
                    mem[_5982 + 128] = 0
                    mem[_5982 + 160] = 0
                    mem[_5982 + 192] = 0
                    mem[_5982 + 224] = 0
                    mem[s + 32] = _5982
                    s = s + 32
                    idx = idx - 1
                    continue 
                require 0 < mem[_4417]
                mem[_4417 + 32] = _3529
                require 1 < mem[_4417]
                mem[_4417 + 64] = _1780
                _6590 = mem[64]
                mem[64] = mem[64] + 256
                mem[_6590] = 0
                mem[_6590 + 32] = 96
                mem[_6590 + 64] = 96
                mem[_6590 + 96] = 0
                mem[_6590 + 128] = 0
                mem[_6590 + 160] = 0
                mem[_6590 + 192] = 0
                mem[_6590 + 224] = 0
                require 0 < mem[_4417]
                _7006 = mem[64]
                mem[64] = mem[64] + 256
                mem[_7006] = 0
                mem[_7006 + 32] = 96
                mem[_7006 + 64] = 96
                mem[_7006 + 96] = 0
                mem[_7006 + 128] = 0
                mem[_7006 + 160] = 0
                mem[_7006 + 192] = 0
                mem[_7006 + 224] = 0
                require 1 < mem[_4417]
                if mem[_3529 + 96] <= mem[_1780 + 96]:
                    idx = 12
                    s = mem[_3529 + 96]
                    while idx >= 4:
                        if not mem[_3529 + 96] - idx:
                            idx = idx - 1
                            s = s
                            continue 
                        idx = idx - 1
                        s = mem[_3529 + 96] - idx
                        continue 
                    _13065 = mem[_3529 + 96]
                    _13066 = mem[_3529 + 128]
                    _13143 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13143] = 26
                    mem[_13143 + 32] = 'SafeMath: division by zero'
                    if not 10^(_13065 - s):
                        _13207 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13207 + 68] = mem[idx + _13143 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13207 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13207 + -mem[64] + 100
                    _14921 = mem[_1780 + 96]
                    _14922 = mem[_1780 + 128]
                    _15049 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15049] = 26
                    mem[_15049 + 32] = 'SafeMath: division by zero'
                    if not 10^(_14921 - s):
                        _15127 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15127 + 68] = mem[idx + _15049 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15127 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15127 + -mem[64] + 100
                    if not _14922 / 10^(_14921 - s):
                        _15511 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15511] = 26
                        mem[_15511 + 32] = 'SafeMath: division by zero'
                        if not _13066 / 10^(_13065 - s):
                            _15804 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15804 + 68] = mem[idx + _15511 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15804 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15804 + -mem[64] + 100
                        _16329 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16329] = 26
                        mem[_16329 + 32] = 'SafeMath: division by zero'
                        if 0 / _13066 / 10^(_13065 - s):
                            return (1000000 * 10^18 / 0 / _13066 / 10^(_13065 - s))
                        _16573 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _16573 + 68] = mem[idx + _16329 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16573 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _16573 + -mem[64] + 100
                    if 10^12 * _14922 / 10^(_14921 - s) / _14922 / 10^(_14921 - s) != 10^12:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15803 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15803] = 26
                    mem[_15803 + 32] = 'SafeMath: division by zero'
                    if not _13066 / 10^(_13065 - s):
                        _15945 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15945 + 68] = mem[idx + _15803 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15945 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15945 + -mem[64] + 100
                    _16571 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16571] = 26
                    mem[_16571 + 32] = 'SafeMath: division by zero'
                    if 10^12 * _14922 / 10^(_14921 - s) / _13066 / 10^(_13065 - s):
                        return (1000000 * 10^18 / 10^12 * _14922 / 10^(_14921 - s) / _13066 / 10^(_13065 - s))
                    _16713 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16713 + 68] = mem[idx + _16571 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16713 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16713 + -mem[64] + 100
                idx = 12
                s = mem[_1780 + 96]
                while idx >= 4:
                    if not mem[_1780 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1780 + 96] - idx
                    continue 
                _13067 = mem[_3529 + 96]
                _13068 = mem[_3529 + 128]
                _13144 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13144] = 26
                mem[_13144 + 32] = 'SafeMath: division by zero'
                if not 10^(_13067 - s):
                    _13208 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13208 + 68] = mem[idx + _13144 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13208 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13208 + -mem[64] + 100
                _14923 = mem[_1780 + 96]
                _14924 = mem[_1780 + 128]
                _15051 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15051] = 26
                mem[_15051 + 32] = 'SafeMath: division by zero'
                if not 10^(_14923 - s):
                    _15128 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15128 + 68] = mem[idx + _15051 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15128 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15128 + -mem[64] + 100
                if not _14924 / 10^(_14923 - s):
                    _15512 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15512] = 26
                    mem[_15512 + 32] = 'SafeMath: division by zero'
                    if not _13068 / 10^(_13067 - s):
                        _15807 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15807 + 68] = mem[idx + _15512 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15807 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15807 + -mem[64] + 100
                    _16331 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16331] = 26
                    mem[_16331 + 32] = 'SafeMath: division by zero'
                    if 0 / _13068 / 10^(_13067 - s):
                        return (1000000 * 10^18 / 0 / _13068 / 10^(_13067 - s))
                    _16576 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16576 + 68] = mem[idx + _16331 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16576 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16576 + -mem[64] + 100
                if 10^12 * _14924 / 10^(_14923 - s) / _14924 / 10^(_14923 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15806 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15806] = 26
                mem[_15806 + 32] = 'SafeMath: division by zero'
                if not _13068 / 10^(_13067 - s):
                    _15947 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15947 + 68] = mem[idx + _15806 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15947 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15947 + -mem[64] + 100
                _16574 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16574] = 26
                mem[_16574 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14924 / 10^(_14923 - s) / _13068 / 10^(_13067 - s):
                    return (1000000 * 10^18 / 10^12 * _14924 / 10^(_14923 - s) / _13068 / 10^(_13067 - s))
                _16715 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16715 + 68] = mem[idx + _16574 + 32]
                    idx = idx + 32
                    continue 
                mem[_16715 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16715 + -mem[64] + 100
            _4257 = mem[64]
            mem[mem[64]] = 2
            _5981 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5981] = 0
            mem[_5981 + 32] = 96
            mem[_5981 + 64] = 96
            mem[_5981 + 96] = 0
            mem[_5981 + 128] = 0
            mem[_5981 + 160] = 0
            mem[_5981 + 192] = 0
            mem[_5981 + 224] = 0
            mem[var206001] = _5981
            s = var206001
            idx = var206002
            while idx - 1:
                _5981 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5981] = 0
                mem[_5981 + 32] = 96
                mem[_5981 + 64] = 96
                mem[_5981 + 96] = 0
                mem[_5981 + 128] = 0
                mem[_5981 + 160] = 0
                mem[_5981 + 192] = 0
                mem[_5981 + 224] = 0
                mem[s + 32] = _5981
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4257]
            mem[_4257 + 32] = _1780
            require 1 < mem[_4257]
            mem[_4257 + 64] = _3529
            _6589 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6589] = 0
            mem[_6589 + 32] = 96
            mem[_6589 + 64] = 96
            mem[_6589 + 96] = 0
            mem[_6589 + 128] = 0
            mem[_6589 + 160] = 0
            mem[_6589 + 192] = 0
            mem[_6589 + 224] = 0
            require 0 < mem[_4257]
            _7005 = mem[64]
            mem[64] = mem[64] + 256
            mem[_7005] = 0
            mem[_7005 + 32] = 96
            mem[_7005 + 64] = 96
            mem[_7005 + 96] = 0
            mem[_7005 + 128] = 0
            mem[_7005 + 160] = 0
            mem[_7005 + 192] = 0
            mem[_7005 + 224] = 0
            require 1 < mem[_4257]
            if mem[_1780 + 96] <= mem[_3529 + 96]:
                idx = 12
                s = mem[_1780 + 96]
                while idx >= 4:
                    if not mem[_1780 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1780 + 96] - idx
                    continue 
                _13061 = mem[_1780 + 96]
                _13062 = mem[_1780 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_13061 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3529 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3529 + 128] / 10^(mem[_3529 + 96] - s):
                    if not _13062 / 10^(_13061 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _13062 / 10^(_13061 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _13062 / 10^(_13061 - s))
                if 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _13062 / 10^(_13061 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / _13062 / 10^(_13061 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / _13062 / 10^(_13061 - s))
            idx = 12
            s = mem[_3529 + 96]
            while idx >= 4:
                if not mem[_3529 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3529 + 96] - idx
                continue 
            _13063 = mem[_1780 + 96]
            _13064 = mem[_1780 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13063 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3529 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3529 + 128] / 10^(mem[_3529 + 96] - s):
                if not _13064 / 10^(_13063 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13064 / 10^(_13063 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13064 / 10^(_13063 - s))
            if 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13064 / 10^(_13063 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / _13064 / 10^(_13063 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3529 + 128] / 10^(mem[_3529 + 96] - s) / _13064 / 10^(_13063 - s))
        mem[_2632 + ceil32(return_data.size) + _2648 + 32] = 0
        require ext_code.size(address(_1800))
        staticcall address(_1800).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3443 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3459 = mem[_3443]
        require mem[_3443] == mem[_3443 + 31 len 1]
        require ext_code.size(address(_1800))
        staticcall address(_1800).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3507 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3530 = mem[_3507]
        _3553 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3553] = address(_1800)
        mem[_3553 + 32] = _1816 + ceil32(return_data.size)
        mem[_3553 + 64] = _2632 + ceil32(return_data.size)
        mem[_3553 + 96] = uint8(_3459)
        mem[_3553 + 128] = 0
        mem[_3553 + 160] = _3530
        mem[_3553 + 192] = 0
        mem[_3553 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3587 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3603 = mem[_3587]
        require mem[_3587] == mem[_3587 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3603))
        staticcall address(_3603).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3651 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_1780 + 128] = mem[_3651]
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3715 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3731 = mem[_3715]
        require mem[_3715] == mem[_3715 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3731))
        staticcall address(_3731).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3779 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_3553 + 128] = mem[_3779]
        _3811 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3811] = 0
        mem[_3811 + 32] = 96
        mem[_3811 + 64] = 96
        mem[_3811 + 96] = 0
        mem[_3811 + 128] = 0
        mem[_3811 + 160] = 0
        mem[_3811 + 192] = 0
        mem[_3811 + 224] = 0
        _3834 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3834] = 0
        mem[_3834 + 32] = 96
        mem[_3834 + 64] = 96
        mem[_3834 + 96] = 0
        mem[_3834 + 128] = 0
        mem[_3834 + 160] = 0
        mem[_3834 + 192] = 0
        mem[_3834 + 224] = 0
        if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
            _3875 = mem[64]
            mem[mem[64]] = 2
            _4956 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4956] = 0
            mem[_4956 + 32] = 96
            mem[_4956 + 64] = 96
            mem[_4956 + 96] = 0
            mem[_4956 + 128] = 0
            mem[_4956 + 160] = 0
            mem[_4956 + 192] = 0
            mem[_4956 + 224] = 0
            mem[var192001] = _4956
            s = var192001
            idx = var192002
            while idx - 1:
                _4956 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4956] = 0
                mem[_4956 + 32] = 96
                mem[_4956 + 64] = 96
                mem[_4956 + 96] = 0
                mem[_4956 + 128] = 0
                mem[_4956 + 160] = 0
                mem[_4956 + 192] = 0
                mem[_4956 + 224] = 0
                mem[s + 32] = _4956
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3875]
            mem[_3875 + 32] = _3553
            require 1 < mem[_3875]
            mem[_3875 + 64] = _1780
            _5244 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5244] = 0
            mem[_5244 + 32] = 96
            mem[_5244 + 64] = 96
            mem[_5244 + 96] = 0
            mem[_5244 + 128] = 0
            mem[_5244 + 160] = 0
            mem[_5244 + 192] = 0
            mem[_5244 + 224] = 0
            require 0 < mem[_3875]
            _5528 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5528] = 0
            mem[_5528 + 32] = 96
            mem[_5528 + 64] = 96
            mem[_5528 + 96] = 0
            mem[_5528 + 128] = 0
            mem[_5528 + 160] = 0
            mem[_5528 + 192] = 0
            mem[_5528 + 224] = 0
            require 1 < mem[_3875]
            if mem[_3553 + 96] <= mem[_1780 + 96]:
                idx = 12
                s = mem[_3553 + 96]
                while idx >= 4:
                    if not mem[_3553 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3553 + 96] - idx
                    continue 
                _6237 = mem[_3553 + 96]
                _6238 = mem[_3553 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6237 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6238 / 10^(_6237 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6238 / 10^(_6237 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6238 / 10^(_6237 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6238 / 10^(_6237 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6238 / 10^(_6237 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6238 / 10^(_6237 - s))
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _6239 = mem[_3553 + 96]
            _6240 = mem[_3553 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6239 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6240 / 10^(_6239 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6240 / 10^(_6239 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6240 / 10^(_6239 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6240 / 10^(_6239 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6240 / 10^(_6239 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6240 / 10^(_6239 - s))
        if wbnbAddress == address(_1800):
            _3923 = mem[64]
            mem[mem[64]] = 2
            _4955 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4955] = 0
            mem[_4955 + 32] = 96
            mem[_4955 + 64] = 96
            mem[_4955 + 96] = 0
            mem[_4955 + 128] = 0
            mem[_4955 + 160] = 0
            mem[_4955 + 192] = 0
            mem[_4955 + 224] = 0
            mem[var196001] = _4955
            s = var196001
            idx = var196002
            while idx - 1:
                _4955 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4955] = 0
                mem[_4955 + 32] = 96
                mem[_4955 + 64] = 96
                mem[_4955 + 96] = 0
                mem[_4955 + 128] = 0
                mem[_4955 + 160] = 0
                mem[_4955 + 192] = 0
                mem[_4955 + 224] = 0
                mem[s + 32] = _4955
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3923]
            mem[_3923 + 32] = _1780
            require 1 < mem[_3923]
            mem[_3923 + 64] = _3553
            _5243 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5243] = 0
            mem[_5243 + 32] = 96
            mem[_5243 + 64] = 96
            mem[_5243 + 96] = 0
            mem[_5243 + 128] = 0
            mem[_5243 + 160] = 0
            mem[_5243 + 192] = 0
            mem[_5243 + 224] = 0
            require 0 < mem[_3923]
            _5527 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5527] = 0
            mem[_5527 + 32] = 96
            mem[_5527 + 64] = 96
            mem[_5527 + 96] = 0
            mem[_5527 + 128] = 0
            mem[_5527 + 160] = 0
            mem[_5527 + 192] = 0
            mem[_5527 + 224] = 0
            require 1 < mem[_3923]
            if mem[_1780 + 96] <= mem[_3553 + 96]:
                idx = 12
                s = mem[_1780 + 96]
                while idx >= 4:
                    if not mem[_1780 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1780 + 96] - idx
                    continue 
                _6233 = mem[_1780 + 96]
                _6234 = mem[_1780 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6233 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3553 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3553 + 128] / 10^(mem[_3553 + 96] - s):
                    if not _6234 / 10^(_6233 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6234 / 10^(_6233 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6234 / 10^(_6233 - s))
                if 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6234 / 10^(_6233 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _6234 / 10^(_6233 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _6234 / 10^(_6233 - s))
            idx = 12
            s = mem[_3553 + 96]
            while idx >= 4:
                if not mem[_3553 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3553 + 96] - idx
                continue 
            _6235 = mem[_1780 + 96]
            _6236 = mem[_1780 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6235 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3553 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3553 + 128] / 10^(mem[_3553 + 96] - s):
                if not _6236 / 10^(_6235 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6236 / 10^(_6235 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6236 / 10^(_6235 - s))
            if 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6236 / 10^(_6235 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _6236 / 10^(_6235 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _6236 / 10^(_6235 - s))
        if busdAddress == uint64(ext_call.return_data[0]) << 96:
            _3971 = mem[64]
            mem[mem[64]] = 2
            _4954 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4954] = 0
            mem[_4954 + 32] = 96
            mem[_4954 + 64] = 96
            mem[_4954 + 96] = 0
            mem[_4954 + 128] = 0
            mem[_4954 + 160] = 0
            mem[_4954 + 192] = 0
            mem[_4954 + 224] = 0
            mem[var199001] = _4954
            s = var199001
            idx = var199002
            while idx - 1:
                _4954 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4954] = 0
                mem[_4954 + 32] = 96
                mem[_4954 + 64] = 96
                mem[_4954 + 96] = 0
                mem[_4954 + 128] = 0
                mem[_4954 + 160] = 0
                mem[_4954 + 192] = 0
                mem[_4954 + 224] = 0
                mem[s + 32] = _4954
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3971]
            mem[_3971 + 32] = _3553
            require 1 < mem[_3971]
            mem[_3971 + 64] = _1780
            _5242 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5242] = 0
            mem[_5242 + 32] = 96
            mem[_5242 + 64] = 96
            mem[_5242 + 96] = 0
            mem[_5242 + 128] = 0
            mem[_5242 + 160] = 0
            mem[_5242 + 192] = 0
            mem[_5242 + 224] = 0
            require 0 < mem[_3971]
            _5526 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5526] = 0
            mem[_5526 + 32] = 96
            mem[_5526 + 64] = 96
            mem[_5526 + 96] = 0
            mem[_5526 + 128] = 0
            mem[_5526 + 160] = 0
            mem[_5526 + 192] = 0
            mem[_5526 + 224] = 0
            require 1 < mem[_3971]
            if mem[_3553 + 96] <= mem[_1780 + 96]:
                idx = 12
                s = mem[_3553 + 96]
                while idx >= 4:
                    if not mem[_3553 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3553 + 96] - idx
                    continue 
                _6229 = mem[_3553 + 96]
                _6230 = mem[_3553 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6229 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6230 / 10^(_6229 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6230 / 10^(_6229 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6230 / 10^(_6229 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6230 / 10^(_6229 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6230 / 10^(_6229 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6230 / 10^(_6229 - s))
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _6231 = mem[_3553 + 96]
            _6232 = mem[_3553 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6231 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6232 / 10^(_6231 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6232 / 10^(_6231 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6232 / 10^(_6231 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6232 / 10^(_6231 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6232 / 10^(_6231 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6232 / 10^(_6231 - s))
        if usdtAddress == uint64(ext_call.return_data[0]) << 96:
            _4019 = mem[64]
            mem[mem[64]] = 2
            _4953 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4953] = 0
            mem[_4953 + 32] = 96
            mem[_4953 + 64] = 96
            mem[_4953 + 96] = 0
            mem[_4953 + 128] = 0
            mem[_4953 + 160] = 0
            mem[_4953 + 192] = 0
            mem[_4953 + 224] = 0
            mem[var202001] = _4953
            s = var202001
            idx = var202002
            while idx - 1:
                _4953 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4953] = 0
                mem[_4953 + 32] = 96
                mem[_4953 + 64] = 96
                mem[_4953 + 96] = 0
                mem[_4953 + 128] = 0
                mem[_4953 + 160] = 0
                mem[_4953 + 192] = 0
                mem[_4953 + 224] = 0
                mem[s + 32] = _4953
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4019]
            mem[_4019 + 32] = _3553
            require 1 < mem[_4019]
            mem[_4019 + 64] = _1780
            _5241 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5241] = 0
            mem[_5241 + 32] = 96
            mem[_5241 + 64] = 96
            mem[_5241 + 96] = 0
            mem[_5241 + 128] = 0
            mem[_5241 + 160] = 0
            mem[_5241 + 192] = 0
            mem[_5241 + 224] = 0
            require 0 < mem[_4019]
            _5525 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5525] = 0
            mem[_5525 + 32] = 96
            mem[_5525 + 64] = 96
            mem[_5525 + 96] = 0
            mem[_5525 + 128] = 0
            mem[_5525 + 160] = 0
            mem[_5525 + 192] = 0
            mem[_5525 + 224] = 0
            require 1 < mem[_4019]
            if mem[_3553 + 96] <= mem[_1780 + 96]:
                idx = 12
                s = mem[_3553 + 96]
                while idx >= 4:
                    if not mem[_3553 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3553 + 96] - idx
                    continue 
                _6225 = mem[_3553 + 96]
                _6226 = mem[_3553 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6225 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6226 / 10^(_6225 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6226 / 10^(_6225 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6226 / 10^(_6225 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6226 / 10^(_6225 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6226 / 10^(_6225 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6226 / 10^(_6225 - s))
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _6227 = mem[_3553 + 96]
            _6228 = mem[_3553 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6227 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6228 / 10^(_6227 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6228 / 10^(_6227 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6228 / 10^(_6227 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6228 / 10^(_6227 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6228 / 10^(_6227 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6228 / 10^(_6227 - s))
        idx = 0
        while idx < sub_27d312da.length:
            mem[0] = 1
            if sub_27d312da[idx] != address(ext_call.return_data[0]):
                idx = idx + 1
                continue 
            _4422 = mem[64]
            mem[mem[64]] = 2
            _5984 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5984] = 0
            mem[_5984 + 32] = 96
            mem[_5984 + 64] = 96
            mem[_5984 + 96] = 0
            mem[_5984 + 128] = 0
            mem[_5984 + 160] = 0
            mem[_5984 + 192] = 0
            mem[_5984 + 224] = 0
            mem[var211001] = _5984
            s = var211001
            idx = var211002
            while idx - 1:
                _5984 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5984] = 0
                mem[_5984 + 32] = 96
                mem[_5984 + 64] = 96
                mem[_5984 + 96] = 0
                mem[_5984 + 128] = 0
                mem[_5984 + 160] = 0
                mem[_5984 + 192] = 0
                mem[_5984 + 224] = 0
                mem[s + 32] = _5984
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4422]
            mem[_4422 + 32] = _3553
            require 1 < mem[_4422]
            mem[_4422 + 64] = _1780
            _6592 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6592] = 0
            mem[_6592 + 32] = 96
            mem[_6592 + 64] = 96
            mem[_6592 + 96] = 0
            mem[_6592 + 128] = 0
            mem[_6592 + 160] = 0
            mem[_6592 + 192] = 0
            mem[_6592 + 224] = 0
            require 0 < mem[_4422]
            _7024 = mem[64]
            mem[64] = mem[64] + 256
            mem[_7024] = 0
            mem[_7024 + 32] = 96
            mem[_7024 + 64] = 96
            mem[_7024 + 96] = 0
            mem[_7024 + 128] = 0
            mem[_7024 + 160] = 0
            mem[_7024 + 192] = 0
            mem[_7024 + 224] = 0
            require 1 < mem[_4422]
            if mem[_3553 + 96] <= mem[_1780 + 96]:
                idx = 12
                s = mem[_3553 + 96]
                while idx >= 4:
                    if not mem[_3553 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3553 + 96] - idx
                    continue 
                _13073 = mem[_3553 + 96]
                _13074 = mem[_3553 + 128]
                _13147 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13147] = 26
                mem[_13147 + 32] = 'SafeMath: division by zero'
                if not 10^(_13073 - s):
                    _13211 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13211 + 68] = mem[idx + _13147 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13211 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13211 + -mem[64] + 100
                _14929 = mem[_1780 + 96]
                _14930 = mem[_1780 + 128]
                _15057 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15057] = 26
                mem[_15057 + 32] = 'SafeMath: division by zero'
                if not 10^(_14929 - s):
                    _15131 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15131 + 68] = mem[idx + _15057 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15131 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15131 + -mem[64] + 100
                if not _14930 / 10^(_14929 - s):
                    _15515 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15515] = 26
                    mem[_15515 + 32] = 'SafeMath: division by zero'
                    if not _13074 / 10^(_13073 - s):
                        _15816 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15816 + 68] = mem[idx + _15515 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15816 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15816 + -mem[64] + 100
                    _16337 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16337] = 26
                    mem[_16337 + 32] = 'SafeMath: division by zero'
                    if 0 / _13074 / 10^(_13073 - s):
                        return (1000000 * 10^18 / 0 / _13074 / 10^(_13073 - s))
                    _16585 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16585 + 68] = mem[idx + _16337 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16585 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16585 + -mem[64] + 100
                if 10^12 * _14930 / 10^(_14929 - s) / _14930 / 10^(_14929 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15815 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15815] = 26
                mem[_15815 + 32] = 'SafeMath: division by zero'
                if not _13074 / 10^(_13073 - s):
                    _15953 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15953 + 68] = mem[idx + _15815 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15953 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15953 + -mem[64] + 100
                _16583 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16583] = 26
                mem[_16583 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14930 / 10^(_14929 - s) / _13074 / 10^(_13073 - s):
                    return (1000000 * 10^18 / 10^12 * _14930 / 10^(_14929 - s) / _13074 / 10^(_13073 - s))
                _16721 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16721 + 68] = mem[idx + _16583 + 32]
                    idx = idx + 32
                    continue 
                mem[_16721 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16721 + -mem[64] + 100
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _13075 = mem[_3553 + 96]
            _13076 = mem[_3553 + 128]
            _13148 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13148] = 26
            mem[_13148 + 32] = 'SafeMath: division by zero'
            if not 10^(_13075 - s):
                _13212 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13212 + 68] = mem[idx + _13148 + 32]
                    idx = idx + 32
                    continue 
                mem[_13212 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13212 + -mem[64] + 100
            _14931 = mem[_1780 + 96]
            _14932 = mem[_1780 + 128]
            _15059 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15059] = 26
            mem[_15059 + 32] = 'SafeMath: division by zero'
            if not 10^(_14931 - s):
                _15132 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15132 + 68] = mem[idx + _15059 + 32]
                    idx = idx + 32
                    continue 
                mem[_15132 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15132 + -mem[64] + 100
            if not _14932 / 10^(_14931 - s):
                _15516 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15516] = 26
                mem[_15516 + 32] = 'SafeMath: division by zero'
                if not _13076 / 10^(_13075 - s):
                    _15819 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15819 + 68] = mem[idx + _15516 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15819 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15819 + -mem[64] + 100
                _16339 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16339] = 26
                mem[_16339 + 32] = 'SafeMath: division by zero'
                if 0 / _13076 / 10^(_13075 - s):
                    return (1000000 * 10^18 / 0 / _13076 / 10^(_13075 - s))
                _16588 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16588 + 68] = mem[idx + _16339 + 32]
                    idx = idx + 32
                    continue 
                mem[_16588 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16588 + -mem[64] + 100
            if 10^12 * _14932 / 10^(_14931 - s) / _14932 / 10^(_14931 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15818 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15818] = 26
            mem[_15818 + 32] = 'SafeMath: division by zero'
            if not _13076 / 10^(_13075 - s):
                _15955 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15955 + 68] = mem[idx + _15818 + 32]
                    idx = idx + 32
                    continue 
                mem[_15955 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15955 + -mem[64] + 100
            _16586 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16586] = 26
            mem[_16586 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14932 / 10^(_14931 - s) / _13076 / 10^(_13075 - s):
                return (1000000 * 10^18 / 10^12 * _14932 / 10^(_14931 - s) / _13076 / 10^(_13075 - s))
            _16723 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16723 + 68] = mem[idx + _16586 + 32]
                idx = idx + 32
                continue 
            mem[_16723 + 94] = 0
            revert with memory
              from mem[64]
               len _16723 + -mem[64] + 100
        _4262 = mem[64]
        mem[mem[64]] = 2
        _5983 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_5983] = 0
        mem[_5983 + 32] = 96
        mem[_5983 + 64] = 96
        mem[_5983 + 96] = 0
        mem[_5983 + 128] = 0
        mem[_5983 + 160] = 0
        mem[_5983 + 192] = 0
        mem[_5983 + 224] = 0
        mem[var207001] = _5983
        s = var207001
        idx = var207002
        while idx - 1:
            _5983 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5983] = 0
            mem[_5983 + 32] = 96
            mem[_5983 + 64] = 96
            mem[_5983 + 96] = 0
            mem[_5983 + 128] = 0
            mem[_5983 + 160] = 0
            mem[_5983 + 192] = 0
            mem[_5983 + 224] = 0
            mem[s + 32] = _5983
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4262]
        mem[_4262 + 32] = _1780
        require 1 < mem[_4262]
        mem[_4262 + 64] = _3553
        _6591 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6591] = 0
        mem[_6591 + 32] = 96
        mem[_6591 + 64] = 96
        mem[_6591 + 96] = 0
        mem[_6591 + 128] = 0
        mem[_6591 + 160] = 0
        mem[_6591 + 192] = 0
        mem[_6591 + 224] = 0
        require 0 < mem[_4262]
        _7023 = mem[64]
        mem[64] = mem[64] + 256
        mem[_7023] = 0
        mem[_7023 + 32] = 96
        mem[_7023 + 64] = 96
        mem[_7023 + 96] = 0
        mem[_7023 + 128] = 0
        mem[_7023 + 160] = 0
        mem[_7023 + 192] = 0
        mem[_7023 + 224] = 0
        require 1 < mem[_4262]
        if mem[_1780 + 96] <= mem[_3553 + 96]:
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _13069 = mem[_1780 + 96]
            _13070 = mem[_1780 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13069 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3553 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3553 + 128] / 10^(mem[_3553 + 96] - s):
                if not _13070 / 10^(_13069 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13070 / 10^(_13069 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13070 / 10^(_13069 - s))
            if 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13070 / 10^(_13069 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _13070 / 10^(_13069 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _13070 / 10^(_13069 - s))
        idx = 12
        s = mem[_3553 + 96]
        while idx >= 4:
            if not mem[_3553 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3553 + 96] - idx
            continue 
        _13071 = mem[_1780 + 96]
        _13072 = mem[_1780 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13071 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3553 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3553 + 128] / 10^(mem[_3553 + 96] - s):
            if not _13072 / 10^(_13071 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13072 / 10^(_13071 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13072 / 10^(_13071 - s))
        if 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13072 / 10^(_13071 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _13072 / 10^(_13071 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3553 + 128] / 10^(mem[_3553 + 96] - s) / _13072 / 10^(_13071 - s))
    mem[_1816 + ceil32(return_data.size) + _1824 + 32] = 0
    mem[mem[64]] = 0x95d89b4100000000000000000000000000000000000000000000000000000000
    require ext_code.size(address(_1800))
    staticcall address(_1800).0x95d89b41 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _2636 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2644 = mem[_2636]
    require mem[_2636] <= test266151307()
    require _2636 + return_data.size > _2636 + mem[_2636] + 31
    _2652 = mem[_2636 + mem[_2636]]
    require mem[_2636 + mem[_2636]] <= test266151307()
    require ceil32(mem[_2636 + mem[_2636]]) + 32 >= 0 and _2636 + ceil32(return_data.size) + ceil32(mem[_2636 + mem[_2636]]) + 32 <= test266151307()
    mem[64] = _2636 + ceil32(return_data.size) + ceil32(mem[_2636 + mem[_2636]]) + 32
    mem[_2636 + ceil32(return_data.size)] = _2652
    require _2644 + _2652 + 32 <= return_data.size
    mem[_2636 + ceil32(return_data.size) + 32 len ceil32(_2652)] = mem[_2636 + _2644 + 32 len ceil32(_2652)]
    if ceil32(_2652) <= _2652:
        require ext_code.size(address(_1800))
        staticcall address(_1800).0x313ce567 with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3436 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3452 = mem[_3436]
        require mem[_3436] == mem[_3436 + 31 len 1]
        require ext_code.size(address(_1800))
        staticcall address(_1800).0x18160ddd with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3500 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3516 = mem[_3500]
        _3531 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3531] = address(_1800)
        mem[_3531 + 32] = _1816 + ceil32(return_data.size)
        mem[_3531 + 64] = _2636 + ceil32(return_data.size)
        mem[_3531 + 96] = uint8(_3452)
        mem[_3531 + 128] = 0
        mem[_3531 + 160] = _3516
        mem[_3531 + 192] = 0
        mem[_3531 + 224] = 0
        require ext_code.size(arg1)
        staticcall arg1.token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3580 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3596 = mem[_3580]
        require mem[_3580] == mem[_3580 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3596))
        staticcall address(_3596).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3644 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_1780 + 128] = mem[_3644]
        require ext_code.size(arg1)
        staticcall arg1.token1() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3708 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3724 = mem[_3708]
        require mem[_3708] == mem[_3708 + 12 len 20]
        mem[mem[64] + 4] = arg1
        require ext_code.size(address(_3724))
        staticcall address(_3724).0x70a08231 with:
                gas gas_remaining wei
               args address(arg1)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3772 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[_3531 + 128] = mem[_3772]
        _3804 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3804] = 0
        mem[_3804 + 32] = 96
        mem[_3804 + 64] = 96
        mem[_3804 + 96] = 0
        mem[_3804 + 128] = 0
        mem[_3804 + 160] = 0
        mem[_3804 + 192] = 0
        mem[_3804 + 224] = 0
        _3820 = mem[64]
        mem[64] = mem[64] + 256
        mem[_3820] = 0
        mem[_3820 + 32] = 96
        mem[_3820 + 64] = 96
        mem[_3820 + 96] = 0
        mem[_3820 + 128] = 0
        mem[_3820 + 160] = 0
        mem[_3820 + 192] = 0
        mem[_3820 + 224] = 0
        if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
            _3867 = mem[64]
            mem[mem[64]] = 2
            _4960 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4960] = 0
            mem[_4960 + 32] = 96
            mem[_4960 + 64] = 96
            mem[_4960 + 96] = 0
            mem[_4960 + 128] = 0
            mem[_4960 + 160] = 0
            mem[_4960 + 192] = 0
            mem[_4960 + 224] = 0
            mem[var192001] = _4960
            s = var192001
            idx = var192002
            while idx - 1:
                _4960 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4960] = 0
                mem[_4960 + 32] = 96
                mem[_4960 + 64] = 96
                mem[_4960 + 96] = 0
                mem[_4960 + 128] = 0
                mem[_4960 + 160] = 0
                mem[_4960 + 192] = 0
                mem[_4960 + 224] = 0
                mem[s + 32] = _4960
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3867]
            mem[_3867 + 32] = _3531
            require 1 < mem[_3867]
            mem[_3867 + 64] = _1780
            _5248 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5248] = 0
            mem[_5248 + 32] = 96
            mem[_5248 + 64] = 96
            mem[_5248 + 96] = 0
            mem[_5248 + 128] = 0
            mem[_5248 + 160] = 0
            mem[_5248 + 192] = 0
            mem[_5248 + 224] = 0
            require 0 < mem[_3867]
            _5534 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5534] = 0
            mem[_5534 + 32] = 96
            mem[_5534 + 64] = 96
            mem[_5534 + 96] = 0
            mem[_5534 + 128] = 0
            mem[_5534 + 160] = 0
            mem[_5534 + 192] = 0
            mem[_5534 + 224] = 0
            require 1 < mem[_3867]
            if mem[_3531 + 96] <= mem[_1780 + 96]:
                idx = 12
                s = mem[_3531 + 96]
                while idx >= 4:
                    if not mem[_3531 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3531 + 96] - idx
                    continue 
                _6255 = mem[_3531 + 96]
                _6256 = mem[_3531 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6255 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6256 / 10^(_6255 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6256 / 10^(_6255 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6256 / 10^(_6255 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6256 / 10^(_6255 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6256 / 10^(_6255 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6256 / 10^(_6255 - s))
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _6257 = mem[_3531 + 96]
            _6258 = mem[_3531 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6257 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6258 / 10^(_6257 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6258 / 10^(_6257 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6258 / 10^(_6257 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6258 / 10^(_6257 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6258 / 10^(_6257 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6258 / 10^(_6257 - s))
        if wbnbAddress == address(_1800):
            _3915 = mem[64]
            mem[mem[64]] = 2
            _4959 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4959] = 0
            mem[_4959 + 32] = 96
            mem[_4959 + 64] = 96
            mem[_4959 + 96] = 0
            mem[_4959 + 128] = 0
            mem[_4959 + 160] = 0
            mem[_4959 + 192] = 0
            mem[_4959 + 224] = 0
            mem[var196001] = _4959
            s = var196001
            idx = var196002
            while idx - 1:
                _4959 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4959] = 0
                mem[_4959 + 32] = 96
                mem[_4959 + 64] = 96
                mem[_4959 + 96] = 0
                mem[_4959 + 128] = 0
                mem[_4959 + 160] = 0
                mem[_4959 + 192] = 0
                mem[_4959 + 224] = 0
                mem[s + 32] = _4959
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3915]
            mem[_3915 + 32] = _1780
            require 1 < mem[_3915]
            mem[_3915 + 64] = _3531
            _5247 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5247] = 0
            mem[_5247 + 32] = 96
            mem[_5247 + 64] = 96
            mem[_5247 + 96] = 0
            mem[_5247 + 128] = 0
            mem[_5247 + 160] = 0
            mem[_5247 + 192] = 0
            mem[_5247 + 224] = 0
            require 0 < mem[_3915]
            _5533 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5533] = 0
            mem[_5533 + 32] = 96
            mem[_5533 + 64] = 96
            mem[_5533 + 96] = 0
            mem[_5533 + 128] = 0
            mem[_5533 + 160] = 0
            mem[_5533 + 192] = 0
            mem[_5533 + 224] = 0
            require 1 < mem[_3915]
            if mem[_1780 + 96] <= mem[_3531 + 96]:
                idx = 12
                s = mem[_1780 + 96]
                while idx >= 4:
                    if not mem[_1780 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_1780 + 96] - idx
                    continue 
                _6251 = mem[_1780 + 96]
                _6252 = mem[_1780 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6251 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_3531 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_3531 + 128] / 10^(mem[_3531 + 96] - s):
                    if not _6252 / 10^(_6251 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6252 / 10^(_6251 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6252 / 10^(_6251 - s))
                if 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6252 / 10^(_6251 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / _6252 / 10^(_6251 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / _6252 / 10^(_6251 - s))
            idx = 12
            s = mem[_3531 + 96]
            while idx >= 4:
                if not mem[_3531 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3531 + 96] - idx
                continue 
            _6253 = mem[_1780 + 96]
            _6254 = mem[_1780 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6253 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3531 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3531 + 128] / 10^(mem[_3531 + 96] - s):
                if not _6254 / 10^(_6253 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6254 / 10^(_6253 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6254 / 10^(_6253 - s))
            if 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6254 / 10^(_6253 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / _6254 / 10^(_6253 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / _6254 / 10^(_6253 - s))
        if busdAddress == uint64(ext_call.return_data[0]) << 96:
            _3962 = mem[64]
            mem[mem[64]] = 2
            _4958 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4958] = 0
            mem[_4958 + 32] = 96
            mem[_4958 + 64] = 96
            mem[_4958 + 96] = 0
            mem[_4958 + 128] = 0
            mem[_4958 + 160] = 0
            mem[_4958 + 192] = 0
            mem[_4958 + 224] = 0
            mem[var199001] = _4958
            s = var199001
            idx = var199002
            while idx - 1:
                _4958 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4958] = 0
                mem[_4958 + 32] = 96
                mem[_4958 + 64] = 96
                mem[_4958 + 96] = 0
                mem[_4958 + 128] = 0
                mem[_4958 + 160] = 0
                mem[_4958 + 192] = 0
                mem[_4958 + 224] = 0
                mem[s + 32] = _4958
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_3962]
            mem[_3962 + 32] = _3531
            require 1 < mem[_3962]
            mem[_3962 + 64] = _1780
            _5246 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5246] = 0
            mem[_5246 + 32] = 96
            mem[_5246 + 64] = 96
            mem[_5246 + 96] = 0
            mem[_5246 + 128] = 0
            mem[_5246 + 160] = 0
            mem[_5246 + 192] = 0
            mem[_5246 + 224] = 0
            require 0 < mem[_3962]
            _5532 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5532] = 0
            mem[_5532 + 32] = 96
            mem[_5532 + 64] = 96
            mem[_5532 + 96] = 0
            mem[_5532 + 128] = 0
            mem[_5532 + 160] = 0
            mem[_5532 + 192] = 0
            mem[_5532 + 224] = 0
            require 1 < mem[_3962]
            if mem[_3531 + 96] <= mem[_1780 + 96]:
                idx = 12
                s = mem[_3531 + 96]
                while idx >= 4:
                    if not mem[_3531 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3531 + 96] - idx
                    continue 
                _6247 = mem[_3531 + 96]
                _6248 = mem[_3531 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6247 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6248 / 10^(_6247 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6248 / 10^(_6247 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6248 / 10^(_6247 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6248 / 10^(_6247 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6248 / 10^(_6247 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6248 / 10^(_6247 - s))
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _6249 = mem[_3531 + 96]
            _6250 = mem[_3531 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6249 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6250 / 10^(_6249 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6250 / 10^(_6249 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6250 / 10^(_6249 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6250 / 10^(_6249 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6250 / 10^(_6249 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6250 / 10^(_6249 - s))
        if usdtAddress == uint64(ext_call.return_data[0]) << 96:
            _4010 = mem[64]
            mem[mem[64]] = 2
            _4957 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_4957] = 0
            mem[_4957 + 32] = 96
            mem[_4957 + 64] = 96
            mem[_4957 + 96] = 0
            mem[_4957 + 128] = 0
            mem[_4957 + 160] = 0
            mem[_4957 + 192] = 0
            mem[_4957 + 224] = 0
            mem[var202001] = _4957
            s = var202001
            idx = var202002
            while idx - 1:
                _4957 = mem[64]
                mem[64] = mem[64] + 256
                mem[_4957] = 0
                mem[_4957 + 32] = 96
                mem[_4957 + 64] = 96
                mem[_4957 + 96] = 0
                mem[_4957 + 128] = 0
                mem[_4957 + 160] = 0
                mem[_4957 + 192] = 0
                mem[_4957 + 224] = 0
                mem[s + 32] = _4957
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4010]
            mem[_4010 + 32] = _3531
            require 1 < mem[_4010]
            mem[_4010 + 64] = _1780
            _5245 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5245] = 0
            mem[_5245 + 32] = 96
            mem[_5245 + 64] = 96
            mem[_5245 + 96] = 0
            mem[_5245 + 128] = 0
            mem[_5245 + 160] = 0
            mem[_5245 + 192] = 0
            mem[_5245 + 224] = 0
            require 0 < mem[_4010]
            _5531 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5531] = 0
            mem[_5531 + 32] = 96
            mem[_5531 + 64] = 96
            mem[_5531 + 96] = 0
            mem[_5531 + 128] = 0
            mem[_5531 + 160] = 0
            mem[_5531 + 192] = 0
            mem[_5531 + 224] = 0
            require 1 < mem[_4010]
            if mem[_3531 + 96] <= mem[_1780 + 96]:
                idx = 12
                s = mem[_3531 + 96]
                while idx >= 4:
                    if not mem[_3531 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3531 + 96] - idx
                    continue 
                _6243 = mem[_3531 + 96]
                _6244 = mem[_3531 + 128]
                mem[mem[64]] = 26
                mem[mem[64] + 32] = 'SafeMath: division by zero'
                if not 10^(_6243 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^(mem[_1780 + 96] - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                    if not _6244 / 10^(_6243 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    if not 0 / _6244 / 10^(_6243 - s):
                        revert with 0, 'SafeMath: division by zero', 0
                    return (1000000 * 10^18 / 0 / _6244 / 10^(_6243 - s))
                if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not _6244 / 10^(_6243 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6244 / 10^(_6243 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6244 / 10^(_6243 - s))
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _6245 = mem[_3531 + 96]
            _6246 = mem[_3531 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6245 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6246 / 10^(_6245 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6246 / 10^(_6245 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6246 / 10^(_6245 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6246 / 10^(_6245 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6246 / 10^(_6245 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6246 / 10^(_6245 - s))
        idx = 0
        while idx < sub_27d312da.length:
            mem[0] = 1
            if sub_27d312da[idx] != address(ext_call.return_data[0]):
                idx = idx + 1
                continue 
            _4427 = mem[64]
            mem[mem[64]] = 2
            _5986 = mem[64] + 96
            mem[64] = mem[64] + 352
            mem[_5986] = 0
            mem[_5986 + 32] = 96
            mem[_5986 + 64] = 96
            mem[_5986 + 96] = 0
            mem[_5986 + 128] = 0
            mem[_5986 + 160] = 0
            mem[_5986 + 192] = 0
            mem[_5986 + 224] = 0
            mem[var211001] = _5986
            s = var211001
            idx = var211002
            while idx - 1:
                _5986 = mem[64]
                mem[64] = mem[64] + 256
                mem[_5986] = 0
                mem[_5986 + 32] = 96
                mem[_5986 + 64] = 96
                mem[_5986 + 96] = 0
                mem[_5986 + 128] = 0
                mem[_5986 + 160] = 0
                mem[_5986 + 192] = 0
                mem[_5986 + 224] = 0
                mem[s + 32] = _5986
                s = s + 32
                idx = idx - 1
                continue 
            require 0 < mem[_4427]
            mem[_4427 + 32] = _3531
            require 1 < mem[_4427]
            mem[_4427 + 64] = _1780
            _6594 = mem[64]
            mem[64] = mem[64] + 256
            mem[_6594] = 0
            mem[_6594 + 32] = 96
            mem[_6594 + 64] = 96
            mem[_6594 + 96] = 0
            mem[_6594 + 128] = 0
            mem[_6594 + 160] = 0
            mem[_6594 + 192] = 0
            mem[_6594 + 224] = 0
            require 0 < mem[_4427]
            _7042 = mem[64]
            mem[64] = mem[64] + 256
            mem[_7042] = 0
            mem[_7042 + 32] = 96
            mem[_7042 + 64] = 96
            mem[_7042 + 96] = 0
            mem[_7042 + 128] = 0
            mem[_7042 + 160] = 0
            mem[_7042 + 192] = 0
            mem[_7042 + 224] = 0
            require 1 < mem[_4427]
            if mem[_3531 + 96] <= mem[_1780 + 96]:
                idx = 12
                s = mem[_3531 + 96]
                while idx >= 4:
                    if not mem[_3531 + 96] - idx:
                        idx = idx - 1
                        s = s
                        continue 
                    idx = idx - 1
                    s = mem[_3531 + 96] - idx
                    continue 
                _13081 = mem[_3531 + 96]
                _13082 = mem[_3531 + 128]
                _13151 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13151] = 26
                mem[_13151 + 32] = 'SafeMath: division by zero'
                if not 10^(_13081 - s):
                    _13215 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13215 + 68] = mem[idx + _13151 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13215 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13215 + -mem[64] + 100
                _14937 = mem[_1780 + 96]
                _14938 = mem[_1780 + 128]
                _15065 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15065] = 26
                mem[_15065 + 32] = 'SafeMath: division by zero'
                if not 10^(_14937 - s):
                    _15135 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15135 + 68] = mem[idx + _15065 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15135 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15135 + -mem[64] + 100
                if not _14938 / 10^(_14937 - s):
                    _15519 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15519] = 26
                    mem[_15519 + 32] = 'SafeMath: division by zero'
                    if not _13082 / 10^(_13081 - s):
                        _15828 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15828 + 68] = mem[idx + _15519 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15828 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15828 + -mem[64] + 100
                    _16345 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16345] = 26
                    mem[_16345 + 32] = 'SafeMath: division by zero'
                    if 0 / _13082 / 10^(_13081 - s):
                        return (1000000 * 10^18 / 0 / _13082 / 10^(_13081 - s))
                    _16597 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _16597 + 68] = mem[idx + _16345 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16597 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _16597 + -mem[64] + 100
                if 10^12 * _14938 / 10^(_14937 - s) / _14938 / 10^(_14937 - s) != 10^12:
                    revert with 0, 'SafeMath: multiplication overflow'
                _15827 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15827] = 26
                mem[_15827 + 32] = 'SafeMath: division by zero'
                if not _13082 / 10^(_13081 - s):
                    _15961 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15961 + 68] = mem[idx + _15827 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15961 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15961 + -mem[64] + 100
                _16595 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16595] = 26
                mem[_16595 + 32] = 'SafeMath: division by zero'
                if 10^12 * _14938 / 10^(_14937 - s) / _13082 / 10^(_13081 - s):
                    return (1000000 * 10^18 / 10^12 * _14938 / 10^(_14937 - s) / _13082 / 10^(_13081 - s))
                _16729 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16729 + 68] = mem[idx + _16595 + 32]
                    idx = idx + 32
                    continue 
                mem[_16729 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16729 + -mem[64] + 100
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _13083 = mem[_3531 + 96]
            _13084 = mem[_3531 + 128]
            _13152 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13152] = 26
            mem[_13152 + 32] = 'SafeMath: division by zero'
            if not 10^(_13083 - s):
                _13216 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13216 + 68] = mem[idx + _13152 + 32]
                    idx = idx + 32
                    continue 
                mem[_13216 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13216 + -mem[64] + 100
            _14939 = mem[_1780 + 96]
            _14940 = mem[_1780 + 128]
            _15067 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15067] = 26
            mem[_15067 + 32] = 'SafeMath: division by zero'
            if not 10^(_14939 - s):
                _15136 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15136 + 68] = mem[idx + _15067 + 32]
                    idx = idx + 32
                    continue 
                mem[_15136 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15136 + -mem[64] + 100
            if not _14940 / 10^(_14939 - s):
                _15520 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15520] = 26
                mem[_15520 + 32] = 'SafeMath: division by zero'
                if not _13084 / 10^(_13083 - s):
                    _15831 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15831 + 68] = mem[idx + _15520 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15831 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15831 + -mem[64] + 100
                _16347 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16347] = 26
                mem[_16347 + 32] = 'SafeMath: division by zero'
                if 0 / _13084 / 10^(_13083 - s):
                    return (1000000 * 10^18 / 0 / _13084 / 10^(_13083 - s))
                _16600 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16600 + 68] = mem[idx + _16347 + 32]
                    idx = idx + 32
                    continue 
                mem[_16600 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16600 + -mem[64] + 100
            if 10^12 * _14940 / 10^(_14939 - s) / _14940 / 10^(_14939 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15830 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15830] = 26
            mem[_15830 + 32] = 'SafeMath: division by zero'
            if not _13084 / 10^(_13083 - s):
                _15963 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15963 + 68] = mem[idx + _15830 + 32]
                    idx = idx + 32
                    continue 
                mem[_15963 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15963 + -mem[64] + 100
            _16598 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16598] = 26
            mem[_16598 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14940 / 10^(_14939 - s) / _13084 / 10^(_13083 - s):
                return (1000000 * 10^18 / 10^12 * _14940 / 10^(_14939 - s) / _13084 / 10^(_13083 - s))
            _16731 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16731 + 68] = mem[idx + _16598 + 32]
                idx = idx + 32
                continue 
            mem[_16731 + 94] = 0
            revert with memory
              from mem[64]
               len _16731 + -mem[64] + 100
        _4267 = mem[64]
        mem[mem[64]] = 2
        _5985 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_5985] = 0
        mem[_5985 + 32] = 96
        mem[_5985 + 64] = 96
        mem[_5985 + 96] = 0
        mem[_5985 + 128] = 0
        mem[_5985 + 160] = 0
        mem[_5985 + 192] = 0
        mem[_5985 + 224] = 0
        mem[var207001] = _5985
        s = var207001
        idx = var207002
        while idx - 1:
            _5985 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5985] = 0
            mem[_5985 + 32] = 96
            mem[_5985 + 64] = 96
            mem[_5985 + 96] = 0
            mem[_5985 + 128] = 0
            mem[_5985 + 160] = 0
            mem[_5985 + 192] = 0
            mem[_5985 + 224] = 0
            mem[s + 32] = _5985
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4267]
        mem[_4267 + 32] = _1780
        require 1 < mem[_4267]
        mem[_4267 + 64] = _3531
        _6593 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6593] = 0
        mem[_6593 + 32] = 96
        mem[_6593 + 64] = 96
        mem[_6593 + 96] = 0
        mem[_6593 + 128] = 0
        mem[_6593 + 160] = 0
        mem[_6593 + 192] = 0
        mem[_6593 + 224] = 0
        require 0 < mem[_4267]
        _7041 = mem[64]
        mem[64] = mem[64] + 256
        mem[_7041] = 0
        mem[_7041 + 32] = 96
        mem[_7041 + 64] = 96
        mem[_7041 + 96] = 0
        mem[_7041 + 128] = 0
        mem[_7041 + 160] = 0
        mem[_7041 + 192] = 0
        mem[_7041 + 224] = 0
        require 1 < mem[_4267]
        if mem[_1780 + 96] <= mem[_3531 + 96]:
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _13077 = mem[_1780 + 96]
            _13078 = mem[_1780 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_13077 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3531 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3531 + 128] / 10^(mem[_3531 + 96] - s):
                if not _13078 / 10^(_13077 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _13078 / 10^(_13077 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _13078 / 10^(_13077 - s))
            if 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _13078 / 10^(_13077 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / _13078 / 10^(_13077 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / _13078 / 10^(_13077 - s))
        idx = 12
        s = mem[_3531 + 96]
        while idx >= 4:
            if not mem[_3531 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3531 + 96] - idx
            continue 
        _13079 = mem[_1780 + 96]
        _13080 = mem[_1780 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13079 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3531 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3531 + 128] / 10^(mem[_3531 + 96] - s):
            if not _13080 / 10^(_13079 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13080 / 10^(_13079 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13080 / 10^(_13079 - s))
        if 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13080 / 10^(_13079 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / _13080 / 10^(_13079 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3531 + 128] / 10^(mem[_3531 + 96] - s) / _13080 / 10^(_13079 - s))
    mem[_2636 + ceil32(return_data.size) + _2652 + 32] = 0
    require ext_code.size(address(_1800))
    staticcall address(_1800).0x313ce567 with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3444 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3460 = mem[_3444]
    require mem[_3444] == mem[_3444 + 31 len 1]
    require ext_code.size(address(_1800))
    staticcall address(_1800).0x18160ddd with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3508 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3532 = mem[_3508]
    _3556 = mem[64]
    mem[64] = mem[64] + 256
    mem[_3556] = address(_1800)
    mem[_3556 + 32] = _1816 + ceil32(return_data.size)
    mem[_3556 + 64] = _2636 + ceil32(return_data.size)
    mem[_3556 + 96] = uint8(_3460)
    mem[_3556 + 128] = 0
    mem[_3556 + 160] = _3532
    mem[_3556 + 192] = 0
    mem[_3556 + 224] = 0
    require ext_code.size(arg1)
    staticcall arg1.token0() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3588 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3604 = mem[_3588]
    require mem[_3588] == mem[_3588 + 12 len 20]
    mem[mem[64] + 4] = arg1
    require ext_code.size(address(_3604))
    staticcall address(_3604).0x70a08231 with:
            gas gas_remaining wei
           args address(arg1)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3652 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    mem[_1780 + 128] = mem[_3652]
    require ext_code.size(arg1)
    staticcall arg1.token1() with:
            gas gas_remaining wei
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3716 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _3732 = mem[_3716]
    require mem[_3716] == mem[_3716 + 12 len 20]
    mem[mem[64] + 4] = arg1
    require ext_code.size(address(_3732))
    staticcall address(_3732).0x70a08231 with:
            gas gas_remaining wei
           args address(arg1)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _3780 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    mem[_3556 + 128] = mem[_3780]
    _3812 = mem[64]
    mem[64] = mem[64] + 256
    mem[_3812] = 0
    mem[_3812 + 32] = 96
    mem[_3812 + 64] = 96
    mem[_3812 + 96] = 0
    mem[_3812 + 128] = 0
    mem[_3812 + 160] = 0
    mem[_3812 + 192] = 0
    mem[_3812 + 224] = 0
    _3836 = mem[64]
    mem[64] = mem[64] + 256
    mem[_3836] = 0
    mem[_3836 + 32] = 96
    mem[_3836 + 64] = 96
    mem[_3836 + 96] = 0
    mem[_3836 + 128] = 0
    mem[_3836 + 160] = 0
    mem[_3836 + 192] = 0
    mem[_3836 + 224] = 0
    if wbnbAddress == uint64(ext_call.return_data[0]) << 96:
        _3876 = mem[64]
        mem[mem[64]] = 2
        _4964 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_4964] = 0
        mem[_4964 + 32] = 96
        mem[_4964 + 64] = 96
        mem[_4964 + 96] = 0
        mem[_4964 + 128] = 0
        mem[_4964 + 160] = 0
        mem[_4964 + 192] = 0
        mem[_4964 + 224] = 0
        mem[var193001] = _4964
        s = var193001
        idx = var193002
        while idx - 1:
            _4964 = mem[64]
            mem[64] = mem[64] + 256
            mem[_4964] = 0
            mem[_4964 + 32] = 96
            mem[_4964 + 64] = 96
            mem[_4964 + 96] = 0
            mem[_4964 + 128] = 0
            mem[_4964 + 160] = 0
            mem[_4964 + 192] = 0
            mem[_4964 + 224] = 0
            mem[s + 32] = _4964
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_3876]
        mem[_3876 + 32] = _3556
        require 1 < mem[_3876]
        mem[_3876 + 64] = _1780
        _5252 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5252] = 0
        mem[_5252 + 32] = 96
        mem[_5252 + 64] = 96
        mem[_5252 + 96] = 0
        mem[_5252 + 128] = 0
        mem[_5252 + 160] = 0
        mem[_5252 + 192] = 0
        mem[_5252 + 224] = 0
        require 0 < mem[_3876]
        _5540 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5540] = 0
        mem[_5540 + 32] = 96
        mem[_5540 + 64] = 96
        mem[_5540 + 96] = 0
        mem[_5540 + 128] = 0
        mem[_5540 + 160] = 0
        mem[_5540 + 192] = 0
        mem[_5540 + 224] = 0
        require 1 < mem[_3876]
        if mem[_3556 + 96] <= mem[_1780 + 96]:
            idx = 12
            s = mem[_3556 + 96]
            while idx >= 4:
                if not mem[_3556 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3556 + 96] - idx
                continue 
            _6273 = mem[_3556 + 96]
            _6274 = mem[_3556 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6273 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6274 / 10^(_6273 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6274 / 10^(_6273 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6274 / 10^(_6273 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6274 / 10^(_6273 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6274 / 10^(_6273 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6274 / 10^(_6273 - s))
        idx = 12
        s = mem[_1780 + 96]
        while idx >= 4:
            if not mem[_1780 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1780 + 96] - idx
            continue 
        _6275 = mem[_3556 + 96]
        _6276 = mem[_3556 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_6275 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_1780 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
            if not _6276 / 10^(_6275 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _6276 / 10^(_6275 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _6276 / 10^(_6275 - s))
        if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _6276 / 10^(_6275 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6276 / 10^(_6275 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6276 / 10^(_6275 - s))
    if wbnbAddress == address(_1800):
        _3924 = mem[64]
        mem[mem[64]] = 2
        _4963 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_4963] = 0
        mem[_4963 + 32] = 96
        mem[_4963 + 64] = 96
        mem[_4963 + 96] = 0
        mem[_4963 + 128] = 0
        mem[_4963 + 160] = 0
        mem[_4963 + 192] = 0
        mem[_4963 + 224] = 0
        mem[var197001] = _4963
        s = var197001
        idx = var197002
        while idx - 1:
            _4963 = mem[64]
            mem[64] = mem[64] + 256
            mem[_4963] = 0
            mem[_4963 + 32] = 96
            mem[_4963 + 64] = 96
            mem[_4963 + 96] = 0
            mem[_4963 + 128] = 0
            mem[_4963 + 160] = 0
            mem[_4963 + 192] = 0
            mem[_4963 + 224] = 0
            mem[s + 32] = _4963
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_3924]
        mem[_3924 + 32] = _1780
        require 1 < mem[_3924]
        mem[_3924 + 64] = _3556
        _5251 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5251] = 0
        mem[_5251 + 32] = 96
        mem[_5251 + 64] = 96
        mem[_5251 + 96] = 0
        mem[_5251 + 128] = 0
        mem[_5251 + 160] = 0
        mem[_5251 + 192] = 0
        mem[_5251 + 224] = 0
        require 0 < mem[_3924]
        _5539 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5539] = 0
        mem[_5539 + 32] = 96
        mem[_5539 + 64] = 96
        mem[_5539 + 96] = 0
        mem[_5539 + 128] = 0
        mem[_5539 + 160] = 0
        mem[_5539 + 192] = 0
        mem[_5539 + 224] = 0
        require 1 < mem[_3924]
        if mem[_1780 + 96] <= mem[_3556 + 96]:
            idx = 12
            s = mem[_1780 + 96]
            while idx >= 4:
                if not mem[_1780 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_1780 + 96] - idx
                continue 
            _6269 = mem[_1780 + 96]
            _6270 = mem[_1780 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6269 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_3556 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_3556 + 128] / 10^(mem[_3556 + 96] - s):
                if not _6270 / 10^(_6269 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6270 / 10^(_6269 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6270 / 10^(_6269 - s))
            if 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6270 / 10^(_6269 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / _6270 / 10^(_6269 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / _6270 / 10^(_6269 - s))
        idx = 12
        s = mem[_3556 + 96]
        while idx >= 4:
            if not mem[_3556 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_3556 + 96] - idx
            continue 
        _6271 = mem[_1780 + 96]
        _6272 = mem[_1780 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_6271 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3556 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3556 + 128] / 10^(mem[_3556 + 96] - s):
            if not _6272 / 10^(_6271 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _6272 / 10^(_6271 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _6272 / 10^(_6271 - s))
        if 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _6272 / 10^(_6271 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / _6272 / 10^(_6271 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / _6272 / 10^(_6271 - s))
    if busdAddress == uint64(ext_call.return_data[0]) << 96:
        _3972 = mem[64]
        mem[mem[64]] = 2
        _4962 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_4962] = 0
        mem[_4962 + 32] = 96
        mem[_4962 + 64] = 96
        mem[_4962 + 96] = 0
        mem[_4962 + 128] = 0
        mem[_4962 + 160] = 0
        mem[_4962 + 192] = 0
        mem[_4962 + 224] = 0
        mem[var200001] = _4962
        s = var200001
        idx = var200002
        while idx - 1:
            _4962 = mem[64]
            mem[64] = mem[64] + 256
            mem[_4962] = 0
            mem[_4962 + 32] = 96
            mem[_4962 + 64] = 96
            mem[_4962 + 96] = 0
            mem[_4962 + 128] = 0
            mem[_4962 + 160] = 0
            mem[_4962 + 192] = 0
            mem[_4962 + 224] = 0
            mem[s + 32] = _4962
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_3972]
        mem[_3972 + 32] = _3556
        require 1 < mem[_3972]
        mem[_3972 + 64] = _1780
        _5250 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5250] = 0
        mem[_5250 + 32] = 96
        mem[_5250 + 64] = 96
        mem[_5250 + 96] = 0
        mem[_5250 + 128] = 0
        mem[_5250 + 160] = 0
        mem[_5250 + 192] = 0
        mem[_5250 + 224] = 0
        require 0 < mem[_3972]
        _5538 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5538] = 0
        mem[_5538 + 32] = 96
        mem[_5538 + 64] = 96
        mem[_5538 + 96] = 0
        mem[_5538 + 128] = 0
        mem[_5538 + 160] = 0
        mem[_5538 + 192] = 0
        mem[_5538 + 224] = 0
        require 1 < mem[_3972]
        if mem[_3556 + 96] <= mem[_1780 + 96]:
            idx = 12
            s = mem[_3556 + 96]
            while idx >= 4:
                if not mem[_3556 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3556 + 96] - idx
                continue 
            _6265 = mem[_3556 + 96]
            _6266 = mem[_3556 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6265 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6266 / 10^(_6265 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6266 / 10^(_6265 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6266 / 10^(_6265 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6266 / 10^(_6265 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6266 / 10^(_6265 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6266 / 10^(_6265 - s))
        idx = 12
        s = mem[_1780 + 96]
        while idx >= 4:
            if not mem[_1780 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1780 + 96] - idx
            continue 
        _6267 = mem[_3556 + 96]
        _6268 = mem[_3556 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_6267 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_1780 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
            if not _6268 / 10^(_6267 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _6268 / 10^(_6267 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _6268 / 10^(_6267 - s))
        if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _6268 / 10^(_6267 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6268 / 10^(_6267 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6268 / 10^(_6267 - s))
    if usdtAddress == uint64(ext_call.return_data[0]) << 96:
        _4020 = mem[64]
        mem[mem[64]] = 2
        _4961 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_4961] = 0
        mem[_4961 + 32] = 96
        mem[_4961 + 64] = 96
        mem[_4961 + 96] = 0
        mem[_4961 + 128] = 0
        mem[_4961 + 160] = 0
        mem[_4961 + 192] = 0
        mem[_4961 + 224] = 0
        mem[var203001] = _4961
        s = var203001
        idx = var203002
        while idx - 1:
            _4961 = mem[64]
            mem[64] = mem[64] + 256
            mem[_4961] = 0
            mem[_4961 + 32] = 96
            mem[_4961 + 64] = 96
            mem[_4961 + 96] = 0
            mem[_4961 + 128] = 0
            mem[_4961 + 160] = 0
            mem[_4961 + 192] = 0
            mem[_4961 + 224] = 0
            mem[s + 32] = _4961
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4020]
        mem[_4020 + 32] = _3556
        require 1 < mem[_4020]
        mem[_4020 + 64] = _1780
        _5249 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5249] = 0
        mem[_5249 + 32] = 96
        mem[_5249 + 64] = 96
        mem[_5249 + 96] = 0
        mem[_5249 + 128] = 0
        mem[_5249 + 160] = 0
        mem[_5249 + 192] = 0
        mem[_5249 + 224] = 0
        require 0 < mem[_4020]
        _5537 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5537] = 0
        mem[_5537 + 32] = 96
        mem[_5537 + 64] = 96
        mem[_5537 + 96] = 0
        mem[_5537 + 128] = 0
        mem[_5537 + 160] = 0
        mem[_5537 + 192] = 0
        mem[_5537 + 224] = 0
        require 1 < mem[_4020]
        if mem[_3556 + 96] <= mem[_1780 + 96]:
            idx = 12
            s = mem[_3556 + 96]
            while idx >= 4:
                if not mem[_3556 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3556 + 96] - idx
                continue 
            _6261 = mem[_3556 + 96]
            _6262 = mem[_3556 + 128]
            mem[mem[64]] = 26
            mem[mem[64] + 32] = 'SafeMath: division by zero'
            if not 10^(_6261 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^(mem[_1780 + 96] - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
                if not _6262 / 10^(_6261 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                if not 0 / _6262 / 10^(_6261 - s):
                    revert with 0, 'SafeMath: division by zero', 0
                return (1000000 * 10^18 / 0 / _6262 / 10^(_6261 - s))
            if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            if not _6262 / 10^(_6261 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6262 / 10^(_6261 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6262 / 10^(_6261 - s))
        idx = 12
        s = mem[_1780 + 96]
        while idx >= 4:
            if not mem[_1780 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1780 + 96] - idx
            continue 
        _6263 = mem[_3556 + 96]
        _6264 = mem[_3556 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_6263 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_1780 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_1780 + 128] / 10^(mem[_1780 + 96] - s):
            if not _6264 / 10^(_6263 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _6264 / 10^(_6263 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _6264 / 10^(_6263 - s))
        if 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _6264 / 10^(_6263 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6264 / 10^(_6263 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_1780 + 128] / 10^(mem[_1780 + 96] - s) / _6264 / 10^(_6263 - s))
    idx = 0
    while idx < sub_27d312da.length:
        mem[0] = 1
        if sub_27d312da[idx] != address(ext_call.return_data[0]):
            idx = idx + 1
            continue 
        _4432 = mem[64]
        mem[mem[64]] = 2
        _5988 = mem[64] + 96
        mem[64] = mem[64] + 352
        mem[_5988] = 0
        mem[_5988 + 32] = 96
        mem[_5988 + 64] = 96
        mem[_5988 + 96] = 0
        mem[_5988 + 128] = 0
        mem[_5988 + 160] = 0
        mem[_5988 + 192] = 0
        mem[_5988 + 224] = 0
        mem[var212001] = _5988
        s = var212001
        idx = var212002
        while idx - 1:
            _5988 = mem[64]
            mem[64] = mem[64] + 256
            mem[_5988] = 0
            mem[_5988 + 32] = 96
            mem[_5988 + 64] = 96
            mem[_5988 + 96] = 0
            mem[_5988 + 128] = 0
            mem[_5988 + 160] = 0
            mem[_5988 + 192] = 0
            mem[_5988 + 224] = 0
            mem[s + 32] = _5988
            s = s + 32
            idx = idx - 1
            continue 
        require 0 < mem[_4432]
        mem[_4432 + 32] = _3556
        require 1 < mem[_4432]
        mem[_4432 + 64] = _1780
        _6596 = mem[64]
        mem[64] = mem[64] + 256
        mem[_6596] = 0
        mem[_6596 + 32] = 96
        mem[_6596 + 64] = 96
        mem[_6596 + 96] = 0
        mem[_6596 + 128] = 0
        mem[_6596 + 160] = 0
        mem[_6596 + 192] = 0
        mem[_6596 + 224] = 0
        require 0 < mem[_4432]
        _7060 = mem[64]
        mem[64] = mem[64] + 256
        mem[_7060] = 0
        mem[_7060 + 32] = 96
        mem[_7060 + 64] = 96
        mem[_7060 + 96] = 0
        mem[_7060 + 128] = 0
        mem[_7060 + 160] = 0
        mem[_7060 + 192] = 0
        mem[_7060 + 224] = 0
        require 1 < mem[_4432]
        if mem[_3556 + 96] <= mem[_1780 + 96]:
            idx = 12
            s = mem[_3556 + 96]
            while idx >= 4:
                if not mem[_3556 + 96] - idx:
                    idx = idx - 1
                    s = s
                    continue 
                idx = idx - 1
                s = mem[_3556 + 96] - idx
                continue 
            _13089 = mem[_3556 + 96]
            _13090 = mem[_3556 + 128]
            _13155 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13155] = 26
            mem[_13155 + 32] = 'SafeMath: division by zero'
            if not 10^(_13089 - s):
                _13219 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _13219 + 68] = mem[idx + _13155 + 32]
                    idx = idx + 32
                    continue 
                mem[_13219 + 94] = 0
                revert with memory
                  from mem[64]
                   len _13219 + -mem[64] + 100
            _14945 = mem[_1780 + 96]
            _14946 = mem[_1780 + 128]
            _15073 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15073] = 26
            mem[_15073 + 32] = 'SafeMath: division by zero'
            if not 10^(_14945 - s):
                _15139 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15139 + 68] = mem[idx + _15073 + 32]
                    idx = idx + 32
                    continue 
                mem[_15139 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15139 + -mem[64] + 100
            if not _14946 / 10^(_14945 - s):
                _15523 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15523] = 26
                mem[_15523 + 32] = 'SafeMath: division by zero'
                if not _13090 / 10^(_13089 - s):
                    _15840 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15840 + 68] = mem[idx + _15523 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15840 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15840 + -mem[64] + 100
                _16353 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16353] = 26
                mem[_16353 + 32] = 'SafeMath: division by zero'
                if 0 / _13090 / 10^(_13089 - s):
                    return (1000000 * 10^18 / 0 / _13090 / 10^(_13089 - s))
                _16609 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _16609 + 68] = mem[idx + _16353 + 32]
                    idx = idx + 32
                    continue 
                mem[_16609 + 94] = 0
                revert with memory
                  from mem[64]
                   len _16609 + -mem[64] + 100
            if 10^12 * _14946 / 10^(_14945 - s) / _14946 / 10^(_14945 - s) != 10^12:
                revert with 0, 'SafeMath: multiplication overflow'
            _15839 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15839] = 26
            mem[_15839 + 32] = 'SafeMath: division by zero'
            if not _13090 / 10^(_13089 - s):
                _15969 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15969 + 68] = mem[idx + _15839 + 32]
                    idx = idx + 32
                    continue 
                mem[_15969 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15969 + -mem[64] + 100
            _16607 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16607] = 26
            mem[_16607 + 32] = 'SafeMath: division by zero'
            if 10^12 * _14946 / 10^(_14945 - s) / _13090 / 10^(_13089 - s):
                return (1000000 * 10^18 / 10^12 * _14946 / 10^(_14945 - s) / _13090 / 10^(_13089 - s))
            _16737 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16737 + 68] = mem[idx + _16607 + 32]
                idx = idx + 32
                continue 
            mem[_16737 + 94] = 0
            revert with memory
              from mem[64]
               len _16737 + -mem[64] + 100
        idx = 12
        s = mem[_1780 + 96]
        while idx >= 4:
            if not mem[_1780 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1780 + 96] - idx
            continue 
        _13091 = mem[_3556 + 96]
        _13092 = mem[_3556 + 128]
        _13156 = mem[64]
        mem[64] = mem[64] + 64
        mem[_13156] = 26
        mem[_13156 + 32] = 'SafeMath: division by zero'
        if not 10^(_13091 - s):
            _13220 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _13220 + 68] = mem[idx + _13156 + 32]
                idx = idx + 32
                continue 
            mem[_13220 + 94] = 0
            revert with memory
              from mem[64]
               len _13220 + -mem[64] + 100
        _14947 = mem[_1780 + 96]
        _14948 = mem[_1780 + 128]
        _15075 = mem[64]
        mem[64] = mem[64] + 64
        mem[_15075] = 26
        mem[_15075 + 32] = 'SafeMath: division by zero'
        if not 10^(_14947 - s):
            _15140 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _15140 + 68] = mem[idx + _15075 + 32]
                idx = idx + 32
                continue 
            mem[_15140 + 94] = 0
            revert with memory
              from mem[64]
               len _15140 + -mem[64] + 100
        if not _14948 / 10^(_14947 - s):
            _15524 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15524] = 26
            mem[_15524 + 32] = 'SafeMath: division by zero'
            if not _13092 / 10^(_13091 - s):
                _15843 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15843 + 68] = mem[idx + _15524 + 32]
                    idx = idx + 32
                    continue 
                mem[_15843 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15843 + -mem[64] + 100
            _16355 = mem[64]
            mem[64] = mem[64] + 64
            mem[_16355] = 26
            mem[_16355 + 32] = 'SafeMath: division by zero'
            if 0 / _13092 / 10^(_13091 - s):
                return (1000000 * 10^18 / 0 / _13092 / 10^(_13091 - s))
            _16612 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _16612 + 68] = mem[idx + _16355 + 32]
                idx = idx + 32
                continue 
            mem[_16612 + 94] = 0
            revert with memory
              from mem[64]
               len _16612 + -mem[64] + 100
        if 10^12 * _14948 / 10^(_14947 - s) / _14948 / 10^(_14947 - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        _15842 = mem[64]
        mem[64] = mem[64] + 64
        mem[_15842] = 26
        mem[_15842 + 32] = 'SafeMath: division by zero'
        if not _13092 / 10^(_13091 - s):
            _15971 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _15971 + 68] = mem[idx + _15842 + 32]
                idx = idx + 32
                continue 
            mem[_15971 + 94] = 0
            revert with memory
              from mem[64]
               len _15971 + -mem[64] + 100
        _16610 = mem[64]
        mem[64] = mem[64] + 64
        mem[_16610] = 26
        mem[_16610 + 32] = 'SafeMath: division by zero'
        if 10^12 * _14948 / 10^(_14947 - s) / _13092 / 10^(_13091 - s):
            return (1000000 * 10^18 / 10^12 * _14948 / 10^(_14947 - s) / _13092 / 10^(_13091 - s))
        _16739 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _16739 + 68] = mem[idx + _16610 + 32]
            idx = idx + 32
            continue 
        mem[_16739 + 94] = 0
        revert with memory
          from mem[64]
           len _16739 + -mem[64] + 100
    _4272 = mem[64]
    mem[mem[64]] = 2
    _5987 = mem[64] + 96
    mem[64] = mem[64] + 352
    mem[_5987] = 0
    mem[_5987 + 32] = 96
    mem[_5987 + 64] = 96
    mem[_5987 + 96] = 0
    mem[_5987 + 128] = 0
    mem[_5987 + 160] = 0
    mem[_5987 + 192] = 0
    mem[_5987 + 224] = 0
    mem[var208001] = _5987
    s = var208001
    idx = var208002
    while idx - 1:
        _5987 = mem[64]
        mem[64] = mem[64] + 256
        mem[_5987] = 0
        mem[_5987 + 32] = 96
        mem[_5987 + 64] = 96
        mem[_5987 + 96] = 0
        mem[_5987 + 128] = 0
        mem[_5987 + 160] = 0
        mem[_5987 + 192] = 0
        mem[_5987 + 224] = 0
        mem[s + 32] = _5987
        s = s + 32
        idx = idx - 1
        continue 
    require 0 < mem[_4272]
    mem[_4272 + 32] = _1780
    require 1 < mem[_4272]
    mem[_4272 + 64] = _3556
    _6595 = mem[64]
    mem[64] = mem[64] + 256
    mem[_6595] = 0
    mem[_6595 + 32] = 96
    mem[_6595 + 64] = 96
    mem[_6595 + 96] = 0
    mem[_6595 + 128] = 0
    mem[_6595 + 160] = 0
    mem[_6595 + 192] = 0
    mem[_6595 + 224] = 0
    require 0 < mem[_4272]
    _7059 = mem[64]
    mem[64] = mem[64] + 256
    mem[_7059] = 0
    mem[_7059 + 32] = 96
    mem[_7059 + 64] = 96
    mem[_7059 + 96] = 0
    mem[_7059 + 128] = 0
    mem[_7059 + 160] = 0
    mem[_7059 + 192] = 0
    mem[_7059 + 224] = 0
    require 1 < mem[_4272]
    if mem[_1780 + 96] <= mem[_3556 + 96]:
        idx = 12
        s = mem[_1780 + 96]
        while idx >= 4:
            if not mem[_1780 + 96] - idx:
                idx = idx - 1
                s = s
                continue 
            idx = idx - 1
            s = mem[_1780 + 96] - idx
            continue 
        _13085 = mem[_1780 + 96]
        _13086 = mem[_1780 + 128]
        mem[mem[64]] = 26
        mem[mem[64] + 32] = 'SafeMath: division by zero'
        if not 10^(_13085 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^(mem[_3556 + 96] - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not mem[_3556 + 128] / 10^(mem[_3556 + 96] - s):
            if not _13086 / 10^(_13085 - s):
                revert with 0, 'SafeMath: division by zero', 0
            if not 0 / _13086 / 10^(_13085 - s):
                revert with 0, 'SafeMath: division by zero', 0
            return (1000000 * 10^18 / 0 / _13086 / 10^(_13085 - s))
        if 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) != 10^12:
            revert with 0, 'SafeMath: multiplication overflow'
        if not _13086 / 10^(_13085 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / _13086 / 10^(_13085 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / _13086 / 10^(_13085 - s))
    idx = 12
    s = mem[_3556 + 96]
    while idx >= 4:
        if not mem[_3556 + 96] - idx:
            idx = idx - 1
            s = s
            continue 
        idx = idx - 1
        s = mem[_3556 + 96] - idx
        continue 
    _13087 = mem[_1780 + 96]
    _13088 = mem[_1780 + 128]
    mem[mem[64]] = 26
    mem[mem[64] + 32] = 'SafeMath: division by zero'
    if not 10^(_13087 - s):
        revert with 0, 'SafeMath: division by zero', 0
    if not 10^(mem[_3556 + 96] - s):
        revert with 0, 'SafeMath: division by zero', 0
    if not mem[_3556 + 128] / 10^(mem[_3556 + 96] - s):
        if not _13088 / 10^(_13087 - s):
            revert with 0, 'SafeMath: division by zero', 0
        if not 0 / _13088 / 10^(_13087 - s):
            revert with 0, 'SafeMath: division by zero', 0
        return (1000000 * 10^18 / 0 / _13088 / 10^(_13087 - s))
    if 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) != 10^12:
        revert with 0, 'SafeMath: multiplication overflow'
    if not _13088 / 10^(_13087 - s):
        revert with 0, 'SafeMath: division by zero', 0
    if not 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / _13088 / 10^(_13087 - s):
        revert with 0, 'SafeMath: division by zero', 0
    return (1000000 * 10^18 / 10^12 * mem[_3556 + 128] / 10^(mem[_3556 + 96] - s) / _13088 / 10^(_13087 - s))
}



}

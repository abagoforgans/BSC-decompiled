contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#
const totalSupply = 100000000 * 10^18


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
array of address stor5;
uint256 stor6;
uint256 totalFees;
array of struct stor8;
array of struct stor9;
uint8 decimals;

function totalFees() payable {
    return totalFees
}

function decimals() payable {
    return decimals
}

function owner() payable {
    return owner
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[address(msg.sender)][address(arg1)] < arg2:
        revert with 'NH{q', 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if allowance[address(msg.sender)][address(arg1)] > -arg2 - 1:
        revert with 'NH{q', 17
    if allowance[address(msg.sender)][address(arg1)] + arg2 < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is not excluded'
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        if stor5[idx] != arg1:
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            continue 
        if stor5.length < 1:
            revert with 'NH{q', 17
        if stor5.length - 1 >= stor5.length:
            revert with 'NH{q', 50
        if idx >= stor5.length:
            revert with 'NH{q', 50
        stor5[idx] = stor5[stor5.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor5.length:
            revert with 'NH{q', 49
        stor5[stor5.length] = 0
        stor5.length--
}

function name() payable {
    if bool(stor8.length):
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 'NH{q', 34
        if bool(stor8.length):
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 'NH{q', 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length.field_1), data=mem[128 len ceil32(stor8.length.field_1)])
                mem[128] = 256 * stor8.length.field_8
        else:
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 'NH{q', 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length.field_1), data=mem[128 len ceil32(stor8.length.field_1)])
                mem[128] = 256 * stor8.length.field_8
        mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
        if ceil32(stor8.length.field_1) > stor8.length.field_1:
            mem[ceil32(stor8.length.field_1) + stor8.length.field_1 + 192] = 0
        return Array(len=2 * Mask(256, -1, stor8.length.field_1), data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
    if bool(stor8.length) == stor8.length.field_1 < 32:
        revert with 'NH{q', 34
    if bool(stor8.length):
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 'NH{q', 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    else:
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 'NH{q', 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
    if ceil32(stor8.length.field_1) > stor8.length.field_1:
        mem[ceil32(stor8.length.field_1) + stor8.length.field_1 + 192] = 0
    return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
}

function symbol() payable {
    if bool(stor9.length):
        if bool(stor9.length) == stor9.length.field_1 < 32:
            revert with 'NH{q', 34
        if bool(stor9.length):
            if bool(stor9.length) == stor9.length.field_1 < 32:
                revert with 'NH{q', 34
            if stor9.length.field_1:
                if 31 < stor9.length.field_1:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while stor9.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length.field_1), data=mem[128 len ceil32(stor9.length.field_1)])
                mem[128] = 256 * stor9.length.field_8
        else:
            if bool(stor9.length) == stor9.length.field_1 < 32:
                revert with 'NH{q', 34
            if stor9.length.field_1:
                if 31 < stor9.length.field_1:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while stor9.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length.field_1), data=mem[128 len ceil32(stor9.length.field_1)])
                mem[128] = 256 * stor9.length.field_8
        mem[ceil32(stor9.length.field_1) + 192 len ceil32(stor9.length.field_1)] = mem[128 len ceil32(stor9.length.field_1)]
        if ceil32(stor9.length.field_1) > stor9.length.field_1:
            mem[ceil32(stor9.length.field_1) + stor9.length.field_1 + 192] = 0
        return Array(len=2 * Mask(256, -1, stor9.length.field_1), data=mem[128 len ceil32(stor9.length.field_1)], mem[(2 * ceil32(stor9.length.field_1)) + 192 len 2 * ceil32(stor9.length.field_1)]), 
    if bool(stor9.length) == stor9.length.field_1 < 32:
        revert with 'NH{q', 34
    if bool(stor9.length):
        if bool(stor9.length) == stor9.length.field_1 < 32:
            revert with 'NH{q', 34
        if stor9.length.field_1:
            if 31 < stor9.length.field_1:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while stor9.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    else:
        if bool(stor9.length) == stor9.length.field_1 < 32:
            revert with 'NH{q', 34
        if stor9.length.field_1:
            if 31 < stor9.length.field_1:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while stor9.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    mem[ceil32(stor9.length.field_1) + 192 len ceil32(stor9.length.field_1)] = mem[128 len ceil32(stor9.length.field_1)]
    if ceil32(stor9.length.field_1) > stor9.length.field_1:
        mem[ceil32(stor9.length.field_1) + stor9.length.field_1 + 192] = 0
    return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)], mem[(2 * ceil32(stor9.length.field_1)) + 192 len 2 * ceil32(stor9.length.field_1)]), 
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if arg1 > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = 100000000 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _65 = mem[64]
            mem[64] = mem[64] + 64
            mem[_65] = 26
            mem[_65 + 32] = 'SafeMath: division by zero'
            _76 = mem[64]
            mem[64] = mem[64] + 64
            mem[_76] = 26
            mem[_76 + 32] = 'SafeMath: division by zero'
            if stor6 / 100000000 * 10^18 > 0:
                if not stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 18
                return (arg1 / stor6 / 100000000 * 10^18)
            _81 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_81 + idx + 68] = mem[_76 + idx + 32]
                idx = idx + 32
                continue 
            mem[_81 + 94] = 0
            revert with memory
              from mem[64]
               len _81 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 'NH{q', 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _69 = mem[64]
            mem[64] = mem[64] + 64
            mem[_69] = 26
            mem[_69 + 32] = 'SafeMath: division by zero'
            _82 = mem[64]
            mem[64] = mem[64] + 64
            mem[_82] = 26
            mem[_82 + 32] = 'SafeMath: division by zero'
            if stor6 / 100000000 * 10^18 > 0:
                if not stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 18
                return (arg1 / stor6 / 100000000 * 10^18)
            _84 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_84 + idx + 68] = mem[_82 + idx + 32]
                idx = idx + 32
                continue 
            mem[_84 + 94] = 0
            revert with memory
              from mem[64]
               len _84 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 'NH{q', 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _68 = mem[64]
        mem[64] = mem[64] + 64
        mem[_68] = 30
        mem[_68 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _70 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_70 + idx + 68] = mem[_68 + idx + 32]
                idx = idx + 32
                continue 
            mem[_70 + 98] = 0
            revert with memory
              from mem[64]
               len _70 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 'NH{q', 17
        if idx >= stor5.length:
            revert with 'NH{q', 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _79 = mem[64]
        mem[64] = mem[64] + 64
        mem[_79] = 30
        mem[_79 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 'NH{q', 17
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _83 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_83 + idx + 68] = mem[_79 + idx + 32]
            idx = idx + 32
            continue 
        mem[_83 + 98] = 0
        revert with memory
          from mem[64]
           len _83 + -mem[64] + 100
    if t < stor6 / 100000000 * 10^18:
        if stor6 / 100000000 * 10^18 <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not stor6 / 100000000 * 10^18:
            revert with 'NH{q', 18
        return (arg1 / stor6 / 100000000 * 10^18)
    if s <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not s:
        revert with 'NH{q', 18
    if t / s <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not t / s:
        revert with 'NH{q', 18
    return (arg1 / t / s)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = 100000000 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _70 = mem[64]
            mem[64] = mem[64] + 64
            mem[_70] = 26
            mem[_70 + 32] = 'SafeMath: division by zero'
            _81 = mem[64]
            mem[64] = mem[64] + 64
            mem[_81] = 26
            mem[_81 + 32] = 'SafeMath: division by zero'
            if stor6 / 100000000 * 10^18 > 0:
                if not stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 18
                return (stor1[address(arg1)] / stor6 / 100000000 * 10^18)
            _86 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_86 + idx + 68] = mem[_81 + idx + 32]
                idx = idx + 32
                continue 
            mem[_86 + 94] = 0
            revert with memory
              from mem[64]
               len _86 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 'NH{q', 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _74 = mem[64]
            mem[64] = mem[64] + 64
            mem[_74] = 26
            mem[_74 + 32] = 'SafeMath: division by zero'
            _87 = mem[64]
            mem[64] = mem[64] + 64
            mem[_87] = 26
            mem[_87 + 32] = 'SafeMath: division by zero'
            if stor6 / 100000000 * 10^18 > 0:
                if not stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 18
                return (stor1[address(arg1)] / stor6 / 100000000 * 10^18)
            _89 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_89 + idx + 68] = mem[_87 + idx + 32]
                idx = idx + 32
                continue 
            mem[_89 + 94] = 0
            revert with memory
              from mem[64]
               len _89 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 'NH{q', 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _73 = mem[64]
        mem[64] = mem[64] + 64
        mem[_73] = 30
        mem[_73 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _75 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_75 + idx + 68] = mem[_73 + idx + 32]
                idx = idx + 32
                continue 
            mem[_75 + 98] = 0
            revert with memory
              from mem[64]
               len _75 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 'NH{q', 17
        if idx >= stor5.length:
            revert with 'NH{q', 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _84 = mem[64]
        mem[64] = mem[64] + 64
        mem[_84] = 30
        mem[_84 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 'NH{q', 17
            if idx == -1:
                revert with 'NH{q', 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _88 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_88 + idx + 68] = mem[_84 + idx + 32]
            idx = idx + 32
            continue 
        mem[_88 + 98] = 0
        revert with memory
          from mem[64]
           len _88 + -mem[64] + 100
    if t < stor6 / 100000000 * 10^18:
        if stor6 / 100000000 * 10^18 <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not stor6 / 100000000 * 10^18:
            revert with 'NH{q', 18
        return (stor1[address(arg1)] / stor6 / 100000000 * 10^18)
    if s <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not s:
        revert with 'NH{q', 18
    if t / s <= 0:
        revert with 0, 'SafeMath: division by zero', 0
    if not t / s:
        revert with 'NH{q', 18
    return (stor1[address(arg1)] / t / s)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is not excluded'
    if stor1[address(arg1)] > 0:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor6:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _78 = mem[64]
                mem[64] = mem[64] + 64
                mem[_78] = 26
                mem[_78 + 32] = 'SafeMath: division by zero'
                _89 = mem[64]
                mem[64] = mem[64] + 64
                mem[_89] = 26
                mem[_89 + 32] = 'SafeMath: division by zero'
                if stor6 / 100000000 * 10^18 > 0:
                    if not stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100000000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor5[stor5.length] = arg1
                _94 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_94 + idx + 68] = mem[_89 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_94 + 94] = 0
                revert with memory
                  from mem[64]
                   len _94 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _82 = mem[64]
                mem[64] = mem[64] + 64
                mem[_82] = 26
                mem[_82 + 32] = 'SafeMath: division by zero'
                _95 = mem[64]
                mem[64] = mem[64] + 64
                mem[_95] = 26
                mem[_95 + 32] = 'SafeMath: division by zero'
                if stor6 / 100000000 * 10^18 > 0:
                    if not stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100000000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor5[stor5.length] = arg1
                _97 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_97 + idx + 68] = mem[_95 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_97 + 94] = 0
                revert with memory
                  from mem[64]
                   len _97 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 1
            _81 = mem[64]
            mem[64] = mem[64] + 64
            mem[_81] = 30
            mem[_81 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _83 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_83 + idx + 68] = mem[_81 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_83 + 98] = 0
                revert with memory
                  from mem[64]
                   len _83 + -mem[64] + 100
            if t < stor1[stor5[idx]]:
                revert with 'NH{q', 17
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 2
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 30
            mem[_92 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                if s < stor2[stor5[idx]]:
                    revert with 'NH{q', 17
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _96 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_96 + idx + 68] = mem[_92 + idx + 32]
                idx = idx + 32
                continue 
            mem[_96 + 98] = 0
            revert with memory
              from mem[64]
               len _96 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if stor6 / 100000000 * 10^18 <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor6 / 100000000 * 10^18:
                revert with 'NH{q', 18
            stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100000000 * 10^18
        else:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not s:
                revert with 'NH{q', 18
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 'NH{q', 18
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
    stor4[address(arg1)] = 1
    stor5.length++
    stor5[stor5.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if arg1 > 100000000 * 10^18:
        revert with 0, 'Amount must be less than supply'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if arg2:
        if not arg1 / 100:
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 'NH{q', 17
            idx = 0
            s = 100000000 * 10^18
            t = stor6
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _529 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_529] = 26
                    mem[_529 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _664 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_664] = 30
                    mem[_664 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100000000 * 10^18:
                        if arg1 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor6 / 100000000 * 10^18)
                    _680 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_680 + idx + 68] = mem[_664 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_680 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _680 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] > s:
                    _550 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_550] = 26
                    mem[_550 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                        revert with 'NH{q', 17
                    if not arg1:
                        revert with 'NH{q', 18
                    if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _681 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_681] = 30
                    mem[_681 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100000000 * 10^18:
                        if arg1 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor6 / 100000000 * 10^18)
                    _705 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_705 + idx + 68] = mem[_681 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_705 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _705 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _543 = mem[64]
                mem[64] = mem[64] + 64
                mem[_543] = 30
                mem[_543 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _554 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_554 + idx + 68] = mem[_543 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_554 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _554 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 'NH{q', 17
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _586 = mem[64]
                mem[64] = mem[64] + 64
                mem[_586] = 30
                mem[_586 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 'NH{q', 17
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _594 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_594 + idx + 68] = mem[_586 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_594 + 98] = 0
                revert with memory
                  from mem[64]
                   len _594 + -mem[64] + 100
            if t < stor6 / 100000000 * 10^18:
                if not arg1:
                    return 0
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 'NH{q', 17
                return (arg1 * stor6 / 100000000 * 10^18)
            if s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not s:
                revert with 'NH{q', 18
            if not arg1:
                return 0
            if arg1 and t / s > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 'NH{q', 17
            return (arg1 * t / s)
        if arg1 / 100 and 11 > -1 / arg1 / 100:
            revert with 'NH{q', 17
        if not arg1 / 100:
            revert with 'NH{q', 18
        if 11 * arg1 / 100 / arg1 / 100 != 11:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 11 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 11 * arg1 / 100:
            revert with 'NH{q', 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _525 = mem[64]
                mem[64] = mem[64] + 64
                mem[_525] = 26
                mem[_525 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 11 * arg1 / 100:
                        return 0
                    if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg1 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _662 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_662] = 30
                    mem[_662 + 32] = 'SafeMath: subtraction overflow'
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 <= 0:
                        if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        return (-11 * arg1 / 100 * stor6 / 100000000 * 10^18)
                    _676 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_676 + idx + 68] = mem[_662 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_676 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _676 + -mem[64] + 100
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 11 * arg1 / 100:
                    _661 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_661] = 30
                    mem[_661 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100000000 * 10^18:
                        if arg1 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor6 / 100000000 * 10^18)
                    _675 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_675 + idx + 68] = mem[_661 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_675 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _675 + -mem[64] + 100
                if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _799 = mem[64]
                mem[64] = mem[64] + 64
                mem[_799] = 30
                mem[_799 + 32] = 'SafeMath: subtraction overflow'
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    return ((arg1 * stor6 / 100000000 * 10^18) - (11 * arg1 / 100 * stor6 / 100000000 * 10^18))
                _825 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_825 + idx + 68] = mem[_799 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_825 + 98] = 0
                revert with memory
                  from mem[64]
                   len _825 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _541 = mem[64]
                mem[64] = mem[64] + 64
                mem[_541] = 30
                mem[_541 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _553 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_553 + idx + 68] = mem[_541 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_553 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _553 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 'NH{q', 17
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _585 = mem[64]
                mem[64] = mem[64] + 64
                mem[_585] = 30
                mem[_585 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 'NH{q', 17
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _593 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_593 + idx + 68] = mem[_585 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_593 + 98] = 0
                revert with memory
                  from mem[64]
                   len _593 + -mem[64] + 100
            _549 = mem[64]
            mem[64] = mem[64] + 64
            mem[_549] = 26
            mem[_549 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 11 * arg1 / 100:
                    return 0
                if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _678 = mem[64]
                mem[64] = mem[64] + 64
                mem[_678] = 30
                mem[_678 + 32] = 'SafeMath: subtraction overflow'
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 <= 0:
                    if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    return (-11 * arg1 / 100 * stor6 / 100000000 * 10^18)
                _704 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_704 + idx + 68] = mem[_678 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_704 + 98] = 0
                revert with memory
                  from mem[64]
                   len _704 + -mem[64] + 100
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 11 * arg1 / 100:
                _677 = mem[64]
                mem[64] = mem[64] + 64
                mem[_677] = 30
                mem[_677 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _703 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_703 + idx + 68] = mem[_677 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_703 + 98] = 0
                revert with memory
                  from mem[64]
                   len _703 + -mem[64] + 100
            if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                revert with 'NH{q', 17
            if not 11 * arg1 / 100:
                revert with 'NH{q', 18
            if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _828 = mem[64]
            mem[64] = mem[64] + 64
            mem[_828] = 30
            mem[_828 + 32] = 'SafeMath: subtraction overflow'
            if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 <= arg1 * stor6 / 100000000 * 10^18:
                if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                return ((arg1 * stor6 / 100000000 * 10^18) - (11 * arg1 / 100 * stor6 / 100000000 * 10^18))
            _847 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_847 + idx + 68] = mem[_828 + idx + 32]
                idx = idx + 32
                continue 
            mem[_847 + 98] = 0
            revert with memory
              from mem[64]
               len _847 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                if not 11 * arg1 / 100:
                    return 0
                if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                return (-11 * arg1 / 100 * stor6 / 100000000 * 10^18)
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 11 * arg1 / 100:
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 'NH{q', 17
                return (arg1 * stor6 / 100000000 * 10^18)
            if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                revert with 'NH{q', 17
            if not 11 * arg1 / 100:
                revert with 'NH{q', 18
            if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                revert with 'NH{q', 17
            return ((arg1 * stor6 / 100000000 * 10^18) - (11 * arg1 / 100 * stor6 / 100000000 * 10^18))
        if s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not s:
            revert with 'NH{q', 18
        if not arg1:
            if not 11 * arg1 / 100:
                return 0
            if 11 * arg1 / 100 and t / s > -1 / 11 * arg1 / 100:
                revert with 'NH{q', 17
            if not 11 * arg1 / 100:
                revert with 'NH{q', 18
            if 11 * arg1 / 100 * t / s / 11 * arg1 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 11 * arg1 / 100 * t / s > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < 11 * arg1 / 100 * t / s:
                revert with 'NH{q', 17
            return (-11 * arg1 / 100 * t / s)
        if arg1 and t / s > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if not 11 * arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 'NH{q', 17
            return (arg1 * t / s)
        if 11 * arg1 / 100 and t / s > -1 / 11 * arg1 / 100:
            revert with 'NH{q', 17
        if not 11 * arg1 / 100:
            revert with 'NH{q', 18
        if 11 * arg1 / 100 * t / s / 11 * arg1 / 100 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if 11 * arg1 / 100 * t / s > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * t / s < 11 * arg1 / 100 * t / s:
            revert with 'NH{q', 17
        return ((arg1 * t / s) - (11 * arg1 / 100 * t / s))
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 0:
            revert with 'NH{q', 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _537 = mem[64]
                mem[64] = mem[64] + 64
                mem[_537] = 26
                mem[_537 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _669 = mem[64]
                mem[64] = mem[64] + 64
                mem[_669] = 30
                mem[_669 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _688 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_688 + idx + 68] = mem[_669 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_688 + 98] = 0
                revert with memory
                  from mem[64]
                   len _688 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _552 = mem[64]
                mem[64] = mem[64] + 64
                mem[_552] = 26
                mem[_552 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _689 = mem[64]
                mem[64] = mem[64] + 64
                mem[_689] = 30
                mem[_689 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _708 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_708 + idx + 68] = mem[_689 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_708 + 98] = 0
                revert with memory
                  from mem[64]
                   len _708 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 1
            _547 = mem[64]
            mem[64] = mem[64] + 64
            mem[_547] = 30
            mem[_547 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _556 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_556 + idx + 68] = mem[_547 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_556 + 98] = 0
                revert with memory
                  from mem[64]
                   len _556 + -mem[64] + 100
            if t < stor1[stor5[idx]]:
                revert with 'NH{q', 17
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 2
            _588 = mem[64]
            mem[64] = mem[64] + 64
            mem[_588] = 30
            mem[_588 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                if s < stor2[stor5[idx]]:
                    revert with 'NH{q', 17
                if idx == -1:
                    revert with 'NH{q', 17
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _596 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_596 + idx + 68] = mem[_588 + idx + 32]
                idx = idx + 32
                continue 
            mem[_596 + 98] = 0
            revert with memory
              from mem[64]
               len _596 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                return 0
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor6 / 100000000 * 10^18 < 0:
                revert with 'NH{q', 17
            return (arg1 * stor6 / 100000000 * 10^18)
        if s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not s:
            revert with 'NH{q', 18
        if not arg1:
            return 0
        if arg1 and t / s > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if 0 > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * t / s < 0:
            revert with 'NH{q', 17
    else:
        if arg1 / 100 and 11 > -1 / arg1 / 100:
            revert with 'NH{q', 17
        if not arg1 / 100:
            revert with 'NH{q', 18
        if 11 * arg1 / 100 / arg1 / 100 != 11:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 11 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 11 * arg1 / 100:
            revert with 'NH{q', 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _533 = mem[64]
                mem[64] = mem[64] + 64
                mem[_533] = 26
                mem[_533 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 11 * arg1 / 100:
                        return 0
                    if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg1 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _667 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_667] = 30
                    mem[_667 + 32] = 'SafeMath: subtraction overflow'
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 <= 0:
                        if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        else:
                            return 0
                    _684 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_684 + idx + 68] = mem[_667 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_684 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _684 + -mem[64] + 100
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 11 * arg1 / 100:
                    _666 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_666] = 30
                    mem[_666 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100000000 * 10^18:
                        if arg1 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        return (arg1 * stor6 / 100000000 * 10^18)
                    _683 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_683 + idx + 68] = mem[_666 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_683 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _683 + -mem[64] + 100
                if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _811 = mem[64]
                mem[64] = mem[64] + 64
                mem[_811] = 30
                mem[_811 + 32] = 'SafeMath: subtraction overflow'
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _833 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_833 + idx + 68] = mem[_811 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_833 + 98] = 0
                revert with memory
                  from mem[64]
                   len _833 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _545 = mem[64]
                mem[64] = mem[64] + 64
                mem[_545] = 30
                mem[_545 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _555 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_555 + idx + 68] = mem[_545 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_555 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _555 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 'NH{q', 17
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _587 = mem[64]
                mem[64] = mem[64] + 64
                mem[_587] = 30
                mem[_587 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 'NH{q', 17
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _595 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_595 + idx + 68] = mem[_587 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_595 + 98] = 0
                revert with memory
                  from mem[64]
                   len _595 + -mem[64] + 100
            _551 = mem[64]
            mem[64] = mem[64] + 64
            mem[_551] = 26
            mem[_551 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 11 * arg1 / 100:
                    return 0
                if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _686 = mem[64]
                mem[64] = mem[64] + 64
                mem[_686] = 30
                mem[_686 + 32] = 'SafeMath: subtraction overflow'
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 <= 0:
                    if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    else:
                        return 0
                _707 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_707 + idx + 68] = mem[_686 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_707 + 98] = 0
                revert with memory
                  from mem[64]
                   len _707 + -mem[64] + 100
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 11 * arg1 / 100:
                _685 = mem[64]
                mem[64] = mem[64] + 64
                mem[_685] = 30
                mem[_685 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 'NH{q', 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _706 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_706 + idx + 68] = mem[_685 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_706 + 98] = 0
                revert with memory
                  from mem[64]
                   len _706 + -mem[64] + 100
            if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                revert with 'NH{q', 17
            if not 11 * arg1 / 100:
                revert with 'NH{q', 18
            if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _836 = mem[64]
            mem[64] = mem[64] + 64
            mem[_836] = 30
            mem[_836 + 32] = 'SafeMath: subtraction overflow'
            if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 <= arg1 * stor6 / 100000000 * 10^18:
                if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                return (arg1 * stor6 / 100000000 * 10^18)
            _851 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_851 + idx + 68] = mem[_836 + idx + 32]
                idx = idx + 32
                continue 
            mem[_851 + 98] = 0
            revert with memory
              from mem[64]
               len _851 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                if 11 * arg1 / 100:
                    if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg1 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    else:
                        return 0
                else:
                    return 0
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 11 * arg1 / 100:
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 'NH{q', 17
            else:
                if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
            return (arg1 * stor6 / 100000000 * 10^18)
        if s <= 0:
            revert with 0, 'SafeMath: division by zero', 0
        if not s:
            revert with 'NH{q', 18
        if not arg1:
            if 11 * arg1 / 100:
                if 11 * arg1 / 100 and t / s > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * t / s / 11 * arg1 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 11 * arg1 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 11 * arg1 / 100 * t / s:
                    revert with 'NH{q', 17
                else:
                    return 0
            else:
                return 0
        if arg1 and t / s > -1 / arg1:
            revert with 'NH{q', 17
        if not arg1:
            revert with 'NH{q', 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if not 11 * arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 'NH{q', 17
        else:
            if 11 * arg1 / 100 and t / s > -1 / 11 * arg1 / 100:
                revert with 'NH{q', 17
            if not 11 * arg1 / 100:
                revert with 'NH{q', 18
            if 11 * arg1 / 100 * t / s / 11 * arg1 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 11 * arg1 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 11 * arg1 / 100 * t / s:
                revert with 'NH{q', 17
    return (arg1 * t / s)
}

function reflect(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = msg.sender
    mem[32] = 4
    if stor4[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Excluded addresses cannot call this function'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 0:
            revert with 'NH{q', 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _605 = mem[64]
                mem[64] = mem[64] + 64
                mem[_605] = 26
                mem[_605 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    _646 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_646] = 30
                    mem[_646 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _672 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_672] = 30
                    mem[_672 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _682 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_682 + idx + 68] = mem[_672 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_682 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _682 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 'NH{q', 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _745 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_745] = 30
                    mem[_745 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -arg1 - 1:
                            revert with 'NH{q', 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _764 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_764 + idx + 68] = mem[_745 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_764 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _764 + -mem[64] + 100
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _676 = mem[64]
                mem[64] = mem[64] + 64
                mem[_676] = 30
                mem[_676 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    _688 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_688 + idx + 68] = mem[_676 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_688 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _688 + -mem[64] + 100
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                _774 = mem[64]
                mem[64] = mem[64] + 64
                mem[_774] = 30
                mem[_774 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    _795 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_795 + idx + 68] = mem[_774 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_795 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _795 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                _900 = mem[64]
                mem[64] = mem[64] + 64
                mem[_900] = 30
                mem[_900 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                    if totalFees > -arg1 - 1:
                        revert with 'NH{q', 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _932 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_932 + idx + 68] = mem[_900 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_932 + 98] = 0
                revert with memory
                  from mem[64]
                   len _932 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _611 = mem[64]
                mem[64] = mem[64] + 64
                mem[_611] = 30
                mem[_611 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _616 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_616 + idx + 68] = mem[_611 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_616 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _616 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 'NH{q', 17
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _632 = mem[64]
                mem[64] = mem[64] + 64
                mem[_632] = 30
                mem[_632 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 'NH{q', 17
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _636 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_636 + idx + 68] = mem[_632 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_636 + 98] = 0
                revert with memory
                  from mem[64]
                   len _636 + -mem[64] + 100
            _614 = mem[64]
            mem[64] = mem[64] + 64
            mem[_614] = 26
            mem[_614 + 32] = 'SafeMath: division by zero'
            if not arg1:
                _648 = mem[64]
                mem[64] = mem[64] + 64
                mem[_648] = 30
                mem[_648 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 1
                _683 = mem[64]
                mem[64] = mem[64] + 64
                mem[_683] = 30
                mem[_683 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _697 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_697 + idx + 68] = mem[_683 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_697 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _697 + -mem[64] + 100
                if stor1[address(msg.sender)] < 0:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                _766 = mem[64]
                mem[64] = mem[64] + 64
                mem[_766] = 30
                mem[_766 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if stor6 < 0:
                        revert with 'NH{q', 17
                    if totalFees > -arg1 - 1:
                        revert with 'NH{q', 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _788 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_788 + idx + 68] = mem[_766 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_788 + 98] = 0
                revert with memory
                  from mem[64]
                   len _788 + -mem[64] + 100
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _689 = mem[64]
            mem[64] = mem[64] + 64
            mem[_689] = 30
            mem[_689 + 32] = 'SafeMath: subtraction overflow'
            if 0 > arg1 * stor6 / 100000000 * 10^18:
                _702 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_702 + idx + 68] = mem[_689 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_702 + 98] = 0
                revert with memory
                  from mem[64]
                   len _702 + -mem[64] + 100
            if arg1 * stor6 / 100000000 * 10^18 < 0:
                revert with 'NH{q', 17
            mem[0] = msg.sender
            mem[32] = 1
            _798 = mem[64]
            mem[64] = mem[64] + 64
            mem[_798] = 30
            mem[_798 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                _813 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_813 + idx + 68] = mem[_798 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_813 + 98] = 0
                revert with memory
                  from mem[64]
                   len _813 + -mem[64] + 100
            if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                revert with 'NH{q', 17
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
            _934 = mem[64]
            mem[64] = mem[64] + 64
            mem[_934] = 30
            mem[_934 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                if stor6 < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                if totalFees > -arg1 - 1:
                    revert with 'NH{q', 17
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _952 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_952 + idx + 68] = mem[_934 + idx + 32]
                idx = idx + 32
                continue 
            mem[_952 + 98] = 0
            revert with memory
              from mem[64]
               len _952 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 'NH{q', 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 'NH{q', 17
            else:
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 'NH{q', 17
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                if arg1 * stor6 / 100000000 * 10^18 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
        else:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not s:
                revert with 'NH{q', 18
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 'NH{q', 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 'NH{q', 17
            else:
                if arg1 and t / s > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 'NH{q', 17
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * t / s:
                    revert with 'NH{q', 17
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * t / s:
                    revert with 'NH{q', 17
                stor6 += -1 * arg1 * t / s
    else:
        if arg1 / 100 and 11 > -1 / arg1 / 100:
            revert with 'NH{q', 17
        if not arg1 / 100:
            revert with 'NH{q', 18
        if 11 * arg1 / 100 / arg1 / 100 != 11:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 11 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 11 * arg1 / 100:
            revert with 'NH{q', 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _601 = mem[64]
                mem[64] = mem[64] + 64
                mem[_601] = 26
                mem[_601 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 11 * arg1 / 100:
                        _645 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_645] = 30
                        mem[_645 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 1
                        _670 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_670] = 30
                        mem[_670 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _679 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_679 + idx + 68] = mem[_670 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_679 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _679 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_739] = 30
                        mem[_739 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -arg1 - 1:
                                revert with 'NH{q', 17
                            if totalFees + arg1 < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg1
                        _759 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_759 + idx + 68] = mem[_739 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_759 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _759 + -mem[64] + 100
                    if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg1 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _674 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_674] = 30
                    mem[_674 + 32] = 'SafeMath: subtraction overflow'
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                        _685 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_685 + idx + 68] = mem[_674 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_685 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _685 + -mem[64] + 100
                    if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _770 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_770] = 30
                    mem[_770 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _790 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_790 + idx + 68] = mem[_770 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_790 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _790 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 'NH{q', 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _893 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_893] = 30
                    mem[_893 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -arg1 - 1:
                            revert with 'NH{q', 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _925 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_925 + idx + 68] = mem[_893 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_925 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _925 + -mem[64] + 100
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 11 * arg1 / 100:
                    _673 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_673] = 30
                    mem[_673 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor6 / 100000000 * 10^18:
                        _684 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_684 + idx + 68] = mem[_673 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_684 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _684 + -mem[64] + 100
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 'NH{q', 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _769 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_769] = 30
                    mem[_769 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                        _789 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_789 + idx + 68] = mem[_769 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_789 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _789 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                    _892 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_892] = 30
                    mem[_892 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                        if stor6 < arg1 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                        if totalFees > -arg1 - 1:
                            revert with 'NH{q', 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _924 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_924 + idx + 68] = mem[_892 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_924 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _924 + -mem[64] + 100
                if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _781 = mem[64]
                mem[64] = mem[64] + 64
                mem[_781] = 30
                mem[_781 + 32] = 'SafeMath: subtraction overflow'
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                    _799 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_799 + idx + 68] = mem[_781 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_799 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _799 + -mem[64] + 100
                if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                _939 = mem[64]
                mem[64] = mem[64] + 64
                mem[_939] = 30
                mem[_939 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    _954 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_954 + idx + 68] = mem[_939 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_954 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _954 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                _1051 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1051] = 30
                mem[_1051 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                    if totalFees > -arg1 - 1:
                        revert with 'NH{q', 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1072 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1072 + idx + 68] = mem[_1051 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1072 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1072 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 'NH{q', 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _609 = mem[64]
                mem[64] = mem[64] + 64
                mem[_609] = 30
                mem[_609 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _615 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_615 + idx + 68] = mem[_609 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_615 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _615 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 'NH{q', 17
                if idx >= stor5.length:
                    revert with 'NH{q', 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _631 = mem[64]
                mem[64] = mem[64] + 64
                mem[_631] = 30
                mem[_631 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 'NH{q', 17
                    if idx == -1:
                        revert with 'NH{q', 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _635 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_635 + idx + 68] = mem[_631 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_635 + 98] = 0
                revert with memory
                  from mem[64]
                   len _635 + -mem[64] + 100
            _613 = mem[64]
            mem[64] = mem[64] + 64
            mem[_613] = 26
            mem[_613 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 11 * arg1 / 100:
                    _647 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_647] = 30
                    mem[_647 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _680 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_680] = 30
                    mem[_680 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _693 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_693 + idx + 68] = mem[_680 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_693 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _693 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 'NH{q', 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _762 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_762] = 30
                    mem[_762 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -arg1 - 1:
                            revert with 'NH{q', 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _784 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_784 + idx + 68] = mem[_762 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_784 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _784 + -mem[64] + 100
                if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                    revert with 'NH{q', 17
                if not 11 * arg1 / 100:
                    revert with 'NH{q', 18
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _687 = mem[64]
                mem[64] = mem[64] + 64
                mem[_687] = 30
                mem[_687 + 32] = 'SafeMath: subtraction overflow'
                if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                    _700 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_700 + idx + 68] = mem[_687 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_700 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _700 + -mem[64] + 100
                if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                _794 = mem[64]
                mem[64] = mem[64] + 64
                mem[_794] = 30
                mem[_794 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _809 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_809 + idx + 68] = mem[_794 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_809 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _809 + -mem[64] + 100
                if stor1[address(msg.sender)] < 0:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                _929 = mem[64]
                mem[64] = mem[64] + 64
                mem[_929] = 30
                mem[_929 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if stor6 < 0:
                        revert with 'NH{q', 17
                    if totalFees > -arg1 - 1:
                        revert with 'NH{q', 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _950 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_950 + idx + 68] = mem[_929 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_950 + 98] = 0
                revert with memory
                  from mem[64]
                   len _950 + -mem[64] + 100
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 'NH{q', 17
            if not arg1:
                revert with 'NH{q', 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 11 * arg1 / 100:
                _686 = mem[64]
                mem[64] = mem[64] + 64
                mem[_686] = 30
                mem[_686 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    _699 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_699 + idx + 68] = mem[_686 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_699 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _699 + -mem[64] + 100
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                _793 = mem[64]
                mem[64] = mem[64] + 64
                mem[_793] = 30
                mem[_793 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    _808 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_808 + idx + 68] = mem[_793 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_808 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _808 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                _928 = mem[64]
                mem[64] = mem[64] + 64
                mem[_928] = 30
                mem[_928 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                    if totalFees > -arg1 - 1:
                        revert with 'NH{q', 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _949 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_949 + idx + 68] = mem[_928 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_949 + 98] = 0
                revert with memory
                  from mem[64]
                   len _949 + -mem[64] + 100
            if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                revert with 'NH{q', 17
            if not 11 * arg1 / 100:
                revert with 'NH{q', 18
            if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _803 = mem[64]
            mem[64] = mem[64] + 64
            mem[_803] = 30
            mem[_803 + 32] = 'SafeMath: subtraction overflow'
            if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                _818 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_818 + idx + 68] = mem[_803 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_818 + 98] = 0
                revert with memory
                  from mem[64]
                   len _818 + -mem[64] + 100
            if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                revert with 'NH{q', 17
            mem[0] = msg.sender
            mem[32] = 1
            _960 = mem[64]
            mem[64] = mem[64] + 64
            mem[_960] = 30
            mem[_960 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                _975 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_975 + idx + 68] = mem[_960 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_975 + 98] = 0
                revert with memory
                  from mem[64]
                   len _975 + -mem[64] + 100
            if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                revert with 'NH{q', 17
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
            _1075 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1075] = 30
            mem[_1075 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                if stor6 < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                if totalFees > -arg1 - 1:
                    revert with 'NH{q', 17
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1082 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_1082 + idx + 68] = mem[_1075 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1082 + 98] = 0
            revert with memory
              from mem[64]
               len _1082 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                if 11 * arg1 / 100:
                    if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg1 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 'NH{q', 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 'NH{q', 17
            else:
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 11 * arg1 / 100:
                    if 0 > arg1 * stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 'NH{q', 17
                else:
                    if 11 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg1 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg1 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 / 11 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 11 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor6 / 100000000 * 10^18 < 11 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                if arg1 * stor6 / 100000000 * 10^18 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * stor6 / 100000000 * 10^18:
                    revert with 'NH{q', 17
                stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
        else:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero', 0
            if not s:
                revert with 'NH{q', 18
            if not arg1:
                if 11 * arg1 / 100:
                    if 11 * arg1 / 100 and t / s > -1 / 11 * arg1 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg1 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg1 / 100 * t / s / 11 * arg1 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 11 * arg1 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 11 * arg1 / 100 * t / s:
                        revert with 'NH{q', 17
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 'NH{q', 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 'NH{q', 17
            else:
                if arg1 and t / s > -1 / arg1:
                    revert with 'NH{q', 17
                if not arg1:
                    revert with 'NH{q', 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 11 * arg1 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 'NH{q', 17
                else:
                    if 11 * arg1 / 100 and t / s > -1 / 11 * arg1 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg1 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg1 / 100 * t / s / 11 * arg1 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 11 * arg1 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 11 * arg1 / 100 * t / s:
                        revert with 'NH{q', 17
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * t / s:
                    revert with 'NH{q', 17
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * t / s:
                    revert with 'NH{q', 17
                stor6 += -1 * arg1 * t / s
    if totalFees > -arg1 - 1:
        revert with 'NH{q', 17
    if totalFees + arg1 < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg1
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Transfer amount must be greater than zero'
    if not stor4[address(msg.sender)]:
        if stor4[address(msg.sender)]:
            mem[0] = msg.sender
            mem[32] = 4
            if stor4[address(msg.sender)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 0:
                        revert with 'NH{q', 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _11313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11313] = 26
                            mem[_11313 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _11970 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11970] = 30
                                mem[_11970 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12346 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12346] = 30
                                mem[_12346 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12468 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12468 + idx + 68] = mem[_12346 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12468 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12468 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _15049 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15049] = 30
                                mem[_15049 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _15267 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15267 + idx + 68] = mem[_15049 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15267 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15267 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12392] = 30
                            mem[_12392 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12558 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12558 + idx + 68] = mem[_12392 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12558 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12558 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _13782 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13782] = 30
                            mem[_13782 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14082 + idx + 68] = mem[_13782 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14082 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _17593 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17593] = 30
                            mem[_17593 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _17835 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_17835 + idx + 68] = mem[_17593 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_17835 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17835 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 'NH{q', 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _11431 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11431] = 30
                            mem[_11431 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _11520 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11520 + idx + 68] = mem[_11431 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11520 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11520 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 'NH{q', 17
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _11760 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11760] = 30
                            mem[_11760 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _11820 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11820 + idx + 68] = mem[_11760 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11820 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11820 + -mem[64] + 100
                        _11490 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11490] = 26
                        mem[_11490 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _12000 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12000] = 30
                            mem[_12000 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _12469 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12469] = 30
                            mem[_12469 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _12651 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12651 + idx + 68] = mem[_12469 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12651 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12651 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _15268 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15268] = 30
                            mem[_15268 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _15580 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15580 + idx + 68] = mem[_15268 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15580 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15580 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12559] = 30
                        mem[_12559 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            _12768 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12768 + idx + 68] = mem[_12559 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12768 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12768 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _14084 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14084] = 30
                        mem[_14084 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _14310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14310 + idx + 68] = mem[_14084 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14310 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14310 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        _17837 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17837] = 30
                        mem[_17837 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _18075 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_18075 + idx + 68] = mem[_17837 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_18075 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18075 + -mem[64] + 100
                    if t < stor6 / 100000000 * 10^18:
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                    else:
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not s:
                            revert with 'NH{q', 18
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6 < 0:
                        revert with 'NH{q', 17
                    if totalFees > -1:
                        revert with 'NH{q', 17
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if arg2 / 100 and 11 > -1 / arg2 / 100:
                        revert with 'NH{q', 17
                    if not arg2 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg2 / 100 / arg2 / 100 != 11:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 11 * arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 11 * arg2 / 100:
                        revert with 'NH{q', 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _11309 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11309] = 26
                            mem[_11309 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    _11969 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11969] = 30
                                    mem[_11969 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12344 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12344] = 30
                                    mem[_12344 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12465 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12465 + idx + 68] = mem[_12344 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12465 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12465 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15045 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15045] = 30
                                    mem[_15045 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _15263 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15263 + idx + 68] = mem[_15045 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15263 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15263 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12390 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12390] = 30
                                mem[_12390 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _12555 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12555 + idx + 68] = mem[_12390 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12555 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12555 + -mem[64] + 100
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13778 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13778] = 30
                                mem[_13778 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14078 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14078 + idx + 68] = mem[_13778 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14078 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14078 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _17586 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17586] = 30
                                mem[_17586 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _17831 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17831 + idx + 68] = mem[_17586 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17831 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17831 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                _12389 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12389] = 30
                                mem[_12389 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12554 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12554 + idx + 68] = mem[_12389 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12554 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12554 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13777] = 30
                                mem[_13777 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14077 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14077 + idx + 68] = mem[_13777 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14077 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14077 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17585 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17585] = 30
                                mem[_17585 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _17830 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17830 + idx + 68] = mem[_17585 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17830 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17830 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13901 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13901] = 30
                            mem[_13901 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14199 + idx + 68] = mem[_13901 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14199 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16265 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16265] = 30
                            mem[_16265 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16626 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16626 + idx + 68] = mem[_16265 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16626 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16626 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _19736 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19736] = 30
                            mem[_19736 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_20054 + idx + 68] = mem[_19736 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_20054 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20054 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 'NH{q', 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _11429 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11429] = 30
                            mem[_11429 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _11519 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11519 + idx + 68] = mem[_11429 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11519 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11519 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 'NH{q', 17
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _11759 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11759] = 30
                            mem[_11759 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _11819 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11819 + idx + 68] = mem[_11759 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11819 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11819 + -mem[64] + 100
                        _11489 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11489] = 26
                        mem[_11489 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 11 * arg2 / 100:
                                _11999 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11999] = 30
                                mem[_11999 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12466 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12466] = 30
                                mem[_12466 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12647 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12647 + idx + 68] = mem[_12466 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12647 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12647 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _15264 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15264] = 30
                                mem[_15264 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _15575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15575 + idx + 68] = mem[_15264 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15575 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15575 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12557 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12557] = 30
                            mem[_12557 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _12766 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12766 + idx + 68] = mem[_12557 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12766 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12766 + -mem[64] + 100
                            if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14081 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14081] = 30
                            mem[_14081 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _14307 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14307 + idx + 68] = mem[_14081 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14307 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14307 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            _17834 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17834] = 30
                            mem[_17834 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _18071 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18071 + idx + 68] = mem[_17834 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18071 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18071 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 11 * arg2 / 100:
                            _12556 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12556] = 30
                            mem[_12556 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12765 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12765 + idx + 68] = mem[_12556 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12765 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12765 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14080 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14080] = 30
                            mem[_14080 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14306 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14306 + idx + 68] = mem[_14080 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14306 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14306 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _17833 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17833] = 30
                            mem[_17833 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _18070 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18070 + idx + 68] = mem[_17833 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18070 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18070 + -mem[64] + 100
                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        if not 11 * arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14203 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14203] = 30
                        mem[_14203 + 32] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                            _14429 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14429 + idx + 68] = mem[_14203 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14429 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14429 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _16629 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16629] = 30
                        mem[_16629 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _16844 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16844 + idx + 68] = mem[_16629 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16844 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16844 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                        _20057 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20057] = 30
                        mem[_20057 + 32] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _20266 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_20266 + idx + 68] = mem[_20057 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_20266 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20266 + -mem[64] + 100
                    if t < stor6 / 100000000 * 10^18:
                        if not arg2:
                            if not 11 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                            else:
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                            else:
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                    else:
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not s:
                            revert with 'NH{q', 18
                        if not arg2:
                            if not 11 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                            else:
                                if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 11 * arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 11 * arg2 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                if 11 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 11 * arg2 / 100 * t / s:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * t / s
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                            else:
                                if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                if 11 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 11 * arg2 / 100 * t / s:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * t / s
                    if totalFees > (-11 * arg2 / 100) - 1:
                        revert with 'NH{q', 17
                    if totalFees + (11 * arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 11 * arg2 / 100
                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if stor4[address(arg1)]:
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11321] = 26
                                mem[_11321 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _11972 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11972] = 30
                                    mem[_11972 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12349] = 30
                                    mem[_12349 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12474 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12474 + idx + 68] = mem[_12349 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12474 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12474 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15057] = 30
                                    mem[_15057 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15277 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15277 + idx + 68] = mem[_15057 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15277 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15277 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12397 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12397] = 30
                                mem[_12397 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12564 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12564 + idx + 68] = mem[_12397 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12564 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12564 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13790 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13790] = 30
                                mem[_13790 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14090 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14090 + idx + 68] = mem[_13790 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14090 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14090 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17607 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17607] = 30
                                mem[_17607 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _17845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17845 + idx + 68] = mem[_17607 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17845 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17845 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11435] = 30
                                mem[_11435 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11522 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11522 + idx + 68] = mem[_11435 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11522 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11522 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11762 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11762] = 30
                                mem[_11762 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11822 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11822 + idx + 68] = mem[_11762 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11822 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11822 + -mem[64] + 100
                            _11492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11492] = 26
                            mem[_11492 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _12002 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12002] = 30
                                mem[_12002 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12475 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12475] = 30
                                mem[_12475 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12659 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12659 + idx + 68] = mem[_12475 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12659 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12659 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _15278 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15278] = 30
                                mem[_15278 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _15593 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15593 + idx + 68] = mem[_15278 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15593 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15593 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12565] = 30
                            mem[_12565 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12773 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12773 + idx + 68] = mem[_12565 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12773 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12773 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14092 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14092] = 30
                            mem[_14092 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14318 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14318 + idx + 68] = mem[_14092 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14318 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14318 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _17847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17847] = 30
                            mem[_17847 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _18088 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18088 + idx + 68] = mem[_17847 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18088 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18088 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -1:
                            revert with 'NH{q', 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 11 > -1 / arg2 / 100:
                            revert with 'NH{q', 17
                        if not arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 / arg2 / 100 != 11:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11317 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11317] = 26
                                mem[_11317 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _11971 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11971] = 30
                                        mem[_11971 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12347 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12347] = 30
                                        mem[_12347 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12471 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12471 + idx + 68] = mem[_12347 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12471 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12471 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15053 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15053] = 30
                                        mem[_15053 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15273 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15273 + idx + 68] = mem[_15053 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15273 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15273 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12395 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12395] = 30
                                    mem[_12395 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12561 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12561 + idx + 68] = mem[_12395 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12561 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12561 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13786 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13786] = 30
                                    mem[_13786 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14086 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14086 + idx + 68] = mem[_13786 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14086 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14086 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17600 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17600] = 30
                                    mem[_17600 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17841 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17841 + idx + 68] = mem[_17600 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17841 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17841 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12394 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12394] = 30
                                    mem[_12394 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12560 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12560 + idx + 68] = mem[_12394 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12560 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12560 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13785 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13785] = 30
                                    mem[_13785 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14085 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14085 + idx + 68] = mem[_13785 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14085 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14085 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17599] = 30
                                    mem[_17599 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17840 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17840 + idx + 68] = mem[_17599 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17840 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17840 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13913 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13913] = 30
                                mem[_13913 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14206 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14206 + idx + 68] = mem[_13913 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14206 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14206 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16280 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16280] = 30
                                mem[_16280 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16631 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16631 + idx + 68] = mem[_16280 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16631 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16631 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _19758 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19758] = 30
                                mem[_19758 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20063 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20063 + idx + 68] = mem[_19758 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20063 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20063 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11433] = 30
                                mem[_11433 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11521 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11521 + idx + 68] = mem[_11433 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11521 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11521 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11761 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11761] = 30
                                mem[_11761 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11821 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11821 + idx + 68] = mem[_11761 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11821 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11821 + -mem[64] + 100
                            _11491 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11491] = 26
                            mem[_11491 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    _12001 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12001] = 30
                                    mem[_12001 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12472 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12472] = 30
                                    mem[_12472 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12655 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12655 + idx + 68] = mem[_12472 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12655 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12655 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15274 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15274] = 30
                                    mem[_15274 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _15588 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15588 + idx + 68] = mem[_15274 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15588 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15588 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12563 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12563] = 30
                                mem[_12563 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _12771 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12771 + idx + 68] = mem[_12563 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12771 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12771 + -mem[64] + 100
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14089 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14089] = 30
                                mem[_14089 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14315 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14315 + idx + 68] = mem[_14089 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14315 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14315 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _17844 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17844] = 30
                                mem[_17844 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18084 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18084 + idx + 68] = mem[_17844 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18084 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18084 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                _12562 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12562] = 30
                                mem[_12562 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12770 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12770 + idx + 68] = mem[_12562 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12770 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12770 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14088 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14088] = 30
                                mem[_14088 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14314 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14314 + idx + 68] = mem[_14088 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14314 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14314 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17843 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17843] = 30
                                mem[_17843 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18083 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18083 + idx + 68] = mem[_17843 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18083 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18083 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14210 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14210] = 30
                            mem[_14210 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14440 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14440 + idx + 68] = mem[_14210 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14440 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14440 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16634] = 30
                            mem[_16634 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16851 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16851 + idx + 68] = mem[_16634 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16851 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16851 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20066 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20066] = 30
                            mem[_20066 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20274 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_20274 + idx + 68] = mem[_20066 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_20274 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20274 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                        if totalFees > (-11 * arg2 / 100) - 1:
                            revert with 'NH{q', 17
                        if totalFees + (11 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 11 * arg2 / 100
                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                else:
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11329 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11329] = 26
                                mem[_11329 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _11974 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11974] = 30
                                    mem[_11974 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12352 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12352] = 30
                                    mem[_12352 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12480 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12480 + idx + 68] = mem[_12352 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12480 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12480 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15065] = 30
                                    mem[_15065 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15287 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15287 + idx + 68] = mem[_15065 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15287 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15287 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12402 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12402] = 30
                                mem[_12402 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12570 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12570 + idx + 68] = mem[_12402 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12570 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12570 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13798 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13798] = 30
                                mem[_13798 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14098 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14098 + idx + 68] = mem[_13798 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14098 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14098 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17621 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17621] = 30
                                mem[_17621 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _17855 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17855 + idx + 68] = mem[_17621 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17855 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17855 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11439 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11439] = 30
                                mem[_11439 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11524 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11524 + idx + 68] = mem[_11439 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11524 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11524 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11764 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11764] = 30
                                mem[_11764 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11824 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11824 + idx + 68] = mem[_11764 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11824 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11824 + -mem[64] + 100
                            _11494 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11494] = 26
                            mem[_11494 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _12004 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12004] = 30
                                mem[_12004 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12481 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12481] = 30
                                mem[_12481 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12667 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12667 + idx + 68] = mem[_12481 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12667 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12667 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _15288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15288] = 30
                                mem[_15288 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _15606 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15606 + idx + 68] = mem[_15288 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15606 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15606 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12571] = 30
                            mem[_12571 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12778 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12778 + idx + 68] = mem[_12571 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12778 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12778 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14100 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14100] = 30
                            mem[_14100 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14326 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14326 + idx + 68] = mem[_14100 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14326 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14326 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _17857 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17857] = 30
                            mem[_17857 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _18101 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18101 + idx + 68] = mem[_17857 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18101 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18101 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -1:
                            revert with 'NH{q', 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 11 > -1 / arg2 / 100:
                            revert with 'NH{q', 17
                        if not arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 / arg2 / 100 != 11:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11325 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11325] = 26
                                mem[_11325 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _11973 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11973] = 30
                                        mem[_11973 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12350] = 30
                                        mem[_12350 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12477 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12477 + idx + 68] = mem[_12350 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12477 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12477 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15061 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15061] = 30
                                        mem[_15061 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15283 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15283 + idx + 68] = mem[_15061 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15283 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15283 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12400 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12400] = 30
                                    mem[_12400 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12567 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12567 + idx + 68] = mem[_12400 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12567 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12567 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13794 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13794] = 30
                                    mem[_13794 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14094 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14094 + idx + 68] = mem[_13794 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14094 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14094 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17614 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17614] = 30
                                    mem[_17614 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17851 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17851 + idx + 68] = mem[_17614 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17851 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17851 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12399 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12399] = 30
                                    mem[_12399 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12566 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12566 + idx + 68] = mem[_12399 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12566 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12566 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13793 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13793] = 30
                                    mem[_13793 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14093 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14093 + idx + 68] = mem[_13793 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14093 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14093 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17613 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17613] = 30
                                    mem[_17613 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17850 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17850 + idx + 68] = mem[_17613 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17850 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17850 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13925 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13925] = 30
                                mem[_13925 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14213 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14213 + idx + 68] = mem[_13925 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14213 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14213 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16295] = 30
                                mem[_16295 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16636 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16636 + idx + 68] = mem[_16295 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16636 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16636 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _19780 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19780] = 30
                                mem[_19780 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20072 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20072 + idx + 68] = mem[_19780 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20072 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20072 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11437 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11437] = 30
                                mem[_11437 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11523 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11523 + idx + 68] = mem[_11437 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11523 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11523 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11763 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11763] = 30
                                mem[_11763 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11823 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11823 + idx + 68] = mem[_11763 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11823 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11823 + -mem[64] + 100
                            _11493 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11493] = 26
                            mem[_11493 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    _12003 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12003] = 30
                                    mem[_12003 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12478 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12478] = 30
                                    mem[_12478 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12663 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12663 + idx + 68] = mem[_12478 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12663 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12663 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15284 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15284] = 30
                                    mem[_15284 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _15601 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15601 + idx + 68] = mem[_15284 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15601 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15601 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12569] = 30
                                mem[_12569 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _12776 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12776 + idx + 68] = mem[_12569 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12776 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12776 + -mem[64] + 100
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14097 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14097] = 30
                                mem[_14097 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14323 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14323 + idx + 68] = mem[_14097 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14323 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14323 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _17854 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17854] = 30
                                mem[_17854 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18097 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18097 + idx + 68] = mem[_17854 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18097 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18097 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                _12568 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12568] = 30
                                mem[_12568 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12775 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12775 + idx + 68] = mem[_12568 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12775 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12775 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14096 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14096] = 30
                                mem[_14096 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14322 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14322 + idx + 68] = mem[_14096 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14322 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14322 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17853 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17853] = 30
                                mem[_17853 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18096 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18096 + idx + 68] = mem[_17853 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18096 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18096 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14217 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14217] = 30
                            mem[_14217 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14451 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14451 + idx + 68] = mem[_14217 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14451 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14451 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16639] = 30
                            mem[_16639 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16858 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16858 + idx + 68] = mem[_16639 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16858 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16858 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20075 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20075] = 30
                            mem[_20075 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20282 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_20282 + idx + 68] = mem[_20075 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_20282 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20282 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                        if totalFees > (-11 * arg2 / 100) - 1:
                            revert with 'NH{q', 17
                        if totalFees + (11 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 11 * arg2 / 100
                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
        else:
            mem[0] = arg1
            mem[32] = 4
            if stor4[address(arg1)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 0:
                        revert with 'NH{q', 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _11361 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11361] = 26
                            mem[_11361 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _11982 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11982] = 30
                                mem[_11982 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12364 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12364] = 30
                                mem[_12364 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12504 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12504 + idx + 68] = mem[_12364 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12504 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12504 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _16766 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16766] = 30
                                mem[_16766 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _17027 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17027 + idx + 68] = mem[_16766 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17027 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17027 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12422 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12422] = 30
                            mem[_12422 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12594 + idx + 68] = mem[_12422 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12594 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12594 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _13830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13830] = 30
                            mem[_13830 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14130 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14130 + idx + 68] = mem[_13830 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14130 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14130 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > -arg2 - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _19133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19133] = 30
                            mem[_19133 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19350 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19350 + idx + 68] = mem[_19133 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19350 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19350 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 'NH{q', 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _11455 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11455] = 30
                            mem[_11455 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _11532 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11532 + idx + 68] = mem[_11455 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11532 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11532 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 'NH{q', 17
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _11772 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11772] = 30
                            mem[_11772 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _11832 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11832 + idx + 68] = mem[_11772 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11832 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11832 + -mem[64] + 100
                        _11502 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11502] = 26
                        mem[_11502 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _12012 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12012] = 30
                            mem[_12012 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _12505 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12505] = 30
                            mem[_12505 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _12699 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12699 + idx + 68] = mem[_12505 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12699 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12699 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] > -arg2 - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _17029 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17029] = 30
                            mem[_17029 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _17523 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_17523 + idx + 68] = mem[_17029 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_17523 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17523 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12595 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12595] = 30
                        mem[_12595 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            _12798 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12798 + idx + 68] = mem[_12595 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12798 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12798 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _14132 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14132] = 30
                        mem[_14132 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _14358 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14358 + idx + 68] = mem[_14132 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14358 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14358 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor2[address(arg1)] > -arg2 - 1:
                            revert with 'NH{q', 17
                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] += arg2
                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        _19352 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19352] = 30
                        mem[_19352 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _19702 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_19702 + idx + 68] = mem[_19352 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_19702 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19702 + -mem[64] + 100
                    if t < stor6 / 100000000 * 10^18:
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] > -arg2 - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > -arg2 - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                    else:
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not s:
                            revert with 'NH{q', 18
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] > -arg2 - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor2[address(arg1)] > -arg2 - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6 < 0:
                        revert with 'NH{q', 17
                    if totalFees > -1:
                        revert with 'NH{q', 17
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if arg2 / 100 and 11 > -1 / arg2 / 100:
                        revert with 'NH{q', 17
                    if not arg2 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg2 / 100 / arg2 / 100 != 11:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 11 * arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 11 * arg2 / 100:
                        revert with 'NH{q', 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _11357 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11357] = 26
                            mem[_11357 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    _11981 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11981] = 30
                                    mem[_11981 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12362 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12362] = 30
                                    mem[_12362 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12501 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12501 + idx + 68] = mem[_12362 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12501 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12501 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _16763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16763] = 30
                                    mem[_16763 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17021 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17021 + idx + 68] = mem[_16763 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17021 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17021 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12420] = 30
                                mem[_12420 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _12591 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12591 + idx + 68] = mem[_12420 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12591 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12591 + -mem[64] + 100
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13826 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13826] = 30
                                mem[_13826 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14126 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14126 + idx + 68] = mem[_13826 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14126 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14126 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _19126 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19126] = 30
                                mem[_19126 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19345 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19345 + idx + 68] = mem[_19126 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19345 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19345 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                _12419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12419] = 30
                                mem[_12419 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12590 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12590 + idx + 68] = mem[_12419 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12590 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12590 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13825 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13825] = 30
                                mem[_13825 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14125 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14125 + idx + 68] = mem[_13825 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14125 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14125 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _19125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19125] = 30
                                mem[_19125 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19344 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19344 + idx + 68] = mem[_19125 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19344 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19344 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13973 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13973] = 30
                            mem[_13973 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14241 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14241 + idx + 68] = mem[_13973 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14241 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14241 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16355] = 30
                            mem[_16355 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16656 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16656 + idx + 68] = mem[_16355 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16656 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16656 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _21033 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21033] = 30
                            mem[_21033 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21184 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_21184 + idx + 68] = mem[_21033 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21184 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21184 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 'NH{q', 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _11453 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11453] = 30
                            mem[_11453 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _11531 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11531 + idx + 68] = mem[_11453 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11531 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11531 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 'NH{q', 17
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _11771 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11771] = 30
                            mem[_11771 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx == -1:
                                    revert with 'NH{q', 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _11831 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11831 + idx + 68] = mem[_11771 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11831 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11831 + -mem[64] + 100
                        _11501 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11501] = 26
                        mem[_11501 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 11 * arg2 / 100:
                                _12011 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12011] = 30
                                mem[_12011 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12502] = 30
                                mem[_12502 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12695 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12695 + idx + 68] = mem[_12502 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12695 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12695 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _17025 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17025] = 30
                                mem[_17025 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _17521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17521 + idx + 68] = mem[_17025 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17521 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17521 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12593 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12593] = 30
                            mem[_12593 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _12796 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12796 + idx + 68] = mem[_12593 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12796 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12796 + -mem[64] + 100
                            if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14129 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14129] = 30
                            mem[_14129 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _14355 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14355 + idx + 68] = mem[_14129 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14355 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14355 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                            if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            _19349 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19349] = 30
                            mem[_19349 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _19700 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19700 + idx + 68] = mem[_19349 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19700 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19700 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 11 * arg2 / 100:
                            _12592 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12592] = 30
                            mem[_12592 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12795 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12795 + idx + 68] = mem[_12592 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12795 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12795 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14128 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14128] = 30
                            mem[_14128 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14354 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14354 + idx + 68] = mem[_14128 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14354 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14354 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _19348 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19348] = 30
                            mem[_19348 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _19699 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19699 + idx + 68] = mem[_19348 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19699 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19699 + -mem[64] + 100
                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        if not 11 * arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14245 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14245] = 30
                        mem[_14245 + 32] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                            _14495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14495 + idx + 68] = mem[_14245 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14495 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14495 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _16659 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16659] = 30
                        mem[_16659 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _16885 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16885 + idx + 68] = mem[_16659 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16885 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16885 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                            revert with 'NH{q', 17
                        if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                        _21187 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21187] = 30
                        mem[_21187 + 32] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _21472 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_21472 + idx + 68] = mem[_21187 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_21472 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21472 + -mem[64] + 100
                    if t < stor6 / 100000000 * 10^18:
                        if not arg2:
                            if not 11 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                            else:
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                            else:
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                    else:
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not s:
                            revert with 'NH{q', 18
                        if not arg2:
                            if not 11 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                            else:
                                if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 11 * arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 11 * arg2 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                if 11 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 11 * arg2 / 100 * t / s:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * t / s
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                            else:
                                if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                if 11 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 11 * arg2 / 100 * t / s:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * t / s
                    if totalFees > (-11 * arg2 / 100) - 1:
                        revert with 'NH{q', 17
                    if totalFees + (11 * arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 11 * arg2 / 100
                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = msg.sender
                mem[32] = 4
                if stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11337 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11337] = 26
                                mem[_11337 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _11976 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11976] = 30
                                    mem[_11976 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12355 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12355] = 30
                                    mem[_12355 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12486 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12486 + idx + 68] = mem[_12355 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12486 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12486 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15073 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15073] = 30
                                    mem[_15073 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15297 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15297 + idx + 68] = mem[_15073 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15297 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15297 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12407] = 30
                                mem[_12407 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12576 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12576 + idx + 68] = mem[_12407 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12576 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12576 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13806 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13806] = 30
                                mem[_13806 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14106 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14106 + idx + 68] = mem[_13806 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14106 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14106 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17635 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17635] = 30
                                mem[_17635 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _17865 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17865 + idx + 68] = mem[_17635 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17865 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17865 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11443 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11443] = 30
                                mem[_11443 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11526 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11526 + idx + 68] = mem[_11443 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11526 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11526 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11766 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11766] = 30
                                mem[_11766 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11826 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11826 + idx + 68] = mem[_11766 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11826 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11826 + -mem[64] + 100
                            _11496 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11496] = 26
                            mem[_11496 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _12006 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12006] = 30
                                mem[_12006 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12487] = 30
                                mem[_12487 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12675 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12675 + idx + 68] = mem[_12487 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12675 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12675 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _15298 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15298] = 30
                                mem[_15298 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _15619 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15619 + idx + 68] = mem[_15298 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15619 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15619 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12577 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12577] = 30
                            mem[_12577 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12783 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12783 + idx + 68] = mem[_12577 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12783 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12783 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14108 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14108] = 30
                            mem[_14108 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14334 + idx + 68] = mem[_14108 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14334 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _17867 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17867] = 30
                            mem[_17867 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _18114 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18114 + idx + 68] = mem[_17867 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18114 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18114 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -1:
                            revert with 'NH{q', 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 11 > -1 / arg2 / 100:
                            revert with 'NH{q', 17
                        if not arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 / arg2 / 100 != 11:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11333 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11333] = 26
                                mem[_11333 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _11975 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11975] = 30
                                        mem[_11975 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12353 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12353] = 30
                                        mem[_12353 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12483 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12483 + idx + 68] = mem[_12353 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12483 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12483 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15069 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15069] = 30
                                        mem[_15069 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15293 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15293 + idx + 68] = mem[_15069 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15293 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15293 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12405 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12405] = 30
                                    mem[_12405 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12573 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12573 + idx + 68] = mem[_12405 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12573 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12573 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13802 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13802] = 30
                                    mem[_13802 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14102 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14102 + idx + 68] = mem[_13802 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14102 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14102 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17628 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17628] = 30
                                    mem[_17628 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17861 + idx + 68] = mem[_17628 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17861 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17861 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12404 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12404] = 30
                                    mem[_12404 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12572 + idx + 68] = mem[_12404 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12572 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12572 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13801 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13801] = 30
                                    mem[_13801 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14101 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14101 + idx + 68] = mem[_13801 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14101 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14101 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17627 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17627] = 30
                                    mem[_17627 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17860 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17860 + idx + 68] = mem[_17627 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17860 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17860 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13937 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13937] = 30
                                mem[_13937 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14220 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14220 + idx + 68] = mem[_13937 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14220 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14220 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16310 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16310] = 30
                                mem[_16310 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16641 + idx + 68] = mem[_16310 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16641 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16641 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _19802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19802] = 30
                                mem[_19802 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20081 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20081 + idx + 68] = mem[_19802 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20081 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20081 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11441 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11441] = 30
                                mem[_11441 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11525 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11525 + idx + 68] = mem[_11441 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11525 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11525 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11765] = 30
                                mem[_11765 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11825 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11825 + idx + 68] = mem[_11765 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11825 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11825 + -mem[64] + 100
                            _11495 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11495] = 26
                            mem[_11495 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    _12005 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12005] = 30
                                    mem[_12005 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12484 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12484] = 30
                                    mem[_12484 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12671 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12671 + idx + 68] = mem[_12484 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12671 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12671 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15294] = 30
                                    mem[_15294 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _15614 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15614 + idx + 68] = mem[_15294 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15614 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15614 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12575 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12575] = 30
                                mem[_12575 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _12781 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12781 + idx + 68] = mem[_12575 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12781 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12781 + -mem[64] + 100
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14105] = 30
                                mem[_14105 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14331 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14331 + idx + 68] = mem[_14105 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14331 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14331 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _17864 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17864] = 30
                                mem[_17864 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18110 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18110 + idx + 68] = mem[_17864 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18110 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18110 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                _12574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12574] = 30
                                mem[_12574 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12780 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12780 + idx + 68] = mem[_12574 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12780 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12780 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14104] = 30
                                mem[_14104 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14330 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14330 + idx + 68] = mem[_14104 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14330 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14330 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17863 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17863] = 30
                                mem[_17863 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18109 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18109 + idx + 68] = mem[_17863 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18109 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18109 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14224 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14224] = 30
                            mem[_14224 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14462 + idx + 68] = mem[_14224 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14462 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14462 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16644] = 30
                            mem[_16644 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16865 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16865 + idx + 68] = mem[_16644 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16865 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16865 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20084 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20084] = 30
                            mem[_20084 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20290 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_20290 + idx + 68] = mem[_20084 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_20290 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20290 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                        if totalFees > (-11 * arg2 / 100) - 1:
                            revert with 'NH{q', 17
                        if totalFees + (11 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 11 * arg2 / 100
                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11345 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11345] = 26
                                    mem[_11345 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _11978 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11978] = 30
                                        mem[_11978 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12358 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12358] = 30
                                        mem[_12358 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12492 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12492 + idx + 68] = mem[_12358 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12492 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12492 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15081 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15081] = 30
                                        mem[_15081 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _15307 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15307 + idx + 68] = mem[_15081 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15307 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15307 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12412] = 30
                                    mem[_12412 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12582 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12582 + idx + 68] = mem[_12412 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12582 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12582 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13814] = 30
                                    mem[_13814 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14114 + idx + 68] = mem[_13814 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14114 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14114 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17649 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17649] = 30
                                    mem[_17649 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17875 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17875 + idx + 68] = mem[_17649 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17875 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17875 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11447] = 30
                                    mem[_11447 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11528 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11528 + idx + 68] = mem[_11447 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11528 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11528 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11768 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11768] = 30
                                    mem[_11768 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11828 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11828 + idx + 68] = mem[_11768 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11828 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11828 + -mem[64] + 100
                                _11498 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11498] = 26
                                mem[_11498 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _12008 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12008] = 30
                                    mem[_12008 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12493 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12493] = 30
                                    mem[_12493 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12683 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12683 + idx + 68] = mem[_12493 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12683 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12683 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15308] = 30
                                    mem[_15308 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15632 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15632 + idx + 68] = mem[_15308 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15632 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15632 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12583 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12583] = 30
                                mem[_12583 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12788 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12788 + idx + 68] = mem[_12583 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12788 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12788 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14116 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14116] = 30
                                mem[_14116 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14342 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14342 + idx + 68] = mem[_14116 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14342 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14342 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17877 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17877] = 30
                                mem[_17877 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18127 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18127 + idx + 68] = mem[_17877 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18127 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18127 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 11 > -1 / arg2 / 100:
                                revert with 'NH{q', 17
                            if not arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 / arg2 / 100 != 11:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11341 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11341] = 26
                                    mem[_11341 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            _11977 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11977] = 30
                                            mem[_11977 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12356 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12356] = 30
                                            mem[_12356 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12489 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12489 + idx + 68] = mem[_12356 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12489 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12489 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15077 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15077] = 30
                                            mem[_15077 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _15303 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15303 + idx + 68] = mem[_15077 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15303 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15303 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12410] = 30
                                        mem[_12410 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _12579 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12579 + idx + 68] = mem[_12410 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12579 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12579 + -mem[64] + 100
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13810 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13810] = 30
                                        mem[_13810 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14110 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14110 + idx + 68] = mem[_13810 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14110 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14110 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        _17642 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17642] = 30
                                        mem[_17642 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17871 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17871 + idx + 68] = mem[_17642 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17871 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17871 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        _12409 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12409] = 30
                                        mem[_12409 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12578 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12578 + idx + 68] = mem[_12409 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12578 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12578 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13809 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13809] = 30
                                        mem[_13809 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14109 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14109 + idx + 68] = mem[_13809 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14109 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14109 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17641 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17641] = 30
                                        mem[_17641 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17870 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17870 + idx + 68] = mem[_17641 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17870 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17870 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13949] = 30
                                    mem[_13949 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14227 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14227 + idx + 68] = mem[_13949 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14227 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14227 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16325] = 30
                                    mem[_16325 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _16646 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16646 + idx + 68] = mem[_16325 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16646 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16646 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19824 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19824] = 30
                                    mem[_19824 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20090 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20090 + idx + 68] = mem[_19824 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20090 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20090 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11445 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11445] = 30
                                    mem[_11445 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11527 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11527 + idx + 68] = mem[_11445 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11527 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11527 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11767 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11767] = 30
                                    mem[_11767 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11827 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11827 + idx + 68] = mem[_11767 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11827 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11827 + -mem[64] + 100
                                _11497 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11497] = 26
                                mem[_11497 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _12007 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12007] = 30
                                        mem[_12007 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12490 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12490] = 30
                                        mem[_12490 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12679 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12679 + idx + 68] = mem[_12490 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12679 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12679 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15304 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15304] = 30
                                        mem[_15304 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15627 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15627 + idx + 68] = mem[_15304 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15627 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15627 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12581 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12581] = 30
                                    mem[_12581 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12786 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12786 + idx + 68] = mem[_12581 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12786 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12786 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14113 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14113] = 30
                                    mem[_14113 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14339 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14339 + idx + 68] = mem[_14113 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14339 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14339 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17874 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17874] = 30
                                    mem[_17874 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18123 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18123 + idx + 68] = mem[_17874 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18123 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18123 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12580 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12580] = 30
                                    mem[_12580 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12785 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12785 + idx + 68] = mem[_12580 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12785 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12785 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14112 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14112] = 30
                                    mem[_14112 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14338 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14338 + idx + 68] = mem[_14112 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14338 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14338 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17873] = 30
                                    mem[_17873 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18122 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18122 + idx + 68] = mem[_17873 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18122 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18122 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14231 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14231] = 30
                                mem[_14231 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14473 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14473 + idx + 68] = mem[_14231 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14473 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14473 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16649 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16649] = 30
                                mem[_16649 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16872 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16872 + idx + 68] = mem[_16649 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16872 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16872 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20093] = 30
                                mem[_20093 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20298 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20298 + idx + 68] = mem[_20093 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20298 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20298 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11353] = 26
                                    mem[_11353 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _11980 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11980] = 30
                                        mem[_11980 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12361 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12361] = 30
                                        mem[_12361 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12498 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12498 + idx + 68] = mem[_12361 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12498 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12498 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15089 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15089] = 30
                                        mem[_15089 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _15317 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15317 + idx + 68] = mem[_15089 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15317 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15317 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12417 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12417] = 30
                                    mem[_12417 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12588 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12588 + idx + 68] = mem[_12417 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12588 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12588 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13822 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13822] = 30
                                    mem[_13822 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14122 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14122 + idx + 68] = mem[_13822 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14122 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14122 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17663 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17663] = 30
                                    mem[_17663 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17885 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17885 + idx + 68] = mem[_17663 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17885 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17885 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11451 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11451] = 30
                                    mem[_11451 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11530 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11530 + idx + 68] = mem[_11451 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11530 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11530 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11770 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11770] = 30
                                    mem[_11770 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11830 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11830 + idx + 68] = mem[_11770 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11830 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11830 + -mem[64] + 100
                                _11500 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11500] = 26
                                mem[_11500 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _12010 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12010] = 30
                                    mem[_12010 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12499 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12499] = 30
                                    mem[_12499 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12691 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12691 + idx + 68] = mem[_12499 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12691 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12691 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15318] = 30
                                    mem[_15318 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15645 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15645 + idx + 68] = mem[_15318 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15645 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15645 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12589 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12589] = 30
                                mem[_12589 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12793 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12793 + idx + 68] = mem[_12589 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12793 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12793 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14124] = 30
                                mem[_14124 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14350 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14350 + idx + 68] = mem[_14124 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14350 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14350 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17887] = 30
                                mem[_17887 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18140 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18140 + idx + 68] = mem[_17887 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18140 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18140 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 11 > -1 / arg2 / 100:
                                revert with 'NH{q', 17
                            if not arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 / arg2 / 100 != 11:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11349] = 26
                                    mem[_11349 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            _11979 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11979] = 30
                                            mem[_11979 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12359 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12359] = 30
                                            mem[_12359 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12495 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12495 + idx + 68] = mem[_12359 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12495 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12495 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15085 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15085] = 30
                                            mem[_15085 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _15313 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15313 + idx + 68] = mem[_15085 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15313 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15313 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12415] = 30
                                        mem[_12415 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _12585 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12585 + idx + 68] = mem[_12415 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12585 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12585 + -mem[64] + 100
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13818 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13818] = 30
                                        mem[_13818 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14118 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14118 + idx + 68] = mem[_13818 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14118 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14118 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        _17656 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17656] = 30
                                        mem[_17656 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17881 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17881 + idx + 68] = mem[_17656 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17881 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17881 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        _12414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12414] = 30
                                        mem[_12414 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12584 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12584 + idx + 68] = mem[_12414 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12584 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12584 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13817 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13817] = 30
                                        mem[_13817 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14117 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14117 + idx + 68] = mem[_13817 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14117 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14117 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17655 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17655] = 30
                                        mem[_17655 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17880 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17880 + idx + 68] = mem[_17655 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17880 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17880 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13961 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13961] = 30
                                    mem[_13961 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14234 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14234 + idx + 68] = mem[_13961 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14234 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14234 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16340 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16340] = 30
                                    mem[_16340 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _16651 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16651 + idx + 68] = mem[_16340 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16651 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16651 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19846 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19846] = 30
                                    mem[_19846 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20099 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20099 + idx + 68] = mem[_19846 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20099 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20099 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11449 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11449] = 30
                                    mem[_11449 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11529 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11529 + idx + 68] = mem[_11449 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11529 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11529 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11769] = 30
                                    mem[_11769 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11829 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11829 + idx + 68] = mem[_11769 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11829 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11829 + -mem[64] + 100
                                _11499 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11499] = 26
                                mem[_11499 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _12009 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12009] = 30
                                        mem[_12009 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12496 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12496] = 30
                                        mem[_12496 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12687 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12687 + idx + 68] = mem[_12496 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12687 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12687 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15314 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15314] = 30
                                        mem[_15314 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15640 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15640 + idx + 68] = mem[_15314 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15640 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15640 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12587] = 30
                                    mem[_12587 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12791 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12791 + idx + 68] = mem[_12587 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12791 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12791 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14121 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14121] = 30
                                    mem[_14121 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14347 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14347 + idx + 68] = mem[_14121 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14347 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14347 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17884 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17884] = 30
                                    mem[_17884 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18136 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18136 + idx + 68] = mem[_17884 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18136 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18136 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12586] = 30
                                    mem[_12586 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12790 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12790 + idx + 68] = mem[_12586 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12790 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12790 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14120 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14120] = 30
                                    mem[_14120 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14346 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14346 + idx + 68] = mem[_14120 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14346 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14346 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17883 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17883] = 30
                                    mem[_17883 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18135 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18135 + idx + 68] = mem[_17883 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18135 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18135 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14238 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14238] = 30
                                mem[_14238 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14484 + idx + 68] = mem[_14238 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14484 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14484 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16654 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16654] = 30
                                mem[_16654 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16879 + idx + 68] = mem[_16654 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16879 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16879 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20102 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20102] = 30
                                mem[_20102 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20306 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20306 + idx + 68] = mem[_20102 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20306 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20306 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
    else:
        mem[0] = arg1
        mem[32] = 4
        if not stor4[address(arg1)]:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg2 / 100:
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 0 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg2 < 0:
                    revert with 'NH{q', 17
                idx = 0
                s = 100000000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _11425 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11425] = 26
                        mem[_11425 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _11998 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11998] = 30
                            mem[_11998 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _12388 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12388] = 30
                            mem[_12388 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _12552 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12552 + idx + 68] = mem[_12388 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12552 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12552 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _13485 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13485] = 30
                            mem[_13485 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _13772 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_13772 + idx + 68] = mem[_13485 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13772 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13772 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _17120 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17120] = 30
                            mem[_17120 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _17579 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_17579 + idx + 68] = mem[_17120 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_17579 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17579 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12462] = 30
                        mem[_12462 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            _12642 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12642 + idx + 68] = mem[_12462 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12642 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12642 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _13894 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13894] = 30
                        mem[_13894 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _14195 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14195 + idx + 68] = mem[_13894 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14195 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14195 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _15763 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15763] = 30
                        mem[_15763 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _16256 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16256 + idx + 68] = mem[_15763 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16256 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16256 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        _19448 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19448] = 30
                        mem[_19448 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _19723 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_19723 + idx + 68] = mem[_19448 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_19723 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19723 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 'NH{q', 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 'NH{q', 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _11487 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11487] = 30
                        mem[_11487 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _11548 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11548 + idx + 68] = mem[_11487 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11548 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11548 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor5.length:
                            revert with 'NH{q', 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _11788 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11788] = 30
                        mem[_11788 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _11848 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11848 + idx + 68] = mem[_11788 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11848 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11848 + -mem[64] + 100
                    _11518 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11518] = 26
                    mem[_11518 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        _12028 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12028] = 30
                        mem[_12028 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _12553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12553] = 30
                        mem[_12553 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _12763 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12763 + idx + 68] = mem[_12553 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12763 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12763 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _13774 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13774] = 30
                        mem[_13774 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _14076 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14076 + idx + 68] = mem[_13774 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14076 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14076 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] > -1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        _17580 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17580] = 30
                        mem[_17580 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _17827 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_17827 + idx + 68] = mem[_17580 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_17827 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17827 + -mem[64] + 100
                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                        revert with 'NH{q', 17
                    if not arg2:
                        revert with 'NH{q', 18
                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12643 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12643] = 30
                    mem[_12643 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                        _12838 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_12838 + idx + 68] = mem[_12643 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_12838 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12838 + -mem[64] + 100
                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                        revert with 'NH{q', 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    _14198 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14198] = 30
                    mem[_14198 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _14423 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14423 + idx + 68] = mem[_14198 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14423 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14423 + -mem[64] + 100
                    if stor2[address(msg.sender)] < arg2:
                        revert with 'NH{q', 17
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _16258 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16258] = 30
                    mem[_16258 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                        _16624 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16624 + idx + 68] = mem[_16258 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16624 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16624 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                        revert with 'NH{q', 17
                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                    _19725 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19725] = 30
                    mem[_19725 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -1:
                            revert with 'NH{q', 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    _20050 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_20050 + idx + 68] = mem[_19725 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_20050 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _20050 + -mem[64] + 100
                if t < stor6 / 100000000 * 10^18:
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < 0:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] > -1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                else:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < 0:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] > -1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if arg2 and t / s > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg2 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 * t / s < 0:
                            revert with 'NH{q', 17
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * t / s > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < arg2 * t / s:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                        if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += arg2 * t / s
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 'NH{q', 17
                if totalFees > -1:
                    revert with 'NH{q', 17
                if totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if arg2 / 100 and 11 > -1 / arg2 / 100:
                    revert with 'NH{q', 17
                if not arg2 / 100:
                    revert with 'NH{q', 18
                if 11 * arg2 / 100 / arg2 / 100 != 11:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 11 * arg2 / 100 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg2 < 11 * arg2 / 100:
                    revert with 'NH{q', 17
                idx = 0
                s = 100000000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _11421 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11421] = 26
                        mem[_11421 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 11 * arg2 / 100:
                                _11997 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11997] = 30
                                mem[_11997 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 2
                                _12386 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12386] = 30
                                mem[_12386 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _12549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12549 + idx + 68] = mem[_12386 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12549 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12549 + -mem[64] + 100
                                if stor2[address(msg.sender)] < arg2:
                                    revert with 'NH{q', 17
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13479] = 30
                                mem[_13479 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _13767 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_13767 + idx + 68] = mem[_13479 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13767 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13767 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _17115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17115] = 30
                                mem[_17115 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _17574 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17574 + idx + 68] = mem[_17115 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17574 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17574 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12460 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12460] = 30
                            mem[_12460 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _12639 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12639 + idx + 68] = mem[_12460 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12639 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12639 + -mem[64] + 100
                            if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 2
                            _13890 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13890] = 30
                            mem[_13890 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _14190 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14190 + idx + 68] = mem[_13890 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14190 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14190 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15756 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15756] = 30
                            mem[_15756 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _16249 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16249 + idx + 68] = mem[_15756 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16249 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16249 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            _19440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19440] = 30
                            mem[_19440 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _19719 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19719 + idx + 68] = mem[_19440 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19719 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19719 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 11 * arg2 / 100:
                            _12459 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12459] = 30
                            mem[_12459 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12638 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12638 + idx + 68] = mem[_12459 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12638 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12638 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 2
                            _13889 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13889] = 30
                            mem[_13889 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _14189 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14189 + idx + 68] = mem[_13889 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14189 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14189 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15755 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15755] = 30
                            mem[_15755 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16248 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16248 + idx + 68] = mem[_15755 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16248 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16248 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _19439 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19439] = 30
                            mem[_19439 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _19718 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19718 + idx + 68] = mem[_19439 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19718 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19718 + -mem[64] + 100
                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        if not 11 * arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14069 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14069] = 30
                        mem[_14069 + 32] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                            _14297 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14297 + idx + 68] = mem[_14069 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14297 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14297 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _16473 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16473] = 30
                        mem[_16473 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _16700 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16700 + idx + 68] = mem[_16473 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16700 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16700 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _18248 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18248] = 30
                        mem[_18248 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _18644 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18644 + idx + 68] = mem[_18248 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18644 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18644 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                        _21270 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21270] = 30
                        mem[_21270 + 32] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _21506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_21506 + idx + 68] = mem[_21270 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_21506 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21506 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 'NH{q', 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 'NH{q', 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _11485 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11485] = 30
                        mem[_11485 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _11547 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_11547 + idx + 68] = mem[_11485 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_11547 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11547 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 'NH{q', 17
                        if idx >= stor5.length:
                            revert with 'NH{q', 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _11787 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11787] = 30
                        mem[_11787 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 'NH{q', 17
                            if idx == -1:
                                revert with 'NH{q', 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _11847 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_11847 + idx + 68] = mem[_11787 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_11847 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11847 + -mem[64] + 100
                    _11517 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11517] = 26
                    mem[_11517 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not 11 * arg2 / 100:
                            _12027 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12027] = 30
                            mem[_12027 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _12550 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12550] = 30
                            mem[_12550 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _12759 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12759 + idx + 68] = mem[_12550 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12759 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12759 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _13770 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13770] = 30
                            mem[_13770 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _14072 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14072 + idx + 68] = mem[_13770 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14072 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14072 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _17576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17576] = 30
                            mem[_17576 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _17822 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_17822 + idx + 68] = mem[_17576 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_17822 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17822 + -mem[64] + 100
                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        if not 11 * arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12641 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12641] = 30
                        mem[_12641 + 32] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                            _12836 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12836 + idx + 68] = mem[_12641 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12836 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12836 + -mem[64] + 100
                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _14194 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14194] = 30
                        mem[_14194 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _14419 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14419 + idx + 68] = mem[_14194 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14419 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14419 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _16253 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16253] = 30
                        mem[_16253 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _16622 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16622 + idx + 68] = mem[_16253 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16622 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16622 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        _19722 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19722] = 30
                        mem[_19722 + 32] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _20046 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_20046 + idx + 68] = mem[_19722 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_20046 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20046 + -mem[64] + 100
                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                        revert with 'NH{q', 17
                    if not arg2:
                        revert with 'NH{q', 18
                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 11 * arg2 / 100:
                        _12640 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12640] = 30
                        mem[_12640 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            _12835 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_12835 + idx + 68] = mem[_12640 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_12835 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12835 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 'NH{q', 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _14193 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14193] = 30
                        mem[_14193 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _14418 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14418 + idx + 68] = mem[_14193 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14418 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14418 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 'NH{q', 17
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _16252 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16252] = 30
                        mem[_16252 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _16621 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16621 + idx + 68] = mem[_16252 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16621 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16621 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                            revert with 'NH{q', 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        _19721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19721] = 30
                        mem[_19721 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _20045 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_20045 + idx + 68] = mem[_19721 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_20045 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20045 + -mem[64] + 100
                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                        revert with 'NH{q', 17
                    if not 11 * arg2 / 100:
                        revert with 'NH{q', 18
                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14301 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14301] = 30
                    mem[_14301 + 32] = 'SafeMath: subtraction overflow'
                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                        _14582 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_14582 + idx + 68] = mem[_14301 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14582 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14582 + -mem[64] + 100
                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    _16706 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16706] = 30
                    mem[_16706 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _16937 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16937 + idx + 68] = mem[_16706 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16937 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16937 + -mem[64] + 100
                    if stor2[address(msg.sender)] < arg2:
                        revert with 'NH{q', 17
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _18647 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18647] = 30
                    mem[_18647 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                        _19017 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_19017 + idx + 68] = mem[_18647 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_19017 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19017 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                        revert with 'NH{q', 17
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                        revert with 'NH{q', 17
                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                    _21510 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21510] = 30
                    mem[_21510 + 32] = 'SafeMath: subtraction overflow'
                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 'NH{q', 17
                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        if totalFees > (-11 * arg2 / 100) - 1:
                            revert with 'NH{q', 17
                        if totalFees + (11 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 11 * arg2 / 100
                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                        return 1
                    _21748 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_21748 + idx + 68] = mem[_21510 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_21748 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _21748 + -mem[64] + 100
                if t < stor6 / 100000000 * 10^18:
                    if not arg2:
                        if not 11 * arg2 / 100:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                        else:
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                    else:
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 11 * arg2 / 100:
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                        else:
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                else:
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not s:
                        revert with 'NH{q', 18
                    if not arg2:
                        if not 11 * arg2 / 100:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > -1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                        else:
                            if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 11 * arg2 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 11 * arg2 / 100 * t / s:
                                revert with 'NH{q', 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                            if 11 * arg2 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 11 * arg2 / 100 * t / s:
                                revert with 'NH{q', 17
                            stor6 += -11 * arg2 / 100 * t / s
                    else:
                        if arg2 and t / s > -1 / arg2:
                            revert with 'NH{q', 17
                        if not arg2:
                            revert with 'NH{q', 18
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 11 * arg2 / 100:
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 'NH{q', 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                        else:
                            if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                revert with 'NH{q', 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 'NH{q', 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                            if 11 * arg2 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 11 * arg2 / 100 * t / s:
                                revert with 'NH{q', 17
                            stor6 += -11 * arg2 / 100 * t / s
                if totalFees > (-11 * arg2 / 100) - 1:
                    revert with 'NH{q', 17
                if totalFees + (11 * arg2 / 100) < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += 11 * arg2 / 100
                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
        else:
            if stor4[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 4
                if stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11369 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11369] = 26
                                mem[_11369 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _11984 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11984] = 30
                                    mem[_11984 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12367 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12367] = 30
                                    mem[_12367 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12510 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12510 + idx + 68] = mem[_12367 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12510 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12510 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15105 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15105] = 30
                                    mem[_15105 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15333 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15333 + idx + 68] = mem[_15105 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15333 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15333 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12427] = 30
                                mem[_12427 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12600 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12600 + idx + 68] = mem[_12427 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12600 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12600 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13838 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13838] = 30
                                mem[_13838 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14138 + idx + 68] = mem[_13838 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14138 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14138 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17691] = 30
                                mem[_17691 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _17905 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17905 + idx + 68] = mem[_17691 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17905 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17905 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11459 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11459] = 30
                                mem[_11459 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11534 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11534 + idx + 68] = mem[_11459 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11534 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11534 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11774 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11774] = 30
                                mem[_11774 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11834 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11834 + idx + 68] = mem[_11774 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11834 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11834 + -mem[64] + 100
                            _11504 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11504] = 26
                            mem[_11504 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _12014 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12014] = 30
                                mem[_12014 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12511 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12511] = 30
                                mem[_12511 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12707 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12707 + idx + 68] = mem[_12511 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12707 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12707 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _15334 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15334] = 30
                                mem[_15334 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _15669 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15669 + idx + 68] = mem[_15334 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15669 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15669 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12601 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12601] = 30
                            mem[_12601 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12803 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12803 + idx + 68] = mem[_12601 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12803 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12803 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14140 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14140] = 30
                            mem[_14140 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14366 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14366 + idx + 68] = mem[_14140 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14366 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14366 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _17907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17907] = 30
                            mem[_17907 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _18161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18161 + idx + 68] = mem[_17907 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18161 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18161 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -1:
                            revert with 'NH{q', 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 11 > -1 / arg2 / 100:
                            revert with 'NH{q', 17
                        if not arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 / arg2 / 100 != 11:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11365 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11365] = 26
                                mem[_11365 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _11983 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11983] = 30
                                        mem[_11983 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12365 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12365] = 30
                                        mem[_12365 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12507 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12507 + idx + 68] = mem[_12365 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12507 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12507 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15101 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15101] = 30
                                        mem[_15101 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15329 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15329 + idx + 68] = mem[_15101 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15329 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15329 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12425] = 30
                                    mem[_12425 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12597 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12597 + idx + 68] = mem[_12425 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12597 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12597 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13834] = 30
                                    mem[_13834 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14134 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14134 + idx + 68] = mem[_13834 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14134 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14134 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17684 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17684] = 30
                                    mem[_17684 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17901 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17901 + idx + 68] = mem[_17684 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17901 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17901 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12424] = 30
                                    mem[_12424 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12596 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12596 + idx + 68] = mem[_12424 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12596 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12596 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13833 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13833] = 30
                                    mem[_13833 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14133 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14133 + idx + 68] = mem[_13833 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14133 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14133 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17683 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17683] = 30
                                    mem[_17683 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17900 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17900 + idx + 68] = mem[_17683 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17900 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17900 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13985 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13985] = 30
                                mem[_13985 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14248 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14248 + idx + 68] = mem[_13985 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14248 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14248 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16370] = 30
                                mem[_16370 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16663 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16663 + idx + 68] = mem[_16370 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16663 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16663 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _19886 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19886] = 30
                                mem[_19886 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20124 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20124 + idx + 68] = mem[_19886 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20124 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20124 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11457 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11457] = 30
                                mem[_11457 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11533 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11533 + idx + 68] = mem[_11457 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11533 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11533 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11773 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11773] = 30
                                mem[_11773 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11833 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11833 + idx + 68] = mem[_11773 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11833 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11833 + -mem[64] + 100
                            _11503 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11503] = 26
                            mem[_11503 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    _12013 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12013] = 30
                                    mem[_12013 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12508 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12508] = 30
                                    mem[_12508 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12703 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12703 + idx + 68] = mem[_12508 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12703 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12703 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15330 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15330] = 30
                                    mem[_15330 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _15664 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15664 + idx + 68] = mem[_15330 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15664 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15664 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12599 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12599] = 30
                                mem[_12599 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _12801 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12801 + idx + 68] = mem[_12599 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12801 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12801 + -mem[64] + 100
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14137 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14137] = 30
                                mem[_14137 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14363 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14363 + idx + 68] = mem[_14137 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14363 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14363 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _17904 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17904] = 30
                                mem[_17904 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18157 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18157 + idx + 68] = mem[_17904 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18157 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18157 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                _12598 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12598] = 30
                                mem[_12598 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12800 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12800 + idx + 68] = mem[_12598 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12800 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12800 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14136 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14136] = 30
                                mem[_14136 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14362 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14362 + idx + 68] = mem[_14136 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14362 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14362 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17903 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17903] = 30
                                mem[_17903 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18156 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18156 + idx + 68] = mem[_17903 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18156 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18156 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14252 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14252] = 30
                            mem[_14252 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14506 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14506 + idx + 68] = mem[_14252 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14506 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14506 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16666 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16666] = 30
                            mem[_16666 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16891 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16891 + idx + 68] = mem[_16666 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16891 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16891 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20127 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20127] = 30
                            mem[_20127 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20318 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_20318 + idx + 68] = mem[_20127 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_20318 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20318 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                        if totalFees > (-11 * arg2 / 100) - 1:
                            revert with 'NH{q', 17
                        if totalFees + (11 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 11 * arg2 / 100
                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11377] = 26
                                    mem[_11377 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _11986 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11986] = 30
                                        mem[_11986 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12370 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12370] = 30
                                        mem[_12370 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12516 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12516 + idx + 68] = mem[_12370 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12516 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12516 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15113 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15113] = 30
                                        mem[_15113 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _15343 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15343 + idx + 68] = mem[_15113 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15343 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15343 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12432 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12432] = 30
                                    mem[_12432 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12606 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12606 + idx + 68] = mem[_12432 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12606 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12606 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13846 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13846] = 30
                                    mem[_13846 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14146 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14146 + idx + 68] = mem[_13846 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14146 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14146 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17705 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17705] = 30
                                    mem[_17705 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17915 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17915 + idx + 68] = mem[_17705 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17915 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17915 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11463 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11463] = 30
                                    mem[_11463 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11536 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11536 + idx + 68] = mem[_11463 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11536 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11536 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11776 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11776] = 30
                                    mem[_11776 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11836 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11836 + idx + 68] = mem[_11776 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11836 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11836 + -mem[64] + 100
                                _11506 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11506] = 26
                                mem[_11506 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _12016 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12016] = 30
                                    mem[_12016 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12517 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12517] = 30
                                    mem[_12517 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12715 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12715 + idx + 68] = mem[_12517 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12715 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12715 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15344 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15344] = 30
                                    mem[_15344 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15682 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15682 + idx + 68] = mem[_15344 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15682 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15682 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12607 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12607] = 30
                                mem[_12607 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12808 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12808 + idx + 68] = mem[_12607 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12808 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12808 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14148 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14148] = 30
                                mem[_14148 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14374 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14374 + idx + 68] = mem[_14148 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14374 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14374 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17917 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17917] = 30
                                mem[_17917 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18174 + idx + 68] = mem[_17917 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18174 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18174 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 11 > -1 / arg2 / 100:
                                revert with 'NH{q', 17
                            if not arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 / arg2 / 100 != 11:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11373] = 26
                                    mem[_11373 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            _11985 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11985] = 30
                                            mem[_11985 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12368] = 30
                                            mem[_12368 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12513 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12513 + idx + 68] = mem[_12368 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12513 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12513 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15109 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15109] = 30
                                            mem[_15109 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _15339 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15339 + idx + 68] = mem[_15109 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15339 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15339 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12430] = 30
                                        mem[_12430 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _12603 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12603 + idx + 68] = mem[_12430 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12603 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12603 + -mem[64] + 100
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13842 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13842] = 30
                                        mem[_13842 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14142 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14142 + idx + 68] = mem[_13842 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14142 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14142 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        _17698 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17698] = 30
                                        mem[_17698 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17911 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17911 + idx + 68] = mem[_17698 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17911 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17911 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        _12429 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12429] = 30
                                        mem[_12429 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12602 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12602 + idx + 68] = mem[_12429 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12602 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12602 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13841 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13841] = 30
                                        mem[_13841 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14141 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14141 + idx + 68] = mem[_13841 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14141 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14141 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17697 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17697] = 30
                                        mem[_17697 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17910 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17910 + idx + 68] = mem[_17697 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17910 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17910 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13997 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13997] = 30
                                    mem[_13997 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14255 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14255 + idx + 68] = mem[_13997 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14255 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14255 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16385 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16385] = 30
                                    mem[_16385 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _16668 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16668 + idx + 68] = mem[_16385 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16668 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16668 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19908 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19908] = 30
                                    mem[_19908 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20133 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20133 + idx + 68] = mem[_19908 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20133 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20133 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11461 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11461] = 30
                                    mem[_11461 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11535 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11535 + idx + 68] = mem[_11461 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11535 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11535 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11775 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11775] = 30
                                    mem[_11775 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11835 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11835 + idx + 68] = mem[_11775 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11835 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11835 + -mem[64] + 100
                                _11505 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11505] = 26
                                mem[_11505 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _12015 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12015] = 30
                                        mem[_12015 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12514 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12514] = 30
                                        mem[_12514 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12711 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12711 + idx + 68] = mem[_12514 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12711 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12711 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15340 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15340] = 30
                                        mem[_15340 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15677 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15677 + idx + 68] = mem[_15340 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15677 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15677 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12605 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12605] = 30
                                    mem[_12605 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12806 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12806 + idx + 68] = mem[_12605 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12806 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12806 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14145 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14145] = 30
                                    mem[_14145 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14371 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14371 + idx + 68] = mem[_14145 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14371 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14371 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17914] = 30
                                    mem[_17914 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18170 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18170 + idx + 68] = mem[_17914 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18170 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18170 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12604 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12604] = 30
                                    mem[_12604 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12805 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12805 + idx + 68] = mem[_12604 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12805 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12805 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14144 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14144] = 30
                                    mem[_14144 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14370 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14370 + idx + 68] = mem[_14144 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14370 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14370 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17913 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17913] = 30
                                    mem[_17913 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18169 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18169 + idx + 68] = mem[_17913 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18169 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18169 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14259 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14259] = 30
                                mem[_14259 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14517 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14517 + idx + 68] = mem[_14259 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14517 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14517 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16671 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16671] = 30
                                mem[_16671 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16898 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16898 + idx + 68] = mem[_16671 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16898 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16898 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20136 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20136] = 30
                                mem[_20136 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20326 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20326 + idx + 68] = mem[_20136 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20326 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20326 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11385 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11385] = 26
                                    mem[_11385 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _11988 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11988] = 30
                                        mem[_11988 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12373] = 30
                                        mem[_12373 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12522 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12522 + idx + 68] = mem[_12373 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12522 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12522 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15121 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15121] = 30
                                        mem[_15121 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _15353 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15353 + idx + 68] = mem[_15121 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15353 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15353 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12437] = 30
                                    mem[_12437 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12612 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12612 + idx + 68] = mem[_12437 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12612 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12612 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13854 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13854] = 30
                                    mem[_13854 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14154 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14154 + idx + 68] = mem[_13854 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14154 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14154 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17719 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17719] = 30
                                    mem[_17719 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17925 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17925 + idx + 68] = mem[_17719 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17925 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17925 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11467 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11467] = 30
                                    mem[_11467 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11538 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11538 + idx + 68] = mem[_11467 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11538 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11538 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11778 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11778] = 30
                                    mem[_11778 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11838 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11838 + idx + 68] = mem[_11778 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11838 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11838 + -mem[64] + 100
                                _11508 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11508] = 26
                                mem[_11508 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _12018 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12018] = 30
                                    mem[_12018 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12523 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12523] = 30
                                    mem[_12523 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12723 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12723 + idx + 68] = mem[_12523 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12723 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12723 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15354 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15354] = 30
                                    mem[_15354 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15695 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15695 + idx + 68] = mem[_15354 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15695 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15695 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12613 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12613] = 30
                                mem[_12613 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12813 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12813 + idx + 68] = mem[_12613 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12813 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12813 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14156 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14156] = 30
                                mem[_14156 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14382 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14382 + idx + 68] = mem[_14156 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14382 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14382 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17927 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17927] = 30
                                mem[_17927 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18187 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18187 + idx + 68] = mem[_17927 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18187 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18187 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 11 > -1 / arg2 / 100:
                                revert with 'NH{q', 17
                            if not arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 / arg2 / 100 != 11:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11381 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11381] = 26
                                    mem[_11381 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            _11987 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11987] = 30
                                            mem[_11987 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12371 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12371] = 30
                                            mem[_12371 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12519 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12519 + idx + 68] = mem[_12371 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12519 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12519 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15117 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15117] = 30
                                            mem[_15117 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _15349 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15349 + idx + 68] = mem[_15117 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15349 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15349 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12435 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12435] = 30
                                        mem[_12435 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _12609 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12609 + idx + 68] = mem[_12435 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12609 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12609 + -mem[64] + 100
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13850 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13850] = 30
                                        mem[_13850 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14150 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14150 + idx + 68] = mem[_13850 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14150 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14150 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        _17712 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17712] = 30
                                        mem[_17712 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17921 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17921 + idx + 68] = mem[_17712 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17921 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17921 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        _12434 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12434] = 30
                                        mem[_12434 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12608 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12608 + idx + 68] = mem[_12434 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12608 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12608 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13849] = 30
                                        mem[_13849 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14149 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14149 + idx + 68] = mem[_13849 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14149 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14149 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17711 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17711] = 30
                                        mem[_17711 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17920 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17920 + idx + 68] = mem[_17711 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17920 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17920 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14009 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14009] = 30
                                    mem[_14009 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14262 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14262 + idx + 68] = mem[_14009 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14262 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14262 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16400 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16400] = 30
                                    mem[_16400 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _16673 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16673 + idx + 68] = mem[_16400 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16673 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16673 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19930 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19930] = 30
                                    mem[_19930 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20142 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20142 + idx + 68] = mem[_19930 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20142 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20142 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11465 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11465] = 30
                                    mem[_11465 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11537 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11537 + idx + 68] = mem[_11465 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11537 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11537 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11777 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11777] = 30
                                    mem[_11777 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11837 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11837 + idx + 68] = mem[_11777 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11837 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11837 + -mem[64] + 100
                                _11507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11507] = 26
                                mem[_11507 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _12017 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12017] = 30
                                        mem[_12017 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12520 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12520] = 30
                                        mem[_12520 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12719 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12719 + idx + 68] = mem[_12520 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12719 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12719 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15350] = 30
                                        mem[_15350 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15690 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15690 + idx + 68] = mem[_15350 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15690 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15690 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12611 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12611] = 30
                                    mem[_12611 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12811 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12811 + idx + 68] = mem[_12611 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12811 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12811 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14153 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14153] = 30
                                    mem[_14153 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14379 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14379 + idx + 68] = mem[_14153 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14379 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14379 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17924 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17924] = 30
                                    mem[_17924 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18183 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18183 + idx + 68] = mem[_17924 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18183 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18183 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12610 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12610] = 30
                                    mem[_12610 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12810 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12810 + idx + 68] = mem[_12610 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12810 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12810 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14152 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14152] = 30
                                    mem[_14152 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14378 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14378 + idx + 68] = mem[_14152 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14378 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14378 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17923 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17923] = 30
                                    mem[_17923 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18182 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18182 + idx + 68] = mem[_17923 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18182 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18182 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14266 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14266] = 30
                                mem[_14266 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14528 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14528 + idx + 68] = mem[_14266 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14528 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14528 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16676 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16676] = 30
                                mem[_16676 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16905 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16905 + idx + 68] = mem[_16676 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16905 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16905 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20145 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20145] = 30
                                mem[_20145 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20334 + idx + 68] = mem[_20145 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20334 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                if stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11417] = 26
                                mem[_11417 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _11996 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11996] = 30
                                    mem[_11996 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12385 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12385] = 30
                                    mem[_12385 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12546 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12546 + idx + 68] = mem[_12385 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12546 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12546 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] > -arg2 - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _16822 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16822] = 30
                                    mem[_16822 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17111 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17111 + idx + 68] = mem[_16822 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17111 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17111 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12457 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12457] = 30
                                mem[_12457 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12636 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12636 + idx + 68] = mem[_12457 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12636 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12636 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13886 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13886] = 30
                                mem[_13886 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14186 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14186 + idx + 68] = mem[_13886 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14186 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14186 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > -arg2 - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _19190 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19190] = 30
                                mem[_19190 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19432 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19432 + idx + 68] = mem[_19190 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19432 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19432 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11483 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11483] = 30
                                mem[_11483 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11546 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11546 + idx + 68] = mem[_11483 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11546 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11546 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11786 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11786] = 30
                                mem[_11786 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11846 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11846 + idx + 68] = mem[_11786 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11846 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11846 + -mem[64] + 100
                            _11516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11516] = 26
                            mem[_11516 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _12026 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12026] = 30
                                mem[_12026 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _12547 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12547] = 30
                                mem[_12547 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _12755 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12755 + idx + 68] = mem[_12547 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12755 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12755 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _17113 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17113] = 30
                                mem[_17113 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _17567 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17567 + idx + 68] = mem[_17113 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17567 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17567 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _12637 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12637] = 30
                            mem[_12637 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _12833 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_12833 + idx + 68] = mem[_12637 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12833 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12833 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14188 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14188] = 30
                            mem[_14188 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _14414 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14414 + idx + 68] = mem[_14188 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14414 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14414 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > -arg2 - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _19434 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19434] = 30
                            mem[_19434 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19714 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19714 + idx + 68] = mem[_19434 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19714 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19714 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > -arg2 - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 'NH{q', 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > -arg2 - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 'NH{q', 17
                        if totalFees > -1:
                            revert with 'NH{q', 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 11 > -1 / arg2 / 100:
                            revert with 'NH{q', 17
                        if not arg2 / 100:
                            revert with 'NH{q', 18
                        if 11 * arg2 / 100 / arg2 / 100 != 11:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 11 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 11 * arg2 / 100:
                            revert with 'NH{q', 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _11413 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11413] = 26
                                mem[_11413 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _11995 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11995] = 30
                                        mem[_11995 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12383] = 30
                                        mem[_12383 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12543 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12543 + idx + 68] = mem[_12383 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12543 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12543 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _16819 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16819] = 30
                                        mem[_16819 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17105 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17105 + idx + 68] = mem[_16819 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17105 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17105 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12455 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12455] = 30
                                    mem[_12455 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12633 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12633 + idx + 68] = mem[_12455 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12633 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12633 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13882 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13882] = 30
                                    mem[_13882 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14182 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14182 + idx + 68] = mem[_13882 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14182 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14182 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _19183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19183] = 30
                                    mem[_19183 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19427 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19427 + idx + 68] = mem[_19183 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19427 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19427 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12454 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12454] = 30
                                    mem[_12454 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12632 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12632 + idx + 68] = mem[_12454 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12632 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12632 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13881 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13881] = 30
                                    mem[_13881 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14181 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14181 + idx + 68] = mem[_13881 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14181 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14181 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _19182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19182] = 30
                                    mem[_19182 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19426 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19426 + idx + 68] = mem[_19182 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19426 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19426 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14057 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14057] = 30
                                mem[_14057 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14290 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14290 + idx + 68] = mem[_14057 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14290 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14290 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16460 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16460] = 30
                                mem[_16460 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16693 + idx + 68] = mem[_16460 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16693 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16693 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _21079 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21079] = 30
                                mem[_21079 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21253 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21253 + idx + 68] = mem[_21079 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21253 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21253 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 'NH{q', 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _11481 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11481] = 30
                                mem[_11481 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _11545 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11545 + idx + 68] = mem[_11481 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11545 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11545 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 'NH{q', 17
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _11785 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11785] = 30
                                mem[_11785 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx == -1:
                                        revert with 'NH{q', 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _11845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_11845 + idx + 68] = mem[_11785 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11845 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11845 + -mem[64] + 100
                            _11515 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11515] = 26
                            mem[_11515 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    _12025 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12025] = 30
                                    mem[_12025 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12544 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12544] = 30
                                    mem[_12544 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12751 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12751 + idx + 68] = mem[_12544 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12751 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12751 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _17109 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17109] = 30
                                    mem[_17109 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17565 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17565 + idx + 68] = mem[_17109 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17565 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17565 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12635 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12635] = 30
                                mem[_12635 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _12831 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12831 + idx + 68] = mem[_12635 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12831 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12831 + -mem[64] + 100
                                if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14185 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14185] = 30
                                mem[_14185 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14411 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14411 + idx + 68] = mem[_14185 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14411 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14411 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _19431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19431] = 30
                                mem[_19431 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19712 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19712 + idx + 68] = mem[_19431 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19712 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19712 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 'NH{q', 17
                            if not arg2:
                                revert with 'NH{q', 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 11 * arg2 / 100:
                                _12634 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12634] = 30
                                mem[_12634 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12830 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12830 + idx + 68] = mem[_12634 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12830 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12830 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14184 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14184] = 30
                                mem[_14184 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14410 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14410 + idx + 68] = mem[_14184 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14410 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14410 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _19430 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19430] = 30
                                mem[_19430 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19711 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19711 + idx + 68] = mem[_19430 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19711 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19711 + -mem[64] + 100
                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            if not 11 * arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14294 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14294] = 30
                            mem[_14294 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14572 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14572 + idx + 68] = mem[_14294 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14572 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14572 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16696 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16696] = 30
                            mem[_16696 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16932 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16932 + idx + 68] = mem[_16696 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16932 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16932 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 'NH{q', 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                revert with 'NH{q', 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _21256 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21256] = 30
                            mem[_21256 + 32] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21500 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_21500 + idx + 68] = mem[_21256 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21500 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21500 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not s:
                                revert with 'NH{q', 18
                            if not arg2:
                                if not 11 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                else:
                                    if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] > -arg2 + (11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if stor2[address(arg1)] + arg2 - (11 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (11 * arg2 / 100)
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                    if 11 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 11 * arg2 / 100 * t / s:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * t / s
                        if totalFees > (-11 * arg2 / 100) - 1:
                            revert with 'NH{q', 17
                        if totalFees + (11 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 11 * arg2 / 100
                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11393] = 26
                                    mem[_11393 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _11990 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11990] = 30
                                        mem[_11990 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12376 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12376] = 30
                                        mem[_12376 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12528 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12528 + idx + 68] = mem[_12376 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12528 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12528 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15129 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15129] = 30
                                        mem[_15129 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _15363 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15363 + idx + 68] = mem[_15129 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15363 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15363 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12442 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12442] = 30
                                    mem[_12442 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12618 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12618 + idx + 68] = mem[_12442 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12618 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12618 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13862 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13862] = 30
                                    mem[_13862 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14162 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14162 + idx + 68] = mem[_13862 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14162 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14162 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17733 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17733] = 30
                                    mem[_17733 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17935 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17935 + idx + 68] = mem[_17733 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17935 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17935 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11471 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11471] = 30
                                    mem[_11471 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11540 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11540 + idx + 68] = mem[_11471 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11540 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11540 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11780 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11780] = 30
                                    mem[_11780 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11840 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11840 + idx + 68] = mem[_11780 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11840 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11840 + -mem[64] + 100
                                _11510 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11510] = 26
                                mem[_11510 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _12020 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12020] = 30
                                    mem[_12020 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _12529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12529] = 30
                                    mem[_12529 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _12731 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12731 + idx + 68] = mem[_12529 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12731 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12731 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _15364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15364] = 30
                                    mem[_15364 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _15708 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15708 + idx + 68] = mem[_15364 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15708 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15708 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _12619 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12619] = 30
                                mem[_12619 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _12818 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_12818 + idx + 68] = mem[_12619 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12818 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12818 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14164] = 30
                                mem[_14164 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _14390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14390 + idx + 68] = mem[_14164 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14390 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14390 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _17937 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17937] = 30
                                mem[_17937 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 'NH{q', 17
                                    if totalFees > -1:
                                        revert with 'NH{q', 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18200 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18200 + idx + 68] = mem[_17937 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18200 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18200 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > -1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 'NH{q', 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 'NH{q', 17
                            if totalFees > -1:
                                revert with 'NH{q', 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 11 > -1 / arg2 / 100:
                                revert with 'NH{q', 17
                            if not arg2 / 100:
                                revert with 'NH{q', 18
                            if 11 * arg2 / 100 / arg2 / 100 != 11:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 11 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 11 * arg2 / 100:
                                revert with 'NH{q', 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _11389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11389] = 26
                                    mem[_11389 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            _11989 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11989] = 30
                                            mem[_11989 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12374 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12374] = 30
                                            mem[_12374 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12525 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12525 + idx + 68] = mem[_12374 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12525 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12525 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15125 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15125] = 30
                                            mem[_15125 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _15359 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15359 + idx + 68] = mem[_15125 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15359 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15359 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12440] = 30
                                        mem[_12440 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _12615 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12615 + idx + 68] = mem[_12440 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12615 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12615 + -mem[64] + 100
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13858 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13858] = 30
                                        mem[_13858 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14158 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14158 + idx + 68] = mem[_13858 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14158 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14158 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        _17726 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17726] = 30
                                        mem[_17726 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17931 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17931 + idx + 68] = mem[_17726 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17931 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17931 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        _12439 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12439] = 30
                                        mem[_12439 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12614 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12614 + idx + 68] = mem[_12439 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12614 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12614 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13857 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13857] = 30
                                        mem[_13857 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14157 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14157 + idx + 68] = mem[_13857 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14157 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14157 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17725 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17725] = 30
                                        mem[_17725 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17930 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17930 + idx + 68] = mem[_17725 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17930 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17930 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14021 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14021] = 30
                                    mem[_14021 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14269 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14269 + idx + 68] = mem[_14021 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14269 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14269 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16415 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16415] = 30
                                    mem[_16415 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _16678 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16678 + idx + 68] = mem[_16415 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16678 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16678 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19952 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19952] = 30
                                    mem[_19952 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20151 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20151 + idx + 68] = mem[_19952 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20151 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20151 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 'NH{q', 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _11469 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11469] = 30
                                    mem[_11469 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _11539 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11539 + idx + 68] = mem[_11469 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11539 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11539 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 'NH{q', 17
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _11779 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11779] = 30
                                    mem[_11779 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx == -1:
                                            revert with 'NH{q', 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _11839 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_11839 + idx + 68] = mem[_11779 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11839 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11839 + -mem[64] + 100
                                _11509 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11509] = 26
                                mem[_11509 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        _12019 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12019] = 30
                                        mem[_12019 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12526 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12526] = 30
                                        mem[_12526 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12727 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12727 + idx + 68] = mem[_12526 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12727 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12727 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15360] = 30
                                        mem[_15360 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _15703 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15703 + idx + 68] = mem[_15360 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15703 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15703 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12617 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12617] = 30
                                    mem[_12617 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _12816 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12816 + idx + 68] = mem[_12617 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12816 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12816 + -mem[64] + 100
                                    if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14161 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14161] = 30
                                    mem[_14161 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14387 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14387 + idx + 68] = mem[_14161 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14387 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14387 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _17934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17934] = 30
                                    mem[_17934 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18196 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18196 + idx + 68] = mem[_17934 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18196 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18196 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 'NH{q', 17
                                if not arg2:
                                    revert with 'NH{q', 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 11 * arg2 / 100:
                                    _12616 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12616] = 30
                                    mem[_12616 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12815 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12815 + idx + 68] = mem[_12616 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12815 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12815 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14160] = 30
                                    mem[_14160 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14386 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14386 + idx + 68] = mem[_14160 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14386 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14386 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17933 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17933] = 30
                                    mem[_17933 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18195 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18195 + idx + 68] = mem[_17933 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18195 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18195 + -mem[64] + 100
                                if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                if not 11 * arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14273 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14273] = 30
                                mem[_14273 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14539 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14539 + idx + 68] = mem[_14273 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14539 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14539 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16681 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16681] = 30
                                mem[_16681 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16912 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16912 + idx + 68] = mem[_16681 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16912 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16912 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 'NH{q', 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                    revert with 'NH{q', 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20154 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20154] = 30
                                mem[_20154 + 32] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > (-11 * arg2 / 100) - 1:
                                        revert with 'NH{q', 17
                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 11 * arg2 / 100
                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20342 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20342 + idx + 68] = mem[_20154 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20342 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20342 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not s:
                                    revert with 'NH{q', 18
                                if not arg2:
                                    if not 11 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                    else:
                                        if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                        if 11 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 11 * arg2 / 100 * t / s:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * t / s
                            if totalFees > (-11 * arg2 / 100) - 1:
                                revert with 'NH{q', 17
                            if totalFees + (11 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 11 * arg2 / 100
                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if stor4[address(arg1)]:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 0:
                                    revert with 'NH{q', 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _11401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11401] = 26
                                        mem[_11401 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _11992 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11992] = 30
                                            mem[_11992 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12379 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12379] = 30
                                            mem[_12379 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12534 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12534 + idx + 68] = mem[_12379 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12534 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12534 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15137 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15137] = 30
                                            mem[_15137 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > -1:
                                                    revert with 'NH{q', 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _15373 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15373 + idx + 68] = mem[_15137 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15373 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15373 + -mem[64] + 100
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12447 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12447] = 30
                                        mem[_12447 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12624 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12624 + idx + 68] = mem[_12447 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12624 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12624 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13870 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13870] = 30
                                        mem[_13870 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14170 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14170 + idx + 68] = mem[_13870 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14170 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14170 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17747 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17747] = 30
                                        mem[_17747 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17945 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17945 + idx + 68] = mem[_17747 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17945 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17945 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 'NH{q', 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _11475 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11475] = 30
                                        mem[_11475 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _11542 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_11542 + idx + 68] = mem[_11475 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_11542 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _11542 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx >= stor5.length:
                                            revert with 'NH{q', 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _11782 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11782] = 30
                                        mem[_11782 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 'NH{q', 17
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _11842 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11842 + idx + 68] = mem[_11782 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11842 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11842 + -mem[64] + 100
                                    _11512 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11512] = 26
                                    mem[_11512 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _12022 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12022] = 30
                                        mem[_12022 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12535 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12535] = 30
                                        mem[_12535 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12739 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12739 + idx + 68] = mem[_12535 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12739 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12739 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15374 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15374] = 30
                                        mem[_15374 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _15721 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15721 + idx + 68] = mem[_15374 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15721 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15721 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12625 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12625] = 30
                                    mem[_12625 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12823 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12823 + idx + 68] = mem[_12625 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12823 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12823 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14172 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14172] = 30
                                    mem[_14172 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14398 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14398 + idx + 68] = mem[_14172 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14398 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14398 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17947 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17947] = 30
                                    mem[_17947 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18213 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18213 + idx + 68] = mem[_17947 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18213 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18213 + -mem[64] + 100
                                if t < stor6 / 100000000 * 10^18:
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                else:
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not s:
                                        revert with 'NH{q', 18
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if arg2 / 100 and 11 > -1 / arg2 / 100:
                                    revert with 'NH{q', 17
                                if not arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 / arg2 / 100 != 11:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _11397 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11397] = 26
                                        mem[_11397 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not 11 * arg2 / 100:
                                                _11991 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11991] = 30
                                                mem[_11991 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _12377 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_12377] = 30
                                                mem[_12377 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _12531 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_12531 + idx + 68] = mem[_12377 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_12531 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _12531 + -mem[64] + 100
                                                if stor1[address(msg.sender)] < 0:
                                                    revert with 'NH{q', 17
                                                if stor1[address(arg1)] > -1:
                                                    revert with 'NH{q', 17
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _15133 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_15133] = 30
                                                mem[_15133 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if stor6 < 0:
                                                        revert with 'NH{q', 17
                                                    if totalFees > (-11 * arg2 / 100) - 1:
                                                        revert with 'NH{q', 17
                                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += 11 * arg2 / 100
                                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _15369 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_15369 + idx + 68] = mem[_15133 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15369 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15369 + -mem[64] + 100
                                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _12445 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12445] = 30
                                            mem[_12445 + 32] = 'SafeMath: subtraction overflow'
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                _12621 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12621 + idx + 68] = mem[_12445 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12621 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12621 + -mem[64] + 100
                                            if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13866 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13866] = 30
                                            mem[_13866 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14166 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_14166 + idx + 68] = mem[_13866 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14166 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14166 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            _17740 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17740] = 30
                                            mem[_17740 + 32] = 'SafeMath: subtraction overflow'
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                    revert with 'NH{q', 17
                                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17941 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17941 + idx + 68] = mem[_17740 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17941 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17941 + -mem[64] + 100
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 11 * arg2 / 100:
                                            _12444 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12444] = 30
                                            mem[_12444 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                                _12620 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12620 + idx + 68] = mem[_12444 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12620 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12620 + -mem[64] + 100
                                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 'NH{q', 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13865 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13865] = 30
                                            mem[_13865 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                _14165 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_14165 + idx + 68] = mem[_13865 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14165 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14165 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                            _17739 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17739] = 30
                                            mem[_17739 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17940 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17940 + idx + 68] = mem[_17739 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17940 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17940 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _14033 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14033] = 30
                                        mem[_14033 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            _14276 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14276 + idx + 68] = mem[_14033 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14276 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14276 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16430 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16430] = 30
                                        mem[_16430 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _16683 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16683 + idx + 68] = mem[_16430 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16683 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16683 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _19974 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19974] = 30
                                        mem[_19974 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20160 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_20160 + idx + 68] = mem[_19974 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20160 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20160 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 'NH{q', 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _11473 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11473] = 30
                                        mem[_11473 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _11541 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_11541 + idx + 68] = mem[_11473 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_11541 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _11541 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx >= stor5.length:
                                            revert with 'NH{q', 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _11781 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11781] = 30
                                        mem[_11781 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 'NH{q', 17
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _11841 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11841 + idx + 68] = mem[_11781 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11841 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11841 + -mem[64] + 100
                                    _11511 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11511] = 26
                                    mem[_11511 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            _12021 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12021] = 30
                                            mem[_12021 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12532 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12532] = 30
                                            mem[_12532 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12735 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12735 + idx + 68] = mem[_12532 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12735 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12735 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15370 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15370] = 30
                                            mem[_15370 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _15716 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15716 + idx + 68] = mem[_15370 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15716 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15716 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12623 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12623] = 30
                                        mem[_12623 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _12821 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12821 + idx + 68] = mem[_12623 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12821 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12821 + -mem[64] + 100
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14169 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14169] = 30
                                        mem[_14169 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14395 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14395 + idx + 68] = mem[_14169 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14395 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14395 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        _17944 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17944] = 30
                                        mem[_17944 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18209 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18209 + idx + 68] = mem[_17944 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18209 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18209 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        _12622 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12622] = 30
                                        mem[_12622 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12820 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12820 + idx + 68] = mem[_12622 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12820 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12820 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14168 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14168] = 30
                                        mem[_14168 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14394 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14394 + idx + 68] = mem[_14168 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14394 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14394 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17943 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17943] = 30
                                        mem[_17943 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18208 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18208 + idx + 68] = mem[_17943 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18208 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18208 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14280 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14280] = 30
                                    mem[_14280 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14550 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14550 + idx + 68] = mem[_14280 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14550 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14550 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16686 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16686] = 30
                                    mem[_16686 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _16919 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16919 + idx + 68] = mem[_16686 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16919 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16919 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20163 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20163] = 30
                                    mem[_20163 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20350 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20350 + idx + 68] = mem[_20163 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20350 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20350 + -mem[64] + 100
                                if t < stor6 / 100000000 * 10^18:
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                        else:
                                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    else:
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 11 * arg2 / 100:
                                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 'NH{q', 17
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                        else:
                                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not s:
                                        revert with 'NH{q', 18
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                        else:
                                            if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 11 * arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 11 * arg2 / 100 * t / s:
                                                revert with 'NH{q', 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                            if 11 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 11 * arg2 / 100 * t / s:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * t / s
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 11 * arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 0:
                                                revert with 'NH{q', 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                        else:
                                            if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                                revert with 'NH{q', 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                            if 11 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 11 * arg2 / 100 * t / s:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * t / s
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                        else:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 0:
                                    revert with 'NH{q', 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _11409 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11409] = 26
                                        mem[_11409 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _11994 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11994] = 30
                                            mem[_11994 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12382 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12382] = 30
                                            mem[_12382 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12540 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12540 + idx + 68] = mem[_12382 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12540 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12540 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15145 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15145] = 30
                                            mem[_15145 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > -1:
                                                    revert with 'NH{q', 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _15383 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15383 + idx + 68] = mem[_15145 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15383 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15383 + -mem[64] + 100
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12452 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12452] = 30
                                        mem[_12452 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12630 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12630 + idx + 68] = mem[_12452 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12630 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12630 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13878 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13878] = 30
                                        mem[_13878 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14178 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14178 + idx + 68] = mem[_13878 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14178 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14178 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17761 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17761] = 30
                                        mem[_17761 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17955 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17955 + idx + 68] = mem[_17761 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17955 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17955 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 'NH{q', 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _11479 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11479] = 30
                                        mem[_11479 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _11544 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_11544 + idx + 68] = mem[_11479 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_11544 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _11544 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx >= stor5.length:
                                            revert with 'NH{q', 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _11784 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11784] = 30
                                        mem[_11784 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 'NH{q', 17
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _11844 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11844 + idx + 68] = mem[_11784 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11844 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11844 + -mem[64] + 100
                                    _11514 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11514] = 26
                                    mem[_11514 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _12024 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12024] = 30
                                        mem[_12024 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _12541 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12541] = 30
                                        mem[_12541 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _12747 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12747 + idx + 68] = mem[_12541 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12747 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12747 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _15384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15384] = 30
                                        mem[_15384 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > -1:
                                                revert with 'NH{q', 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _15734 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15734 + idx + 68] = mem[_15384 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15734 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15734 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _12631 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12631] = 30
                                    mem[_12631 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _12828 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_12828 + idx + 68] = mem[_12631 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12828 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12828 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14180 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14180] = 30
                                    mem[_14180 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _14406 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14406 + idx + 68] = mem[_14180 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14406 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14406 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _17957 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17957] = 30
                                    mem[_17957 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 'NH{q', 17
                                        if totalFees > -1:
                                            revert with 'NH{q', 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18226 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18226 + idx + 68] = mem[_17957 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18226 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18226 + -mem[64] + 100
                                if t < stor6 / 100000000 * 10^18:
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                else:
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not s:
                                        revert with 'NH{q', 18
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > -1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 'NH{q', 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 'NH{q', 17
                                if totalFees > -1:
                                    revert with 'NH{q', 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if arg2 / 100 and 11 > -1 / arg2 / 100:
                                    revert with 'NH{q', 17
                                if not arg2 / 100:
                                    revert with 'NH{q', 18
                                if 11 * arg2 / 100 / arg2 / 100 != 11:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 11 * arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 11 * arg2 / 100:
                                    revert with 'NH{q', 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _11405 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11405] = 26
                                        mem[_11405 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not 11 * arg2 / 100:
                                                _11993 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_11993] = 30
                                                mem[_11993 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _12380 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_12380] = 30
                                                mem[_12380 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _12537 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_12537 + idx + 68] = mem[_12380 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_12537 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _12537 + -mem[64] + 100
                                                if stor1[address(msg.sender)] < 0:
                                                    revert with 'NH{q', 17
                                                if stor1[address(arg1)] > -1:
                                                    revert with 'NH{q', 17
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _15141 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_15141] = 30
                                                mem[_15141 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if stor6 < 0:
                                                        revert with 'NH{q', 17
                                                    if totalFees > (-11 * arg2 / 100) - 1:
                                                        revert with 'NH{q', 17
                                                    if totalFees + (11 * arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += 11 * arg2 / 100
                                                    emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _15379 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_15379 + idx + 68] = mem[_15141 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15379 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15379 + -mem[64] + 100
                                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _12450 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12450] = 30
                                            mem[_12450 + 32] = 'SafeMath: subtraction overflow'
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                _12627 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12627 + idx + 68] = mem[_12450 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12627 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12627 + -mem[64] + 100
                                            if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13874 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13874] = 30
                                            mem[_13874 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14174 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_14174 + idx + 68] = mem[_13874 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14174 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14174 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            _17754 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17754] = 30
                                            mem[_17754 + 32] = 'SafeMath: subtraction overflow'
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                                if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                    revert with 'NH{q', 17
                                                stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17951 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17951 + idx + 68] = mem[_17754 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17951 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17951 + -mem[64] + 100
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 11 * arg2 / 100:
                                            _12449 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12449] = 30
                                            mem[_12449 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                                _12626 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12626 + idx + 68] = mem[_12449 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12626 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12626 + -mem[64] + 100
                                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 'NH{q', 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13873 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13873] = 30
                                            mem[_13873 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                _14173 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_14173 + idx + 68] = mem[_13873 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14173 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14173 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                            _17753 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17753] = 30
                                            mem[_17753 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17950 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17950 + idx + 68] = mem[_17753 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17950 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17950 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _14045 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14045] = 30
                                        mem[_14045 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            _14283 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14283 + idx + 68] = mem[_14045 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14283 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14283 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16445 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16445] = 30
                                        mem[_16445 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _16688 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16688 + idx + 68] = mem[_16445 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16688 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16688 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _19996 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19996] = 30
                                        mem[_19996 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20169 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_20169 + idx + 68] = mem[_19996 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20169 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20169 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 'NH{q', 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 'NH{q', 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _11477 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11477] = 30
                                        mem[_11477 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _11543 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_11543 + idx + 68] = mem[_11477 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_11543 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _11543 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 'NH{q', 17
                                        if idx >= stor5.length:
                                            revert with 'NH{q', 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _11783 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11783] = 30
                                        mem[_11783 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 'NH{q', 17
                                            if idx == -1:
                                                revert with 'NH{q', 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _11843 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_11843 + idx + 68] = mem[_11783 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11843 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11843 + -mem[64] + 100
                                    _11513 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11513] = 26
                                    mem[_11513 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            _12023 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12023] = 30
                                            mem[_12023 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _12538 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_12538] = 30
                                            mem[_12538 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _12743 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_12743 + idx + 68] = mem[_12538 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_12743 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _12743 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _15380 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15380] = 30
                                            mem[_15380 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 'NH{q', 17
                                                if totalFees > (-11 * arg2 / 100) - 1:
                                                    revert with 'NH{q', 17
                                                if totalFees + (11 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 11 * arg2 / 100
                                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _15729 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_15729 + idx + 68] = mem[_15380 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15729 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15729 + -mem[64] + 100
                                        if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                            revert with 'NH{q', 17
                                        if not 11 * arg2 / 100:
                                            revert with 'NH{q', 18
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _12629 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12629] = 30
                                        mem[_12629 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _12826 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12826 + idx + 68] = mem[_12629 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12826 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12826 + -mem[64] + 100
                                        if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14177] = 30
                                        mem[_14177 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14403 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14403 + idx + 68] = mem[_14177 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14403 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14403 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        _17954 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17954] = 30
                                        mem[_17954 + 32] = 'SafeMath: subtraction overflow'
                                        if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18222 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18222 + idx + 68] = mem[_17954 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18222 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18222 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 'NH{q', 17
                                    if not arg2:
                                        revert with 'NH{q', 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 11 * arg2 / 100:
                                        _12628 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12628] = 30
                                        mem[_12628 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _12825 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_12825 + idx + 68] = mem[_12628 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12825 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12825 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 'NH{q', 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14176] = 30
                                        mem[_14176 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _14402 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14402 + idx + 68] = mem[_14176 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14402 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14402 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                            revert with 'NH{q', 17
                                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                        _17953 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17953] = 30
                                        mem[_17953 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                            if totalFees > (-11 * arg2 / 100) - 1:
                                                revert with 'NH{q', 17
                                            if totalFees + (11 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 11 * arg2 / 100
                                            emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18221 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18221 + idx + 68] = mem[_17953 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18221 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18221 + -mem[64] + 100
                                    if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                        revert with 'NH{q', 17
                                    if not 11 * arg2 / 100:
                                        revert with 'NH{q', 18
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14287 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14287] = 30
                                    mem[_14287 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14561 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14561 + idx + 68] = mem[_14287 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14561 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14561 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16691 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16691] = 30
                                    mem[_16691 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _16926 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16926 + idx + 68] = mem[_16691 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16926 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16926 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 'NH{q', 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                        revert with 'NH{q', 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20172 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20172] = 30
                                    mem[_20172 + 32] = 'SafeMath: subtraction overflow'
                                    if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 'NH{q', 17
                                        stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > (-11 * arg2 / 100) - 1:
                                            revert with 'NH{q', 17
                                        if totalFees + (11 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 11 * arg2 / 100
                                        emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20358 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20358 + idx + 68] = mem[_20172 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20358 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20358 + -mem[64] + 100
                                if t < stor6 / 100000000 * 10^18:
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                        else:
                                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    else:
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 11 * arg2 / 100:
                                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 'NH{q', 17
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                        else:
                                            if 11 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 / 11 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 100000000 * 10^18 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[address(arg1)] > (-1 * arg2 * stor6 / 100000000 * 10^18) + (11 * arg2 / 100 * stor6 / 100000000 * 10^18) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (11 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                            if 11 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 11 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not s:
                                        revert with 'NH{q', 18
                                    if not arg2:
                                        if not 11 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > -1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                        else:
                                            if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 11 * arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 11 * arg2 / 100 * t / s:
                                                revert with 'NH{q', 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] > (11 * arg2 / 100 * t / s) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -11 * arg2 / 100 * t / s
                                            if 11 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 11 * arg2 / 100 * t / s:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * t / s
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 'NH{q', 17
                                        if not arg2:
                                            revert with 'NH{q', 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 11 * arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 0:
                                                revert with 'NH{q', 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] > (-1 * arg2 * t / s) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 'NH{q', 17
                                        else:
                                            if 11 * arg2 / 100 and t / s > -1 / 11 * arg2 / 100:
                                                revert with 'NH{q', 17
                                            if not 11 * arg2 / 100:
                                                revert with 'NH{q', 18
                                            if 11 * arg2 / 100 * t / s / 11 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 11 * arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 11 * arg2 / 100 * t / s:
                                                revert with 'NH{q', 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 'NH{q', 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] > (-1 * arg2 * t / s) + (11 * arg2 / 100 * t / s) - 1:
                                                revert with 'NH{q', 17
                                            if stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (11 * arg2 / 100 * t / s)
                                            if 11 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 11 * arg2 / 100 * t / s:
                                                revert with 'NH{q', 17
                                            stor6 += -11 * arg2 / 100 * t / s
                                if totalFees > (-11 * arg2 / 100) - 1:
                                    revert with 'NH{q', 17
                                if totalFees + (11 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 11 * arg2 / 100
                                emit Transfer((arg2 - (11 * arg2 / 100)), msg.sender, arg1);
    return 1
}



}

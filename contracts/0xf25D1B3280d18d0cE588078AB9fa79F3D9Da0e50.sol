contract main {




// =====================  Runtime code  =====================


const sub_0ffd778e(?) = 0xfe09b6fca8f5f3ab2900d9586d1d15872611c1bd42b268b973ad886d4f2646b5

const DEFAULT_ADMIN_ROLE = 0


uint8 stor0;
uint8 stor0; offset 8
uint16 stor0;
mapping of struct roleAdmin;
uint256 stor151;
uint8 paused;
uint256 openingTime;
uint256 closingTime;
address projectTokenAddress;
uint256 sub_c48cb812;
uint256 sub_93472702;
address sub_da9afae9Address;
mapping of uint256 sub_8aab91cc;
mapping of uint256 sub_0143e86b;
mapping of uint8 stor259;
address sub_19e36708Address;
mapping of uint256 sub_211e04d4;
mapping of uint256 sub_40393b7a;
mapping of uint8 stor263;
address sub_101a7520Address;
mapping of uint256 sub_2e8f0d1f;
mapping of uint256 sub_35e0b18b;
mapping of uint8 stor267;
address marketingAccount;
mapping of uint256 sub_f4ca210f;
mapping of uint256 sub_681af24e;
mapping of uint8 stor271;
address sub_c3beeec5Address;
uint256 stor2029;
uint256 stor3CAD;
uint256 stor51C6;
uint256 stor63D9;
uint256 stor7215;
uint256 stor8C4B;
uint256 storB789;
uint256 storCDD5;
uint256 storD7A2;
uint256 storD9C2;
uint256 storE3F8;
uint256 stor1214;
uint256 stor185C;
uint256 stor18CE;
uint256 stor18F3;
uint256 stor1A08;
uint256 stor1E63;
uint256 stor1E9F;
uint256 stor22FD;
uint256 stor2379;
uint256 stor2391;
uint256 stor2626;
uint256 stor2686;
uint256 stor27CE;
uint256 stor289C;
uint256 stor2907;
uint256 stor2B1B;
uint256 stor2C9B;
uint256 stor2DB4;
uint256 stor2F65;
uint256 stor3056;
uint256 stor34F4;
uint256 stor35A1;
uint256 stor35D4;
uint256 stor36B5;
uint256 stor373B;
uint256 stor3965;
uint256 stor398F;
uint256 stor3A5E;
uint256 stor3EFF;
uint256 stor4D2B;
uint256 stor4FAB;
uint256 stor516F;
uint256 stor51D6;
uint256 stor52D1;
uint256 stor565A;
uint256 stor5718;
uint256 stor5936;
uint256 stor6135;
uint256 stor61F1;
uint256 stor64D9;
uint256 stor67A6;
uint256 stor6AC3;
uint256 stor6D72;
uint256 stor6DED;
uint256 stor6E37;
uint256 stor702B;
uint256 stor7696;
uint256 stor78CC;
uint256 stor7A4B;
uint256 stor82F7;
uint256 stor8684;
uint256 stor87C9;
uint256 stor8AB7;
uint256 stor8DB6;
uint256 stor8F2A;
uint256 stor902D;
uint256 stor9064;
uint256 stor9338;
uint256 stor943E;
uint256 stor9DF3;
uint256 storA5BA;
uint256 storA6EB;
uint256 storA834;
uint256 storA878;
uint256 storAC68;
uint256 storB14B;
uint256 storBBF7;
uint256 storBCB4;
uint256 storBD23;
uint256 storC0DF;
uint256 storC0F5;
uint256 storC1C1;
uint256 storC3C6;
uint256 storC860;
uint256 storC956;
uint256 storCB68;
uint256 storCDA9;
uint256 storD17D;
uint256 storD1DB;
uint256 storD5BA;
uint256 storD6B1;
uint256 storD7D2;
uint256 storD7E2;
uint256 storDE73;
uint256 storE53E;
uint256 storE85C;
uint256 storE998;
uint256 storEBD7;
uint256 storF112;
uint256 storF229;
uint256 storF6F2;
uint256 storFF2A;
uint256 storFF53;

function sub_0143e86b(?) payable {
    require calldata.size - 4 >= 32
    return sub_0143e86b[arg1]
}

function sub_101a7520(?) payable {
    return sub_101a7520Address
}

function sub_19e36708(?) payable {
    return sub_19e36708Address
}

function sub_211e04d4(?) payable {
    require calldata.size - 4 >= 32
    return sub_211e04d4[arg1]
}

function getRoleAdmin(bytes32 arg1) payable {
    require calldata.size - 4 >= 32
    return roleAdmin[arg1].field_256
}

function sub_2e8f0d1f(?) payable {
    require calldata.size - 4 >= 32
    return sub_2e8f0d1f[arg1]
}

function sub_35e0b18b(?) payable {
    require calldata.size - 4 >= 32
    return sub_35e0b18b[arg1]
}

function sub_40393b7a(?) payable {
    require calldata.size - 4 >= 32
    return sub_40393b7a[arg1]
}

function projectToken() payable {
    return projectTokenAddress
}

function closingTime() payable {
    return closingTime
}

function sub_515a6306(?) payable {
    require calldata.size - 4 >= 32
    return bool(stor259[arg1])
}

function paused() payable {
    return bool(paused)
}

function sub_681af24e(?) payable {
    require calldata.size - 4 >= 32
    return sub_681af24e[arg1]
}

function marketingAccount() payable {
    return marketingAccount
}

function sub_8aab91cc(?) payable {
    require calldata.size - 4 >= 32
    return sub_8aab91cc[arg1]
}

function hasRole(bytes32 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    return bool(roleAdmin[arg1][address(arg2)].field_0)
}

function sub_93472702(?) payable {
    return sub_93472702
}

function sub_a62e9cac(?) payable {
    require calldata.size - 4 >= 32
    return bool(stor271[arg1])
}

function openingTime() payable {
    return openingTime
}

function sub_c3beeec5(?) payable {
    return sub_c3beeec5Address
}

function sub_c48cb812(?) payable {
    return sub_c48cb812
}

function sub_d8921480(?) payable {
    require calldata.size - 4 >= 32
    return bool(stor267[arg1])
}

function sub_da9afae9(?) payable {
    return sub_da9afae9Address
}

function sub_f211fedf(?) payable {
    require calldata.size - 4 >= 32
    return bool(stor263[arg1])
}

function sub_f4ca210f(?) payable {
    require calldata.size - 4 >= 32
    return sub_f4ca210f[arg1]
}

function _fallback() payable {
    revert
}

function hasClosed() payable {
    return (block.timestamp > closingTime)
}

function isOpen() payable {
    if block.timestamp < openingTime:
        return block.timestamp >= openingTime
    return block.timestamp <= closingTime
}

function totalSold() payable {
    require ext_code.size(projectTokenAddress)
    staticcall projectTokenAddress.0x18160ddd with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function supportsInterface(bytes4 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    if 0x7965db0b00000000000000000000000000000000000000000000000000000000 == Mask(32, 224, arg1):
        return True
    return (Mask(32, 224, arg1) == 0x1ffc9a700000000000000000000000000000000000000000000000000000000)
}

function renounceRole(bytes32 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg2 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'AccessControl: can only renounce roles for self'
    if roleAdmin[arg1][address(arg2)].field_0:
        roleAdmin[arg1][address(arg2)].field_0 = 0
        emit RoleRevoked(arg1, arg2, msg.sender);
}

function updateMarketingWallet(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if roleAdmin[0][address(msg.sender)].field_0:
        marketingAccount = arg1
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
}

function sub_12b215f1(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if roleAdmin[0][address(msg.sender)].field_0:
        sub_101a7520Address = address(arg1)
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
}

function sub_4cab8aaa(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if roleAdmin[0][address(msg.sender)].field_0:
        sub_da9afae9Address = address(arg1)
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
}

function sub_ea0a3214(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if roleAdmin[0][address(msg.sender)].field_0:
        sub_19e36708Address = address(arg1)
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
}

function updateLiquidityWallet(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if roleAdmin[0][address(msg.sender)].field_0:
        sub_c3beeec5Address = arg1
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
}

function pause() payable {
    if roleAdmin[0xfe09b6fca8f5f3ab2900d9586d1d15872611c1bd42b268b973ad886d4f2646b5][address(msg.sender)].field_0:
        if paused:
            revert with 0, 'Pausable: paused'
        paused = 1
        emit Paused(msg.sender);
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if not msg.sender + 10240:
        idx = 65
        s = 0xfe09b6fca8f5f3ab2900d9586d1d15872611c1bd42b268b973ad886d4f2646b5
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
    revert with 0, 'Strings: hex length insufficient'
}

function unPause() payable {
    if roleAdmin[0xfe09b6fca8f5f3ab2900d9586d1d15872611c1bd42b268b973ad886d4f2646b5][address(msg.sender)].field_0:
        if not paused:
            revert with 0, 'Pausable: not paused'
        paused = 0
        emit Unpaused(msg.sender);
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if not msg.sender + 10240:
        idx = 65
        s = 0xfe09b6fca8f5f3ab2900d9586d1d15872611c1bd42b268b973ad886d4f2646b5
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
    revert with 0, 'Strings: hex length insufficient'
}

function extendTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if roleAdmin[0][address(msg.sender)].field_0:
        if arg1 <= closingTime:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'TimeHelper: before current closing time'
        closingTime = arg1
        emit 0xc911152b: closingTime, arg1
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    while idx > 1:
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        continue 
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
}

function revokeRole(bytes32 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0:
        if roleAdmin[arg1][address(arg2)].field_0:
            roleAdmin[arg1][address(arg2)].field_0 = 0
            emit RoleRevoked(arg1, arg2, msg.sender);
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    s = roleAdmin[arg1].field_256
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if roleAdmin[arg1].field_256 + 16384:
        revert with 0, 'Strings: hex length insufficient'
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
}

function grantRole(bytes32 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if roleAdmin[roleAdmin[arg1].field_256][address(msg.sender)].field_0:
        if not roleAdmin[arg1][address(arg2)].field_0:
            roleAdmin[arg1][address(arg2)].field_0 = 1
            emit RoleGranted(arg1, arg2, msg.sender);
    mem[128 len 42] = call.data[calldata.size len 42]
    idx = 41
    s = address(msg.sender)
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 42:
            revert with 0, 50
        mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if msg.sender + 10240:
        revert with 0, 'Strings: hex length insufficient'
    mem[224 len 66] = call.data[calldata.size len 66]
    idx = 65
    s = roleAdmin[arg1].field_256
    while idx > 1:
        if s % 16 >= 16:
            revert with 0, 50
        if idx >= 66:
            revert with 0, 50
        mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
        if not idx:
            revert with 0, 17
        idx = idx - 1
        s = Mask(252, 0, s) * 0.0625
        continue 
    if roleAdmin[arg1].field_256 + 16384:
        revert with 0, 'Strings: hex length insufficient'
    revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
}

function sub_b356792f(?) payable {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require calldata.size - 36 >= 64
    if uint8(stor0.field_8):
        if ext_code.size(this.address):
            revert with 0, 'Initializable: contract is already initialized'
    else:
        if uint8(stor0.field_0):
            revert with 0, 'Initializable: contract is already initialized'
    if not uint8(stor0.field_8):
        uint16(stor0.field_0) = 257
    if not address(arg1):
        revert with 0, 'Vesting: zero token project address'
    if not uint8(stor0.field_8):
        revert with 0, 'Initializable: contract is not initializing'
    stor151 = 1
    paused = 0
    if ext_code.size(this.address):
        revert with 0, 'Initializable: contract is already initialized'
    if not uint8(stor0.field_8):
        uint16(stor0.field_0) = 257
        revert with 0, 'Initializable: contract is not initializing'
    if arg3 <= arg2:
        revert with 0, 'TimeHelper: closing time is before opening time'
    openingTime = arg2
    closingTime = arg3
    if not uint8(stor0.field_8):
        uint8(stor0.field_8) = 0
    if not roleAdmin[0][address(msg.sender)].field_0:
        roleAdmin[0][address(msg.sender)].field_0 = 1
        emit RoleGranted(0, msg.sender, msg.sender);
    if not roleAdmin[0xfe09b6fca8f5f3ab2900d9586d1d15872611c1bd42b268b973ad886d4f2646b5][address(msg.sender)].field_0:
        roleAdmin[0xfe09b6fca8f5f3ab2900d9586d1d15872611c1bd42b268b973ad886d4f2646b5][address(msg.sender)].field_0 = 1
        emit RoleGranted(0xfe09b6fca8f5f3ab2900d9586d1d15872611c1bd42b268b973ad886d4f2646b5, msg.sender, msg.sender);
    projectTokenAddress = address(arg1)
    sub_da9afae9Address = 0x19ece7c90e631e9ece2494efab9868c3047d6507
    sub_19e36708Address = 0x19ece7c90e631e9ece2494efab9868c3047d6507
    sub_101a7520Address = 0x19ece7c90e631e9ece2494efab9868c3047d6507
    marketingAccount = 0x19ece7c90e631e9ece2494efab9868c3047d6507
    sub_c3beeec5Address = 0x19ece7c90e631e9ece2494efab9868c3047d6507
    if not uint8(stor0.field_8):
        uint8(stor0.field_8) = 0
}

function sub_fba18d97(?) payable {
    require calldata.size - 4 >= 32
    if stor151 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor151 = 2
    if block.timestamp < openingTime:
        revert with 0, 'TimeHelper: not open'
    if block.timestamp > closingTime:
        revert with 0, 'TimeHelper: not open'
    if paused:
        revert with 0, 'Pausable: paused'
    if not roleAdmin[0][address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    if arg1 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: amount must be greater than 0'
    if sub_93472702 > !arg1:
        revert with 0, 17
    if sub_93472702 + arg1 > sub_c48cb812:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: fairdrops reaches maximum'
    require ext_code.size(projectTokenAddress)
    call projectTokenAddress.0x40c10f19 with:
         gas gas_remaining wei
        args sub_da9afae9Address, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    sub_93472702 += arg1
    emit 0x78b4a41c: arg1, sub_19e36708Address
    stor151 = 1
}

function sub_7d4acff8(?) payable {
    require calldata.size - 4 >= 32
    if stor151 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor151 = 2
    if block.timestamp < openingTime:
        revert with 0, 'TimeHelper: not open'
    if block.timestamp > closingTime:
        revert with 0, 'TimeHelper: not open'
    if paused:
        revert with 0, 'Pausable: paused'
    if not roleAdmin[0][address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    if arg1 > 12:
        revert with 0, 'Vesting: index not valid'
    if stor267[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: already claimed this schedule'
    if not arg1:
        if storAC68:
            require ext_code.size(projectTokenAddress)
            call projectTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args marketingAccount, storAC68
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor267[arg1] = 1
        emit 0xc47c0784: storAC68, marketingAccount
    else:
        idx = 0
        s = 0
        while idx < arg1:
            mem[0] = idx
            mem[32] = 266
            if sub_35e0b18b[idx] > 0xc22e450672894ab6cd8efb11d33f5617839a5bc7dea00c22e450672894ab:
                revert with 0, 17
            if s > !(24 * 3600 * sub_35e0b18b[idx]):
                revert with 0, 17
            if openingTime > !(s + (24 * 3600 * sub_35e0b18b[idx])):
                revert with 0, 17
            if block.timestamp < openingTime + s + (24 * 3600 * sub_35e0b18b[idx]):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: Not right time to unlock this schedule'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + (24 * 3600 * sub_35e0b18b[idx])
            continue 
        if sub_2e8f0d1f[arg1]:
            require ext_code.size(projectTokenAddress)
            call projectTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args marketingAccount, sub_2e8f0d1f[arg1]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor267[arg1] = 1
        emit 0xc47c0784: sub_2e8f0d1f[arg1], marketingAccount
    stor151 = 1
}

function sub_24e9bec5(?) payable {
    require calldata.size - 4 >= 32
    if stor151 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor151 = 2
    if block.timestamp < openingTime:
        revert with 0, 'TimeHelper: not open'
    if block.timestamp > closingTime:
        revert with 0, 'TimeHelper: not open'
    if paused:
        revert with 0, 'Pausable: paused'
    if not roleAdmin[0][address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    if arg1 > 12:
        revert with 0, 'Vesting: index not valid'
    if stor259[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: already claimed this schedule'
    if not arg1:
        if storCDD5:
            require ext_code.size(projectTokenAddress)
            call projectTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args sub_19e36708Address, storCDD5
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor259[arg1] = 1
        emit 0x3b41ab1d: storCDD5, sub_19e36708Address
    else:
        idx = 0
        s = 0
        while idx < arg1:
            mem[0] = idx
            mem[32] = 258
            if sub_0143e86b[idx] > 0xc22e450672894ab6cd8efb11d33f5617839a5bc7dea00c22e450672894ab:
                revert with 0, 17
            if s > !(24 * 3600 * sub_0143e86b[idx]):
                revert with 0, 17
            if openingTime > !(s + (24 * 3600 * sub_0143e86b[idx])):
                revert with 0, 17
            if block.timestamp < openingTime + s + (24 * 3600 * sub_0143e86b[idx]):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: Not right time to unlock this schedule'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + (24 * 3600 * sub_0143e86b[idx])
            continue 
        if sub_8aab91cc[arg1]:
            require ext_code.size(projectTokenAddress)
            call projectTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args sub_19e36708Address, sub_8aab91cc[arg1]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor259[arg1] = 1
        emit 0x3b41ab1d: sub_8aab91cc[arg1], sub_19e36708Address
    stor151 = 1
}

function sub_434553f9(?) payable {
    require calldata.size - 4 >= 32
    if stor151 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor151 = 2
    if block.timestamp < openingTime:
        revert with 0, 'TimeHelper: not open'
    if block.timestamp > closingTime:
        revert with 0, 'TimeHelper: not open'
    if paused:
        revert with 0, 'Pausable: paused'
    if not roleAdmin[0][address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    if arg1 > 12:
        revert with 0, 'Vesting: index not valid'
    if stor263[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: already claimed this schedule'
    if not arg1:
        if storA5BA:
            require ext_code.size(projectTokenAddress)
            call projectTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args sub_101a7520Address, storA5BA
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor263[arg1] = 1
        emit 0x6b478bea: storA5BA, sub_101a7520Address
    else:
        idx = 0
        s = 0
        while idx < arg1:
            mem[0] = idx
            mem[32] = 262
            if sub_40393b7a[idx] > 0xc22e450672894ab6cd8efb11d33f5617839a5bc7dea00c22e450672894ab:
                revert with 0, 17
            if s > !(24 * 3600 * sub_40393b7a[idx]):
                revert with 0, 17
            if openingTime > !(s + (24 * 3600 * sub_40393b7a[idx])):
                revert with 0, 17
            if block.timestamp < openingTime + s + (24 * 3600 * sub_40393b7a[idx]):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: Not right time to unlock this schedule'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + (24 * 3600 * sub_40393b7a[idx])
            continue 
        if sub_211e04d4[arg1]:
            require ext_code.size(projectTokenAddress)
            call projectTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args sub_101a7520Address, sub_211e04d4[arg1]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor263[arg1] = 1
        emit 0x6b478bea: sub_211e04d4[arg1], sub_101a7520Address
    stor151 = 1
}

function claimLiquidity(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if stor151 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor151 = 2
    if block.timestamp < openingTime:
        revert with 0, 'TimeHelper: not open'
    if block.timestamp > closingTime:
        revert with 0, 'TimeHelper: not open'
    if paused:
        revert with 0, 'Pausable: paused'
    if not roleAdmin[0][address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    if arg1 > 12:
        revert with 0, 'Vesting: index not valid'
    if stor271[arg1]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: already claimed this schedule'
    if not arg1:
        if storE53E:
            require ext_code.size(projectTokenAddress)
            call projectTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args sub_c3beeec5Address, storE53E
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor271[arg1] = 1
        emit 0xccbafacf: storE53E, sub_c3beeec5Address
    else:
        idx = 0
        s = 0
        while idx < arg1:
            mem[0] = idx
            mem[32] = 270
            if sub_681af24e[idx] > 0xc22e450672894ab6cd8efb11d33f5617839a5bc7dea00c22e450672894ab:
                revert with 0, 17
            if s > !(24 * 3600 * sub_681af24e[idx]):
                revert with 0, 17
            if openingTime > !(s + (24 * 3600 * sub_681af24e[idx])):
                revert with 0, 17
            if block.timestamp < openingTime + s + (24 * 3600 * sub_681af24e[idx]):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: Not right time to unlock this schedule'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + (24 * 3600 * sub_681af24e[idx])
            continue 
        if sub_f4ca210f[arg1]:
            require ext_code.size(projectTokenAddress)
            call projectTokenAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args sub_c3beeec5Address, sub_f4ca210f[arg1]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor271[arg1] = 1
        emit 0xccbafacf: sub_f4ca210f[arg1], sub_c3beeec5Address
    stor151 = 1
}

function setup() payable {
    if stor151 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor151 = 2
    if not roleAdmin[0][address(msg.sender)].field_0:
        mem[128 len 42] = call.data[calldata.size len 42]
        idx = 41
        s = address(msg.sender)
        while idx > 1:
            if s % 16 >= 16:
                revert with 0, 50
            if idx >= 42:
                revert with 0, 50
            mem[idx + 128 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            s = Mask(252, 0, s) * 0.0625
            continue 
        if msg.sender + 10240:
            revert with 0, 'Strings: hex length insufficient'
        mem[224 len 66] = call.data[calldata.size len 66]
        idx = 65
        while idx > 1:
            if idx >= 66:
                revert with 0, 50
            mem[idx + 224 len 8] = Mask(8, -(0, 0) + 256, 0) << (0, 0) - 256
            if not idx:
                revert with 0, 17
            idx = idx - 1
            continue 
        revert with 0, 32, 148, 'AccessControl: account ', mem[160 len 42], 8297, mem[288 len 66], 0, 0 >> 928, 0
    if sub_93472702:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Vesting: cannot setup fairdrops 2nd time'
    require ext_code.size(projectTokenAddress)
    call projectTokenAddress.0x40c10f19 with:
         gas gas_remaining wei
        args sub_da9afae9Address, 10000000 * 10^18
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if sub_93472702 > 0xfffffffffffffffffffffffffffffffffffffffffff7ba6ae9ebfeb7b5ffffff:
        revert with 0, 17
    sub_93472702 += 10000000 * 10^18
    sub_c48cb812 = 100000000 * 10^18
    storCDD5 = 0
    stor78CC = 25000000 * 10^18
    stor34F4 = 25000000 * 10^18
    stor516F = 25000000 * 10^18
    stor7215 = 25000000 * 10^18
    storD9C2 = 25000000 * 10^18
    storD1DB = 25000000 * 10^18
    stor6D72 = 25000000 * 10^18
    stor2DB4 = 25000000 * 10^18
    stor398F = 25000000 * 10^18
    stor3EFF = 25000000 * 10^18
    stor2F65 = 25000000 * 10^18
    stor61F1 = 25000000 * 10^18
    stor565A = 180
    stor902D = 120
    stor63D9 = 120
    stor8DB6 = 120
    storFF2A = 120
    stor3056 = 120
    stor2626 = 120
    stor4D2B = 120
    storB14B = 120
    stor9DF3 = 120
    stor18F3 = 120
    storD17D = 60
    stor7696 = 0
    storA5BA = 0
    stor289C = 33330000 * 10^18
    stor2907 = 33330000 * 10^18
    stor1E63 = 33330000 * 10^18
    storF6F2 = 33330000 * 10^18
    storBCB4 = 33330000 * 10^18
    storBBF7 = 33330000 * 10^18
    storBD23 = 33330000 * 10^18
    storC3C6 = 33330000 * 10^18
    storF229 = 33330000 * 10^18
    storC860 = 33330000 * 10^18
    storFF53 = 33330000 * 10^18
    stor373B = 33370000 * 10^18
    stor36B5 = 180
    stor9338 = 120
    stor8F2A = 120
    stor2029 = 120
    stor1E9F = 120
    storA834 = 120
    storB789 = 120
    stor8C4B = 120
    storCB68 = 120
    stor7A4B = 120
    storE85C = 120
    stor8AB7 = 60
    storD7A2 = 0
    storAC68 = 0
    stor2379 = 8330000 * 10^18
    storC0DF = 8330000 * 10^18
    stor2391 = 8330000 * 10^18
    storEBD7 = 8330000 * 10^18
    storD5BA = 8330000 * 10^18
    stor35A1 = 8330000 * 10^18
    stor185C = 8330000 * 10^18
    stor87C9 = 8330000 * 10^18
    stor5936 = 8330000 * 10^18
    stor5718 = 8330000 * 10^18
    storC0F5 = 8330000 * 10^18
    stor6E37 = 2325 * 10^18 * 24 * 3600
    stor8684 = 180
    storE998 = 120
    stor1A08 = 120
    stor2686 = 120
    storD7E2 = 120
    stor82F7 = 120
    storCDA9 = 120
    stor702B = 120
    stor3A5E = 120
    stor9064 = 120
    stor3965 = 120
    storC1C1 = 60
    storC956 = 0
    storE53E = 20000000 * 10^18
    stor6135 = 6670000 * 10^18
    stor943E = 6670000 * 10^18
    storD6B1 = 6670000 * 10^18
    stor64D9 = 6670000 * 10^18
    stor6AC3 = 6670000 * 10^18
    stor52D1 = 6670000 * 10^18
    stor2C9B = 6670000 * 10^18
    storF112 = 6670000 * 10^18
    stor6DED = 6670000 * 10^18
    stor67A6 = 6670000 * 10^18
    stor3CAD = 6670000 * 10^18
    stor18CE = 6630000 * 10^18
    stor51C6 = 30
    storA878 = 120
    storE3F8 = 120
    stor22FD = 120
    stor4FAB = 120
    storA6EB = 120
    stor1214 = 120
    stor35D4 = 120
    stor51D6 = 120
    stor2B1B = 120
    storD7D2 = 120
    stor27CE = 60
    storDE73 = 0
    stor151 = 1
}



}
